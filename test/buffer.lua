local test = require("test.gambarina")
local ffi = require("ffi")
local Buffer = require("structs.buffer")

test("Buffer basic read operations", function()
	local buf = ffi.new("uint8_t[10]", {1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
	local buffer = Buffer.New(buf, 10)
	ok(buffer:ReadByte() == 1, "first byte should be 1")
	ok(buffer:ReadByte() == 2, "second byte should be 2")
	ok(buffer:ReadByte() == 3, "third byte should be 3")
	buffer:Advance(2)
	ok(buffer:ReadByte() == 6, "after advancing 2, byte should be 6")
	buffer:Advance(-3)
	ok(buffer:ReadByte() == 4, "after advancing -3, byte should be 4")
end)

test("Buffer string read/write", function()
	local buf = ffi.new("uint8_t[20]")
	local buffer = Buffer.New(buf, 20)
	buffer:WriteStringNonNullterminated("hello world")
	buffer:SetPosition(0)
	local str = buffer:ReadStringNonNullterminated()
	ok(str == "hello world", "string should match")
end)

test("Buffer varint read/write", function()
	local buf = ffi.new("uint8_t[10]")
	local buffer = Buffer.New(buf, 10)
	buffer:WriteVariableSizedInteger(300)
	buffer:SetPosition(0)
	local val = buffer:ReadVarInt()
	ok(val == 300, "varint should be 300")
end)

test("Buffer half precision float", function()
	local buf = ffi.new("uint8_t[10]")
	local buffer = Buffer.New(buf, 10)
	buffer:WriteHalf(3.14159)
	buffer:SetPosition(0)
	local val = buffer:ReadHalf()
	ok(math.abs(val - 3.140625) < 0.0001, "half precision value should be close to 3.140625")
end)

test("Buffer push/pop position", function()
	local buf = ffi.new("uint8_t[10]", {1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
	local buffer = Buffer.New(buf, 10)
	ok(buffer:ReadByte() == 1, "first read should be 1")
	buffer:PushPosition(5)
	ok(buffer:ReadByte() == 6, "after push to 5, byte should be 6")
	buffer:PopPosition()
	ok(buffer:ReadByte() == 2, "after pop, byte should be 2")
end)

test("Buffer ReadBits basic", function()
	local buf = ffi.new("uint8_t[2]", {0xAA, 0xCC}) -- 0b10101010, 0b11001100
	local buffer = Buffer.New(buf, 2)
	buffer:RestartReadBits()
	ok(buffer:ReadBits(4) == 0xA, "first 4 bits should be 0xA")
	ok(buffer:ReadBits(4) == 0xA, "next 4 bits should be 0xA")
	ok(buffer:ReadBits(8) == 0xCC, "next 8 bits should be 0xCC")
end)

test("Buffer ReadBits single bits", function()
	local buf = ffi.new("uint8_t[1]", {0xB4}) -- 0b10110100
	local buffer = Buffer.New(buf, 1)
	buffer:RestartReadBits()
	-- Read LSB to MSB
	ok(buffer:ReadBits(1) == 0, "bit 0")
	ok(buffer:ReadBits(1) == 0, "bit 1")
	ok(buffer:ReadBits(1) == 1, "bit 2")
	ok(buffer:ReadBits(1) == 0, "bit 3")
	ok(buffer:ReadBits(1) == 1, "bit 4")
	ok(buffer:ReadBits(1) == 1, "bit 5")
	ok(buffer:ReadBits(1) == 0, "bit 6")
	ok(buffer:ReadBits(1) == 1, "bit 7")
end)

test("Buffer ReadBits various widths", function()
	local buf = ffi.new("uint8_t[4]", {0x12, 0x34, 0x56, 0x78})
	local buffer = Buffer.New(buf, 4)
	buffer:RestartReadBits()
	ok(buffer:ReadBits(2) == 0x2, "bits 1,0 from 0x12")
	ok(buffer:ReadBits(3) == 0x4, "bits 4,3,2 from 0x12")
	ok(buffer:ReadBits(3) == 0x0, "bits 7,6,5 from 0x12")
	ok(buffer:ReadBits(5) == 0x14, "bits 4,3,2,1,0 from 0x34")
	ok(buffer:ReadBits(3) == 0x1, "bits 7,6,5 from 0x34")
end)

test("Buffer ReadBits 16-bit values", function()
	local buf = ffi.new("uint8_t[2]", {0xFF, 0xFF})
	local buffer = Buffer.New(buf, 2)
	buffer:RestartReadBits()
	local val = buffer:ReadBits(16)
	ok(val == 0xFFFF, "16-bit read should be 0xFFFF")
end)

test("Buffer ReadBits 24-bit values", function()
	local buf = ffi.new("uint8_t[3]", {0xFF, 0xFF, 0xFF})
	local buffer = Buffer.New(buf, 3)
	buffer:RestartReadBits()
	local val = buffer:ReadBits(24)
	ok(val == 0xFFFFFF, "24-bit read should be 0xFFFFFF")
end)

test("Buffer ReadBits 32-bit values", function()
	local buf = ffi.new("uint8_t[4]", {0xFF, 0xFF, 0xFF, 0xFF})
	local buffer = Buffer.New(buf, 4)
	buffer:RestartReadBits()
	local val = buffer:ReadBits(32)
	ok(val == 0xFFFFFFFF, "32-bit read should be 0xFFFFFFFF")
end)

test("Buffer ReadBits cross-byte boundary", function()
	local buf = ffi.new("uint8_t[2]", {0xAB, 0xCD})
	local buffer = Buffer.New(buf, 2)
	buffer:RestartReadBits()
	ok(buffer:ReadBits(8) == 0xAB, "first byte")
	ok(buffer:ReadBits(8) == 0xCD, "second byte")
end)

test("Buffer ReadBits zero bits", function()
	local buf = ffi.new("uint8_t[1]", {0xFF})
	local buffer = Buffer.New(buf, 1)
	buffer:RestartReadBits()
	local val = buffer:ReadBits(0)
	ok(val == 0, "reading 0 bits should return 0")
	ok(buffer:ReadBits(8) == 0xFF, "should still read the byte after")
end)

test("Buffer ReadBits restart", function()
	local buf = ffi.new("uint8_t[2]", {0xAB, 0xCD})
	local buffer = Buffer.New(buf, 2)
	buffer:RestartReadBits()
	ok(buffer:ReadBits(4) == 0xB, "first 4 bits")
	buffer:RestartReadBits()
	ok(buffer:ReadBits(4) == 0xB, "after restart, first 4 bits again")
end)

test("Buffer BitsLeftInByte", function()
	local buf = ffi.new("uint8_t[2]", {0xFF, 0xFF})
	local buffer = Buffer.New(buf, 2)
	buffer:RestartReadBits()
	ok(buffer:BitsLeftInByte() == 0, "initially 0")
	buffer:ReadBits(3)
	ok(buffer:BitsLeftInByte() == 5, "after reading 3 bits")
	buffer:ReadBits(5)
	ok(buffer:BitsLeftInByte() == 0, "after reading 8 bits total")
	buffer:ReadBits(7)
	ok(buffer:BitsLeftInByte() == 1, "after reading 15 bits total")
end)

test("Buffer find string", function()
	local buf = ffi.new("uint8_t[20]", "hello world, this is")
	local buffer = Buffer.New(buf, 20)
	local pos = buffer:FindNearest("this")
	ok(buffer:GetStringSlice(pos - #"this", pos - 1) == "this", "should find 'this'")
end)

test("Buffer write mode", function()
	local buf = ffi.new("uint8_t[5]")
	local buffer = Buffer.New(buf, 5):MakeWritable()
	buffer:WriteBytes("hello", 5)
	buffer:SetPosition(0)
	local str = buffer:ReadBytes(5)
	ok(str == "hello", "written string should match")
end)

test("Buffer grow", function()
	local buf = ffi.new("uint8_t[5]")
	local buffer = Buffer.New(buf, 5):MakeWritable()
	buffer:WriteBytes("hello world", 11)
	ok(buffer:GetSize() >= 11, "buffer should grow")
	buffer:SetPosition(0)
	local str = buffer:ReadBytes(11)
	ok(str == "hello world", "grown buffer content should match")
end)

test("Buffer U16 endianness", function()
	local buf = ffi.new("uint8_t[20]")
	local buffer = Buffer.New(buf, 20):MakeWritable()
	buffer:WriteU16LE(0x1234)
	buffer:WriteU16BE(0x1234)
	buffer:SetPosition(0)
	ok(buffer:GetByte(0) == 0x34, "LE byte 0 should be 0x34")
	ok(buffer:GetByte(1) == 0x12, "LE byte 1 should be 0x12")
	ok(buffer:GetByte(2) == 0x12, "BE byte 0 should be 0x12")
	ok(buffer:GetByte(3) == 0x34, "BE byte 1 should be 0x34")
	buffer:SetPosition(0)
	ok(buffer:ReadU16LE() == 0x1234, "LE read should match")
	ok(buffer:ReadU16BE() == 0x1234, "BE read should match")
end)

test("Buffer U32 endianness", function()
	local buf = ffi.new("uint8_t[20]")
	local buffer = Buffer.New(buf, 20):MakeWritable()
	buffer:WriteU32LE(0x12345678)
	buffer:WriteU32BE(0x12345678)
	buffer:SetPosition(0)
	ok(buffer:GetByte(0) == 0x78, "LE byte 0")
	ok(buffer:GetByte(1) == 0x56, "LE byte 1")
	ok(buffer:GetByte(2) == 0x34, "LE byte 2")
	ok(buffer:GetByte(3) == 0x12, "LE byte 3")
	ok(buffer:GetByte(4) == 0x12, "BE byte 0")
	ok(buffer:GetByte(5) == 0x34, "BE byte 1")
	ok(buffer:GetByte(6) == 0x56, "BE byte 2")
	ok(buffer:GetByte(7) == 0x78, "BE byte 3")
	buffer:SetPosition(0)
	ok(buffer:ReadU32LE() == 0x12345678, "LE read should match")
	ok(buffer:ReadU32BE() == 0x12345678, "BE read should match")
end)

test("Buffer I32 signed endianness", function()
	local buf = ffi.new("uint8_t[20]")
	local buffer = Buffer.New(buf, 20):MakeWritable()
	buffer:WriteI32LE(-1234567)
	buffer:WriteI32BE(-1234567)
	buffer:SetPosition(0)
	ok(buffer:ReadI32LE() == -1234567, "LE signed read should match")
	ok(buffer:ReadI32BE() == -1234567, "BE signed read should match")
end)

test("Buffer U64 endianness", function()
	local buf = ffi.new("uint8_t[32]")
	local buffer = Buffer.New(buf, 32):MakeWritable()
	local value = 0x123456789ABCDEF0ULL
	buffer:WriteU64LE(value)
	buffer:WriteU64BE(value)
	buffer:SetPosition(0)
	ok(buffer:GetByte(0) == 0xF0, "LE byte 0")
	ok(buffer:GetByte(1) == 0xDE, "LE byte 1")
	ok(buffer:GetByte(7) == 0x12, "LE byte 7")
	ok(buffer:GetByte(8) == 0x12, "BE byte 0")
	ok(buffer:GetByte(15) == 0xF0, "BE byte 7")
	buffer:SetPosition(0)
	ok(buffer:ReadU64LE() == value, "LE U64 read should match")
	ok(buffer:ReadU64BE() == value, "BE U64 read should match")
end)

test("Buffer Float endianness", function()
	local buf = ffi.new("uint8_t[20]")
	local buffer = Buffer.New(buf, 20):MakeWritable()
	local test_value = 3.14159
	buffer:WriteFloatLE(test_value)
	buffer:WriteFloatBE(test_value)
	buffer:SetPosition(0)
	local le_byte0 = buffer:GetByte(0)
	local be_byte0 = buffer:GetByte(4)
	local le_byte3 = buffer:GetByte(3)
	local be_byte3 = buffer:GetByte(7)
	ok(le_byte0 == be_byte3, "Float LE byte 0 should equal BE byte 3")
	ok(le_byte3 == be_byte0, "Float LE byte 3 should equal BE byte 0")
	buffer:SetPosition(0)
	local read_le = buffer:ReadFloatLE()
	local read_be = buffer:ReadFloatBE()
	ok(math.abs(read_le - test_value) < 0.00001, "Float LE read should match")
	ok(math.abs(read_be - test_value) < 0.00001, "Float BE read should match")
end)

test("Buffer Double endianness", function()
	local buf = ffi.new("uint8_t[32]")
	local buffer = Buffer.New(buf, 32):MakeWritable()
	local test_value = 3.141592653589793
	buffer:WriteDoubleLE(test_value)
	buffer:WriteDoubleBE(test_value)
	buffer:SetPosition(0)
	local le_byte0 = buffer:GetByte(0)
	local be_byte0 = buffer:GetByte(8)
	local le_byte7 = buffer:GetByte(7)
	local be_byte7 = buffer:GetByte(15)
	ok(le_byte0 == be_byte7, "Double LE byte 0 should equal BE byte 7")
	ok(le_byte7 == be_byte0, "Double LE byte 7 should equal BE byte 0")
	buffer:SetPosition(0)
	local read_le = buffer:ReadDoubleLE()
	local read_be = buffer:ReadDoubleBE()
	ok(math.abs(read_le - test_value) < 0.000000000001, "Double LE read should match")
	ok(math.abs(read_be - test_value) < 0.000000000001, "Double BE read should match")
end)

test("Buffer I16 endianness", function()
	local buf = ffi.new("uint8_t[20]")
	local buffer = Buffer.New(buf, 20):MakeWritable()
	buffer:WriteI16LE(-12345)
	buffer:WriteI16BE(-12345)
	buffer:SetPosition(0)
	ok(buffer:ReadI16LE() == -12345, "I16 LE read should match")
	ok(buffer:ReadI16BE() == -12345, "I16 BE read should match")
end)

test("Buffer I64 endianness", function()
	local buf = ffi.new("uint8_t[32]")
	local buffer = Buffer.New(buf, 32):MakeWritable()
	local value = -9223372036854775807LL
	buffer:WriteI64LE(value)
	buffer:WriteI64BE(value)
	buffer:SetPosition(0)
	ok(buffer:ReadI64LE() == value, "I64 LE read should match")
	ok(buffer:ReadI64BE() == value, "I64 BE read should match")
end)

test("Buffer cross-endian compatibility", function()
	local buf = ffi.new("uint8_t[20]")
	local buffer = Buffer.New(buf, 20):MakeWritable()
	buffer:WriteU32LE(0x12345678)
	buffer:SetPosition(0)
	local swapped = buffer:ReadU32BE()
	ok(swapped == 0x78563412, "cross-endian read should give swapped value")
end)

test("Buffer NaN handling with endianness", function()
	local buf = ffi.new("uint8_t[32]")
	local buffer = Buffer.New(buf, 32):MakeWritable()
	local nan = 0 / 0
	buffer:WriteFloatLE(nan)
	buffer:WriteFloatBE(nan)
	buffer:WriteDoubleLE(nan)
	buffer:WriteDoubleBE(nan)
	buffer:SetPosition(0)
	local f_le = buffer:ReadFloatLE()
	local f_be = buffer:ReadFloatBE()
	local d_le = buffer:ReadDoubleLE()
	local d_be = buffer:ReadDoubleBE()
	ok(f_le ~= f_le, "Float LE NaN check")
	ok(f_be ~= f_be, "Float BE NaN check")
	ok(d_le ~= d_le, "Double LE NaN check")
	ok(d_be ~= d_be, "Double BE NaN check")
end)
