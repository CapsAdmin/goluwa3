local T = require("test.t")
local Quat = require("structs.quat")
local Vec3 = require("structs.vec3")
local Ang3 = require("structs.ang3")

T.test("Quat construction", function()
	local q = Quat(1, 2, 3, 4)
	T(q.x == 1)["=="](true)
	T(q.y == 2)["=="](true)
	T(q.z == 3)["=="](true)
	T(q.w == 4)["=="](true)
end)

T.test("Quat default construction", function()
	local q = Quat()
	T(q.x == 0)["=="](true)
	T(q.y == 0)["=="](true)
	T(q.z == 0)["=="](true)
	T(q.w == 0)["=="](true)
end)

T.test("Quat identity", function()
	local q = Quat(1, 2, 3, 4)
	q:Identity()
	T(q.x == 0)["=="](true)
	T(q.y == 0)["=="](true)
	T(q.z == 0)["=="](true)
	T(q.w == 1)["=="](true)
end)

T.test("Quat copy", function()
	local q1 = Quat(1, 2, 3, 4)
	local q2 = q1:Copy()
	T(q2.x == 1)["=="](true)
	T(q2.y == 2)["=="](true)
	T(q2.z == 3)["=="](true)
	T(q2.w == 4)["=="](true)
	q2.x = 10
	T(q1.x == 1)["=="](true)
end)

T.test("Quat scalar multiplication", function()
	local q = Quat(1, 2, 3, 4)
	local q2 = q * 2
	T(q2.x == 2)["=="](true)
	T(q2.y == 4)["=="](true)
	T(q2.z == 6)["=="](true)
	T(q2.w == 8)["=="](true)
end)

T.test("Quat scalar division", function()
	local q = Quat(2, 4, 6, 8)
	local q2 = q / 2
	T(q2.x == 1)["=="](true)
	T(q2.y == 2)["=="](true)
	T(q2.z == 3)["=="](true)
	T(q2.w == 4)["=="](true)
end)

T.test("Quat conjugate", function()
	local q = Quat(1, 2, 3, 4)
	local conj = q:GetConjugated()
	T(conj.x == -1)["=="](true)
	T(conj.y == -2)["=="](true)
	T(conj.z == -3)["=="](true)
	T(conj.w == 4)["=="](true)
end)

T.test("Quat dot product", function()
	local q1 = Quat(1, 0, 0, 0)
	local q2 = Quat(1, 0, 0, 0)
	local dot = q1:Dot(q2)
	T(dot == 1)["=="](true)
end)

T.test("Quat dot product orthogonal", function()
	local q1 = Quat(1, 0, 0, 0)
	local q2 = Quat(0, 1, 0, 0)
	local dot = q1:Dot(q2)
	T(dot == 0)["=="](true)
end)

T.test("Quat length", function()
	local q = Quat(0, 0, 0, 1)
	local len = q:GetLength()
	T(math.abs(len - 1) < 0.0001)["=="](true)
end)

T.test("Quat length non-unit", function()
	local q = Quat(1, 2, 2, 0)
	local len = q:GetLength()
	T(math.abs(len - 3) < 0.0001)["=="](true)
end)

T.test("Quat normalize", function()
	local q = Quat(0, 0, 0, 2)
	q:Normalize()
	T(math.abs(q:GetLength() - 1) < 0.0001)["=="](true)
	T(math.abs(q.w - 1) < 0.0001)["=="](true)
end)

T.test("Quat normalize general", function()
	local q = Quat(1, 2, 2, 0)
	local n = q:GetNormalized()
	T(math.abs(n:GetLength() - 1) < 0.0001)["=="](true)
end)

T.test("Quat lerp", function()
	local q1 = Quat(0, 0, 0, 1)
	local q2 = Quat(0, 0, 0, 0)
	local lerped = q1:GetLerped(0.5, q2)
	T(math.abs(lerped.w - 0.5) < 0.0001)["=="](true)
end)

T.test("Quat SetAngles and GetAngles roundtrip", function()
	-- Use zero angles for a clean roundtrip test
	local ang = Ang3(0, 0, 0)
	local q = Quat():SetAngles(ang)
	local ang2 = q:GetAngles()
	T(math.abs(ang2.x) < 0.0001)["=="](true)
	T(math.abs(ang2.y) < 0.0001)["=="](true)
	T(math.abs(ang2.z) < 0.0001)["=="](true)
end)

T.test("Quat SetAngles produces valid quaternion", function()
	local ang = Ang3(0.5, 0.3, 0.1)
	local q = Quat():SetAngles(ang)
	-- A rotation quaternion should be normalized
	T(math.abs(q:GetLength() - 1) < 0.0001)["=="](true)
	-- GetAngles should return an Ang3
	local ang2 = q:GetAngles()
	T(ang2 ~= nil)["=="](true)
end)

T.test("Quat identity angles", function()
	local q = Quat()
	q:Identity()
	local ang = q:GetAngles()
	T(math.abs(ang.x) < 0.0001)["=="](true)
	T(math.abs(ang.y) < 0.0001)["=="](true)
	T(math.abs(ang.z) < 0.0001)["=="](true)
end)

T.test("QuatFromAxis", function()
	local axis = Vec3(0, 0, 1)
	local q = QuatFromAxis(math.pi / 2, axis) -- 90 degrees around Z
	T(q ~= nil)["=="](true)
	T(math.abs(q:GetLength() - 1) < 0.0001)["=="](true)
end)

T.test("Quat multiplication identity", function()
	local q1 = Quat()
	q1:Identity()
	local q2 = Quat()
	q2:Identity()
	local q3 = q1 * q2
	T(math.abs(q3.w - 1) < 0.0001)["=="](true)
	T(math.abs(q3.x) < 0.0001)["=="](true)
	T(math.abs(q3.y) < 0.0001)["=="](true)
	T(math.abs(q3.z) < 0.0001)["=="](true)
end)

T.test("Quat equality", function()
	local q1 = Quat(1, 2, 3, 4)
	local q2 = Quat(1, 2, 3, 4)
	local q3 = Quat(1, 2, 3, 5)
	T(q1 == q2)["=="](true)
	T(not (q1 == q3))["=="](true)
end)

T.test("Quat GetFloatPointer", function()
	local q = Quat(1, 2, 3, 4)
	local ptr = q:GetFloatPointer()
	T(ptr ~= nil)["=="](true)
	T(ptr[0] == 1)["=="](true)
	T(ptr[1] == 2)["=="](true)
	T(ptr[2] == 3)["=="](true)
	T(ptr[3] == 4)["=="](true)
end)

T.test("Quat GetDoublePointer", function()
	local q = Quat(1, 2, 3, 4)
	local ptr = q:GetDoublePointer()
	T(ptr ~= nil)["=="](true)
	T(ptr[0] == 1)["=="](true)
	T(ptr[1] == 2)["=="](true)
	T(ptr[2] == 3)["=="](true)
	T(ptr[3] == 4)["=="](true)
end)

T.test("Quat Rotate around X axis", function()
	local q = Quat()
	q:Identity()
	local angle = math.pi / 2 -- 90 degrees
	q:Rotate(angle, 1, 0, 0) -- Rotate around X axis
	T(q.x ~= 0)["=="](true)
	T(math.abs(q:GetLength() - 1) < 0.0001)["=="](true)
end)

T.test("Quat Rotate around Y axis", function()
	local q = Quat()
	q:Identity()
	local angle = math.pi / 2 -- 90 degrees
	q:Rotate(angle, 0, 1, 0) -- Rotate around Y axis
	T(q.y ~= 0)["=="](true)
	T(math.abs(q:GetLength() - 1) < 0.0001)["=="](true)
end)

T.test("Quat Rotate around Z axis", function()
	local q = Quat()
	q:Identity()
	local angle = math.pi / 2 -- 90 degrees
	q:Rotate(angle, 0, 0, 1) -- Rotate around Z axis
	T(q.z ~= 0)["=="](true)
	T(math.abs(q:GetLength() - 1) < 0.0001)["=="](true)
end)

T.test("Quat Rotate modifies quaternion in place", function()
	local q = Quat()
	q:Identity()
	local original_w = q.w
	q:Rotate(0.1, 1, 0, 0) -- Small rotation around X
	T(q.w ~= original_w)["=="](true)
	T(q.x ~= 0)["=="](true)
end)

T.test("Quat RotatePitch", function()
	local q = Quat()
	q:Identity()
	local angle = math.pi / 4 -- 45 degrees
	q:RotatePitch(angle)
	T(math.abs(q:GetLength() - 1) < 0.0001)["=="](true)
	-- Pitch should modify the quaternion
	T(not (q.x == 0 and q.y == 0 and q.z == 0 and q.w == 1))["=="](true)
end)

T.test("Quat RotateYaw", function()
	local q = Quat()
	q:Identity()
	local angle = math.pi / 4 -- 45 degrees
	q:RotateYaw(angle)
	T(math.abs(q:GetLength() - 1) < 0.0001)["=="](true)
	T(not (q.x == 0 and q.y == 0 and q.z == 0 and q.w == 1))["=="](true)
end)

T.test("Quat RotateRoll", function()
	local q = Quat()
	q:Identity()
	local angle = math.pi / 4 -- 45 degrees
	q:RotateRoll(angle)
	T(math.abs(q:GetLength() - 1) < 0.0001)["=="](true)
	T(not (q.x == 0 and q.y == 0 and q.z == 0 and q.w == 1))["=="](true)
end)

T.test("Quat multiple rotations", function()
	local q = Quat()
	q:Identity()
	q:RotatePitch(0.1)
	q:RotateYaw(0.2)
	q:RotateRoll(0.3)
	T(math.abs(q:GetLength() - 1) < 0.0001)["=="](true)
end)

T.test("Quat Rotate with zero angle", function()
	local q = Quat()
	q:Identity()
	q:Rotate(0, 1, 0, 0)
	T(q.x == 0 and q.y == 0 and q.z == 0 and q.w == 1)["=="](true)
end)
