local ffi = require("ffi")
local N = ffi.new
local mod = {}
ffi.cdef[=[
		struct ANativeWindow;
		struct AHardwareBuffer;
		struct wl_display;
		struct wl_surface;
	 	struct _screen_context;
	 	struct _screen_window;
	 	struct _screen_buffer;
		typedef void* zx_handle_t;
		typedef void* HINSTANCE;
		typedef void* HWND;
		typedef void* HANDLE;
		typedef void* LPCWSTR;
		typedef void* DWORD;
		typedef void* xcb_window_t;
	]=]

function mod.GetExtension(lib, instance, name)
	local ptr = lib.vkGetInstanceProcAddr(instance, name)

	if ptr == nil then error("extension function not found", 2) end

	local func = ffi.cast(mod["PFN_" .. name], ptr)
	return func
end

function mod.find_library()
	local function try_load(tbl)
		local errors = {}

		for _, name in ipairs(tbl) do
			local status, lib = pcall(ffi.load, name)

			if status then
				llog("Loaded Vulkan library:", name)
				return lib
			else
				table.insert(errors, lib)
			end
		end

		return nil, table.concat(errors, "\n")
	end

	if ffi.os == "Windows" then
		return assert(try_load({"vulkan-1.dll"}))
	elseif ffi.os == "OSX" then
		local home = os.getenv("HOME")
		local vulkan_sdk = os.getenv("VULKAN_SDK")
		local paths = {}
		-- Load the Vulkan LOADER (not the ICD directly)
		-- The loader will automatically find kosmickrisp via the ICD system
		table.insert(paths, "/opt/homebrew/lib/libvulkan.dylib")
		table.insert(paths, "/opt/homebrew/lib/libvulkan.1.dylib")
		table.insert(paths, "/usr/local/lib/libvulkan.dylib")
		table.insert(paths, "libvulkan.dylib")
		table.insert(paths, "libvulkan.1.dylib")

		-- Try VULKAN_SDK paths
		if vulkan_sdk then
			table.insert(paths, vulkan_sdk .. "/lib/libvulkan.dylib")
			table.insert(paths, vulkan_sdk .. "/lib/libvulkan.1.dylib")
		end

		-- Try VulkanSDK in home directory
		if home and vulkan_sdk then
			table.insert(paths, home .. "/VulkanSDK/1.4.328.1/macOS/lib/libvulkan.1.dylib")
		end

		return assert(try_load(paths))
	end

	return assert(try_load({"libvulkan.so", "libvulkan.so.1"}))
end

do -- Preprocessor Definitions
	mod.STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS = 6
	mod.STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS = 2
	mod.STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS = 8
	mod.STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS = 4
	mod.STD_VIDEO_AV1_MAX_NUM_CB_POINTS = 10
	mod.STD_VIDEO_AV1_MAX_NUM_CR_POINTS = 10
	mod.STD_VIDEO_AV1_MAX_NUM_PLANES = 3
	mod.STD_VIDEO_AV1_MAX_NUM_POS_CHROMA = 25
	mod.STD_VIDEO_AV1_MAX_NUM_POS_LUMA = 24
	mod.STD_VIDEO_AV1_MAX_NUM_Y_POINTS = 14
	mod.STD_VIDEO_AV1_MAX_SEGMENTS = 8
	mod.STD_VIDEO_AV1_MAX_TILE_COLS = 64
	mod.STD_VIDEO_AV1_MAX_TILE_ROWS = 64
	mod.STD_VIDEO_AV1_NUM_REF_FRAMES = 8
	mod.STD_VIDEO_AV1_PRIMARY_REF_NONE = 7
	mod.STD_VIDEO_AV1_REFS_PER_FRAME = 7
	mod.STD_VIDEO_AV1_SEG_LVL_MAX = 8
	mod.STD_VIDEO_AV1_SELECT_INTEGER_MV = 2
	mod.STD_VIDEO_AV1_SELECT_SCREEN_CONTENT_TOOLS = 2
	mod.STD_VIDEO_AV1_SKIP_MODE_FRAMES = 2
	mod.STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME = 8
	mod.STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE = 2
	mod.STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE = 8
	mod.STD_VIDEO_H264_CPB_CNT_LIST_SIZE = 32
	mod.STD_VIDEO_H264_MAX_CHROMA_PLANES = 2
	mod.STD_VIDEO_H264_MAX_NUM_LIST_REF = 32
	mod.STD_VIDEO_H264_NO_REFERENCE_PICTURE = 0xFF
	mod.STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS = 16
	mod.STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS = 6
	mod.STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS = 64
	mod.STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS = 6
	mod.STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE = 6
	mod.STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE = 19
	mod.STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE = 21
	mod.STD_VIDEO_H265_CPB_CNT_LIST_SIZE = 32
	mod.STD_VIDEO_H265_MAX_CHROMA_PLANES = 2
	mod.STD_VIDEO_H265_MAX_DELTA_POC = 48
	mod.STD_VIDEO_H265_MAX_DPB_SIZE = 16
	mod.STD_VIDEO_H265_MAX_LONG_TERM_PICS = 16
	mod.STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS = 32
	mod.STD_VIDEO_H265_MAX_NUM_LIST_REF = 15
	mod.STD_VIDEO_H265_MAX_SHORT_TERM_REF_PIC_SETS = 64
	mod.STD_VIDEO_H265_NO_REFERENCE_PICTURE = 0xFF
	mod.STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE = 3
	mod.STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE = 128
	mod.STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS = 64
	mod.STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS = 6
	mod.STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS = 64
	mod.STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS = 2
	mod.STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS = 16
	mod.STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS = 6
	mod.STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS = 64
	mod.STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS = 6
	mod.STD_VIDEO_H265_SUBLAYERS_LIST_SIZE = 7
	mod.STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS = 2
	mod.STD_VIDEO_VP9_MAX_REF_FRAMES = 4
	mod.STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB = 3
	mod.STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS = 7
	mod.STD_VIDEO_VP9_MAX_SEGMENTS = 8
	mod.STD_VIDEO_VP9_NUM_REF_FRAMES = 8
	mod.STD_VIDEO_VP9_REFS_PER_FRAME = 3
	mod.STD_VIDEO_VP9_SEG_LVL_MAX = 4
	mod.VK_AMD_ANTI_LAG_EXTENSION_NAME = "VK_AMD_anti_lag"
	mod.VK_AMD_ANTI_LAG_SPEC_VERSION = 1
	mod.VK_AMD_BUFFER_MARKER_EXTENSION_NAME = "VK_AMD_buffer_marker"
	mod.VK_AMD_BUFFER_MARKER_SPEC_VERSION = 1
	mod.VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME = "VK_AMD_device_coherent_memory"
	mod.VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION = 1
	mod.VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME = "VK_AMD_display_native_hdr"
	mod.VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION = 1
	mod.VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_AMD_draw_indirect_count"
	mod.VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION = 2
	mod.VK_AMD_GCN_SHADER_EXTENSION_NAME = "VK_AMD_gcn_shader"
	mod.VK_AMD_GCN_SHADER_SPEC_VERSION = 1
	mod.VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME = "VK_AMD_gpu_shader_half_float"
	mod.VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION = 2
	mod.VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME = "VK_AMD_gpu_shader_int16"
	mod.VK_AMD_GPU_SHADER_INT16_SPEC_VERSION = 2
	mod.VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME = "VK_AMD_memory_overallocation_behavior"
	mod.VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION = 1
	mod.VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME = "VK_AMD_mixed_attachment_samples"
	mod.VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION = 1
	mod.VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME = "VK_AMD_negative_viewport_height"
	mod.VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION = 1
	mod.VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME = "VK_AMD_pipeline_compiler_control"
	mod.VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION = 1
	mod.VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME = "VK_AMD_rasterization_order"
	mod.VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_BALLOT_EXTENSION_NAME = "VK_AMD_shader_ballot"
	mod.VK_AMD_SHADER_BALLOT_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME = "VK_AMD_shader_core_properties2"
	mod.VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME = "VK_AMD_shader_core_properties"
	mod.VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION = 2
	mod.VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME = "VK_AMD_shader_early_and_late_fragment_tests"
	mod.VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME = "VK_AMD_shader_explicit_vertex_parameter"
	mod.VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME = "VK_AMD_shader_fragment_mask"
	mod.VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME = "VK_AMD_shader_image_load_store_lod"
	mod.VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_INFO_EXTENSION_NAME = "VK_AMD_shader_info"
	mod.VK_AMD_SHADER_INFO_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME = "VK_AMD_shader_trinary_minmax"
	mod.VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION = 1
	mod.VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME = "VK_AMD_texture_gather_bias_lod"
	mod.VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION = 1
	mod.VK_AMD_anti_lag = 1
	mod.VK_AMD_buffer_marker = 1
	mod.VK_AMD_device_coherent_memory = 1
	mod.VK_AMD_display_native_hdr = 1
	mod.VK_AMD_draw_indirect_count = 1
	mod.VK_AMD_gcn_shader = 1
	mod.VK_AMD_gpu_shader_half_float = 1
	mod.VK_AMD_gpu_shader_int16 = 1
	mod.VK_AMD_memory_overallocation_behavior = 1
	mod.VK_AMD_mixed_attachment_samples = 1
	mod.VK_AMD_negative_viewport_height = 1
	mod.VK_AMD_pipeline_compiler_control = 1
	mod.VK_AMD_rasterization_order = 1
	mod.VK_AMD_shader_ballot = 1
	mod.VK_AMD_shader_core_properties = 1
	mod.VK_AMD_shader_core_properties2 = 1
	mod.VK_AMD_shader_early_and_late_fragment_tests = 1
	mod.VK_AMD_shader_explicit_vertex_parameter = 1
	mod.VK_AMD_shader_fragment_mask = 1
	mod.VK_AMD_shader_image_load_store_lod = 1
	mod.VK_AMD_shader_info = 1
	mod.VK_AMD_shader_trinary_minmax = 1
	mod.VK_AMD_texture_gather_bias_lod = 1
	mod.VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_EXTENSION_NAME = "VK_ANDROID_external_format_resolve"
	mod.VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_SPEC_VERSION = 1
	mod.VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME = "VK_ANDROID_external_memory_android_hardware_buffer"
	mod.VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 5
	mod.VK_ANDROID_external_format_resolve = 1
	mod.VK_ANDROID_external_memory_android_hardware_buffer = 1
	mod.VK_API_VERSION_1_0 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 0), 29),
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_API_VERSION_1_1 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 0), 29),
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 1), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_API_VERSION_1_2 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 0), 29),
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 2), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_API_VERSION_1_3 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 0), 29),
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 3), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_API_VERSION_1_4 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 0), 29),
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 4), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_ARM_DATA_GRAPH_EXTENSION_NAME = "VK_ARM_data_graph"
	mod.VK_ARM_DATA_GRAPH_SPEC_VERSION = 1
	mod.VK_ARM_FORMAT_PACK_EXTENSION_NAME = "VK_ARM_format_pack"
	mod.VK_ARM_FORMAT_PACK_SPEC_VERSION = 1
	mod.VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME = "VK_ARM_pipeline_opacity_micromap"
	mod.VK_ARM_PIPELINE_OPACITY_MICROMAP_SPEC_VERSION = 1
	mod.VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME = "VK_ARM_rasterization_order_attachment_access"
	mod.VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION = 1
	mod.VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME = "VK_ARM_render_pass_striped"
	mod.VK_ARM_RENDER_PASS_STRIPED_SPEC_VERSION = 1
	mod.VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME = "VK_ARM_scheduling_controls"
	mod.VK_ARM_SCHEDULING_CONTROLS_SPEC_VERSION = 1
	mod.VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME = "VK_ARM_shader_core_builtins"
	mod.VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION = 2
	mod.VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME = "VK_ARM_shader_core_properties"
	mod.VK_ARM_SHADER_CORE_PROPERTIES_SPEC_VERSION = 1
	mod.VK_ARM_TENSORS_EXTENSION_NAME = "VK_ARM_tensors"
	mod.VK_ARM_TENSORS_SPEC_VERSION = 1
	mod.VK_ARM_data_graph = 1
	mod.VK_ARM_format_pack = 1
	mod.VK_ARM_pipeline_opacity_micromap = 1
	mod.VK_ARM_rasterization_order_attachment_access = 1
	mod.VK_ARM_render_pass_striped = 1
	mod.VK_ARM_scheduling_controls = 1
	mod.VK_ARM_shader_core_builtins = 1
	mod.VK_ARM_shader_core_properties = 1
	mod.VK_ARM_tensors = 1
	mod.VK_ATTACHMENT_UNUSED = bit.bnot(0)
	mod.VK_EXT_4444_FORMATS_EXTENSION_NAME = "VK_EXT_4444_formats"
	mod.VK_EXT_4444_FORMATS_SPEC_VERSION = 1
	mod.VK_EXT_4444_formats = 1
	mod.VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME = "VK_EXT_acquire_drm_display"
	mod.VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION = 1
	mod.VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME = "VK_EXT_astc_decode_mode"
	mod.VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION = 1
	mod.VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_attachment_feedback_loop_dynamic_state"
	mod.VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_SPEC_VERSION = 1
	mod.VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME = "VK_EXT_attachment_feedback_loop_layout"
	mod.VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_SPEC_VERSION = 2
	mod.VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME = "VK_EXT_blend_operation_advanced"
	mod.VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION = 2
	mod.VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME = "VK_EXT_border_color_swizzle"
	mod.VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION = 1
	mod.VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_EXT_buffer_device_address"
	mod.VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 2
	mod.VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = "VK_EXT_calibrated_timestamps"
	mod.VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION = 2
	mod.VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME = "VK_EXT_color_write_enable"
	mod.VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION = 1
	mod.VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME = "VK_EXT_conditional_rendering"
	mod.VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION = 2
	mod.VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_conservative_rasterization"
	mod.VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION = 1
	mod.VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME = "VK_EXT_custom_border_color"
	mod.VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION = 12
	mod.VK_EXT_DEBUG_MARKER_EXTENSION_NAME = "VK_EXT_debug_marker"
	mod.VK_EXT_DEBUG_MARKER_SPEC_VERSION = 4
	mod.VK_EXT_DEBUG_REPORT_EXTENSION_NAME = "VK_EXT_debug_report"
	mod.VK_EXT_DEBUG_REPORT_SPEC_VERSION = 10
	mod.VK_EXT_DEBUG_UTILS_EXTENSION_NAME = "VK_EXT_debug_utils"
	mod.VK_EXT_DEBUG_UTILS_SPEC_VERSION = 2
	mod.VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME = "VK_EXT_depth_bias_control"
	mod.VK_EXT_DEPTH_BIAS_CONTROL_SPEC_VERSION = 1
	mod.VK_EXT_DEPTH_CLAMP_CONTROL_EXTENSION_NAME = "VK_EXT_depth_clamp_control"
	mod.VK_EXT_DEPTH_CLAMP_CONTROL_SPEC_VERSION = 1
	mod.VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME = "VK_EXT_depth_clamp_zero_one"
	mod.VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION = 1
	mod.VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME = "VK_EXT_depth_clip_control"
	mod.VK_EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION = 1
	mod.VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME = "VK_EXT_depth_clip_enable"
	mod.VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION = 1
	mod.VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME = "VK_EXT_depth_range_unrestricted"
	mod.VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION = 1
	mod.VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME = "VK_EXT_descriptor_buffer"
	mod.VK_EXT_DESCRIPTOR_BUFFER_SPEC_VERSION = 1
	mod.VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME = "VK_EXT_descriptor_indexing"
	mod.VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION = 2
	mod.VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME = "VK_EXT_device_address_binding_report"
	mod.VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_SPEC_VERSION = 1
	mod.VK_EXT_DEVICE_FAULT_EXTENSION_NAME = "VK_EXT_device_fault"
	mod.VK_EXT_DEVICE_FAULT_SPEC_VERSION = 2
	mod.VK_EXT_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = "VK_EXT_device_generated_commands"
	mod.VK_EXT_DEVICE_GENERATED_COMMANDS_SPEC_VERSION = 1
	mod.VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME = "VK_EXT_device_memory_report"
	mod.VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION = 2
	mod.VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME = "VK_EXT_directfb_surface"
	mod.VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION = 1
	mod.VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME = "VK_EXT_direct_mode_display"
	mod.VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION = 1
	mod.VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME = "VK_EXT_discard_rectangles"
	mod.VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION = 2
	mod.VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME = "VK_EXT_display_control"
	mod.VK_EXT_DISPLAY_CONTROL_SPEC_VERSION = 1
	mod.VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME = "VK_EXT_display_surface_counter"
	mod.VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION = 1
	mod.VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME = "VK_EXT_dynamic_rendering_unused_attachments"
	mod.VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_SPEC_VERSION = 1
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME = "VK_EXT_extended_dynamic_state2"
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION = 1
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME = "VK_EXT_extended_dynamic_state3"
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_3_SPEC_VERSION = 2
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_extended_dynamic_state"
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION = 1
	mod.VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME = "VK_EXT_external_memory_acquire_unmodified"
	mod.VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_SPEC_VERSION = 1
	mod.VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME = "VK_EXT_external_memory_dma_buf"
	mod.VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION = 1
	mod.VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME = "VK_EXT_external_memory_host"
	mod.VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION = 1
	mod.VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME = "VK_EXT_external_memory_metal"
	mod.VK_EXT_EXTERNAL_MEMORY_METAL_SPEC_VERSION = 1
	mod.VK_EXT_FILTER_CUBIC_EXTENSION_NAME = "VK_EXT_filter_cubic"
	mod.VK_EXT_FILTER_CUBIC_SPEC_VERSION = 3
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME = "VK_EXT_fragment_density_map2"
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION = 1
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME = "VK_EXT_fragment_density_map"
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME = "VK_EXT_fragment_density_map_offset"
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION = 1
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION = 2
	mod.VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME = "VK_EXT_fragment_shader_interlock"
	mod.VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION = 1
	mod.VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME = "VK_EXT_frame_boundary"
	mod.VK_EXT_FRAME_BOUNDARY_SPEC_VERSION = 1
	mod.VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME = "VK_EXT_global_priority"
	mod.VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME = "VK_EXT_global_priority_query"
	mod.VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION = 1
	mod.VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION = 2
	mod.VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME = "VK_EXT_graphics_pipeline_library"
	mod.VK_EXT_GRAPHICS_PIPELINE_LIBRARY_SPEC_VERSION = 1
	mod.VK_EXT_HDR_METADATA_EXTENSION_NAME = "VK_EXT_hdr_metadata"
	mod.VK_EXT_HDR_METADATA_SPEC_VERSION = 3
	mod.VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME = "VK_EXT_headless_surface"
	mod.VK_EXT_HEADLESS_SURFACE_SPEC_VERSION = 1
	mod.VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME = "VK_EXT_host_image_copy"
	mod.VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION = 1
	mod.VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME = "VK_EXT_host_query_reset"
	mod.VK_EXT_HOST_QUERY_RESET_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME = "VK_EXT_image_2d_view_of_3d"
	mod.VK_EXT_IMAGE_2D_VIEW_OF_3D_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME = "VK_EXT_image_compression_control"
	mod.VK_EXT_IMAGE_COMPRESSION_CONTROL_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME = "VK_EXT_image_compression_control_swapchain"
	mod.VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME = "VK_EXT_image_drm_format_modifier"
	mod.VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION = 2
	mod.VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_image_robustness"
	mod.VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME = "VK_EXT_image_sliced_view_of_3d"
	mod.VK_EXT_IMAGE_SLICED_VIEW_OF_3D_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME = "VK_EXT_image_view_min_lod"
	mod.VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION = 1
	mod.VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME = "VK_EXT_index_type_uint8"
	mod.VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION = 1
	mod.VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME = "VK_EXT_inline_uniform_block"
	mod.VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION = 1
	mod.VK_EXT_LAYER_SETTINGS_EXTENSION_NAME = "VK_EXT_layer_settings"
	mod.VK_EXT_LAYER_SETTINGS_SPEC_VERSION = 2
	mod.VK_EXT_LEGACY_DITHERING_EXTENSION_NAME = "VK_EXT_legacy_dithering"
	mod.VK_EXT_LEGACY_DITHERING_SPEC_VERSION = 2
	mod.VK_EXT_LEGACY_VERTEX_ATTRIBUTES_EXTENSION_NAME = "VK_EXT_legacy_vertex_attributes"
	mod.VK_EXT_LEGACY_VERTEX_ATTRIBUTES_SPEC_VERSION = 1
	mod.VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_line_rasterization"
	mod.VK_EXT_LINE_RASTERIZATION_SPEC_VERSION = 1
	mod.VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME = "VK_EXT_load_store_op_none"
	mod.VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION = 1
	mod.VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME = "VK_EXT_map_memory_placed"
	mod.VK_EXT_MAP_MEMORY_PLACED_SPEC_VERSION = 1
	mod.VK_EXT_MEMORY_BUDGET_EXTENSION_NAME = "VK_EXT_memory_budget"
	mod.VK_EXT_MEMORY_BUDGET_SPEC_VERSION = 1
	mod.VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME = "VK_EXT_memory_priority"
	mod.VK_EXT_MEMORY_PRIORITY_SPEC_VERSION = 1
	mod.VK_EXT_MESH_SHADER_EXTENSION_NAME = "VK_EXT_mesh_shader"
	mod.VK_EXT_MESH_SHADER_SPEC_VERSION = 1
	mod.VK_EXT_METAL_OBJECTS_EXTENSION_NAME = "VK_EXT_metal_objects"
	mod.VK_EXT_METAL_OBJECTS_SPEC_VERSION = 2
	mod.VK_EXT_METAL_SURFACE_EXTENSION_NAME = "VK_EXT_metal_surface"
	mod.VK_EXT_METAL_SURFACE_SPEC_VERSION = 1
	mod.VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME = "VK_EXT_multisampled_render_to_single_sampled"
	mod.VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION = 1
	mod.VK_EXT_MULTI_DRAW_EXTENSION_NAME = "VK_EXT_multi_draw"
	mod.VK_EXT_MULTI_DRAW_SPEC_VERSION = 1
	mod.VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME = "VK_EXT_mutable_descriptor_type"
	mod.VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION = 1
	mod.VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME = "VK_EXT_nested_command_buffer"
	mod.VK_EXT_NESTED_COMMAND_BUFFER_SPEC_VERSION = 1
	mod.VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME = "VK_EXT_non_seamless_cube_map"
	mod.VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION = 1
	mod.VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME = "VK_EXT_opacity_micromap"
	mod.VK_EXT_OPACITY_MICROMAP_SPEC_VERSION = 2
	mod.VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME = "VK_EXT_pageable_device_local_memory"
	mod.VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION = 1
	mod.VK_EXT_PCI_BUS_INFO_EXTENSION_NAME = "VK_EXT_pci_bus_info"
	mod.VK_EXT_PCI_BUS_INFO_SPEC_VERSION = 2
	mod.VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME = "VK_EXT_physical_device_drm"
	mod.VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION = 1
	mod.VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME = "VK_EXT_pipeline_creation_cache_control"
	mod.VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION = 3
	mod.VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME = "VK_EXT_pipeline_creation_feedback"
	mod.VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION = 1
	mod.VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME = "VK_EXT_pipeline_library_group_handles"
	mod.VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_SPEC_VERSION = 1
	mod.VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME = "VK_EXT_pipeline_properties"
	mod.VK_EXT_PIPELINE_PROPERTIES_SPEC_VERSION = 1
	mod.VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME = "VK_EXT_pipeline_protected_access"
	mod.VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION = 1
	mod.VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_pipeline_robustness"
	mod.VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION = 1
	mod.VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME = "VK_EXT_post_depth_coverage"
	mod.VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION = 1
	mod.VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME = "VK_EXT_present_mode_fifo_latest_ready"
	mod.VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION = 1
	mod.VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME = "VK_EXT_primitives_generated_query"
	mod.VK_EXT_PRIMITIVES_GENERATED_QUERY_SPEC_VERSION = 1
	mod.VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME = "VK_EXT_primitive_topology_list_restart"
	mod.VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION = 1
	mod.VK_EXT_PRIVATE_DATA_EXTENSION_NAME = "VK_EXT_private_data"
	mod.VK_EXT_PRIVATE_DATA_SPEC_VERSION = 1
	mod.VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME = "VK_EXT_provoking_vertex"
	mod.VK_EXT_PROVOKING_VERTEX_SPEC_VERSION = 1
	mod.VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME = "VK_EXT_queue_family_foreign"
	mod.VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION = 1
	mod.VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME = "VK_EXT_rasterization_order_attachment_access"
	mod.VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION = 1
	mod.VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME = "VK_EXT_rgba10x6_formats"
	mod.VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION = 1
	mod.VK_EXT_ROBUSTNESS_2_EXTENSION_NAME = "VK_EXT_robustness2"
	mod.VK_EXT_ROBUSTNESS_2_SPEC_VERSION = 1
	mod.VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME = "VK_EXT_sampler_filter_minmax"
	mod.VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION = 2
	mod.VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME = "VK_EXT_sample_locations"
	mod.VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION = 1
	mod.VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME = "VK_EXT_scalar_block_layout"
	mod.VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION = 1
	mod.VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME = "VK_EXT_separate_stencil_usage"
	mod.VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME = "VK_EXT_shader_atomic_float2"
	mod.VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME = "VK_EXT_shader_atomic_float"
	mod.VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME = "VK_EXT_shader_demote_to_helper_invocation"
	mod.VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_FLOAT8_EXTENSION_NAME = "VK_EXT_shader_float8"
	mod.VK_EXT_SHADER_FLOAT8_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME = "VK_EXT_shader_image_atomic_int64"
	mod.VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME = "VK_EXT_shader_module_identifier"
	mod.VK_EXT_SHADER_MODULE_IDENTIFIER_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_OBJECT_EXTENSION_NAME = "VK_EXT_shader_object"
	mod.VK_EXT_SHADER_OBJECT_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME = "VK_EXT_shader_replicated_composites"
	mod.VK_EXT_SHADER_REPLICATED_COMPOSITES_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME = "VK_EXT_shader_stencil_export"
	mod.VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME = "VK_EXT_shader_subgroup_ballot"
	mod.VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME = "VK_EXT_shader_subgroup_vote"
	mod.VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME = "VK_EXT_shader_tile_image"
	mod.VK_EXT_SHADER_TILE_IMAGE_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME = "VK_EXT_shader_viewport_index_layer"
	mod.VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION = 1
	mod.VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME = "VK_EXT_subgroup_size_control"
	mod.VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION = 2
	mod.VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME = "VK_EXT_subpass_merge_feedback"
	mod.VK_EXT_SUBPASS_MERGE_FEEDBACK_SPEC_VERSION = 2
	mod.VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME = "VK_EXT_surface_maintenance1"
	mod.VK_EXT_SURFACE_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME = "VK_EXT_swapchain_colorspace"
	mod.VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION = 5
	mod.VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME = "VK_EXT_swapchain_maintenance1"
	mod.VK_EXT_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME = "VK_EXT_texel_buffer_alignment"
	mod.VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION = 1
	mod.VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME = "VK_EXT_texture_compression_astc_hdr"
	mod.VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION = 1
	mod.VK_EXT_TOOLING_INFO_EXTENSION_NAME = "VK_EXT_tooling_info"
	mod.VK_EXT_TOOLING_INFO_SPEC_VERSION = 1
	mod.VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME = "VK_EXT_transform_feedback"
	mod.VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION = 1
	mod.VK_EXT_VALIDATION_CACHE_EXTENSION_NAME = "VK_EXT_validation_cache"
	mod.VK_EXT_VALIDATION_CACHE_SPEC_VERSION = 1
	mod.VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME = "VK_EXT_validation_features"
	mod.VK_EXT_VALIDATION_FEATURES_SPEC_VERSION = 6
	mod.VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME = "VK_EXT_validation_flags"
	mod.VK_EXT_VALIDATION_FLAGS_SPEC_VERSION = 3
	mod.VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = "VK_EXT_vertex_attribute_divisor"
	mod.VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION = 3
	mod.VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_vertex_attribute_robustness"
	mod.VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_SPEC_VERSION = 1
	mod.VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_vertex_input_dynamic_state"
	mod.VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION = 2
	mod.VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME = "VK_EXT_ycbcr_2plane_444_formats"
	mod.VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION = 1
	mod.VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME = "VK_EXT_ycbcr_image_arrays"
	mod.VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION = 1
	mod.VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_EXTENSION_NAME = "VK_EXT_zero_initialize_device_memory"
	mod.VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_SPEC_VERSION = 1
	mod.VK_EXT_acquire_drm_display = 1
	mod.VK_EXT_astc_decode_mode = 1
	mod.VK_EXT_attachment_feedback_loop_dynamic_state = 1
	mod.VK_EXT_attachment_feedback_loop_layout = 1
	mod.VK_EXT_blend_operation_advanced = 1
	mod.VK_EXT_border_color_swizzle = 1
	mod.VK_EXT_buffer_device_address = 1
	mod.VK_EXT_calibrated_timestamps = 1
	mod.VK_EXT_color_write_enable = 1
	mod.VK_EXT_conditional_rendering = 1
	mod.VK_EXT_conservative_rasterization = 1
	mod.VK_EXT_custom_border_color = 1
	mod.VK_EXT_debug_marker = 1
	mod.VK_EXT_debug_report = 1
	mod.VK_EXT_debug_utils = 1
	mod.VK_EXT_depth_bias_control = 1
	mod.VK_EXT_depth_clamp_control = 1
	mod.VK_EXT_depth_clamp_zero_one = 1
	mod.VK_EXT_depth_clip_control = 1
	mod.VK_EXT_depth_clip_enable = 1
	mod.VK_EXT_depth_range_unrestricted = 1
	mod.VK_EXT_descriptor_buffer = 1
	mod.VK_EXT_descriptor_indexing = 1
	mod.VK_EXT_device_address_binding_report = 1
	mod.VK_EXT_device_fault = 1
	mod.VK_EXT_device_generated_commands = 1
	mod.VK_EXT_device_memory_report = 1
	mod.VK_EXT_direct_mode_display = 1
	mod.VK_EXT_directfb_surface = 1
	mod.VK_EXT_discard_rectangles = 1
	mod.VK_EXT_display_control = 1
	mod.VK_EXT_display_surface_counter = 1
	mod.VK_EXT_dynamic_rendering_unused_attachments = 1
	mod.VK_EXT_extended_dynamic_state = 1
	mod.VK_EXT_extended_dynamic_state2 = 1
	mod.VK_EXT_extended_dynamic_state3 = 1
	mod.VK_EXT_external_memory_acquire_unmodified = 1
	mod.VK_EXT_external_memory_dma_buf = 1
	mod.VK_EXT_external_memory_host = 1
	mod.VK_EXT_external_memory_metal = 1
	mod.VK_EXT_filter_cubic = 1
	mod.VK_EXT_fragment_density_map = 1
	mod.VK_EXT_fragment_density_map2 = 1
	mod.VK_EXT_fragment_density_map_offset = 1
	mod.VK_EXT_fragment_shader_interlock = 1
	mod.VK_EXT_frame_boundary = 1
	mod.VK_EXT_global_priority = 1
	mod.VK_EXT_global_priority_query = 1
	mod.VK_EXT_graphics_pipeline_library = 1
	mod.VK_EXT_hdr_metadata = 1
	mod.VK_EXT_headless_surface = 1
	mod.VK_EXT_host_image_copy = 1
	mod.VK_EXT_host_query_reset = 1
	mod.VK_EXT_image_2d_view_of_3d = 1
	mod.VK_EXT_image_compression_control = 1
	mod.VK_EXT_image_compression_control_swapchain = 1
	mod.VK_EXT_image_drm_format_modifier = 1
	mod.VK_EXT_image_robustness = 1
	mod.VK_EXT_image_sliced_view_of_3d = 1
	mod.VK_EXT_image_view_min_lod = 1
	mod.VK_EXT_index_type_uint8 = 1
	mod.VK_EXT_inline_uniform_block = 1
	mod.VK_EXT_layer_settings = 1
	mod.VK_EXT_legacy_dithering = 1
	mod.VK_EXT_legacy_vertex_attributes = 1
	mod.VK_EXT_line_rasterization = 1
	mod.VK_EXT_load_store_op_none = 1
	mod.VK_EXT_map_memory_placed = 1
	mod.VK_EXT_memory_budget = 1
	mod.VK_EXT_memory_priority = 1
	mod.VK_EXT_mesh_shader = 1
	mod.VK_EXT_metal_objects = 1
	mod.VK_EXT_metal_surface = 1
	mod.VK_EXT_multi_draw = 1
	mod.VK_EXT_multisampled_render_to_single_sampled = 1
	mod.VK_EXT_mutable_descriptor_type = 1
	mod.VK_EXT_nested_command_buffer = 1
	mod.VK_EXT_non_seamless_cube_map = 1
	mod.VK_EXT_opacity_micromap = 1
	mod.VK_EXT_pageable_device_local_memory = 1
	mod.VK_EXT_pci_bus_info = 1
	mod.VK_EXT_physical_device_drm = 1
	mod.VK_EXT_pipeline_creation_cache_control = 1
	mod.VK_EXT_pipeline_creation_feedback = 1
	mod.VK_EXT_pipeline_library_group_handles = 1
	mod.VK_EXT_pipeline_properties = 1
	mod.VK_EXT_pipeline_protected_access = 1
	mod.VK_EXT_pipeline_robustness = 1
	mod.VK_EXT_post_depth_coverage = 1
	mod.VK_EXT_present_mode_fifo_latest_ready = 1
	mod.VK_EXT_primitive_topology_list_restart = 1
	mod.VK_EXT_primitives_generated_query = 1
	mod.VK_EXT_private_data = 1
	mod.VK_EXT_provoking_vertex = 1
	mod.VK_EXT_queue_family_foreign = 1
	mod.VK_EXT_rasterization_order_attachment_access = 1
	mod.VK_EXT_rgba10x6_formats = 1
	mod.VK_EXT_robustness2 = 1
	mod.VK_EXT_sample_locations = 1
	mod.VK_EXT_sampler_filter_minmax = 1
	mod.VK_EXT_scalar_block_layout = 1
	mod.VK_EXT_separate_stencil_usage = 1
	mod.VK_EXT_shader_atomic_float = 1
	mod.VK_EXT_shader_atomic_float2 = 1
	mod.VK_EXT_shader_demote_to_helper_invocation = 1
	mod.VK_EXT_shader_float8 = 1
	mod.VK_EXT_shader_image_atomic_int64 = 1
	mod.VK_EXT_shader_module_identifier = 1
	mod.VK_EXT_shader_object = 1
	mod.VK_EXT_shader_replicated_composites = 1
	mod.VK_EXT_shader_stencil_export = 1
	mod.VK_EXT_shader_subgroup_ballot = 1
	mod.VK_EXT_shader_subgroup_vote = 1
	mod.VK_EXT_shader_tile_image = 1
	mod.VK_EXT_shader_viewport_index_layer = 1
	mod.VK_EXT_subgroup_size_control = 1
	mod.VK_EXT_subpass_merge_feedback = 1
	mod.VK_EXT_surface_maintenance1 = 1
	mod.VK_EXT_swapchain_colorspace = 1
	mod.VK_EXT_swapchain_maintenance1 = 1
	mod.VK_EXT_texel_buffer_alignment = 1
	mod.VK_EXT_texture_compression_astc_hdr = 1
	mod.VK_EXT_tooling_info = 1
	mod.VK_EXT_transform_feedback = 1
	mod.VK_EXT_validation_cache = 1
	mod.VK_EXT_validation_features = 1
	mod.VK_EXT_validation_flags = 1
	mod.VK_EXT_vertex_attribute_divisor = 1
	mod.VK_EXT_vertex_attribute_robustness = 1
	mod.VK_EXT_vertex_input_dynamic_state = 1
	mod.VK_EXT_ycbcr_2plane_444_formats = 1
	mod.VK_EXT_ycbcr_image_arrays = 1
	mod.VK_EXT_zero_initialize_device_memory = 1
	mod.VK_FALSE = 0
	mod.VK_GGP_FRAME_TOKEN_EXTENSION_NAME = "VK_GGP_frame_token"
	mod.VK_GGP_FRAME_TOKEN_SPEC_VERSION = 1
	mod.VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME = "VK_GGP_stream_descriptor_surface"
	mod.VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION = 1
	mod.VK_GGP_frame_token = 1
	mod.VK_GGP_stream_descriptor_surface = 1
	mod.VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME = "VK_GOOGLE_decorate_string"
	mod.VK_GOOGLE_DECORATE_STRING_SPEC_VERSION = 1
	mod.VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME = "VK_GOOGLE_display_timing"
	mod.VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION = 1
	mod.VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME = "VK_GOOGLE_hlsl_functionality1"
	mod.VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION = 1
	mod.VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME = "VK_GOOGLE_hlsl_functionality1"
	mod.VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION = 1
	mod.VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME = "VK_GOOGLE_surfaceless_query"
	mod.VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION = 2
	mod.VK_GOOGLE_USER_TYPE_EXTENSION_NAME = "VK_GOOGLE_user_type"
	mod.VK_GOOGLE_USER_TYPE_SPEC_VERSION = 1
	mod.VK_GOOGLE_decorate_string = 1
	mod.VK_GOOGLE_display_timing = 1
	mod.VK_GOOGLE_hlsl_functionality1 = 1
	mod.VK_GOOGLE_surfaceless_query = 1
	mod.VK_GOOGLE_user_type = 1
	mod.VK_HEADER_VERSION = 328
	mod.VK_HEADER_VERSION_COMPLETE = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 0), 29),
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 4), 12),
		ffi.cast("uint32_t", 328)
	)
	mod.VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME = "VK_HUAWEI_cluster_culling_shader"
	mod.VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION = 3
	mod.VK_HUAWEI_HDR_VIVID_EXTENSION_NAME = "VK_HUAWEI_hdr_vivid"
	mod.VK_HUAWEI_HDR_VIVID_SPEC_VERSION = 1
	mod.VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME = "VK_HUAWEI_invocation_mask"
	mod.VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION = 1
	mod.VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME = "VK_HUAWEI_subpass_shading"
	mod.VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION = 3
	mod.VK_HUAWEI_cluster_culling_shader = 1
	mod.VK_HUAWEI_hdr_vivid = 1
	mod.VK_HUAWEI_invocation_mask = 1
	mod.VK_HUAWEI_subpass_shading = 1
	mod.VK_IMG_FILTER_CUBIC_EXTENSION_NAME = "VK_IMG_filter_cubic"
	mod.VK_IMG_FILTER_CUBIC_SPEC_VERSION = 1
	mod.VK_IMG_FORMAT_PVRTC_EXTENSION_NAME = "VK_IMG_format_pvrtc"
	mod.VK_IMG_FORMAT_PVRTC_SPEC_VERSION = 1
	mod.VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME = "VK_IMG_relaxed_line_rasterization"
	mod.VK_IMG_RELAXED_LINE_RASTERIZATION_SPEC_VERSION = 1
	mod.VK_IMG_filter_cubic = 1
	mod.VK_IMG_format_pvrtc = 1
	mod.VK_IMG_relaxed_line_rasterization = 1
	mod.VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_INTEL_performance_query"
	mod.VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION = 2
	mod.VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME = "VK_INTEL_shader_integer_functions2"
	mod.VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION = 1
	mod.VK_INTEL_performance_query = 1
	mod.VK_INTEL_shader_integer_functions2 = 1
	mod.VK_KHR_16BIT_STORAGE_EXTENSION_NAME = "VK_KHR_16bit_storage"
	mod.VK_KHR_16BIT_STORAGE_SPEC_VERSION = 1
	mod.VK_KHR_16bit_storage = 1
	mod.VK_KHR_8BIT_STORAGE_EXTENSION_NAME = "VK_KHR_8bit_storage"
	mod.VK_KHR_8BIT_STORAGE_SPEC_VERSION = 1
	mod.VK_KHR_8bit_storage = 1
	mod.VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME = "VK_KHR_acceleration_structure"
	mod.VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION = 13
	mod.VK_KHR_ANDROID_SURFACE_EXTENSION_NAME = "VK_KHR_android_surface"
	mod.VK_KHR_ANDROID_SURFACE_SPEC_VERSION = 6
	mod.VK_KHR_BIND_MEMORY_2_EXTENSION_NAME = "VK_KHR_bind_memory2"
	mod.VK_KHR_BIND_MEMORY_2_SPEC_VERSION = 1
	mod.VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_KHR_buffer_device_address"
	mod.VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 1
	mod.VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = "VK_KHR_calibrated_timestamps"
	mod.VK_KHR_CALIBRATED_TIMESTAMPS_SPEC_VERSION = 1
	mod.VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = "VK_KHR_compute_shader_derivatives"
	mod.VK_KHR_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION = 1
	mod.VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME = "VK_KHR_cooperative_matrix"
	mod.VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION = 2
	mod.VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME = "VK_KHR_copy_commands2"
	mod.VK_KHR_COPY_COMMANDS_2_SPEC_VERSION = 1
	mod.VK_KHR_COPY_MEMORY_INDIRECT_EXTENSION_NAME = "VK_KHR_copy_memory_indirect"
	mod.VK_KHR_COPY_MEMORY_INDIRECT_SPEC_VERSION = 1
	mod.VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME = "VK_KHR_create_renderpass2"
	mod.VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION = 1
	mod.VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_KHR_dedicated_allocation"
	mod.VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION = 3
	mod.VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME = "VK_KHR_deferred_host_operations"
	mod.VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION = 4
	mod.VK_KHR_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME = "VK_KHR_depth_clamp_zero_one"
	mod.VK_KHR_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION = 1
	mod.VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME = "VK_KHR_depth_stencil_resolve"
	mod.VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION = 1
	mod.VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME = "VK_KHR_descriptor_update_template"
	mod.VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION = 1
	mod.VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME = "VK_KHR_device_group_creation"
	mod.VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION = 1
	mod.VK_KHR_DEVICE_GROUP_EXTENSION_NAME = "VK_KHR_device_group"
	mod.VK_KHR_DEVICE_GROUP_SPEC_VERSION = 4
	mod.VK_KHR_DISPLAY_EXTENSION_NAME = "VK_KHR_display"
	mod.VK_KHR_DISPLAY_SPEC_VERSION = 23
	mod.VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_display_swapchain"
	mod.VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 10
	mod.VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_KHR_draw_indirect_count"
	mod.VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION = 1
	mod.VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME = "VK_KHR_driver_properties"
	mod.VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION = 1
	mod.VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME = "VK_KHR_dynamic_rendering"
	mod.VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME = "VK_KHR_dynamic_rendering_local_read"
	mod.VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_SPEC_VERSION = 1
	mod.VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_fence_capabilities"
	mod.VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME = "VK_KHR_external_fence"
	mod.VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME = "VK_KHR_external_fence_fd"
	mod.VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_FENCE_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_memory_capabilities"
	mod.VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_KHR_external_memory"
	mod.VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME = "VK_KHR_external_memory_fd"
	mod.VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_semaphore_capabilities"
	mod.VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME = "VK_KHR_external_semaphore"
	mod.VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME = "VK_KHR_external_semaphore_fd"
	mod.VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION = 1
	mod.VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME = "VK_KHR_format_feature_flags2"
	mod.VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION = 2
	mod.VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = "VK_KHR_fragment_shader_barycentric"
	mod.VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION = 1
	mod.VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME = "VK_KHR_fragment_shading_rate"
	mod.VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION = 2
	mod.VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_display_properties2"
	mod.VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION = 1
	mod.VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME = "VK_KHR_get_memory_requirements2"
	mod.VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION = 1
	mod.VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_physical_device_properties2"
	mod.VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION = 2
	mod.VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME = "VK_KHR_get_surface_capabilities2"
	mod.VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION = 1
	mod.VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME = "VK_KHR_global_priority"
	mod.VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION = 1
	mod.VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME = "VK_KHR_imageless_framebuffer"
	mod.VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION = 1
	mod.VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME = "VK_KHR_image_format_list"
	mod.VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION = 1
	mod.VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME = "VK_KHR_incremental_present"
	mod.VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION = 2
	mod.VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME = "VK_KHR_index_type_uint8"
	mod.VK_KHR_INDEX_TYPE_UINT8_SPEC_VERSION = 1
	mod.VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME = "VK_KHR_line_rasterization"
	mod.VK_KHR_LINE_RASTERIZATION_SPEC_VERSION = 1
	mod.VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME = "VK_KHR_load_store_op_none"
	mod.VK_KHR_LOAD_STORE_OP_NONE_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE1_EXTENSION_NAME = "VK_KHR_maintenance1"
	mod.VK_KHR_MAINTENANCE1_SPEC_VERSION = 2
	mod.VK_KHR_MAINTENANCE2_EXTENSION_NAME = "VK_KHR_maintenance2"
	mod.VK_KHR_MAINTENANCE2_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE3_EXTENSION_NAME = "VK_KHR_maintenance3"
	mod.VK_KHR_MAINTENANCE3_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_maintenance1"
	mod.VK_KHR_MAINTENANCE_1_SPEC_VERSION = 2
	mod.VK_KHR_MAINTENANCE_2_EXTENSION_NAME = "VK_KHR_maintenance2"
	mod.VK_KHR_MAINTENANCE_2_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_3_EXTENSION_NAME = "VK_KHR_maintenance3"
	mod.VK_KHR_MAINTENANCE_3_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_4_EXTENSION_NAME = "VK_KHR_maintenance4"
	mod.VK_KHR_MAINTENANCE_4_SPEC_VERSION = 2
	mod.VK_KHR_MAINTENANCE_5_EXTENSION_NAME = "VK_KHR_maintenance5"
	mod.VK_KHR_MAINTENANCE_5_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_6_EXTENSION_NAME = "VK_KHR_maintenance6"
	mod.VK_KHR_MAINTENANCE_6_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_7_EXTENSION_NAME = "VK_KHR_maintenance7"
	mod.VK_KHR_MAINTENANCE_7_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_8_EXTENSION_NAME = "VK_KHR_maintenance8"
	mod.VK_KHR_MAINTENANCE_8_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_9_EXTENSION_NAME = "VK_KHR_maintenance9"
	mod.VK_KHR_MAINTENANCE_9_SPEC_VERSION = 1
	mod.VK_KHR_MAP_MEMORY_2_EXTENSION_NAME = "VK_KHR_map_memory2"
	mod.VK_KHR_MAP_MEMORY_2_SPEC_VERSION = 1
	mod.VK_KHR_MULTIVIEW_EXTENSION_NAME = "VK_KHR_multiview"
	mod.VK_KHR_MULTIVIEW_SPEC_VERSION = 1
	mod.VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_KHR_performance_query"
	mod.VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION = 1
	mod.VK_KHR_PIPELINE_BINARY_EXTENSION_NAME = "VK_KHR_pipeline_binary"
	mod.VK_KHR_PIPELINE_BINARY_SPEC_VERSION = 1
	mod.VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME = "VK_KHR_pipeline_executable_properties"
	mod.VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION = 1
	mod.VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME = "VK_KHR_pipeline_library"
	mod.VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION = 1
	mod.VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME = "VK_KHR_portability_enumeration"
	mod.VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION = 1
	mod.VK_KHR_PRESENT_ID_2_EXTENSION_NAME = "VK_KHR_present_id2"
	mod.VK_KHR_PRESENT_ID_2_SPEC_VERSION = 1
	mod.VK_KHR_PRESENT_ID_EXTENSION_NAME = "VK_KHR_present_id"
	mod.VK_KHR_PRESENT_ID_SPEC_VERSION = 1
	mod.VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME = "VK_KHR_present_mode_fifo_latest_ready"
	mod.VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION = 1
	mod.VK_KHR_PRESENT_WAIT_2_EXTENSION_NAME = "VK_KHR_present_wait2"
	mod.VK_KHR_PRESENT_WAIT_2_SPEC_VERSION = 1
	mod.VK_KHR_PRESENT_WAIT_EXTENSION_NAME = "VK_KHR_present_wait"
	mod.VK_KHR_PRESENT_WAIT_SPEC_VERSION = 1
	mod.VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME = "VK_KHR_push_descriptor"
	mod.VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION = 2
	mod.VK_KHR_RAY_QUERY_EXTENSION_NAME = "VK_KHR_ray_query"
	mod.VK_KHR_RAY_QUERY_SPEC_VERSION = 1
	mod.VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_ray_tracing_maintenance1"
	mod.VK_KHR_RAY_TRACING_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME = "VK_KHR_ray_tracing_pipeline"
	mod.VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION = 1
	mod.VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME = "VK_KHR_ray_tracing_position_fetch"
	mod.VK_KHR_RAY_TRACING_POSITION_FETCH_SPEC_VERSION = 1
	mod.VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME = "VK_KHR_relaxed_block_layout"
	mod.VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION = 1
	mod.VK_KHR_ROBUSTNESS_2_EXTENSION_NAME = "VK_KHR_robustness2"
	mod.VK_KHR_ROBUSTNESS_2_SPEC_VERSION = 1
	mod.VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = "VK_KHR_sampler_mirror_clamp_to_edge"
	mod.VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION = 3
	mod.VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME = "VK_KHR_sampler_ycbcr_conversion"
	mod.VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION = 14
	mod.VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME = "VK_KHR_separate_depth_stencil_layouts"
	mod.VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME = "VK_KHR_shader_atomic_int64"
	mod.VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME = "VK_KHR_shader_bfloat16"
	mod.VK_KHR_SHADER_BFLOAT16_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_CLOCK_EXTENSION_NAME = "VK_KHR_shader_clock"
	mod.VK_KHR_SHADER_CLOCK_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME = "VK_KHR_shader_draw_parameters"
	mod.VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME = "VK_KHR_shader_expect_assume"
	mod.VK_KHR_SHADER_EXPECT_ASSUME_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME = "VK_KHR_shader_float16_int8"
	mod.VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME = "VK_KHR_shader_float_controls2"
	mod.VK_KHR_SHADER_FLOAT_CONTROLS_2_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME = "VK_KHR_shader_float_controls"
	mod.VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION = 4
	mod.VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME = "VK_KHR_shader_integer_dot_product"
	mod.VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME = "VK_KHR_shader_maximal_reconvergence"
	mod.VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME = "VK_KHR_shader_non_semantic_info"
	mod.VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME = "VK_KHR_shader_quad_control"
	mod.VK_KHR_SHADER_QUAD_CONTROL_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION_NAME = "VK_KHR_shader_relaxed_extended_instruction"
	mod.VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME = "VK_KHR_shader_subgroup_extended_types"
	mod.VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME = "VK_KHR_shader_subgroup_rotate"
	mod.VK_KHR_SHADER_SUBGROUP_ROTATE_SPEC_VERSION = 2
	mod.VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME = "VK_KHR_shader_subgroup_uniform_control_flow"
	mod.VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME = "VK_KHR_shader_terminate_invocation"
	mod.VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME = "VK_KHR_shader_untyped_pointers"
	mod.VK_KHR_SHADER_UNTYPED_POINTERS_SPEC_VERSION = 1
	mod.VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME = "VK_KHR_shared_presentable_image"
	mod.VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION = 1
	mod.VK_KHR_SPIRV_1_4_EXTENSION_NAME = "VK_KHR_spirv_1_4"
	mod.VK_KHR_SPIRV_1_4_SPEC_VERSION = 1
	mod.VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME = "VK_KHR_storage_buffer_storage_class"
	mod.VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION = 1
	mod.VK_KHR_SURFACE_EXTENSION_NAME = "VK_KHR_surface"
	mod.VK_KHR_SURFACE_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_surface_maintenance1"
	mod.VK_KHR_SURFACE_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME = "VK_KHR_surface_protected_capabilities"
	mod.VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION = 1
	mod.VK_KHR_SURFACE_SPEC_VERSION = 25
	mod.VK_KHR_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_swapchain"
	mod.VK_KHR_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_swapchain_maintenance1"
	mod.VK_KHR_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME = "VK_KHR_swapchain_mutable_format"
	mod.VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION = 1
	mod.VK_KHR_SWAPCHAIN_SPEC_VERSION = 70
	mod.VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME = "VK_KHR_synchronization2"
	mod.VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION = 1
	mod.VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME = "VK_KHR_timeline_semaphore"
	mod.VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION = 2
	mod.VK_KHR_UNIFIED_IMAGE_LAYOUTS_EXTENSION_NAME = "VK_KHR_unified_image_layouts"
	mod.VK_KHR_UNIFIED_IMAGE_LAYOUTS_SPEC_VERSION = 1
	mod.VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME = "VK_KHR_uniform_buffer_standard_layout"
	mod.VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION = 1
	mod.VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME = "VK_KHR_variable_pointers"
	mod.VK_KHR_VARIABLE_POINTERS_SPEC_VERSION = 1
	mod.VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = "VK_KHR_vertex_attribute_divisor"
	mod.VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME = "VK_KHR_video_decode_av1"
	mod.VK_KHR_VIDEO_DECODE_AV1_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME = "VK_KHR_video_decode_h264"
	mod.VK_KHR_VIDEO_DECODE_H264_SPEC_VERSION = 9
	mod.VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME = "VK_KHR_video_decode_h265"
	mod.VK_KHR_VIDEO_DECODE_H265_SPEC_VERSION = 8
	mod.VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME = "VK_KHR_video_decode_queue"
	mod.VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION = 8
	mod.VK_KHR_VIDEO_DECODE_VP9_EXTENSION_NAME = "VK_KHR_video_decode_vp9"
	mod.VK_KHR_VIDEO_DECODE_VP9_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_ENCODE_AV1_EXTENSION_NAME = "VK_KHR_video_encode_av1"
	mod.VK_KHR_VIDEO_ENCODE_AV1_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME = "VK_KHR_video_encode_h264"
	mod.VK_KHR_VIDEO_ENCODE_H264_SPEC_VERSION = 14
	mod.VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME = "VK_KHR_video_encode_h265"
	mod.VK_KHR_VIDEO_ENCODE_H265_SPEC_VERSION = 14
	mod.VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_EXTENSION_NAME = "VK_KHR_video_encode_intra_refresh"
	mod.VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_EXTENSION_NAME = "VK_KHR_video_encode_quantization_map"
	mod.VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_SPEC_VERSION = 2
	mod.VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME = "VK_KHR_video_encode_queue"
	mod.VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION = 12
	mod.VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_video_maintenance1"
	mod.VK_KHR_VIDEO_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_MAINTENANCE_2_EXTENSION_NAME = "VK_KHR_video_maintenance2"
	mod.VK_KHR_VIDEO_MAINTENANCE_2_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_QUEUE_EXTENSION_NAME = "VK_KHR_video_queue"
	mod.VK_KHR_VIDEO_QUEUE_SPEC_VERSION = 8
	mod.VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME = "VK_KHR_vulkan_memory_model"
	mod.VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION = 3
	mod.VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME = "VK_KHR_wayland_surface"
	mod.VK_KHR_WAYLAND_SURFACE_SPEC_VERSION = 6
	mod.VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME = "VK_KHR_workgroup_memory_explicit_layout"
	mod.VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION = 1
	mod.VK_KHR_XLIB_SURFACE_EXTENSION_NAME = "VK_KHR_xlib_surface"
	mod.VK_KHR_XLIB_SURFACE_SPEC_VERSION = 6
	mod.VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME = "VK_KHR_zero_initialize_workgroup_memory"
	mod.VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION = 1
	mod.VK_KHR_acceleration_structure = 1
	mod.VK_KHR_android_surface = 1
	mod.VK_KHR_bind_memory2 = 1
	mod.VK_KHR_buffer_device_address = 1
	mod.VK_KHR_calibrated_timestamps = 1
	mod.VK_KHR_compute_shader_derivatives = 1
	mod.VK_KHR_cooperative_matrix = 1
	mod.VK_KHR_copy_commands2 = 1
	mod.VK_KHR_copy_memory_indirect = 1
	mod.VK_KHR_create_renderpass2 = 1
	mod.VK_KHR_dedicated_allocation = 1
	mod.VK_KHR_deferred_host_operations = 1
	mod.VK_KHR_depth_clamp_zero_one = 1
	mod.VK_KHR_depth_stencil_resolve = 1
	mod.VK_KHR_descriptor_update_template = 1
	mod.VK_KHR_device_group = 1
	mod.VK_KHR_device_group_creation = 1
	mod.VK_KHR_display = 1
	mod.VK_KHR_display_swapchain = 1
	mod.VK_KHR_draw_indirect_count = 1
	mod.VK_KHR_driver_properties = 1
	mod.VK_KHR_dynamic_rendering = 1
	mod.VK_KHR_dynamic_rendering_local_read = 1
	mod.VK_KHR_external_fence = 1
	mod.VK_KHR_external_fence_capabilities = 1
	mod.VK_KHR_external_fence_fd = 1
	mod.VK_KHR_external_memory = 1
	mod.VK_KHR_external_memory_capabilities = 1
	mod.VK_KHR_external_memory_fd = 1
	mod.VK_KHR_external_semaphore = 1
	mod.VK_KHR_external_semaphore_capabilities = 1
	mod.VK_KHR_external_semaphore_fd = 1
	mod.VK_KHR_format_feature_flags2 = 1
	mod.VK_KHR_fragment_shader_barycentric = 1
	mod.VK_KHR_fragment_shading_rate = 1
	mod.VK_KHR_get_display_properties2 = 1
	mod.VK_KHR_get_memory_requirements2 = 1
	mod.VK_KHR_get_physical_device_properties2 = 1
	mod.VK_KHR_get_surface_capabilities2 = 1
	mod.VK_KHR_global_priority = 1
	mod.VK_KHR_image_format_list = 1
	mod.VK_KHR_imageless_framebuffer = 1
	mod.VK_KHR_incremental_present = 1
	mod.VK_KHR_index_type_uint8 = 1
	mod.VK_KHR_line_rasterization = 1
	mod.VK_KHR_load_store_op_none = 1
	mod.VK_KHR_maintenance1 = 1
	mod.VK_KHR_maintenance2 = 1
	mod.VK_KHR_maintenance3 = 1
	mod.VK_KHR_maintenance4 = 1
	mod.VK_KHR_maintenance5 = 1
	mod.VK_KHR_maintenance6 = 1
	mod.VK_KHR_maintenance7 = 1
	mod.VK_KHR_maintenance8 = 1
	mod.VK_KHR_maintenance9 = 1
	mod.VK_KHR_map_memory2 = 1
	mod.VK_KHR_multiview = 1
	mod.VK_KHR_performance_query = 1
	mod.VK_KHR_pipeline_binary = 1
	mod.VK_KHR_pipeline_executable_properties = 1
	mod.VK_KHR_pipeline_library = 1
	mod.VK_KHR_portability_enumeration = 1
	mod.VK_KHR_present_id = 1
	mod.VK_KHR_present_id2 = 1
	mod.VK_KHR_present_mode_fifo_latest_ready = 1
	mod.VK_KHR_present_wait = 1
	mod.VK_KHR_present_wait2 = 1
	mod.VK_KHR_push_descriptor = 1
	mod.VK_KHR_ray_query = 1
	mod.VK_KHR_ray_tracing_maintenance1 = 1
	mod.VK_KHR_ray_tracing_pipeline = 1
	mod.VK_KHR_ray_tracing_position_fetch = 1
	mod.VK_KHR_relaxed_block_layout = 1
	mod.VK_KHR_robustness2 = 1
	mod.VK_KHR_sampler_mirror_clamp_to_edge = 1
	mod.VK_KHR_sampler_ycbcr_conversion = 1
	mod.VK_KHR_separate_depth_stencil_layouts = 1
	mod.VK_KHR_shader_atomic_int64 = 1
	mod.VK_KHR_shader_bfloat16 = 1
	mod.VK_KHR_shader_clock = 1
	mod.VK_KHR_shader_draw_parameters = 1
	mod.VK_KHR_shader_expect_assume = 1
	mod.VK_KHR_shader_float16_int8 = 1
	mod.VK_KHR_shader_float_controls = 1
	mod.VK_KHR_shader_float_controls2 = 1
	mod.VK_KHR_shader_integer_dot_product = 1
	mod.VK_KHR_shader_maximal_reconvergence = 1
	mod.VK_KHR_shader_non_semantic_info = 1
	mod.VK_KHR_shader_quad_control = 1
	mod.VK_KHR_shader_relaxed_extended_instruction = 1
	mod.VK_KHR_shader_subgroup_extended_types = 1
	mod.VK_KHR_shader_subgroup_rotate = 1
	mod.VK_KHR_shader_subgroup_uniform_control_flow = 1
	mod.VK_KHR_shader_terminate_invocation = 1
	mod.VK_KHR_shader_untyped_pointers = 1
	mod.VK_KHR_shared_presentable_image = 1
	mod.VK_KHR_spirv_1_4 = 1
	mod.VK_KHR_storage_buffer_storage_class = 1
	mod.VK_KHR_surface = 1
	mod.VK_KHR_surface_maintenance1 = 1
	mod.VK_KHR_surface_protected_capabilities = 1
	mod.VK_KHR_swapchain = 1
	mod.VK_KHR_swapchain_maintenance1 = 1
	mod.VK_KHR_swapchain_mutable_format = 1
	mod.VK_KHR_synchronization2 = 1
	mod.VK_KHR_timeline_semaphore = 1
	mod.VK_KHR_unified_image_layouts = 1
	mod.VK_KHR_uniform_buffer_standard_layout = 1
	mod.VK_KHR_variable_pointers = 1
	mod.VK_KHR_vertex_attribute_divisor = 1
	mod.VK_KHR_video_decode_av1 = 1
	mod.VK_KHR_video_decode_h264 = 1
	mod.VK_KHR_video_decode_h265 = 1
	mod.VK_KHR_video_decode_queue = 1
	mod.VK_KHR_video_decode_vp9 = 1
	mod.VK_KHR_video_encode_av1 = 1
	mod.VK_KHR_video_encode_h264 = 1
	mod.VK_KHR_video_encode_h265 = 1
	mod.VK_KHR_video_encode_intra_refresh = 1
	mod.VK_KHR_video_encode_quantization_map = 1
	mod.VK_KHR_video_encode_queue = 1
	mod.VK_KHR_video_maintenance1 = 1
	mod.VK_KHR_video_maintenance2 = 1
	mod.VK_KHR_video_queue = 1
	mod.VK_KHR_vulkan_memory_model = 1
	mod.VK_KHR_wayland_surface = 1
	mod.VK_KHR_workgroup_memory_explicit_layout = 1
	mod.VK_KHR_xlib_surface = 1
	mod.VK_KHR_zero_initialize_workgroup_memory = 1
	mod.VK_LOD_CLAMP_NONE = 1000.0
	mod.VK_LUID_SIZE = 8
	mod.VK_LUID_SIZE_KHR = 8
	mod.VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME = "VK_LUNARG_direct_driver_loading"
	mod.VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION = 1
	mod.VK_LUNARG_direct_driver_loading = 1
	mod.VK_MAX_DESCRIPTION_SIZE = 256
	mod.VK_MAX_DEVICE_GROUP_SIZE = 32
	mod.VK_MAX_DEVICE_GROUP_SIZE_KHR = 32
	mod.VK_MAX_DRIVER_INFO_SIZE = 256
	mod.VK_MAX_DRIVER_INFO_SIZE_KHR = 256
	mod.VK_MAX_DRIVER_NAME_SIZE = 256
	mod.VK_MAX_DRIVER_NAME_SIZE_KHR = 256
	mod.VK_MAX_EXTENSION_NAME_SIZE = 256
	mod.VK_MAX_GLOBAL_PRIORITY_SIZE = 16
	mod.VK_MAX_GLOBAL_PRIORITY_SIZE_EXT = 16
	mod.VK_MAX_GLOBAL_PRIORITY_SIZE_KHR = 16
	mod.VK_MAX_MEMORY_HEAPS = 16
	mod.VK_MAX_MEMORY_TYPES = 32
	mod.VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM = 128
	mod.VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256
	mod.VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR = 32
	mod.VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT = 32
	mod.VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR = 7
	mod.VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR = 3
	mod.VK_MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION_NAME = "VK_MESA_image_alignment_control"
	mod.VK_MESA_IMAGE_ALIGNMENT_CONTROL_SPEC_VERSION = 1
	mod.VK_MESA_image_alignment_control = 1
	mod.VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME = "VK_MSFT_layered_driver"
	mod.VK_MSFT_LAYERED_DRIVER_SPEC_VERSION = 1
	mod.VK_MSFT_layered_driver = 1
	mod.VK_MVK_IOS_SURFACE_EXTENSION_NAME = "VK_MVK_ios_surface"
	mod.VK_MVK_IOS_SURFACE_SPEC_VERSION = 3
	mod.VK_MVK_MACOS_SURFACE_EXTENSION_NAME = "VK_MVK_macos_surface"
	mod.VK_MVK_MACOS_SURFACE_SPEC_VERSION = 3
	mod.VK_MVK_ios_surface = 1
	mod.VK_MVK_macos_surface = 1
	mod.VK_NN_VI_SURFACE_EXTENSION_NAME = "VK_NN_vi_surface"
	mod.VK_NN_VI_SURFACE_SPEC_VERSION = 1
	mod.VK_NN_vi_surface = 1
	mod.VK_NULL_HANDLE = nil -- ((void*)0) -- Failed to parse: [string "local ffi = require('ffi') local x =  ( void ..."]:1: unexpected symbol near ')'
	mod.VK_NVX_BINARY_IMPORT_EXTENSION_NAME = "VK_NVX_binary_import"
	mod.VK_NVX_BINARY_IMPORT_SPEC_VERSION = 2
	mod.VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME = "VK_NVX_image_view_handle"
	mod.VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION = 3
	mod.VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME = "VK_NVX_multiview_per_view_attributes"
	mod.VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION = 1
	mod.VK_NVX_binary_import = 1
	mod.VK_NVX_image_view_handle = 1
	mod.VK_NVX_multiview_per_view_attributes = 1
	mod.VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME = "VK_NV_clip_space_w_scaling"
	mod.VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION = 1
	mod.VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME = "VK_NV_cluster_acceleration_structure"
	mod.VK_NV_CLUSTER_ACCELERATION_STRUCTURE_SPEC_VERSION = 4
	mod.VK_NV_COMMAND_BUFFER_INHERITANCE_EXTENSION_NAME = "VK_NV_command_buffer_inheritance"
	mod.VK_NV_COMMAND_BUFFER_INHERITANCE_SPEC_VERSION = 1
	mod.VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = "VK_NV_compute_shader_derivatives"
	mod.VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION = 1
	mod.VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME = "VK_NV_cooperative_matrix2"
	mod.VK_NV_COOPERATIVE_MATRIX_2_SPEC_VERSION = 1
	mod.VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME = "VK_NV_cooperative_matrix"
	mod.VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION = 1
	mod.VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME = "VK_NV_cooperative_vector"
	mod.VK_NV_COOPERATIVE_VECTOR_SPEC_VERSION = 4
	mod.VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME = "VK_NV_copy_memory_indirect"
	mod.VK_NV_COPY_MEMORY_INDIRECT_SPEC_VERSION = 1
	mod.VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME = "VK_NV_corner_sampled_image"
	mod.VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION = 2
	mod.VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME = "VK_NV_coverage_reduction_mode"
	mod.VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION = 1
	mod.VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_NV_dedicated_allocation"
	mod.VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME = "VK_NV_dedicated_allocation_image_aliasing"
	mod.VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION = 1
	mod.VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION = 1
	mod.VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME = "VK_NV_descriptor_pool_overallocation"
	mod.VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_SPEC_VERSION = 1
	mod.VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME = "VK_NV_device_diagnostics_config"
	mod.VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION = 2
	mod.VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME = "VK_NV_device_diagnostic_checkpoints"
	mod.VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION = 2
	mod.VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME = "VK_NV_device_generated_commands_compute"
	mod.VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_SPEC_VERSION = 2
	mod.VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = "VK_NV_device_generated_commands"
	mod.VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION = 3
	mod.VK_NV_DISPLAY_STEREO_EXTENSION_NAME = "VK_NV_display_stereo"
	mod.VK_NV_DISPLAY_STEREO_SPEC_VERSION = 1
	mod.VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME = "VK_NV_extended_sparse_address_space"
	mod.VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_SPEC_VERSION = 1
	mod.VK_NV_EXTERNAL_COMPUTE_QUEUE_EXTENSION_NAME = "VK_NV_external_compute_queue"
	mod.VK_NV_EXTERNAL_COMPUTE_QUEUE_SPEC_VERSION = 1
	mod.VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_NV_external_memory_capabilities"
	mod.VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1
	mod.VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_NV_external_memory"
	mod.VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME = "VK_NV_external_memory_rdma"
	mod.VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION = 1
	mod.VK_NV_EXTERNAL_MEMORY_SPEC_VERSION = 1
	mod.VK_NV_FILL_RECTANGLE_EXTENSION_NAME = "VK_NV_fill_rectangle"
	mod.VK_NV_FILL_RECTANGLE_SPEC_VERSION = 1
	mod.VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME = "VK_NV_fragment_coverage_to_color"
	mod.VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION = 1
	mod.VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = "VK_NV_fragment_shader_barycentric"
	mod.VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION = 1
	mod.VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME = "VK_NV_fragment_shading_rate_enums"
	mod.VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION = 1
	mod.VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME = "VK_NV_framebuffer_mixed_samples"
	mod.VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION = 1
	mod.VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME = "VK_NV_geometry_shader_passthrough"
	mod.VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION = 1
	mod.VK_NV_GLSL_SHADER_EXTENSION_NAME = "VK_NV_glsl_shader"
	mod.VK_NV_GLSL_SHADER_SPEC_VERSION = 1
	mod.VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME = "VK_NV_inherited_viewport_scissor"
	mod.VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION = 1
	mod.VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME = "VK_NV_linear_color_attachment"
	mod.VK_NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION = 1
	mod.VK_NV_LOW_LATENCY_2_EXTENSION_NAME = "VK_NV_low_latency2"
	mod.VK_NV_LOW_LATENCY_2_SPEC_VERSION = 2
	mod.VK_NV_LOW_LATENCY_EXTENSION_NAME = "VK_NV_low_latency"
	mod.VK_NV_LOW_LATENCY_SPEC_VERSION = 1
	mod.VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME = "VK_NV_memory_decompression"
	mod.VK_NV_MEMORY_DECOMPRESSION_SPEC_VERSION = 1
	mod.VK_NV_MESH_SHADER_EXTENSION_NAME = "VK_NV_mesh_shader"
	mod.VK_NV_MESH_SHADER_SPEC_VERSION = 1
	mod.VK_NV_OPTICAL_FLOW_EXTENSION_NAME = "VK_NV_optical_flow"
	mod.VK_NV_OPTICAL_FLOW_SPEC_VERSION = 1
	mod.VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_EXTENSION_NAME = "VK_NV_partitioned_acceleration_structure"
	mod.VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_SPEC_VERSION = 1
	mod.VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME = "VK_NV_per_stage_descriptor_set"
	mod.VK_NV_PER_STAGE_DESCRIPTOR_SET_SPEC_VERSION = 1
	mod.VK_NV_PRESENT_BARRIER_EXTENSION_NAME = "VK_NV_present_barrier"
	mod.VK_NV_PRESENT_BARRIER_SPEC_VERSION = 1
	mod.VK_NV_PRESENT_METERING_EXTENSION_NAME = "VK_NV_present_metering"
	mod.VK_NV_PRESENT_METERING_SPEC_VERSION = 1
	mod.VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME = "VK_NV_raw_access_chains"
	mod.VK_NV_RAW_ACCESS_CHAINS_SPEC_VERSION = 1
	mod.VK_NV_RAY_TRACING_EXTENSION_NAME = "VK_NV_ray_tracing"
	mod.VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME = "VK_NV_ray_tracing_invocation_reorder"
	mod.VK_NV_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION = 1
	mod.VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME = "VK_NV_ray_tracing_linear_swept_spheres"
	mod.VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_SPEC_VERSION = 1
	mod.VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME = "VK_NV_ray_tracing_motion_blur"
	mod.VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION = 1
	mod.VK_NV_RAY_TRACING_SPEC_VERSION = 3
	mod.VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME = "VK_NV_ray_tracing_validation"
	mod.VK_NV_RAY_TRACING_VALIDATION_SPEC_VERSION = 1
	mod.VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME = "VK_NV_representative_fragment_test"
	mod.VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION = 2
	mod.VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME = "VK_NV_sample_mask_override_coverage"
	mod.VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION = 1
	mod.VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME = "VK_NV_scissor_exclusive"
	mod.VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION = 2
	mod.VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME = "VK_NV_shader_atomic_float16_vector"
	mod.VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_SPEC_VERSION = 1
	mod.VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME = "VK_NV_shader_image_footprint"
	mod.VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION = 2
	mod.VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME = "VK_NV_shader_sm_builtins"
	mod.VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION = 1
	mod.VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME = "VK_NV_shader_subgroup_partitioned"
	mod.VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION = 1
	mod.VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME = "VK_NV_shading_rate_image"
	mod.VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION = 3
	mod.VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME = "VK_NV_viewport_array2"
	mod.VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION = 1
	mod.VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME = "VK_NV_viewport_array2"
	mod.VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION = 1
	mod.VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME = "VK_NV_viewport_swizzle"
	mod.VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION = 1
	mod.VK_NV_clip_space_w_scaling = 1
	mod.VK_NV_cluster_acceleration_structure = 1
	mod.VK_NV_command_buffer_inheritance = 1
	mod.VK_NV_compute_shader_derivatives = 1
	mod.VK_NV_cooperative_matrix = 1
	mod.VK_NV_cooperative_matrix2 = 1
	mod.VK_NV_cooperative_vector = 1
	mod.VK_NV_copy_memory_indirect = 1
	mod.VK_NV_corner_sampled_image = 1
	mod.VK_NV_coverage_reduction_mode = 1
	mod.VK_NV_dedicated_allocation = 1
	mod.VK_NV_dedicated_allocation_image_aliasing = 1
	mod.VK_NV_descriptor_pool_overallocation = 1
	mod.VK_NV_device_diagnostic_checkpoints = 1
	mod.VK_NV_device_diagnostics_config = 1
	mod.VK_NV_device_generated_commands = 1
	mod.VK_NV_device_generated_commands_compute = 1
	mod.VK_NV_display_stereo = 1
	mod.VK_NV_extended_sparse_address_space = 1
	mod.VK_NV_external_compute_queue = 1
	mod.VK_NV_external_memory = 1
	mod.VK_NV_external_memory_capabilities = 1
	mod.VK_NV_external_memory_rdma = 1
	mod.VK_NV_fill_rectangle = 1
	mod.VK_NV_fragment_coverage_to_color = 1
	mod.VK_NV_fragment_shader_barycentric = 1
	mod.VK_NV_fragment_shading_rate_enums = 1
	mod.VK_NV_framebuffer_mixed_samples = 1
	mod.VK_NV_geometry_shader_passthrough = 1
	mod.VK_NV_glsl_shader = 1
	mod.VK_NV_inherited_viewport_scissor = 1
	mod.VK_NV_linear_color_attachment = 1
	mod.VK_NV_low_latency = 1
	mod.VK_NV_low_latency2 = 1
	mod.VK_NV_memory_decompression = 1
	mod.VK_NV_mesh_shader = 1
	mod.VK_NV_optical_flow = 1
	mod.VK_NV_partitioned_acceleration_structure = 1
	mod.VK_NV_per_stage_descriptor_set = 1
	mod.VK_NV_present_barrier = 1
	mod.VK_NV_present_metering = 1
	mod.VK_NV_raw_access_chains = 1
	mod.VK_NV_ray_tracing = 1
	mod.VK_NV_ray_tracing_invocation_reorder = 1
	mod.VK_NV_ray_tracing_linear_swept_spheres = 1
	mod.VK_NV_ray_tracing_motion_blur = 1
	mod.VK_NV_ray_tracing_validation = 1
	mod.VK_NV_representative_fragment_test = 1
	mod.VK_NV_sample_mask_override_coverage = 1
	mod.VK_NV_scissor_exclusive = 1
	mod.VK_NV_shader_atomic_float16_vector = 1
	mod.VK_NV_shader_image_footprint = 1
	mod.VK_NV_shader_sm_builtins = 1
	mod.VK_NV_shader_subgroup_partitioned = 1
	mod.VK_NV_shading_rate_image = 1
	mod.VK_NV_viewport_array2 = 1
	mod.VK_NV_viewport_swizzle = 1
	mod.VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV = bit.bnot(0)
	mod.VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME = "VK_QCOM_filter_cubic_clamp"
	mod.VK_QCOM_FILTER_CUBIC_CLAMP_SPEC_VERSION = 1
	mod.VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME = "VK_QCOM_filter_cubic_weights"
	mod.VK_QCOM_FILTER_CUBIC_WEIGHTS_SPEC_VERSION = 1
	mod.VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME = "VK_QCOM_fragment_density_map_offset"
	mod.VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION = 3
	mod.VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME = "VK_QCOM_image_processing2"
	mod.VK_QCOM_IMAGE_PROCESSING_2_SPEC_VERSION = 1
	mod.VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME = "VK_QCOM_image_processing"
	mod.VK_QCOM_IMAGE_PROCESSING_SPEC_VERSION = 1
	mod.VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME = "VK_QCOM_multiview_per_view_render_areas"
	mod.VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_SPEC_VERSION = 1
	mod.VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME = "VK_QCOM_multiview_per_view_viewports"
	mod.VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_SPEC_VERSION = 1
	mod.VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME = "VK_QCOM_render_pass_shader_resolve"
	mod.VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION = 4
	mod.VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME = "VK_QCOM_render_pass_store_ops"
	mod.VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION = 2
	mod.VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME = "VK_QCOM_render_pass_transform"
	mod.VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION = 5
	mod.VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME = "VK_QCOM_rotated_copy_commands"
	mod.VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION = 2
	mod.VK_QCOM_TILE_MEMORY_HEAP_EXTENSION_NAME = "VK_QCOM_tile_memory_heap"
	mod.VK_QCOM_TILE_MEMORY_HEAP_SPEC_VERSION = 1
	mod.VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME = "VK_QCOM_tile_properties"
	mod.VK_QCOM_TILE_PROPERTIES_SPEC_VERSION = 1
	mod.VK_QCOM_TILE_SHADING_EXTENSION_NAME = "VK_QCOM_tile_shading"
	mod.VK_QCOM_TILE_SHADING_SPEC_VERSION = 2
	mod.VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME = "VK_QCOM_ycbcr_degamma"
	mod.VK_QCOM_YCBCR_DEGAMMA_SPEC_VERSION = 1
	mod.VK_QCOM_filter_cubic_clamp = 1
	mod.VK_QCOM_filter_cubic_weights = 1
	mod.VK_QCOM_fragment_density_map_offset = 1
	mod.VK_QCOM_image_processing = 1
	mod.VK_QCOM_image_processing2 = 1
	mod.VK_QCOM_multiview_per_view_render_areas = 1
	mod.VK_QCOM_multiview_per_view_viewports = 1
	mod.VK_QCOM_render_pass_shader_resolve = 1
	mod.VK_QCOM_render_pass_store_ops = 1
	mod.VK_QCOM_render_pass_transform = 1
	mod.VK_QCOM_rotated_copy_commands = 1
	mod.VK_QCOM_tile_memory_heap = 1
	mod.VK_QCOM_tile_properties = 1
	mod.VK_QCOM_tile_shading = 1
	mod.VK_QCOM_ycbcr_degamma = 1
	mod.VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME = "VK_QNX_external_memory_screen_buffer"
	mod.VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_SPEC_VERSION = 1
	mod.VK_QNX_SCREEN_SURFACE_EXTENSION_NAME = "VK_QNX_screen_surface"
	mod.VK_QNX_SCREEN_SURFACE_SPEC_VERSION = 1
	mod.VK_QNX_external_memory_screen_buffer = 1
	mod.VK_QNX_screen_surface = 1
	mod.VK_QUEUE_FAMILY_EXTERNAL = bit.bnot(1)
	mod.VK_QUEUE_FAMILY_EXTERNAL_KHR = bit.bnot(1)
	mod.VK_QUEUE_FAMILY_FOREIGN_EXT = bit.bnot(2)
	mod.VK_QUEUE_FAMILY_IGNORED = bit.bnot(0)
	mod.VK_REMAINING_3D_SLICES_EXT = bit.bnot(0)
	mod.VK_REMAINING_ARRAY_LAYERS = bit.bnot(0)
	mod.VK_REMAINING_MIP_LEVELS = bit.bnot(0)
	mod.VK_SEC_AMIGO_PROFILING_EXTENSION_NAME = "VK_SEC_amigo_profiling"
	mod.VK_SEC_AMIGO_PROFILING_SPEC_VERSION = 1
	mod.VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_EXTENSION_NAME = "VK_SEC_pipeline_cache_incremental_mode"
	mod.VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_SPEC_VERSION = 1
	mod.VK_SEC_amigo_profiling = 1
	mod.VK_SEC_pipeline_cache_incremental_mode = 1
	mod.VK_SHADER_UNUSED_KHR = bit.bnot(0)
	mod.VK_SHADER_UNUSED_NV = bit.bnot(0)
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_av1_decode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_SPEC_VERSION = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_API_VERSION_1_0_0 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_av1_encode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_SPEC_VERSION = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h264_decode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_SPEC_VERSION = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h264_encode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_SPEC_VERSION = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h265_decode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_SPEC_VERSION = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h265_encode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_SPEC_VERSION = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_API_VERSION_1_0_0 = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_vp9_decode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_SPEC_VERSION = bit.bor(
		bit.lshift(ffi.cast("uint32_t", 1), 22),
		bit.lshift(ffi.cast("uint32_t", 0), 12),
		ffi.cast("uint32_t", 0)
	)
	mod.VK_SUBPASS_EXTERNAL = bit.bnot(0)
	mod.VK_TRUE = 1
	mod.VK_USE_64_BIT_PTR_DEFINES = 1
	mod.VK_UUID_SIZE = 16
	mod.VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME = "VK_VALVE_descriptor_set_host_mapping"
	mod.VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION = 1
	mod.VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_EXTENSION_NAME = "VK_VALVE_fragment_density_map_layered"
	mod.VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_SPEC_VERSION = 1
	mod.VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME = "VK_VALVE_mutable_descriptor_type"
	mod.VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION = 1
	mod.VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_EXTENSION_NAME = "VK_VALVE_video_encode_rgb_conversion"
	mod.VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_SPEC_VERSION = 1
	mod.VK_VALVE_descriptor_set_host_mapping = 1
	mod.VK_VALVE_fragment_density_map_layered = 1
	mod.VK_VALVE_mutable_descriptor_type = 1
	mod.VK_VALVE_video_encode_rgb_conversion = 1
	mod.VK_VERSION_1_0 = 1
	mod.VK_VERSION_1_1 = 1
	mod.VK_VERSION_1_2 = 1
	mod.VK_VERSION_1_3 = 1
	mod.VK_VERSION_1_4 = 1
	mod.VK_WHOLE_SIZE = bit.bnot(0LL)
	mod.VULKAN_ANDROID_H_ = 1
	mod.VULKAN_CORE_H_ = 1
	mod.VULKAN_DIRECTFB_H_ = 1
	mod.VULKAN_GGP_H_ = 1
	mod.VULKAN_H_ = 1
	mod.VULKAN_IOS_H_ = 1
	mod.VULKAN_MACOS_H_ = 1
	mod.VULKAN_METAL_H_ = 1
	mod.VULKAN_SCREEN_H_ = 1
	mod.VULKAN_VIDEO_CODECS_COMMON_H_ = 1
	mod.VULKAN_VIDEO_CODEC_AV1STD_DECODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_AV1STD_ENCODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_AV1STD_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H264STD_DECODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H264STD_ENCODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H264STD_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H265STD_DECODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H265STD_ENCODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H265STD_H_ = 1
	mod.VULKAN_VIDEO_CODEC_VP9STD_DECODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_VP9STD_H_ = 1
	mod.VULKAN_VI_H_ = 1
	mod.VULKAN_WAYLAND_H_ = 1
	mod.VULKAN_XLIB_H_ = 1
	mod.__DATE__ = "Dec 04 2025"
	mod.__GNUC_MINOR__ = 2
	mod.__GNUC_PATCHLEVEL__ = 1
	mod.__GNUC__ = 4
	mod.__LP64__ = 1
	mod.__STDC_HOSTED__ = 1
	mod.__STDC_VERSION__ = 201710
	mod.__STDC__ = 1
	mod.__TIME__ = "12:14:47"
	mod.vulkan_video_codec_av1std = 1
	mod.vulkan_video_codec_av1std_decode = 1
	mod.vulkan_video_codec_av1std_encode = 1
	mod.vulkan_video_codec_h264std = 1
	mod.vulkan_video_codec_h264std_decode = 1
	mod.vulkan_video_codec_h264std_encode = 1
	mod.vulkan_video_codec_h265std = 1
	mod.vulkan_video_codec_h265std_decode = 1
	mod.vulkan_video_codec_h265std_encode = 1
	mod.vulkan_video_codec_vp9std = 1
	mod.vulkan_video_codec_vp9std_decode = 1
	mod.vulkan_video_codecs_common = 1
end

mod.VkSamplerYcbcrConversion = ffi.typeof([[int ]])
mod.VkDescriptorUpdateTemplate = ffi.typeof([[int ]])
mod.Display = ffi.typeof([[void*]])
mod.VisualID = ffi.typeof([[void*]])
mod.Window = ffi.typeof([[void*]])
mod.IDirectFB = ffi.typeof([[void*]])
mod.IDirectFBSurface = ffi.typeof([[void*]])
mod.GgpStreamDescriptor = ffi.typeof([[void*]])
mod.GgpFrameToken = ffi.typeof([[void*]])
mod._screen_context = ffi.typeof([[void*]])
mod.SECURITY_ATTRIBUTES = ffi.typeof([[void*]])
mod.VkBool32 = ffi.typeof([[uint32_t ]])
mod.VkDeviceAddress = ffi.typeof([[uint64_t ]])
mod.VkDeviceSize = ffi.typeof([[uint64_t ]])
mod.VkFlags = ffi.typeof([[uint32_t ]])
mod.VkSampleMask = ffi.typeof([[uint32_t ]])
mod.VkBuffer = ffi.typeof([[void*]])
mod.VkImage = ffi.typeof([[void*]])
mod.VkInstance = ffi.typeof([[void*]])
mod.VkPhysicalDevice = ffi.typeof([[void*]])
mod.VkDevice = ffi.typeof([[void*]])
mod.VkQueue = ffi.typeof([[void*]])
mod.VkSemaphore = ffi.typeof([[void*]])
mod.VkCommandBuffer = ffi.typeof([[void*]])
mod.VkFence = ffi.typeof([[void*]])
mod.VkDeviceMemory = ffi.typeof([[void*]])
mod.VkEvent = ffi.typeof([[void*]])
mod.VkQueryPool = ffi.typeof([[void*]])
mod.VkBufferView = ffi.typeof([[void*]])
mod.VkImageView = ffi.typeof([[void*]])
mod.VkShaderModule = ffi.typeof([[void*]])
mod.VkPipelineCache = ffi.typeof([[void*]])
mod.VkPipelineLayout = ffi.typeof([[void*]])
mod.VkPipeline = ffi.typeof([[void*]])
mod.VkRenderPass = ffi.typeof([[void*]])
mod.VkDescriptorSetLayout = ffi.typeof([[void*]])
mod.VkSampler = ffi.typeof([[void*]])
mod.VkDescriptorSet = ffi.typeof([[void*]])
mod.VkDescriptorPool = ffi.typeof([[void*]])
mod.VkFramebuffer = ffi.typeof([[void*]])
mod.VkCommandPool = ffi.typeof([[void*]])
mod.VkResult = ffi.typeof([[enum {
	VK_SUCCESS = 0,
	VK_NOT_READY = 1,
	VK_TIMEOUT = 2,
	VK_EVENT_SET = 3,
	VK_EVENT_RESET = 4,
	VK_INCOMPLETE = 5,
	VK_ERROR_OUT_OF_HOST_MEMORY = -1,
	VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
	VK_ERROR_INITIALIZATION_FAILED = -3,
	VK_ERROR_DEVICE_LOST = -4,
	VK_ERROR_MEMORY_MAP_FAILED = -5,
	VK_ERROR_LAYER_NOT_PRESENT = -6,
	VK_ERROR_EXTENSION_NOT_PRESENT = -7,
	VK_ERROR_FEATURE_NOT_PRESENT = -8,
	VK_ERROR_INCOMPATIBLE_DRIVER = -9,
	VK_ERROR_TOO_MANY_OBJECTS = -10,
	VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
	VK_ERROR_FRAGMENTED_POOL = -12,
	VK_ERROR_UNKNOWN = -13,
	VK_ERROR_VALIDATION_FAILED = -1000011001,
	VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
	VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
	VK_ERROR_FRAGMENTATION = -1000161000,
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
	VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
	VK_ERROR_NOT_PERMITTED = -1000174001,
	VK_ERROR_SURFACE_LOST_KHR = -1000000000,
	VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
	VK_SUBOPTIMAL_KHR = 1000001003,
	VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
	VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
	VK_ERROR_INVALID_SHADER_NV = -1000012000,
	VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000,
	VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001,
	VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002,
	VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003,
	VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
	VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
	VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
	VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
	VK_THREAD_IDLE_KHR = 1000268000,
	VK_THREAD_DONE_KHR = 1000268001,
	VK_OPERATION_DEFERRED_KHR = 1000268002,
	VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
	VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR = -1000299000,
	VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
	VK_INCOMPATIBLE_SHADER_BINARY_EXT = 1000482000,
	VK_PIPELINE_BINARY_MISSING_KHR = 1000483000,
	VK_ERROR_NOT_ENOUGH_SPACE_KHR = -1000483000,
	VK_ERROR_VALIDATION_FAILED_EXT = VK_ERROR_VALIDATION_FAILED,
	VK_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY,
	VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
	VK_ERROR_FRAGMENTATION_EXT = VK_ERROR_FRAGMENTATION,
	VK_ERROR_NOT_PERMITTED_EXT = VK_ERROR_NOT_PERMITTED,
	VK_ERROR_NOT_PERMITTED_KHR = VK_ERROR_NOT_PERMITTED,
	VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
	VK_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED,
	VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED,
	VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT = VK_INCOMPATIBLE_SHADER_BINARY_EXT,
	VK_RESULT_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkStructureType = ffi.typeof([[enum {
	VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
	VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
	VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54,
	VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
	VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
	VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002,
	VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003,
	VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004,
	VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
	VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000,
	VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001,
	VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
	VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004,
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005,
	VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006,
	VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007,
	VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008,
	VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009,
	VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
	VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001,
	VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
	VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES = 55,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES = 56,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO = 1000174000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES = 1000388000,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES = 1000388001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES = 1000416000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES = 1000528000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES = 1000544000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES = 1000259000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO = 1000259001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES = 1000259002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES = 1000525000,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO = 1000190001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES = 1000190002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES = 1000265000,
	VK_STRUCTURE_TYPE_MEMORY_MAP_INFO = 1000271000,
	VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO = 1000271001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES = 1000470000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES = 1000470001,
	VK_STRUCTURE_TYPE_RENDERING_AREA_INFO = 1000470003,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO = 1000470004,
	VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 = 1000338002,
	VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 = 1000338003,
	VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO = 1000470005,
	VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO = 1000470006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES = 1000080000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES = 1000232000,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO = 1000232001,
	VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO = 1000232002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES = 1000545000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES = 1000545001,
	VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS = 1000545002,
	VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO = 1000545003,
	VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO = 1000545004,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO = 1000545005,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO = 1000545006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES = 1000466000,
	VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO = 1000068000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES = 1000068001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES = 1000068002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES = 1000270000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES = 1000270001,
	VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY = 1000270002,
	VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY = 1000270003,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO = 1000270004,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO = 1000270005,
	VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO = 1000270006,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO = 1000270007,
	VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE = 1000270008,
	VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY = 1000270009,
	VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
	VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
	VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
	VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
	VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
	VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
	VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
	VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
	VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
	VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
	VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000,
	VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001,
	VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003,
	VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
	VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
	VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009,
	VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
	VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012,
	VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
	VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
	VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
	VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
	VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX = 1000029004,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR = 1000038000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000038001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000038002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR = 1000038003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR = 1000038004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR = 1000038005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR = 1000038006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR = 1000038007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR = 1000038008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR = 1000038009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR = 1000038010,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR = 1000038011,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR = 1000038012,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000038013,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR = 1000039000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000039001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000039002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR = 1000039003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR = 1000039004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR = 1000039005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR = 1000039006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR = 1000039007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR = 1000039009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR = 1000039010,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR = 1000039011,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR = 1000039012,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR = 1000039013,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000039014,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR = 1000040000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR = 1000040001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR = 1000040003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000040004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006,
	VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
	VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
	VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
	VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
	VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
	VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
	VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
	VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
	VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
	VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
	VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
	VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
	VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
	VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
	VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
	VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
	VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
	VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
	VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG = 1000110000,
	VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
	VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
	VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
	VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
	VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
	VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
	VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
	VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
	VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
	VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
	VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
	VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
	VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
	VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
	VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR = 1000141000,
	VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
	VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
	VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
	VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
	VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
	VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
	VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
	VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
	VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
	VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
	VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
	VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
	VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
	VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
	VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
	VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR = 1000187000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000187001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000187002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR = 1000187003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR = 1000187004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR = 1000187005,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
	VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
	VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
	VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
	VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
	VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
	VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
	VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
	VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
	VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
	VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
	VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
	VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
	VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
	VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR = 1000235000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
	VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
	VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
	VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
	VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
	VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT = 1000272000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT = 1000272001,
	VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT = 1000272002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
	VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
	VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT = 1000283000,
	VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT = 1000283001,
	VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT = 1000283002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
	VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
	VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
	VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002,
	VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004,
	VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR = 1000299005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR = 1000299007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR = 1000299009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000299010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
	VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM = 1000309000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM = 1000309001,
	VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM = 1000309002,
	VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM = 1000309003,
	VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM = 1000309004,
	VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM = 1000309005,
	VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV = 1000310000,
	VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000,
	VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001,
	VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002,
	VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003,
	VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004,
	VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005,
	VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006,
	VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007,
	VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008,
	VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
	VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
	VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003,
	VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004,
	VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005,
	VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007,
	VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008,
	VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010,
	VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011,
	VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
	VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000,
	VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001,
	VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000,
	VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001,
	VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
	VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
	VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
	VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000,
	VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
	VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
	VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
	VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
	VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
	VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
	VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
	VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
	VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT = 1000375000,
	VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT = 1000375001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000,
	VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001,
	VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
	VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR = 1000387000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE = 1000390000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE = 1000390001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE = 1000390002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE = 1000390003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT = 1000395000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT = 1000395001,
	VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000,
	VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001,
	VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002,
	VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006,
	VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007,
	VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI = 1000404000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI = 1000404001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI = 1000404002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
	VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM = 1000415000,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM = 1000417000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM = 1000417001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM = 1000417002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT = 1000418000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT = 1000418001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM = 1000424000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM = 1000424001,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM = 1000424002,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM = 1000424003,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM = 1000424004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV = 1000427000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV = 1000427001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV = 1000428000,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV = 1000428001,
	VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV = 1000428002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV = 1000429008,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV = 1000429009,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV = 1000429010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR = 1000434000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT = 1000451000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT = 1000451001,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT = 1000453000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002,
	VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003,
	VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG = 1000459000,
	VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG = 1000459001,
	VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM = 1000460000,
	VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM = 1000460001,
	VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM = 1000460002,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM = 1000460003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM = 1000460004,
	VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM = 1000460005,
	VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM = 1000460006,
	VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM = 1000460007,
	VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM = 1000460008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM = 1000460009,
	VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM = 1000460010,
	VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM = 1000460011,
	VK_STRUCTURE_TYPE_TENSOR_COPY_ARM = 1000460012,
	VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM = 1000460013,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM = 1000460014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM = 1000460015,
	VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM = 1000460016,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM = 1000460017,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM = 1000460018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM = 1000460019,
	VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM = 1000460020,
	VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460021,
	VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460022,
	VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM = 1000460023,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002,
	VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID = 1000468000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468001,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD = 1000476000,
	VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD = 1000476001,
	VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD = 1000476002,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR = 1000479000,
	VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR = 1000479001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR = 1000479002,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR = 1000480000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR = 1000480001,
	VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR = 1000480002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR = 1000481000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT = 1000482000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT = 1000482001,
	VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT = 1000482002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR = 1000483000,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR = 1000483001,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR = 1000483002,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR = 1000483003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR = 1000483004,
	VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR = 1000483005,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR = 1000483006,
	VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR = 1000483007,
	VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR = 1000483008,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR = 1000483009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000,
	VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000,
	VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR = 1000274000,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR = 1000274001,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR = 1000274002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR = 1000275000,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR = 1000275001,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR = 1000275002,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR = 1000275003,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR = 1000275004,
	VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR = 1000275005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM = 1000488000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV = 1000491000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491001,
	VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491002,
	VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV = 1000491004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV = 1000492000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV = 1000492001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000,
	VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT = 1000495000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT = 1000495001,
	VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT = 1000496000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT = 1000499000,
	VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV = 1000505000,
	VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV = 1000505001,
	VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV = 1000505002,
	VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV = 1000505003,
	VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV = 1000505004,
	VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV = 1000505005,
	VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV = 1000505006,
	VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV = 1000505007,
	VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV = 1000505008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR = 1000506000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506002,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM = 1000507000,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM = 1000507001,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM = 1000507002,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM = 1000507003,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM = 1000507004,
	VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM = 1000507005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM = 1000507006,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM = 1000507007,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM = 1000507008,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM = 1000507009,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM = 1000507010,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM = 1000507011,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM = 1000507012,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM = 1000507013,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM = 1000507014,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM = 1000507016,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM = 1000507017,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM = 1000507018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM = 1000507019,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM = 1000507015,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM = 1000510000,
	VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM = 1000510001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR = 1000201000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR = 1000511000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR = 1000512000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR = 1000512001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR = 1000512003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000512004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR = 1000512005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR = 1000513000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000513001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR = 1000513002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR = 1000513003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR = 1000513004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR = 1000513005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR = 1000513006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR = 1000513007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR = 1000513008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR = 1000513009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR = 1000513010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR = 1000514000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR = 1000514001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR = 1000514002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR = 1000514003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR = 1000515000,
	VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR = 1000515001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV = 1000516000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM = 1000518000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM = 1000518001,
	VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM = 1000518002,
	VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM = 1000519000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM = 1000519001,
	VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM = 1000519002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM = 1000520000,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM = 1000520001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM = 1000521000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT = 1000524000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR = 1000527000,
	VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT = 1000527001,
	VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX = 1000529000,
	VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX = 1000529001,
	VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX = 1000529002,
	VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX = 1000529003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX = 1000529004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT = 1000530000,
	VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR = 1000184000,
	VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT = 1000545007,
	VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT = 1000545008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV = 1000546000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM = 1000547000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM = 1000547001,
	VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM = 1000547002,
	VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM = 1000547003,
	VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM = 1000547004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR = 1000549000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR = 1000426001,
	VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR = 1000549002,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR = 1000549003,
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV = 1000551000,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV = 1000551001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR = 1000552000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR = 1000552001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR = 1000552002,
	VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR = 1000552003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR = 1000552004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553000,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR = 1000553002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000553005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR = 1000553009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553004,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553007,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV = 1000555000,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV = 1000556000,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV = 1000556001,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV = 1000556002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV = 1000556003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR = 1000558000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV = 1000559000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR = 1000562000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR = 1000562001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR = 1000562002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR = 1000562003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR = 1000562004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV = 1000563000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT = 1000564000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT = 1000567000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV = 1000568000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV = 1000569000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000569001,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV = 1000569002,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV = 1000569003,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV = 1000569004,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV = 1000569005,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV = 1000569006,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000569007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV = 1000570000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000570001,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570002,
	VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV = 1000570003,
	VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV = 1000570004,
	VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV = 1000570005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT = 1000572000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT = 1000572001,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT = 1000572002,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT = 1000572003,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT = 1000572004,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT = 1000572006,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT = 1000572007,
	VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT = 1000572008,
	VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT = 1000572009,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT = 1000572010,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT = 1000572011,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT = 1000572012,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT = 1000572013,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT = 1000572014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR = 1000574000,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR = 1000574002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA = 1000575000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA = 1000575001,
	VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA = 1000575002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT = 1000582000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT = 1000582001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR = 1000584000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR = 1000584001,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR = 1000584002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR = 1000586000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586003,
	VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS = 1000685000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI = 1000590000,
	VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI = 1000590001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV = 1000593000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV = 1000593001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV = 1000593002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM = 1000596000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT = 1000602000,
	VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT = 1000602001,
	VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT = 1000602002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR = 1000421000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT = 1000608000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM = 1000609000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE = 1000611000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE = 1000611001,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE = 1000611002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR = 1000286000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR = 1000286001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT = 1000425000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT = 1000425001,
	VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT = 1000425002,
	VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT = 1000619003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT = 1000620000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR = 1000361000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC = 1000637000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
	VK_STRUCTURE_TYPE_RENDERING_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_INFO,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
	VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
	VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO,
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
	VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
	VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
	VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
	VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES,
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES,
	VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT = VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY,
	VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT = VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT = VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO,
	VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT = VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO,
	VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT = VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE,
	VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT = VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY,
	VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_MAP_INFO,
	VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT = VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR,
	VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT = VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
	VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
	VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
	VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
	VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR = VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
	VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
	VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2,
	VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2,
	VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2,
	VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2,
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2,
	VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR = VK_STRUCTURE_TYPE_BUFFER_COPY_2,
	VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR = VK_STRUCTURE_TYPE_IMAGE_COPY_2,
	VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = VK_STRUCTURE_TYPE_IMAGE_BLIT_2,
	VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2,
	VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2,
	VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2,
	VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
	VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR,
	VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
	VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT,
	VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES,
	VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_AREA_INFO,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO,
	VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2,
	VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2,
	VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
	VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
	VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES,
	VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR = VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS,
	VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR = VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO,
	VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR = VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO,
	VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineCacheHeaderVersion = ffi.typeof([[enum {
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
	VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageLayout = ffi.typeof([[enum {
	VK_IMAGE_LAYOUT_UNDEFINED = 0,
	VK_IMAGE_LAYOUT_GENERAL = 1,
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
	VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
	VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
	VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
	VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ = 1000232000,
	VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002,
	VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
	VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
	VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
	VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
	VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM = 1000460000,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR = 1000553000,
	VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT = 1000620000,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
	VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,
	VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR = VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,
	VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,
	VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,
	VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkObjectType = ffi.typeof([[enum {
	VK_OBJECT_TYPE_UNKNOWN = 0,
	VK_OBJECT_TYPE_INSTANCE = 1,
	VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
	VK_OBJECT_TYPE_DEVICE = 3,
	VK_OBJECT_TYPE_QUEUE = 4,
	VK_OBJECT_TYPE_SEMAPHORE = 5,
	VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
	VK_OBJECT_TYPE_FENCE = 7,
	VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
	VK_OBJECT_TYPE_BUFFER = 9,
	VK_OBJECT_TYPE_IMAGE = 10,
	VK_OBJECT_TYPE_EVENT = 11,
	VK_OBJECT_TYPE_QUERY_POOL = 12,
	VK_OBJECT_TYPE_BUFFER_VIEW = 13,
	VK_OBJECT_TYPE_IMAGE_VIEW = 14,
	VK_OBJECT_TYPE_SHADER_MODULE = 15,
	VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
	VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
	VK_OBJECT_TYPE_RENDER_PASS = 18,
	VK_OBJECT_TYPE_PIPELINE = 19,
	VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
	VK_OBJECT_TYPE_SAMPLER = 21,
	VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
	VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
	VK_OBJECT_TYPE_FRAMEBUFFER = 24,
	VK_OBJECT_TYPE_COMMAND_POOL = 25,
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
	VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000,
	VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
	VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
	VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
	VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
	VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
	VK_OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000,
	VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
	VK_OBJECT_TYPE_CU_MODULE_NVX = 1000029000,
	VK_OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001,
	VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
	VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
	VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
	VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
	VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
	VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000,
	VK_OBJECT_TYPE_MICROMAP_EXT = 1000396000,
	VK_OBJECT_TYPE_TENSOR_ARM = 1000460000,
	VK_OBJECT_TYPE_TENSOR_VIEW_ARM = 1000460001,
	VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 1000464000,
	VK_OBJECT_TYPE_SHADER_EXT = 1000482000,
	VK_OBJECT_TYPE_PIPELINE_BINARY_KHR = 1000483000,
	VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM = 1000507000,
	VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV = 1000556000,
	VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT = 1000572000,
	VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT = 1000572001,
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
	VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT = VK_OBJECT_TYPE_PRIVATE_DATA_SLOT,
	VK_OBJECT_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkVendorId = ffi.typeof([[enum {
	VK_VENDOR_ID_KHRONOS = 0x10000,
	VK_VENDOR_ID_VIV = 0x10001,
	VK_VENDOR_ID_VSI = 0x10002,
	VK_VENDOR_ID_KAZAN = 0x10003,
	VK_VENDOR_ID_CODEPLAY = 0x10004,
	VK_VENDOR_ID_MESA = 0x10005,
	VK_VENDOR_ID_POCL = 0x10006,
	VK_VENDOR_ID_MOBILEYE = 0x10007,
	VK_VENDOR_ID_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSystemAllocationScope = ffi.typeof([[enum {
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
	VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkInternalAllocationType = ffi.typeof([[enum {
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
	VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFormat = ffi.typeof([[enum {
	VK_FORMAT_UNDEFINED = 0,
	VK_FORMAT_R4G4_UNORM_PACK8 = 1,
	VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
	VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
	VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
	VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
	VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
	VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
	VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
	VK_FORMAT_R8_UNORM = 9,
	VK_FORMAT_R8_SNORM = 10,
	VK_FORMAT_R8_USCALED = 11,
	VK_FORMAT_R8_SSCALED = 12,
	VK_FORMAT_R8_UINT = 13,
	VK_FORMAT_R8_SINT = 14,
	VK_FORMAT_R8_SRGB = 15,
	VK_FORMAT_R8G8_UNORM = 16,
	VK_FORMAT_R8G8_SNORM = 17,
	VK_FORMAT_R8G8_USCALED = 18,
	VK_FORMAT_R8G8_SSCALED = 19,
	VK_FORMAT_R8G8_UINT = 20,
	VK_FORMAT_R8G8_SINT = 21,
	VK_FORMAT_R8G8_SRGB = 22,
	VK_FORMAT_R8G8B8_UNORM = 23,
	VK_FORMAT_R8G8B8_SNORM = 24,
	VK_FORMAT_R8G8B8_USCALED = 25,
	VK_FORMAT_R8G8B8_SSCALED = 26,
	VK_FORMAT_R8G8B8_UINT = 27,
	VK_FORMAT_R8G8B8_SINT = 28,
	VK_FORMAT_R8G8B8_SRGB = 29,
	VK_FORMAT_B8G8R8_UNORM = 30,
	VK_FORMAT_B8G8R8_SNORM = 31,
	VK_FORMAT_B8G8R8_USCALED = 32,
	VK_FORMAT_B8G8R8_SSCALED = 33,
	VK_FORMAT_B8G8R8_UINT = 34,
	VK_FORMAT_B8G8R8_SINT = 35,
	VK_FORMAT_B8G8R8_SRGB = 36,
	VK_FORMAT_R8G8B8A8_UNORM = 37,
	VK_FORMAT_R8G8B8A8_SNORM = 38,
	VK_FORMAT_R8G8B8A8_USCALED = 39,
	VK_FORMAT_R8G8B8A8_SSCALED = 40,
	VK_FORMAT_R8G8B8A8_UINT = 41,
	VK_FORMAT_R8G8B8A8_SINT = 42,
	VK_FORMAT_R8G8B8A8_SRGB = 43,
	VK_FORMAT_B8G8R8A8_UNORM = 44,
	VK_FORMAT_B8G8R8A8_SNORM = 45,
	VK_FORMAT_B8G8R8A8_USCALED = 46,
	VK_FORMAT_B8G8R8A8_SSCALED = 47,
	VK_FORMAT_B8G8R8A8_UINT = 48,
	VK_FORMAT_B8G8R8A8_SINT = 49,
	VK_FORMAT_B8G8R8A8_SRGB = 50,
	VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
	VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
	VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
	VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
	VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
	VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
	VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
	VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
	VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
	VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
	VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
	VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
	VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
	VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
	VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
	VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
	VK_FORMAT_R16_UNORM = 70,
	VK_FORMAT_R16_SNORM = 71,
	VK_FORMAT_R16_USCALED = 72,
	VK_FORMAT_R16_SSCALED = 73,
	VK_FORMAT_R16_UINT = 74,
	VK_FORMAT_R16_SINT = 75,
	VK_FORMAT_R16_SFLOAT = 76,
	VK_FORMAT_R16G16_UNORM = 77,
	VK_FORMAT_R16G16_SNORM = 78,
	VK_FORMAT_R16G16_USCALED = 79,
	VK_FORMAT_R16G16_SSCALED = 80,
	VK_FORMAT_R16G16_UINT = 81,
	VK_FORMAT_R16G16_SINT = 82,
	VK_FORMAT_R16G16_SFLOAT = 83,
	VK_FORMAT_R16G16B16_UNORM = 84,
	VK_FORMAT_R16G16B16_SNORM = 85,
	VK_FORMAT_R16G16B16_USCALED = 86,
	VK_FORMAT_R16G16B16_SSCALED = 87,
	VK_FORMAT_R16G16B16_UINT = 88,
	VK_FORMAT_R16G16B16_SINT = 89,
	VK_FORMAT_R16G16B16_SFLOAT = 90,
	VK_FORMAT_R16G16B16A16_UNORM = 91,
	VK_FORMAT_R16G16B16A16_SNORM = 92,
	VK_FORMAT_R16G16B16A16_USCALED = 93,
	VK_FORMAT_R16G16B16A16_SSCALED = 94,
	VK_FORMAT_R16G16B16A16_UINT = 95,
	VK_FORMAT_R16G16B16A16_SINT = 96,
	VK_FORMAT_R16G16B16A16_SFLOAT = 97,
	VK_FORMAT_R32_UINT = 98,
	VK_FORMAT_R32_SINT = 99,
	VK_FORMAT_R32_SFLOAT = 100,
	VK_FORMAT_R32G32_UINT = 101,
	VK_FORMAT_R32G32_SINT = 102,
	VK_FORMAT_R32G32_SFLOAT = 103,
	VK_FORMAT_R32G32B32_UINT = 104,
	VK_FORMAT_R32G32B32_SINT = 105,
	VK_FORMAT_R32G32B32_SFLOAT = 106,
	VK_FORMAT_R32G32B32A32_UINT = 107,
	VK_FORMAT_R32G32B32A32_SINT = 108,
	VK_FORMAT_R32G32B32A32_SFLOAT = 109,
	VK_FORMAT_R64_UINT = 110,
	VK_FORMAT_R64_SINT = 111,
	VK_FORMAT_R64_SFLOAT = 112,
	VK_FORMAT_R64G64_UINT = 113,
	VK_FORMAT_R64G64_SINT = 114,
	VK_FORMAT_R64G64_SFLOAT = 115,
	VK_FORMAT_R64G64B64_UINT = 116,
	VK_FORMAT_R64G64B64_SINT = 117,
	VK_FORMAT_R64G64B64_SFLOAT = 118,
	VK_FORMAT_R64G64B64A64_UINT = 119,
	VK_FORMAT_R64G64B64A64_SINT = 120,
	VK_FORMAT_R64G64B64A64_SFLOAT = 121,
	VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
	VK_FORMAT_D16_UNORM = 124,
	VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
	VK_FORMAT_D32_SFLOAT = 126,
	VK_FORMAT_S8_UINT = 127,
	VK_FORMAT_D16_UNORM_S8_UINT = 128,
	VK_FORMAT_D24_UNORM_S8_UINT = 129,
	VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
	VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
	VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
	VK_FORMAT_BC2_UNORM_BLOCK = 135,
	VK_FORMAT_BC2_SRGB_BLOCK = 136,
	VK_FORMAT_BC3_UNORM_BLOCK = 137,
	VK_FORMAT_BC3_SRGB_BLOCK = 138,
	VK_FORMAT_BC4_UNORM_BLOCK = 139,
	VK_FORMAT_BC4_SNORM_BLOCK = 140,
	VK_FORMAT_BC5_UNORM_BLOCK = 141,
	VK_FORMAT_BC5_SNORM_BLOCK = 142,
	VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
	VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
	VK_FORMAT_BC7_UNORM_BLOCK = 145,
	VK_FORMAT_BC7_SRGB_BLOCK = 146,
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
	VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
	VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
	VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
	VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
	VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
	VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
	VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
	VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
	VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
	VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
	VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
	VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
	VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
	VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
	VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
	VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
	VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
	VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
	VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
	VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
	VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
	VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
	VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
	VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
	VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
	VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
	VK_FORMAT_A1B5G5R5_UNORM_PACK16 = 1000470000,
	VK_FORMAT_A8_UNORM = 1000470001,
	VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
	VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
	VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
	VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
	VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
	VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
	VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
	VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
	VK_FORMAT_R8_BOOL_ARM = 1000460000,
	VK_FORMAT_R16G16_SFIXED5_NV = 1000464000,
	VK_FORMAT_R10X6_UINT_PACK16_ARM = 1000609000,
	VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM = 1000609001,
	VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM = 1000609002,
	VK_FORMAT_R12X4_UINT_PACK16_ARM = 1000609003,
	VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM = 1000609004,
	VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM = 1000609005,
	VK_FORMAT_R14X2_UINT_PACK16_ARM = 1000609006,
	VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM = 1000609007,
	VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM = 1000609008,
	VK_FORMAT_R14X2_UNORM_PACK16_ARM = 1000609009,
	VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM = 1000609010,
	VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM = 1000609011,
	VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM = 1000609012,
	VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM = 1000609013,
	VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK,
	VK_FORMAT_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM,
	VK_FORMAT_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM,
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
	VK_FORMAT_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16,
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
	VK_FORMAT_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16,
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
	VK_FORMAT_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM,
	VK_FORMAT_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM,
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
	VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = VK_FORMAT_G8_B8R8_2PLANE_444_UNORM,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16,
	VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = VK_FORMAT_G16_B16R16_2PLANE_444_UNORM,
	VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = VK_FORMAT_A4R4G4B4_UNORM_PACK16,
	VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = VK_FORMAT_A4B4G4R4_UNORM_PACK16,
	VK_FORMAT_R16G16_S10_5_NV = VK_FORMAT_R16G16_SFIXED5_NV,
	VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR = VK_FORMAT_A1B5G5R5_UNORM_PACK16,
	VK_FORMAT_A8_UNORM_KHR = VK_FORMAT_A8_UNORM,
	VK_FORMAT_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageTiling = ffi.typeof([[enum {
	VK_IMAGE_TILING_OPTIMAL = 0,
	VK_IMAGE_TILING_LINEAR = 1,
	VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
	VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageType = ffi.typeof([[enum {
	VK_IMAGE_TYPE_1D = 0,
	VK_IMAGE_TYPE_2D = 1,
	VK_IMAGE_TYPE_3D = 2,
	VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceType = ffi.typeof([[enum {
	VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
	VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
	VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueryType = ffi.typeof([[enum {
	VK_QUERY_TYPE_OCCLUSION = 0,
	VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
	VK_QUERY_TYPE_TIMESTAMP = 2,
	VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000,
	VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
	VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
	VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
	VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR = 1000299000,
	VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 1000328000,
	VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 1000382000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001,
	VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000,
	VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 1000396001,
	VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSharingMode = ffi.typeof([[enum {
	VK_SHARING_MODE_EXCLUSIVE = 0,
	VK_SHARING_MODE_CONCURRENT = 1,
	VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkComponentSwizzle = ffi.typeof([[enum {
	VK_COMPONENT_SWIZZLE_IDENTITY = 0,
	VK_COMPONENT_SWIZZLE_ZERO = 1,
	VK_COMPONENT_SWIZZLE_ONE = 2,
	VK_COMPONENT_SWIZZLE_R = 3,
	VK_COMPONENT_SWIZZLE_G = 4,
	VK_COMPONENT_SWIZZLE_B = 5,
	VK_COMPONENT_SWIZZLE_A = 6,
	VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageViewType = ffi.typeof([[enum {
	VK_IMAGE_VIEW_TYPE_1D = 0,
	VK_IMAGE_VIEW_TYPE_2D = 1,
	VK_IMAGE_VIEW_TYPE_3D = 2,
	VK_IMAGE_VIEW_TYPE_CUBE = 3,
	VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
	VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
	VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkBlendFactor = ffi.typeof([[enum {
	VK_BLEND_FACTOR_ZERO = 0,
	VK_BLEND_FACTOR_ONE = 1,
	VK_BLEND_FACTOR_SRC_COLOR = 2,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
	VK_BLEND_FACTOR_DST_COLOR = 4,
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
	VK_BLEND_FACTOR_SRC_ALPHA = 6,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
	VK_BLEND_FACTOR_DST_ALPHA = 8,
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
	VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
	VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
	VK_BLEND_FACTOR_SRC1_COLOR = 15,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
	VK_BLEND_FACTOR_SRC1_ALPHA = 17,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
	VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkBlendOp = ffi.typeof([[enum {
	VK_BLEND_OP_ADD = 0,
	VK_BLEND_OP_SUBTRACT = 1,
	VK_BLEND_OP_REVERSE_SUBTRACT = 2,
	VK_BLEND_OP_MIN = 3,
	VK_BLEND_OP_MAX = 4,
	VK_BLEND_OP_ZERO_EXT = 1000148000,
	VK_BLEND_OP_SRC_EXT = 1000148001,
	VK_BLEND_OP_DST_EXT = 1000148002,
	VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
	VK_BLEND_OP_DST_OVER_EXT = 1000148004,
	VK_BLEND_OP_SRC_IN_EXT = 1000148005,
	VK_BLEND_OP_DST_IN_EXT = 1000148006,
	VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
	VK_BLEND_OP_DST_OUT_EXT = 1000148008,
	VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
	VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
	VK_BLEND_OP_XOR_EXT = 1000148011,
	VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
	VK_BLEND_OP_SCREEN_EXT = 1000148013,
	VK_BLEND_OP_OVERLAY_EXT = 1000148014,
	VK_BLEND_OP_DARKEN_EXT = 1000148015,
	VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
	VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
	VK_BLEND_OP_COLORBURN_EXT = 1000148018,
	VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
	VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
	VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
	VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
	VK_BLEND_OP_INVERT_EXT = 1000148023,
	VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
	VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
	VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
	VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
	VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
	VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
	VK_BLEND_OP_HARDMIX_EXT = 1000148030,
	VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
	VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
	VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
	VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
	VK_BLEND_OP_PLUS_EXT = 1000148035,
	VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
	VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
	VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
	VK_BLEND_OP_MINUS_EXT = 1000148039,
	VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
	VK_BLEND_OP_CONTRAST_EXT = 1000148041,
	VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
	VK_BLEND_OP_RED_EXT = 1000148043,
	VK_BLEND_OP_GREEN_EXT = 1000148044,
	VK_BLEND_OP_BLUE_EXT = 1000148045,
	VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCompareOp = ffi.typeof([[enum {
	VK_COMPARE_OP_NEVER = 0,
	VK_COMPARE_OP_LESS = 1,
	VK_COMPARE_OP_EQUAL = 2,
	VK_COMPARE_OP_LESS_OR_EQUAL = 3,
	VK_COMPARE_OP_GREATER = 4,
	VK_COMPARE_OP_NOT_EQUAL = 5,
	VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
	VK_COMPARE_OP_ALWAYS = 7,
	VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDynamicState = ffi.typeof([[enum {
	VK_DYNAMIC_STATE_VIEWPORT = 0,
	VK_DYNAMIC_STATE_SCISSOR = 1,
	VK_DYNAMIC_STATE_LINE_WIDTH = 2,
	VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
	VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
	VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
	VK_DYNAMIC_STATE_CULL_MODE = 1000267000,
	VK_DYNAMIC_STATE_FRONT_FACE = 1000267001,
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002,
	VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003,
	VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004,
	VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005,
	VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006,
	VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007,
	VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
	VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010,
	VK_DYNAMIC_STATE_STENCIL_OP = 1000267011,
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
	VK_DYNAMIC_STATE_LINE_STIPPLE = 1000259000,
	VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT = 1000099001,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT = 1000099002,
	VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
	VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
	VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
	VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
	VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV = 1000205000,
	VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
	VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
	VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
	VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
	VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
	VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
	VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 1000455003,
	VK_DYNAMIC_STATE_POLYGON_MODE_EXT = 1000455004,
	VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 1000455005,
	VK_DYNAMIC_STATE_SAMPLE_MASK_EXT = 1000455006,
	VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007,
	VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 1000455008,
	VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 1000455009,
	VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 1000455010,
	VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 1000455011,
	VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 1000455012,
	VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002,
	VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 1000455013,
	VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014,
	VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015,
	VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 1000455016,
	VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017,
	VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 1000455018,
	VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 1000455019,
	VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 1000455020,
	VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 1000455021,
	VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022,
	VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 1000455023,
	VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 1000455024,
	VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 1000455025,
	VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 1000455026,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 1000455027,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 1000455029,
	VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 1000455030,
	VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
	VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032,
	VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT = 1000524000,
	VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT = 1000582000,
	VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = VK_DYNAMIC_STATE_LINE_STIPPLE,
	VK_DYNAMIC_STATE_CULL_MODE_EXT = VK_DYNAMIC_STATE_CULL_MODE,
	VK_DYNAMIC_STATE_FRONT_FACE_EXT = VK_DYNAMIC_STATE_FRONT_FACE,
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT = VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY,
	VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT = VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT,
	VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT = VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT,
	VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT = VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE,
	VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
	VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
	VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT = VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
	VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE,
	VK_DYNAMIC_STATE_STENCIL_OP_EXT = VK_DYNAMIC_STATE_STENCIL_OP,
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT = VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE,
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE,
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT = VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE,
	VK_DYNAMIC_STATE_LINE_STIPPLE_KHR = VK_DYNAMIC_STATE_LINE_STIPPLE,
	VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFrontFace = ffi.typeof([[enum {
	VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
	VK_FRONT_FACE_CLOCKWISE = 1,
	VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkVertexInputRate = ffi.typeof([[enum {
	VK_VERTEX_INPUT_RATE_VERTEX = 0,
	VK_VERTEX_INPUT_RATE_INSTANCE = 1,
	VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPrimitiveTopology = ffi.typeof([[enum {
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
	VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPolygonMode = ffi.typeof([[enum {
	VK_POLYGON_MODE_FILL = 0,
	VK_POLYGON_MODE_LINE = 1,
	VK_POLYGON_MODE_POINT = 2,
	VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
	VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkStencilOp = ffi.typeof([[enum {
	VK_STENCIL_OP_KEEP = 0,
	VK_STENCIL_OP_ZERO = 1,
	VK_STENCIL_OP_REPLACE = 2,
	VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
	VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
	VK_STENCIL_OP_INVERT = 5,
	VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
	VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
	VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkLogicOp = ffi.typeof([[enum {
	VK_LOGIC_OP_CLEAR = 0,
	VK_LOGIC_OP_AND = 1,
	VK_LOGIC_OP_AND_REVERSE = 2,
	VK_LOGIC_OP_COPY = 3,
	VK_LOGIC_OP_AND_INVERTED = 4,
	VK_LOGIC_OP_NO_OP = 5,
	VK_LOGIC_OP_XOR = 6,
	VK_LOGIC_OP_OR = 7,
	VK_LOGIC_OP_NOR = 8,
	VK_LOGIC_OP_EQUIVALENT = 9,
	VK_LOGIC_OP_INVERT = 10,
	VK_LOGIC_OP_OR_REVERSE = 11,
	VK_LOGIC_OP_COPY_INVERTED = 12,
	VK_LOGIC_OP_OR_INVERTED = 13,
	VK_LOGIC_OP_NAND = 14,
	VK_LOGIC_OP_SET = 15,
	VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkBorderColor = ffi.typeof([[enum {
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
	VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
	VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
	VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
	VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004,
	VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFilter = ffi.typeof([[enum {
	VK_FILTER_NEAREST = 0,
	VK_FILTER_LINEAR = 1,
	VK_FILTER_CUBIC_EXT = 1000015000,
	VK_FILTER_CUBIC_IMG = VK_FILTER_CUBIC_EXT,
	VK_FILTER_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerAddressMode = ffi.typeof([[enum {
	VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
	VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerMipmapMode = ffi.typeof([[enum {
	VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
	VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
	VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDescriptorType = ffi.typeof([[enum {
	VK_DESCRIPTOR_TYPE_SAMPLER = 0,
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
	VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000,
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
	VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000,
	VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 1000440001,
	VK_DESCRIPTOR_TYPE_TENSOR_ARM = 1000460000,
	VK_DESCRIPTOR_TYPE_MUTABLE_EXT = 1000351000,
	VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570000,
	VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK,
	VK_DESCRIPTOR_TYPE_MUTABLE_VALVE = VK_DESCRIPTOR_TYPE_MUTABLE_EXT,
	VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkAttachmentLoadOp = ffi.typeof([[enum {
	VK_ATTACHMENT_LOAD_OP_LOAD = 0,
	VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
	VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
	VK_ATTACHMENT_LOAD_OP_NONE = 1000400000,
	VK_ATTACHMENT_LOAD_OP_NONE_EXT = VK_ATTACHMENT_LOAD_OP_NONE,
	VK_ATTACHMENT_LOAD_OP_NONE_KHR = VK_ATTACHMENT_LOAD_OP_NONE,
	VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkAttachmentStoreOp = ffi.typeof([[enum {
	VK_ATTACHMENT_STORE_OP_STORE = 0,
	VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
	VK_ATTACHMENT_STORE_OP_NONE = 1000301000,
	VK_ATTACHMENT_STORE_OP_NONE_KHR = VK_ATTACHMENT_STORE_OP_NONE,
	VK_ATTACHMENT_STORE_OP_NONE_QCOM = VK_ATTACHMENT_STORE_OP_NONE,
	VK_ATTACHMENT_STORE_OP_NONE_EXT = VK_ATTACHMENT_STORE_OP_NONE,
	VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineBindPoint = ffi.typeof([[enum {
	VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
	VK_PIPELINE_BIND_POINT_COMPUTE = 1,
	VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
	VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
	VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM = 1000507000,
	VK_PIPELINE_BIND_POINT_RAY_TRACING_NV = VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,
	VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCommandBufferLevel = ffi.typeof([[enum {
	VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
	VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
	VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkIndexType = ffi.typeof([[enum {
	VK_INDEX_TYPE_UINT16 = 0,
	VK_INDEX_TYPE_UINT32 = 1,
	VK_INDEX_TYPE_UINT8 = 1000265000,
	VK_INDEX_TYPE_NONE_KHR = 1000165000,
	VK_INDEX_TYPE_NONE_NV = VK_INDEX_TYPE_NONE_KHR,
	VK_INDEX_TYPE_UINT8_EXT = VK_INDEX_TYPE_UINT8,
	VK_INDEX_TYPE_UINT8_KHR = VK_INDEX_TYPE_UINT8,
	VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSubpassContents = ffi.typeof([[enum {
	VK_SUBPASS_CONTENTS_INLINE = 0,
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
	VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = 1000451000,
	VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT = VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR,
	VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkAccessFlagBits = ffi.typeof([[enum {
	VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
	VK_ACCESS_INDEX_READ_BIT = 0x00000002,
	VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
	VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
	VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
	VK_ACCESS_SHADER_READ_BIT = 0x00000020,
	VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
	VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
	VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
	VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
	VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
	VK_ACCESS_HOST_READ_BIT = 0x00002000,
	VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
	VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
	VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
	VK_ACCESS_NONE = 0,
	VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000,
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000,
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000,
	VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000,
	VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000,
	VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000,
	VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000,
	VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000,
	VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000,
	VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT = 0x00020000,
	VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT = 0x00040000,
	VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
	VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
	VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
	VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT,
	VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT,
	VK_ACCESS_NONE_KHR = VK_ACCESS_NONE,
	VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkAccessFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkImageAspectFlagBits = ffi.typeof([[enum {
	VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
	VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
	VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
	VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
	VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
	VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
	VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
	VK_IMAGE_ASPECT_NONE = 0,
	VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
	VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
	VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
	VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
	VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
	VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
	VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
	VK_IMAGE_ASPECT_NONE_KHR = VK_IMAGE_ASPECT_NONE,
	VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageAspectFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkFormatFeatureFlagBits = ffi.typeof([[enum {
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
	VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
	VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
	VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
	VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
	VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000,
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000,
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000,
	VK_FORMAT_FEATURE_DISJOINT_BIT = 0x00400000,
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000,
	VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000,
	VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000,
	VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x00002000,
	VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000,
	VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000,
	VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000,
	VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT,
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
	VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT,
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
	VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFormatFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkImageCreateFlagBits = ffi.typeof([[enum {
	VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
	VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
	VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
	VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
	VK_IMAGE_CREATE_ALIAS_BIT = 0x00000400,
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040,
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020,
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080,
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100,
	VK_IMAGE_CREATE_PROTECTED_BIT = 0x00000800,
	VK_IMAGE_CREATE_DISJOINT_BIT = 0x00000200,
	VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000,
	VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
	VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000,
	VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00010000,
	VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 0x00040000,
	VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = 0x00020000,
	VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = 0x00100000,
	VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT = 0x00008000,
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
	VK_IMAGE_CREATE_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT,
	VK_IMAGE_CREATE_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT,
	VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT,
	VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSampleCountFlagBits = ffi.typeof([[enum {
	VK_SAMPLE_COUNT_1_BIT = 0x00000001,
	VK_SAMPLE_COUNT_2_BIT = 0x00000002,
	VK_SAMPLE_COUNT_4_BIT = 0x00000004,
	VK_SAMPLE_COUNT_8_BIT = 0x00000008,
	VK_SAMPLE_COUNT_16_BIT = 0x00000010,
	VK_SAMPLE_COUNT_32_BIT = 0x00000020,
	VK_SAMPLE_COUNT_64_BIT = 0x00000040,
	VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSampleCountFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkImageUsageFlagBits = ffi.typeof([[enum {
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
	VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
	VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
	VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
	VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
	VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
	VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
	VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
	VK_IMAGE_USAGE_HOST_TRANSFER_BIT = 0x00400000,
	VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00000400,
	VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00000800,
	VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 0x00001000,
	VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200,
	VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00000100,
	VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00002000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00004000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 0x00008000,
	VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x00080000,
	VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x00040000,
	VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 0x00100000,
	VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 0x00200000,
	VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM = 0x00800000,
	VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM = 0x08000000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x02000000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x04000000,
	VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
	VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT = VK_IMAGE_USAGE_HOST_TRANSFER_BIT,
	VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageUsageFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkInstanceCreateFlagBits = ffi.typeof([[enum {
	VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = 0x00000001,
	VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkInstanceCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMemoryHeapFlagBits = ffi.typeof([[enum {
	VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002,
	VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM = 0x00000008,
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
	VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryHeapFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMemoryPropertyFlagBits = ffi.typeof([[enum {
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
	VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
	VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,
	VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,
	VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x00000100,
	VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryPropertyFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueueFlagBits = ffi.typeof([[enum {
	VK_QUEUE_GRAPHICS_BIT = 0x00000001,
	VK_QUEUE_COMPUTE_BIT = 0x00000002,
	VK_QUEUE_TRANSFER_BIT = 0x00000004,
	VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
	VK_QUEUE_PROTECTED_BIT = 0x00000010,
	VK_QUEUE_VIDEO_DECODE_BIT_KHR = 0x00000020,
	VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 0x00000040,
	VK_QUEUE_OPTICAL_FLOW_BIT_NV = 0x00000100,
	VK_QUEUE_DATA_GRAPH_BIT_ARM = 0x00000400,
	VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueueFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDeviceCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDeviceQueueCreateFlagBits = ffi.typeof([[enum {
	VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
	VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDeviceQueueCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineStageFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
	VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
	VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
	VK_PIPELINE_STAGE_NONE = 0,
	VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000,
	VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000,
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000,
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x00200000,
	VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,
	VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000,
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 0x00080000,
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 0x00100000,
	VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT = 0x00020000,
	VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT,
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT,
	VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT,
	VK_PIPELINE_STAGE_NONE_KHR = VK_PIPELINE_STAGE_NONE,
	VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineStageFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMemoryMapFlagBits = ffi.typeof([[enum {
	VK_MEMORY_MAP_PLACED_BIT_EXT = 0x00000001,
	VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryMapFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSparseMemoryBindFlagBits = ffi.typeof([[enum {
	VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
	VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSparseMemoryBindFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSparseImageFormatFlagBits = ffi.typeof([[enum {
	VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
	VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
	VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
	VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSparseImageFormatFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkFenceCreateFlagBits = ffi.typeof([[enum {
	VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
	VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFenceCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSemaphoreCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkEventCreateFlagBits = ffi.typeof([[enum {
	VK_EVENT_CREATE_DEVICE_ONLY_BIT = 0x00000001,
	VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR = VK_EVENT_CREATE_DEVICE_ONLY_BIT,
	VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkEventCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueryPipelineStatisticFlagBits = ffi.typeof([[enum {
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
	VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
	VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
	VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
	VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = 0x00000800,
	VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = 0x00001000,
	VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI = 0x00002000,
	VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueryPipelineStatisticFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueryPoolCreateFlagBits = ffi.typeof([[enum {
	VK_QUERY_POOL_CREATE_RESET_BIT_KHR = 0x00000001,
	VK_QUERY_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueryPoolCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueryResultFlagBits = ffi.typeof([[enum {
	VK_QUERY_RESULT_64_BIT = 0x00000001,
	VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
	VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
	VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
	VK_QUERY_RESULT_WITH_STATUS_BIT_KHR = 0x00000010,
	VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueryResultFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkBufferCreateFlagBits = ffi.typeof([[enum {
	VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
	VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
	VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
	VK_BUFFER_CREATE_PROTECTED_BIT = 0x00000008,
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000010,
	VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000020,
	VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = 0x00000040,
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
	VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkBufferCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkBufferUsageFlagBits = ffi.typeof([[enum {
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
	VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
	VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
	VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
	VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
	VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x00020000,
	VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000,
	VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00004000,
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800,
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000,
	VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200,
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000,
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000,
	VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400,
	VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000,
	VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000,
	VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x00200000,
	VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00400000,
	VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000,
	VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x00800000,
	VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 0x01000000,
	VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM = 0x08000000,
	VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
	VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkBufferUsageFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkBufferViewCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkImageViewCreateFlagBits = ffi.typeof([[enum {
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001,
	VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000004,
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x00000002,
	VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageViewCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkShaderModuleCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCacheCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0x00000001,
	VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR = 0x00000008,
	VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT = VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT,
	VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineCacheCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkColorComponentFlagBits = ffi.typeof([[enum {
	VK_COLOR_COMPONENT_R_BIT = 0x00000001,
	VK_COLOR_COMPONENT_G_BIT = 0x00000002,
	VK_COLOR_COMPONENT_B_BIT = 0x00000004,
	VK_COLOR_COMPONENT_A_BIT = 0x00000008,
	VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkColorComponentFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
	VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
	VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008,
	VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x00000010,
	VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100,
	VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200,
	VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT = 0x08000000,
	VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT = 0x40000000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000,
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000,
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000,
	VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000,
	VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020,
	VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000,
	VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000,
	VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040,
	VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080,
	VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00040000,
	VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 0x00000800,
	VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x20000000,
	VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x00800000,
	VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x00000400,
	VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000,
	VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x02000000,
	VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x04000000,
	VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x01000000,
	VK_PIPELINE_CREATE_DISPATCH_BASE = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
	VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
	VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
	VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
	VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
	VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT = VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT,
	VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT = VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT,
	VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT = VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT,
	VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT = VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT,
	VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineShaderStageCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 0x00000001,
	VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 0x00000002,
	VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,
	VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,
	VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineShaderStageCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkShaderStageFlagBits = ffi.typeof([[enum {
	VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
	VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
	VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
	VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
	VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
	VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
	VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
	VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
	VK_SHADER_STAGE_RAYGEN_BIT_KHR = 0x00000100,
	VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 0x00000200,
	VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 0x00000400,
	VK_SHADER_STAGE_MISS_BIT_KHR = 0x00000800,
	VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 0x00001000,
	VK_SHADER_STAGE_CALLABLE_BIT_KHR = 0x00002000,
	VK_SHADER_STAGE_TASK_BIT_EXT = 0x00000040,
	VK_SHADER_STAGE_MESH_BIT_EXT = 0x00000080,
	VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x00004000,
	VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI = 0x00080000,
	VK_SHADER_STAGE_RAYGEN_BIT_NV = VK_SHADER_STAGE_RAYGEN_BIT_KHR,
	VK_SHADER_STAGE_ANY_HIT_BIT_NV = VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
	VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
	VK_SHADER_STAGE_MISS_BIT_NV = VK_SHADER_STAGE_MISS_BIT_KHR,
	VK_SHADER_STAGE_INTERSECTION_BIT_NV = VK_SHADER_STAGE_INTERSECTION_BIT_KHR,
	VK_SHADER_STAGE_CALLABLE_BIT_NV = VK_SHADER_STAGE_CALLABLE_BIT_KHR,
	VK_SHADER_STAGE_TASK_BIT_NV = VK_SHADER_STAGE_TASK_BIT_EXT,
	VK_SHADER_STAGE_MESH_BIT_NV = VK_SHADER_STAGE_MESH_BIT_EXT,
	VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCullModeFlagBits = ffi.typeof([[enum {
	VK_CULL_MODE_NONE = 0,
	VK_CULL_MODE_FRONT_BIT = 0x00000001,
	VK_CULL_MODE_BACK_BIT = 0x00000002,
	VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
	VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCullModeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineVertexInputStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineInputAssemblyStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineTessellationStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineViewportStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineRasterizationStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineMultisampleStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineDepthStencilStateCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x00000001,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x00000002,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineDepthStencilStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineColorBlendStateCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = 0x00000001,
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT,
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineColorBlendStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineDynamicStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineLayoutCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = 0x00000002,
	VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineLayoutCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkShaderStageFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSamplerCreateFlagBits = ffi.typeof([[enum {
	VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x00000001,
	VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x00000002,
	VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000008,
	VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = 0x00000004,
	VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = 0x00000010,
	VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDescriptorPoolCreateFlagBits = ffi.typeof([[enum {
	VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 0x00000002,
	VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = 0x00000004,
	VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV = 0x00000008,
	VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV = 0x00000010,
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
	VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT,
	VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDescriptorPoolCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDescriptorPoolResetFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDescriptorSetLayoutCreateFlagBits = ffi.typeof([[enum {
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x00000002,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT = 0x00000001,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00000010,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT = 0x00000020,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00000080,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = 0x00000004,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV = 0x00000040,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE = VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDescriptorSetLayoutCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkAttachmentDescriptionFlagBits = ffi.typeof([[enum {
	VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
	VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkAttachmentDescriptionFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDependencyFlagBits = ffi.typeof([[enum {
	VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
	VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004,
	VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002,
	VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = 0x00000008,
	VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR = 0x00000020,
	VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR = 0x00000040,
	VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,
	VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,
	VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDependencyFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkFramebufferCreateFlagBits = ffi.typeof([[enum {
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x00000001,
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,
	VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFramebufferCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkRenderPassCreateFlagBits = ffi.typeof([[enum {
	VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 0x00000002,
	VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = 0x00000004,
	VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkRenderPassCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSubpassDescriptionFlagBits = ffi.typeof([[enum {
	VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001,
	VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002,
	VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 0x00000004,
	VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 0x00000008,
	VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM = 0x00000100,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = 0x00000010,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x00000020,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x00000040,
	VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x00000080,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
	VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSubpassDescriptionFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkCommandPoolCreateFlagBits = ffi.typeof([[enum {
	VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
	VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
	VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004,
	VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCommandPoolCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkCommandPoolResetFlagBits = ffi.typeof([[enum {
	VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
	VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCommandPoolResetFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkCommandBufferUsageFlagBits = ffi.typeof([[enum {
	VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
	VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
	VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
	VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCommandBufferUsageFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueryControlFlagBits = ffi.typeof([[enum {
	VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
	VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueryControlFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkCommandBufferResetFlagBits = ffi.typeof([[enum {
	VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
	VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCommandBufferResetFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkStencilFaceFlagBits = ffi.typeof([[enum {
	VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
	VK_STENCIL_FACE_BACK_BIT = 0x00000002,
	VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
	VK_STENCIL_FRONT_AND_BACK = VK_STENCIL_FACE_FRONT_AND_BACK,
	VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkStencilFaceFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExtent2D = ffi.typeof([[struct {
	uint32_t width;
	uint32_t height;
}]])
ffi.metatype(
	mod.VkExtent2D,
	{
		__tostring = function(s)
			return ("struct VkExtent2D[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.width, t.height)
		end,
	}
)
mod.VkExtent3D = ffi.typeof([[struct {
	uint32_t width;
	uint32_t height;
	uint32_t depth;
}]])
ffi.metatype(
	mod.VkExtent3D,
	{
		__tostring = function(s)
			return ("struct VkExtent3D[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.width, t.height, t.depth)
		end,
	}
)
mod.VkOffset2D = ffi.typeof([[struct {
	int32_t x;
	int32_t y;
}]])
ffi.metatype(
	mod.VkOffset2D,
	{
		__tostring = function(s)
			return ("struct VkOffset2D[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.x, t.y)
		end,
	}
)
mod.VkOffset3D = ffi.typeof([[struct {
	int32_t x;
	int32_t y;
	int32_t z;
}]])
ffi.metatype(
	mod.VkOffset3D,
	{
		__tostring = function(s)
			return ("struct VkOffset3D[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.x, t.y, t.z)
		end,
	}
)
mod.VkRect2D = ffi.typeof([[struct {
	$ offset;
	$ extent;
}]], mod.VkOffset2D, mod.VkExtent2D)
ffi.metatype(
	mod.VkRect2D,
	{
		__tostring = function(s)
			return ("struct VkRect2D[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.offset, t.extent)
		end,
	}
)
mod.VkBaseInStructure = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
ffi.metatype(
	mod.VkBaseInStructure,
	{
		__tostring = function(s)
			return ("struct VkBaseInStructure[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext)
		end,
	}
)
mod.VkBaseOutStructure = ffi.typeof([[struct {
	$ sType;
	void* pNext;
}]], mod.VkStructureType)
ffi.metatype(
	mod.VkBaseOutStructure,
	{
		__tostring = function(s)
			return ("struct VkBaseOutStructure[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext)
		end,
	}
)
mod.VkBufferMemoryBarrier = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcAccessMask;
	$ dstAccessMask;
	uint32_t srcQueueFamilyIndex;
	uint32_t dstQueueFamilyIndex;
	$ buffer;
	$ offset;
	$ size;
}]],
	mod.VkStructureType,
	mod.VkAccessFlags,
	mod.VkAccessFlags,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkBufferMemoryBarrier,
	{
		__tostring = function(s)
			return ("struct VkBufferMemoryBarrier[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcAccessMask,
				t.dstAccessMask,
				t.srcQueueFamilyIndex,
				t.dstQueueFamilyIndex,
				t.buffer,
				t.offset,
				t.size
			)
		end,
	}
)
mod.VkDispatchIndirectCommand = ffi.typeof([[struct {
	uint32_t x;
	uint32_t y;
	uint32_t z;
}]])
ffi.metatype(
	mod.VkDispatchIndirectCommand,
	{
		__tostring = function(s)
			return ("struct VkDispatchIndirectCommand[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.x, t.y, t.z)
		end,
	}
)
mod.VkDrawIndexedIndirectCommand = ffi.typeof([[struct {
	uint32_t indexCount;
	uint32_t instanceCount;
	uint32_t firstIndex;
	int32_t vertexOffset;
	uint32_t firstInstance;
}]])
ffi.metatype(
	mod.VkDrawIndexedIndirectCommand,
	{
		__tostring = function(s)
			return ("struct VkDrawIndexedIndirectCommand[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.indexCount,
				t.instanceCount,
				t.firstIndex,
				t.vertexOffset,
				t.firstInstance
			)
		end,
	}
)
mod.VkDrawIndirectCommand = ffi.typeof([[struct {
	uint32_t vertexCount;
	uint32_t instanceCount;
	uint32_t firstVertex;
	uint32_t firstInstance;
}]])
ffi.metatype(
	mod.VkDrawIndirectCommand,
	{
		__tostring = function(s)
			return ("struct VkDrawIndirectCommand[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.vertexCount, t.instanceCount, t.firstVertex, t.firstInstance)
		end,
	}
)
mod.VkImageSubresourceRange = ffi.typeof(
	[[struct {
	$ aspectMask;
	uint32_t baseMipLevel;
	uint32_t levelCount;
	uint32_t baseArrayLayer;
	uint32_t layerCount;
}]],
	mod.VkImageAspectFlags
)
ffi.metatype(
	mod.VkImageSubresourceRange,
	{
		__tostring = function(s)
			return ("struct VkImageSubresourceRange[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.aspectMask,
				t.baseMipLevel,
				t.levelCount,
				t.baseArrayLayer,
				t.layerCount
			)
		end,
	}
)
mod.VkImageMemoryBarrier = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcAccessMask;
	$ dstAccessMask;
	$ oldLayout;
	$ newLayout;
	uint32_t srcQueueFamilyIndex;
	uint32_t dstQueueFamilyIndex;
	$ image;
	$ subresourceRange;
}]],
	mod.VkStructureType,
	mod.VkAccessFlags,
	mod.VkAccessFlags,
	mod.VkImageLayout,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageSubresourceRange
)
ffi.metatype(
	mod.VkImageMemoryBarrier,
	{
		__tostring = function(s)
			return ("struct VkImageMemoryBarrier[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcAccessMask,
				t.dstAccessMask,
				t.oldLayout,
				t.newLayout,
				t.srcQueueFamilyIndex,
				t.dstQueueFamilyIndex,
				t.image,
				t.subresourceRange
			)
		end,
	}
)
mod.VkMemoryBarrier = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcAccessMask;
	$ dstAccessMask;
}]],
	mod.VkStructureType,
	mod.VkAccessFlags,
	mod.VkAccessFlags
)
ffi.metatype(
	mod.VkMemoryBarrier,
	{
		__tostring = function(s)
			return ("struct VkMemoryBarrier[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.srcAccessMask, t.dstAccessMask)
		end,
	}
)
mod.VkPipelineCacheHeaderVersionOne = ffi.typeof(
	[[struct {
	uint32_t headerSize;
	$ headerVersion;
	uint32_t vendorID;
	uint32_t deviceID;
	uint8_t pipelineCacheUUID[16U];
}]],
	mod.VkPipelineCacheHeaderVersion
)
ffi.metatype(
	mod.VkPipelineCacheHeaderVersionOne,
	{
		__tostring = function(s)
			return ("struct VkPipelineCacheHeaderVersionOne[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.headerSize,
				t.headerVersion,
				t.vendorID,
				t.deviceID,
				t.pipelineCacheUUID
			)
		end,
	}
)
mod.PFN_vkAllocationFunction = ffi.typeof([[void*(*)(void*, size_t , size_t , $ )]], mod.VkSystemAllocationScope)
mod.PFN_vkFreeFunction = ffi.typeof([[void (*)(void*, void*)]])
mod.PFN_vkInternalAllocationNotification = ffi.typeof(
	[[void (*)(void*, size_t , $ , $ )]],
	mod.VkInternalAllocationType,
	mod.VkSystemAllocationScope
)
mod.PFN_vkInternalFreeNotification = ffi.typeof(
	[[void (*)(void*, size_t , $ , $ )]],
	mod.VkInternalAllocationType,
	mod.VkSystemAllocationScope
)
mod.PFN_vkReallocationFunction = ffi.typeof([[void*(*)(void*, void*, size_t , size_t , $ )]], mod.VkSystemAllocationScope)
mod.PFN_vkVoidFunction = ffi.typeof([[void (*)(void )]])
mod.VkAllocationCallbacks = ffi.typeof(
	[[struct {
	void* pUserData;
	$ pfnAllocation;
	$ pfnReallocation;
	$ pfnFree;
	$ pfnInternalAllocation;
	$ pfnInternalFree;
}]],
	mod.PFN_vkAllocationFunction,
	mod.PFN_vkReallocationFunction,
	mod.PFN_vkFreeFunction,
	mod.PFN_vkInternalAllocationNotification,
	mod.PFN_vkInternalFreeNotification
)
ffi.metatype(
	mod.VkAllocationCallbacks,
	{
		__tostring = function(s)
			return ("struct VkAllocationCallbacks[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.pUserData,
				t.pfnAllocation,
				t.pfnReallocation,
				t.pfnFree,
				t.pfnInternalAllocation,
				t.pfnInternalFree
			)
		end,
	}
)
mod.VkApplicationInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const char* pApplicationName;
	uint32_t applicationVersion;
	const char* pEngineName;
	uint32_t engineVersion;
	uint32_t apiVersion;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkApplicationInfo,
	{
		__tostring = function(s)
			return ("struct VkApplicationInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pApplicationName,
				t.applicationVersion,
				t.pEngineName,
				t.engineVersion,
				t.apiVersion
			)
		end,
	}
)
mod.VkFormatProperties = ffi.typeof(
	[[struct {
	$ linearTilingFeatures;
	$ optimalTilingFeatures;
	$ bufferFeatures;
}]],
	mod.VkFormatFeatureFlags,
	mod.VkFormatFeatureFlags,
	mod.VkFormatFeatureFlags
)
ffi.metatype(
	mod.VkFormatProperties,
	{
		__tostring = function(s)
			return ("struct VkFormatProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.linearTilingFeatures, t.optimalTilingFeatures, t.bufferFeatures)
		end,
	}
)
mod.VkImageFormatProperties = ffi.typeof(
	[[struct {
	$ maxExtent;
	uint32_t maxMipLevels;
	uint32_t maxArrayLayers;
	$ sampleCounts;
	$ maxResourceSize;
}]],
	mod.VkExtent3D,
	mod.VkSampleCountFlags,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkImageFormatProperties,
	{
		__tostring = function(s)
			return ("struct VkImageFormatProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.maxExtent,
				t.maxMipLevels,
				t.maxArrayLayers,
				t.sampleCounts,
				t.maxResourceSize
			)
		end,
	}
)
mod.VkInstanceCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const $* pApplicationInfo;
	uint32_t enabledLayerCount;
	const char** const ppEnabledLayerNames;
	uint32_t enabledExtensionCount;
	const char** const ppEnabledExtensionNames;
}]],
	mod.VkStructureType,
	mod.VkInstanceCreateFlags,
	mod.VkApplicationInfo
)
ffi.metatype(
	mod.VkInstanceCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkInstanceCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.pApplicationInfo,
				t.enabledLayerCount,
				t.ppEnabledLayerNames,
				t.enabledExtensionCount,
				t.ppEnabledExtensionNames
			)
		end,
	}
)
mod.VkMemoryHeap = ffi.typeof([[struct {
	$ size;
	$ flags;
}]], mod.VkDeviceSize, mod.VkMemoryHeapFlags)
ffi.metatype(
	mod.VkMemoryHeap,
	{
		__tostring = function(s)
			return ("struct VkMemoryHeap[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.size, t.flags)
		end,
	}
)
mod.VkMemoryType = ffi.typeof([[struct {
	$ propertyFlags;
	uint32_t heapIndex;
}]], mod.VkMemoryPropertyFlags)
ffi.metatype(
	mod.VkMemoryType,
	{
		__tostring = function(s)
			return ("struct VkMemoryType[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.propertyFlags, t.heapIndex)
		end,
	}
)
mod.VkPhysicalDeviceFeatures = ffi.typeof(
	[[struct {
	$ robustBufferAccess;
	$ fullDrawIndexUint32;
	$ imageCubeArray;
	$ independentBlend;
	$ geometryShader;
	$ tessellationShader;
	$ sampleRateShading;
	$ dualSrcBlend;
	$ logicOp;
	$ multiDrawIndirect;
	$ drawIndirectFirstInstance;
	$ depthClamp;
	$ depthBiasClamp;
	$ fillModeNonSolid;
	$ depthBounds;
	$ wideLines;
	$ largePoints;
	$ alphaToOne;
	$ multiViewport;
	$ samplerAnisotropy;
	$ textureCompressionETC2;
	$ textureCompressionASTC_LDR;
	$ textureCompressionBC;
	$ occlusionQueryPrecise;
	$ pipelineStatisticsQuery;
	$ vertexPipelineStoresAndAtomics;
	$ fragmentStoresAndAtomics;
	$ shaderTessellationAndGeometryPointSize;
	$ shaderImageGatherExtended;
	$ shaderStorageImageExtendedFormats;
	$ shaderStorageImageMultisample;
	$ shaderStorageImageReadWithoutFormat;
	$ shaderStorageImageWriteWithoutFormat;
	$ shaderUniformBufferArrayDynamicIndexing;
	$ shaderSampledImageArrayDynamicIndexing;
	$ shaderStorageBufferArrayDynamicIndexing;
	$ shaderStorageImageArrayDynamicIndexing;
	$ shaderClipDistance;
	$ shaderCullDistance;
	$ shaderFloat64;
	$ shaderInt64;
	$ shaderInt16;
	$ shaderResourceResidency;
	$ shaderResourceMinLod;
	$ sparseBinding;
	$ sparseResidencyBuffer;
	$ sparseResidencyImage2D;
	$ sparseResidencyImage3D;
	$ sparseResidency2Samples;
	$ sparseResidency4Samples;
	$ sparseResidency8Samples;
	$ sparseResidency16Samples;
	$ sparseResidencyAliased;
	$ variableMultisampleRate;
	$ inheritedQueries;
}]],
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.robustBufferAccess,
				t.fullDrawIndexUint32,
				t.imageCubeArray,
				t.independentBlend,
				t.geometryShader,
				t.tessellationShader,
				t.sampleRateShading,
				t.dualSrcBlend,
				t.logicOp,
				t.multiDrawIndirect,
				t.drawIndirectFirstInstance,
				t.depthClamp,
				t.depthBiasClamp,
				t.fillModeNonSolid,
				t.depthBounds,
				t.wideLines,
				t.largePoints,
				t.alphaToOne,
				t.multiViewport,
				t.samplerAnisotropy,
				t.textureCompressionETC2,
				t.textureCompressionASTC_LDR,
				t.textureCompressionBC,
				t.occlusionQueryPrecise,
				t.pipelineStatisticsQuery,
				t.vertexPipelineStoresAndAtomics,
				t.fragmentStoresAndAtomics,
				t.shaderTessellationAndGeometryPointSize,
				t.shaderImageGatherExtended,
				t.shaderStorageImageExtendedFormats,
				t.shaderStorageImageMultisample,
				t.shaderStorageImageReadWithoutFormat,
				t.shaderStorageImageWriteWithoutFormat,
				t.shaderUniformBufferArrayDynamicIndexing,
				t.shaderSampledImageArrayDynamicIndexing,
				t.shaderStorageBufferArrayDynamicIndexing,
				t.shaderStorageImageArrayDynamicIndexing,
				t.shaderClipDistance,
				t.shaderCullDistance,
				t.shaderFloat64,
				t.shaderInt64,
				t.shaderInt16,
				t.shaderResourceResidency,
				t.shaderResourceMinLod,
				t.sparseBinding,
				t.sparseResidencyBuffer,
				t.sparseResidencyImage2D,
				t.sparseResidencyImage3D,
				t.sparseResidency2Samples,
				t.sparseResidency4Samples,
				t.sparseResidency8Samples,
				t.sparseResidency16Samples,
				t.sparseResidencyAliased,
				t.variableMultisampleRate,
				t.inheritedQueries
			)
		end,
	}
)
mod.VkPhysicalDeviceLimits = ffi.typeof(
	[[struct {
	uint32_t maxImageDimension1D;
	uint32_t maxImageDimension2D;
	uint32_t maxImageDimension3D;
	uint32_t maxImageDimensionCube;
	uint32_t maxImageArrayLayers;
	uint32_t maxTexelBufferElements;
	uint32_t maxUniformBufferRange;
	uint32_t maxStorageBufferRange;
	uint32_t maxPushConstantsSize;
	uint32_t maxMemoryAllocationCount;
	uint32_t maxSamplerAllocationCount;
	$ bufferImageGranularity;
	$ sparseAddressSpaceSize;
	uint32_t maxBoundDescriptorSets;
	uint32_t maxPerStageDescriptorSamplers;
	uint32_t maxPerStageDescriptorUniformBuffers;
	uint32_t maxPerStageDescriptorStorageBuffers;
	uint32_t maxPerStageDescriptorSampledImages;
	uint32_t maxPerStageDescriptorStorageImages;
	uint32_t maxPerStageDescriptorInputAttachments;
	uint32_t maxPerStageResources;
	uint32_t maxDescriptorSetSamplers;
	uint32_t maxDescriptorSetUniformBuffers;
	uint32_t maxDescriptorSetUniformBuffersDynamic;
	uint32_t maxDescriptorSetStorageBuffers;
	uint32_t maxDescriptorSetStorageBuffersDynamic;
	uint32_t maxDescriptorSetSampledImages;
	uint32_t maxDescriptorSetStorageImages;
	uint32_t maxDescriptorSetInputAttachments;
	uint32_t maxVertexInputAttributes;
	uint32_t maxVertexInputBindings;
	uint32_t maxVertexInputAttributeOffset;
	uint32_t maxVertexInputBindingStride;
	uint32_t maxVertexOutputComponents;
	uint32_t maxTessellationGenerationLevel;
	uint32_t maxTessellationPatchSize;
	uint32_t maxTessellationControlPerVertexInputComponents;
	uint32_t maxTessellationControlPerVertexOutputComponents;
	uint32_t maxTessellationControlPerPatchOutputComponents;
	uint32_t maxTessellationControlTotalOutputComponents;
	uint32_t maxTessellationEvaluationInputComponents;
	uint32_t maxTessellationEvaluationOutputComponents;
	uint32_t maxGeometryShaderInvocations;
	uint32_t maxGeometryInputComponents;
	uint32_t maxGeometryOutputComponents;
	uint32_t maxGeometryOutputVertices;
	uint32_t maxGeometryTotalOutputComponents;
	uint32_t maxFragmentInputComponents;
	uint32_t maxFragmentOutputAttachments;
	uint32_t maxFragmentDualSrcAttachments;
	uint32_t maxFragmentCombinedOutputResources;
	uint32_t maxComputeSharedMemorySize;
	uint32_t maxComputeWorkGroupCount[3];
	uint32_t maxComputeWorkGroupInvocations;
	uint32_t maxComputeWorkGroupSize[3];
	uint32_t subPixelPrecisionBits;
	uint32_t subTexelPrecisionBits;
	uint32_t mipmapPrecisionBits;
	uint32_t maxDrawIndexedIndexValue;
	uint32_t maxDrawIndirectCount;
	float maxSamplerLodBias;
	float maxSamplerAnisotropy;
	uint32_t maxViewports;
	uint32_t maxViewportDimensions[2];
	float viewportBoundsRange[2];
	uint32_t viewportSubPixelBits;
	size_t minMemoryMapAlignment;
	$ minTexelBufferOffsetAlignment;
	$ minUniformBufferOffsetAlignment;
	$ minStorageBufferOffsetAlignment;
	int32_t minTexelOffset;
	uint32_t maxTexelOffset;
	int32_t minTexelGatherOffset;
	uint32_t maxTexelGatherOffset;
	float minInterpolationOffset;
	float maxInterpolationOffset;
	uint32_t subPixelInterpolationOffsetBits;
	uint32_t maxFramebufferWidth;
	uint32_t maxFramebufferHeight;
	uint32_t maxFramebufferLayers;
	$ framebufferColorSampleCounts;
	$ framebufferDepthSampleCounts;
	$ framebufferStencilSampleCounts;
	$ framebufferNoAttachmentsSampleCounts;
	uint32_t maxColorAttachments;
	$ sampledImageColorSampleCounts;
	$ sampledImageIntegerSampleCounts;
	$ sampledImageDepthSampleCounts;
	$ sampledImageStencilSampleCounts;
	$ storageImageSampleCounts;
	uint32_t maxSampleMaskWords;
	$ timestampComputeAndGraphics;
	float timestampPeriod;
	uint32_t maxClipDistances;
	uint32_t maxCullDistances;
	uint32_t maxCombinedClipAndCullDistances;
	uint32_t discreteQueuePriorities;
	float pointSizeRange[2];
	float lineWidthRange[2];
	float pointSizeGranularity;
	float lineWidthGranularity;
	$ strictLines;
	$ standardSampleLocations;
	$ optimalBufferCopyOffsetAlignment;
	$ optimalBufferCopyRowPitchAlignment;
	$ nonCoherentAtomSize;
}]],
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkSampleCountFlags,
	mod.VkSampleCountFlags,
	mod.VkSampleCountFlags,
	mod.VkSampleCountFlags,
	mod.VkSampleCountFlags,
	mod.VkSampleCountFlags,
	mod.VkSampleCountFlags,
	mod.VkSampleCountFlags,
	mod.VkSampleCountFlags,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkPhysicalDeviceLimits,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceLimits[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.maxImageDimension1D,
				t.maxImageDimension2D,
				t.maxImageDimension3D,
				t.maxImageDimensionCube,
				t.maxImageArrayLayers,
				t.maxTexelBufferElements,
				t.maxUniformBufferRange,
				t.maxStorageBufferRange,
				t.maxPushConstantsSize,
				t.maxMemoryAllocationCount,
				t.maxSamplerAllocationCount,
				t.bufferImageGranularity,
				t.sparseAddressSpaceSize,
				t.maxBoundDescriptorSets,
				t.maxPerStageDescriptorSamplers,
				t.maxPerStageDescriptorUniformBuffers,
				t.maxPerStageDescriptorStorageBuffers,
				t.maxPerStageDescriptorSampledImages,
				t.maxPerStageDescriptorStorageImages,
				t.maxPerStageDescriptorInputAttachments,
				t.maxPerStageResources,
				t.maxDescriptorSetSamplers,
				t.maxDescriptorSetUniformBuffers,
				t.maxDescriptorSetUniformBuffersDynamic,
				t.maxDescriptorSetStorageBuffers,
				t.maxDescriptorSetStorageBuffersDynamic,
				t.maxDescriptorSetSampledImages,
				t.maxDescriptorSetStorageImages,
				t.maxDescriptorSetInputAttachments,
				t.maxVertexInputAttributes,
				t.maxVertexInputBindings,
				t.maxVertexInputAttributeOffset,
				t.maxVertexInputBindingStride,
				t.maxVertexOutputComponents,
				t.maxTessellationGenerationLevel,
				t.maxTessellationPatchSize,
				t.maxTessellationControlPerVertexInputComponents,
				t.maxTessellationControlPerVertexOutputComponents,
				t.maxTessellationControlPerPatchOutputComponents,
				t.maxTessellationControlTotalOutputComponents,
				t.maxTessellationEvaluationInputComponents,
				t.maxTessellationEvaluationOutputComponents,
				t.maxGeometryShaderInvocations,
				t.maxGeometryInputComponents,
				t.maxGeometryOutputComponents,
				t.maxGeometryOutputVertices,
				t.maxGeometryTotalOutputComponents,
				t.maxFragmentInputComponents,
				t.maxFragmentOutputAttachments,
				t.maxFragmentDualSrcAttachments,
				t.maxFragmentCombinedOutputResources,
				t.maxComputeSharedMemorySize,
				t.maxComputeWorkGroupCount,
				t.maxComputeWorkGroupInvocations,
				t.maxComputeWorkGroupSize,
				t.subPixelPrecisionBits,
				t.subTexelPrecisionBits,
				t.mipmapPrecisionBits,
				t.maxDrawIndexedIndexValue,
				t.maxDrawIndirectCount,
				t.maxSamplerLodBias,
				t.maxSamplerAnisotropy,
				t.maxViewports,
				t.maxViewportDimensions,
				t.viewportBoundsRange,
				t.viewportSubPixelBits,
				t.minMemoryMapAlignment,
				t.minTexelBufferOffsetAlignment,
				t.minUniformBufferOffsetAlignment,
				t.minStorageBufferOffsetAlignment,
				t.minTexelOffset,
				t.maxTexelOffset,
				t.minTexelGatherOffset,
				t.maxTexelGatherOffset,
				t.minInterpolationOffset,
				t.maxInterpolationOffset,
				t.subPixelInterpolationOffsetBits,
				t.maxFramebufferWidth,
				t.maxFramebufferHeight,
				t.maxFramebufferLayers,
				t.framebufferColorSampleCounts,
				t.framebufferDepthSampleCounts,
				t.framebufferStencilSampleCounts,
				t.framebufferNoAttachmentsSampleCounts,
				t.maxColorAttachments,
				t.sampledImageColorSampleCounts,
				t.sampledImageIntegerSampleCounts,
				t.sampledImageDepthSampleCounts,
				t.sampledImageStencilSampleCounts,
				t.storageImageSampleCounts,
				t.maxSampleMaskWords,
				t.timestampComputeAndGraphics,
				t.timestampPeriod,
				t.maxClipDistances,
				t.maxCullDistances,
				t.maxCombinedClipAndCullDistances,
				t.discreteQueuePriorities,
				t.pointSizeRange,
				t.lineWidthRange,
				t.pointSizeGranularity,
				t.lineWidthGranularity,
				t.strictLines,
				t.standardSampleLocations,
				t.optimalBufferCopyOffsetAlignment,
				t.optimalBufferCopyRowPitchAlignment,
				t.nonCoherentAtomSize
			)
		end,
	}
)
mod.VkPhysicalDeviceMemoryProperties = ffi.typeof(
	[[struct {
	uint32_t memoryTypeCount;
	$ memoryTypes[32U];
	uint32_t memoryHeapCount;
	$ memoryHeaps[16U];
}]],
	mod.VkMemoryType,
	mod.VkMemoryHeap
)
ffi.metatype(
	mod.VkPhysicalDeviceMemoryProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMemoryProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.memoryTypeCount, t.memoryTypes, t.memoryHeapCount, t.memoryHeaps)
		end,
	}
)
mod.VkPhysicalDeviceSparseProperties = ffi.typeof(
	[[struct {
	$ residencyStandard2DBlockShape;
	$ residencyStandard2DMultisampleBlockShape;
	$ residencyStandard3DBlockShape;
	$ residencyAlignedMipSize;
	$ residencyNonResidentStrict;
}]],
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSparseProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSparseProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.residencyStandard2DBlockShape,
				t.residencyStandard2DMultisampleBlockShape,
				t.residencyStandard3DBlockShape,
				t.residencyAlignedMipSize,
				t.residencyNonResidentStrict
			)
		end,
	}
)
mod.VkPhysicalDeviceProperties = ffi.typeof(
	[[struct {
	uint32_t apiVersion;
	uint32_t driverVersion;
	uint32_t vendorID;
	uint32_t deviceID;
	$ deviceType;
	char deviceName[256U];
	uint8_t pipelineCacheUUID[16U];
	$ limits;
	$ sparseProperties;
}]],
	mod.VkPhysicalDeviceType,
	mod.VkPhysicalDeviceLimits,
	mod.VkPhysicalDeviceSparseProperties
)
ffi.metatype(
	mod.VkPhysicalDeviceProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.apiVersion,
				t.driverVersion,
				t.vendorID,
				t.deviceID,
				t.deviceType,
				t.deviceName,
				t.pipelineCacheUUID,
				t.limits,
				t.sparseProperties
			)
		end,
	}
)
mod.VkQueueFamilyProperties = ffi.typeof(
	[[struct {
	$ queueFlags;
	uint32_t queueCount;
	uint32_t timestampValidBits;
	$ minImageTransferGranularity;
}]],
	mod.VkQueueFlags,
	mod.VkExtent3D
)
ffi.metatype(
	mod.VkQueueFamilyProperties,
	{
		__tostring = function(s)
			return ("struct VkQueueFamilyProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.queueFlags,
				t.queueCount,
				t.timestampValidBits,
				t.minImageTransferGranularity
			)
		end,
	}
)
mod.VkDeviceQueueCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t queueFamilyIndex;
	uint32_t queueCount;
	const float* pQueuePriorities;
}]],
	mod.VkStructureType,
	mod.VkDeviceQueueCreateFlags
)
ffi.metatype(
	mod.VkDeviceQueueCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkDeviceQueueCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.queueFamilyIndex,
				t.queueCount,
				t.pQueuePriorities
			)
		end,
	}
)
mod.VkDeviceCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t queueCreateInfoCount;
	const $* pQueueCreateInfos;
	uint32_t enabledLayerCount;
	const char** const ppEnabledLayerNames;
	uint32_t enabledExtensionCount;
	const char** const ppEnabledExtensionNames;
	const $* pEnabledFeatures;
}]],
	mod.VkStructureType,
	mod.VkDeviceCreateFlags,
	mod.VkDeviceQueueCreateInfo,
	mod.VkPhysicalDeviceFeatures
)
ffi.metatype(
	mod.VkDeviceCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkDeviceCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.queueCreateInfoCount,
				t.pQueueCreateInfos,
				t.enabledLayerCount,
				t.ppEnabledLayerNames,
				t.enabledExtensionCount,
				t.ppEnabledExtensionNames,
				t.pEnabledFeatures
			)
		end,
	}
)
mod.VkExtensionProperties = ffi.typeof([[struct {
	char extensionName[256U];
	uint32_t specVersion;
}]])
ffi.metatype(
	mod.VkExtensionProperties,
	{
		__tostring = function(s)
			return ("struct VkExtensionProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.extensionName, t.specVersion)
		end,
	}
)
mod.VkLayerProperties = ffi.typeof([[struct {
	char layerName[256U];
	uint32_t specVersion;
	uint32_t implementationVersion;
	char description[256U];
}]])
ffi.metatype(
	mod.VkLayerProperties,
	{
		__tostring = function(s)
			return ("struct VkLayerProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.layerName, t.specVersion, t.implementationVersion, t.description)
		end,
	}
)
mod.VkSubmitInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t waitSemaphoreCount;
	const $* pWaitSemaphores;
	const $* pWaitDstStageMask;
	uint32_t commandBufferCount;
	const $* pCommandBuffers;
	uint32_t signalSemaphoreCount;
	const $* pSignalSemaphores;
}]],
	mod.VkStructureType,
	mod.VkSemaphore,
	mod.VkPipelineStageFlags,
	mod.VkCommandBuffer,
	mod.VkSemaphore
)
ffi.metatype(
	mod.VkSubmitInfo,
	{
		__tostring = function(s)
			return ("struct VkSubmitInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.waitSemaphoreCount,
				t.pWaitSemaphores,
				t.pWaitDstStageMask,
				t.commandBufferCount,
				t.pCommandBuffers,
				t.signalSemaphoreCount,
				t.pSignalSemaphores
			)
		end,
	}
)
mod.VkMappedMemoryRange = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ memory;
	$ offset;
	$ size;
}]],
	mod.VkStructureType,
	mod.VkDeviceMemory,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkMappedMemoryRange,
	{
		__tostring = function(s)
			return ("struct VkMappedMemoryRange[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memory, t.offset, t.size)
		end,
	}
)
mod.VkMemoryAllocateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ allocationSize;
	uint32_t memoryTypeIndex;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkMemoryAllocateInfo,
	{
		__tostring = function(s)
			return ("struct VkMemoryAllocateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.allocationSize, t.memoryTypeIndex)
		end,
	}
)
mod.VkMemoryRequirements = ffi.typeof(
	[[struct {
	$ size;
	$ alignment;
	uint32_t memoryTypeBits;
}]],
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkMemoryRequirements,
	{
		__tostring = function(s)
			return ("struct VkMemoryRequirements[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.size, t.alignment, t.memoryTypeBits)
		end,
	}
)
mod.VkSparseMemoryBind = ffi.typeof(
	[[struct {
	$ resourceOffset;
	$ size;
	$ memory;
	$ memoryOffset;
	$ flags;
}]],
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceMemory,
	mod.VkDeviceSize,
	mod.VkSparseMemoryBindFlags
)
ffi.metatype(
	mod.VkSparseMemoryBind,
	{
		__tostring = function(s)
			return ("struct VkSparseMemoryBind[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.resourceOffset, t.size, t.memory, t.memoryOffset, t.flags)
		end,
	}
)
mod.VkSparseBufferMemoryBindInfo = ffi.typeof(
	[[struct {
	$ buffer;
	uint32_t bindCount;
	const $* pBinds;
}]],
	mod.VkBuffer,
	mod.VkSparseMemoryBind
)
ffi.metatype(
	mod.VkSparseBufferMemoryBindInfo,
	{
		__tostring = function(s)
			return ("struct VkSparseBufferMemoryBindInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.buffer, t.bindCount, t.pBinds)
		end,
	}
)
mod.VkSparseImageOpaqueMemoryBindInfo = ffi.typeof(
	[[struct {
	$ image;
	uint32_t bindCount;
	const $* pBinds;
}]],
	mod.VkImage,
	mod.VkSparseMemoryBind
)
ffi.metatype(
	mod.VkSparseImageOpaqueMemoryBindInfo,
	{
		__tostring = function(s)
			return ("struct VkSparseImageOpaqueMemoryBindInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.image, t.bindCount, t.pBinds)
		end,
	}
)
mod.VkImageSubresource = ffi.typeof(
	[[struct {
	$ aspectMask;
	uint32_t mipLevel;
	uint32_t arrayLayer;
}]],
	mod.VkImageAspectFlags
)
ffi.metatype(
	mod.VkImageSubresource,
	{
		__tostring = function(s)
			return ("struct VkImageSubresource[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.aspectMask, t.mipLevel, t.arrayLayer)
		end,
	}
)
mod.VkSparseImageMemoryBind = ffi.typeof(
	[[struct {
	$ subresource;
	$ offset;
	$ extent;
	$ memory;
	$ memoryOffset;
	$ flags;
}]],
	mod.VkImageSubresource,
	mod.VkOffset3D,
	mod.VkExtent3D,
	mod.VkDeviceMemory,
	mod.VkDeviceSize,
	mod.VkSparseMemoryBindFlags
)
ffi.metatype(
	mod.VkSparseImageMemoryBind,
	{
		__tostring = function(s)
			return ("struct VkSparseImageMemoryBind[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.subresource, t.offset, t.extent, t.memory, t.memoryOffset, t.flags)
		end,
	}
)
mod.VkSparseImageMemoryBindInfo = ffi.typeof(
	[[struct {
	$ image;
	uint32_t bindCount;
	const $* pBinds;
}]],
	mod.VkImage,
	mod.VkSparseImageMemoryBind
)
ffi.metatype(
	mod.VkSparseImageMemoryBindInfo,
	{
		__tostring = function(s)
			return ("struct VkSparseImageMemoryBindInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.image, t.bindCount, t.pBinds)
		end,
	}
)
mod.VkBindSparseInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t waitSemaphoreCount;
	const $* pWaitSemaphores;
	uint32_t bufferBindCount;
	const $* pBufferBinds;
	uint32_t imageOpaqueBindCount;
	const $* pImageOpaqueBinds;
	uint32_t imageBindCount;
	const $* pImageBinds;
	uint32_t signalSemaphoreCount;
	const $* pSignalSemaphores;
}]],
	mod.VkStructureType,
	mod.VkSemaphore,
	mod.VkSparseBufferMemoryBindInfo,
	mod.VkSparseImageOpaqueMemoryBindInfo,
	mod.VkSparseImageMemoryBindInfo,
	mod.VkSemaphore
)
ffi.metatype(
	mod.VkBindSparseInfo,
	{
		__tostring = function(s)
			return ("struct VkBindSparseInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.waitSemaphoreCount,
				t.pWaitSemaphores,
				t.bufferBindCount,
				t.pBufferBinds,
				t.imageOpaqueBindCount,
				t.pImageOpaqueBinds,
				t.imageBindCount,
				t.pImageBinds,
				t.signalSemaphoreCount,
				t.pSignalSemaphores
			)
		end,
	}
)
mod.VkSparseImageFormatProperties = ffi.typeof(
	[[struct {
	$ aspectMask;
	$ imageGranularity;
	$ flags;
}]],
	mod.VkImageAspectFlags,
	mod.VkExtent3D,
	mod.VkSparseImageFormatFlags
)
ffi.metatype(
	mod.VkSparseImageFormatProperties,
	{
		__tostring = function(s)
			return ("struct VkSparseImageFormatProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.aspectMask, t.imageGranularity, t.flags)
		end,
	}
)
mod.VkSparseImageMemoryRequirements = ffi.typeof(
	[[struct {
	$ formatProperties;
	uint32_t imageMipTailFirstLod;
	$ imageMipTailSize;
	$ imageMipTailOffset;
	$ imageMipTailStride;
}]],
	mod.VkSparseImageFormatProperties,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkSparseImageMemoryRequirements,
	{
		__tostring = function(s)
			return ("struct VkSparseImageMemoryRequirements[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.formatProperties,
				t.imageMipTailFirstLod,
				t.imageMipTailSize,
				t.imageMipTailOffset,
				t.imageMipTailStride
			)
		end,
	}
)
mod.VkFenceCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkFenceCreateFlags
)
ffi.metatype(
	mod.VkFenceCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkFenceCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.VkSemaphoreCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkSemaphoreCreateFlags
)
ffi.metatype(
	mod.VkSemaphoreCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkSemaphoreCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.VkEventCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkEventCreateFlags
)
ffi.metatype(
	mod.VkEventCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkEventCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.VkQueryPoolCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ queryType;
	uint32_t queryCount;
	$ pipelineStatistics;
}]],
	mod.VkStructureType,
	mod.VkQueryPoolCreateFlags,
	mod.VkQueryType,
	mod.VkQueryPipelineStatisticFlags
)
ffi.metatype(
	mod.VkQueryPoolCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkQueryPoolCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.queryType,
				t.queryCount,
				t.pipelineStatistics
			)
		end,
	}
)
mod.VkBufferCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ size;
	$ usage;
	$ sharingMode;
	uint32_t queueFamilyIndexCount;
	const uint32_t* pQueueFamilyIndices;
}]],
	mod.VkStructureType,
	mod.VkBufferCreateFlags,
	mod.VkDeviceSize,
	mod.VkBufferUsageFlags,
	mod.VkSharingMode
)
ffi.metatype(
	mod.VkBufferCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkBufferCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.size,
				t.usage,
				t.sharingMode,
				t.queueFamilyIndexCount,
				t.pQueueFamilyIndices
			)
		end,
	}
)
mod.VkBufferViewCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ buffer;
	$ format;
	$ offset;
	$ range;
}]],
	mod.VkStructureType,
	mod.VkBufferViewCreateFlags,
	mod.VkBuffer,
	mod.VkFormat,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkBufferViewCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkBufferViewCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.buffer, t.format, t.offset, t.range)
		end,
	}
)
mod.VkImageCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ imageType;
	$ format;
	$ extent;
	uint32_t mipLevels;
	uint32_t arrayLayers;
	$ samples;
	$ tiling;
	$ usage;
	$ sharingMode;
	uint32_t queueFamilyIndexCount;
	const uint32_t* pQueueFamilyIndices;
	$ initialLayout;
}]],
	mod.VkStructureType,
	mod.VkImageCreateFlags,
	mod.VkImageType,
	mod.VkFormat,
	mod.VkExtent3D,
	mod.VkSampleCountFlagBits,
	mod.VkImageTiling,
	mod.VkImageUsageFlags,
	mod.VkSharingMode,
	mod.VkImageLayout
)
ffi.metatype(
	mod.VkImageCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkImageCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.imageType,
				t.format,
				t.extent,
				t.mipLevels,
				t.arrayLayers,
				t.samples,
				t.tiling,
				t.usage,
				t.sharingMode,
				t.queueFamilyIndexCount,
				t.pQueueFamilyIndices,
				t.initialLayout
			)
		end,
	}
)
mod.VkSubresourceLayout = ffi.typeof(
	[[struct {
	$ offset;
	$ size;
	$ rowPitch;
	$ arrayPitch;
	$ depthPitch;
}]],
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkSubresourceLayout,
	{
		__tostring = function(s)
			return ("struct VkSubresourceLayout[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.offset, t.size, t.rowPitch, t.arrayPitch, t.depthPitch)
		end,
	}
)
mod.VkComponentMapping = ffi.typeof(
	[[struct {
	$ r;
	$ g;
	$ b;
	$ a;
}]],
	mod.VkComponentSwizzle,
	mod.VkComponentSwizzle,
	mod.VkComponentSwizzle,
	mod.VkComponentSwizzle
)
ffi.metatype(
	mod.VkComponentMapping,
	{
		__tostring = function(s)
			return ("struct VkComponentMapping[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.r, t.g, t.b, t.a)
		end,
	}
)
mod.VkImageViewCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ image;
	$ viewType;
	$ format;
	$ components;
	$ subresourceRange;
}]],
	mod.VkStructureType,
	mod.VkImageViewCreateFlags,
	mod.VkImage,
	mod.VkImageViewType,
	mod.VkFormat,
	mod.VkComponentMapping,
	mod.VkImageSubresourceRange
)
ffi.metatype(
	mod.VkImageViewCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkImageViewCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.image,
				t.viewType,
				t.format,
				t.components,
				t.subresourceRange
			)
		end,
	}
)
mod.VkShaderModuleCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	size_t codeSize;
	const uint32_t* pCode;
}]],
	mod.VkStructureType,
	mod.VkShaderModuleCreateFlags
)
ffi.metatype(
	mod.VkShaderModuleCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkShaderModuleCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.codeSize, t.pCode)
		end,
	}
)
mod.VkPipelineCacheCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	size_t initialDataSize;
	const void* pInitialData;
}]],
	mod.VkStructureType,
	mod.VkPipelineCacheCreateFlags
)
ffi.metatype(
	mod.VkPipelineCacheCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineCacheCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.initialDataSize, t.pInitialData)
		end,
	}
)
mod.VkSpecializationMapEntry = ffi.typeof([[struct {
	uint32_t constantID;
	uint32_t offset;
	size_t size;
}]])
ffi.metatype(
	mod.VkSpecializationMapEntry,
	{
		__tostring = function(s)
			return ("struct VkSpecializationMapEntry[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.constantID, t.offset, t.size)
		end,
	}
)
mod.VkSpecializationInfo = ffi.typeof(
	[[struct {
	uint32_t mapEntryCount;
	const $* pMapEntries;
	size_t dataSize;
	const void* pData;
}]],
	mod.VkSpecializationMapEntry
)
ffi.metatype(
	mod.VkSpecializationInfo,
	{
		__tostring = function(s)
			return ("struct VkSpecializationInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.mapEntryCount, t.pMapEntries, t.dataSize, t.pData)
		end,
	}
)
mod.VkPipelineShaderStageCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ stage;
	$ module;
	const char* pName;
	const $* pSpecializationInfo;
}]],
	mod.VkStructureType,
	mod.VkPipelineShaderStageCreateFlags,
	mod.VkShaderStageFlagBits,
	mod.VkShaderModule,
	mod.VkSpecializationInfo
)
ffi.metatype(
	mod.VkPipelineShaderStageCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineShaderStageCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.stage,
				t.module,
				t.pName,
				t.pSpecializationInfo
			)
		end,
	}
)
mod.VkComputePipelineCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ stage;
	$ layout;
	$ basePipelineHandle;
	int32_t basePipelineIndex;
}]],
	mod.VkStructureType,
	mod.VkPipelineCreateFlags,
	mod.VkPipelineShaderStageCreateInfo,
	mod.VkPipelineLayout,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkComputePipelineCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkComputePipelineCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.stage,
				t.layout,
				t.basePipelineHandle,
				t.basePipelineIndex
			)
		end,
	}
)
mod.VkVertexInputBindingDescription = ffi.typeof(
	[[struct {
	uint32_t binding;
	uint32_t stride;
	$ inputRate;
}]],
	mod.VkVertexInputRate
)
ffi.metatype(
	mod.VkVertexInputBindingDescription,
	{
		__tostring = function(s)
			return ("struct VkVertexInputBindingDescription[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.binding, t.stride, t.inputRate)
		end,
	}
)
mod.VkVertexInputAttributeDescription = ffi.typeof(
	[[struct {
	uint32_t location;
	uint32_t binding;
	$ format;
	uint32_t offset;
}]],
	mod.VkFormat
)
ffi.metatype(
	mod.VkVertexInputAttributeDescription,
	{
		__tostring = function(s)
			return ("struct VkVertexInputAttributeDescription[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.location, t.binding, t.format, t.offset)
		end,
	}
)
mod.VkPipelineVertexInputStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t vertexBindingDescriptionCount;
	const $* pVertexBindingDescriptions;
	uint32_t vertexAttributeDescriptionCount;
	const $* pVertexAttributeDescriptions;
}]],
	mod.VkStructureType,
	mod.VkPipelineVertexInputStateCreateFlags,
	mod.VkVertexInputBindingDescription,
	mod.VkVertexInputAttributeDescription
)
ffi.metatype(
	mod.VkPipelineVertexInputStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineVertexInputStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.vertexBindingDescriptionCount,
				t.pVertexBindingDescriptions,
				t.vertexAttributeDescriptionCount,
				t.pVertexAttributeDescriptions
			)
		end,
	}
)
mod.VkPipelineInputAssemblyStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ topology;
	$ primitiveRestartEnable;
}]],
	mod.VkStructureType,
	mod.VkPipelineInputAssemblyStateCreateFlags,
	mod.VkPrimitiveTopology,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPipelineInputAssemblyStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineInputAssemblyStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.topology, t.primitiveRestartEnable)
		end,
	}
)
mod.VkPipelineTessellationStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t patchControlPoints;
}]],
	mod.VkStructureType,
	mod.VkPipelineTessellationStateCreateFlags
)
ffi.metatype(
	mod.VkPipelineTessellationStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineTessellationStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.patchControlPoints)
		end,
	}
)
mod.VkViewport = ffi.typeof([[struct {
	float x;
	float y;
	float width;
	float height;
	float minDepth;
	float maxDepth;
}]])
ffi.metatype(
	mod.VkViewport,
	{
		__tostring = function(s)
			return ("struct VkViewport[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.x, t.y, t.width, t.height, t.minDepth, t.maxDepth)
		end,
	}
)
mod.VkPipelineViewportStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t viewportCount;
	const $* pViewports;
	uint32_t scissorCount;
	const $* pScissors;
}]],
	mod.VkStructureType,
	mod.VkPipelineViewportStateCreateFlags,
	mod.VkViewport,
	mod.VkRect2D
)
ffi.metatype(
	mod.VkPipelineViewportStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineViewportStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.viewportCount,
				t.pViewports,
				t.scissorCount,
				t.pScissors
			)
		end,
	}
)
mod.VkPipelineRasterizationStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ depthClampEnable;
	$ rasterizerDiscardEnable;
	$ polygonMode;
	$ cullMode;
	$ frontFace;
	$ depthBiasEnable;
	float depthBiasConstantFactor;
	float depthBiasClamp;
	float depthBiasSlopeFactor;
	float lineWidth;
}]],
	mod.VkStructureType,
	mod.VkPipelineRasterizationStateCreateFlags,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkPolygonMode,
	mod.VkCullModeFlags,
	mod.VkFrontFace,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPipelineRasterizationStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineRasterizationStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.depthClampEnable,
				t.rasterizerDiscardEnable,
				t.polygonMode,
				t.cullMode,
				t.frontFace,
				t.depthBiasEnable,
				t.depthBiasConstantFactor,
				t.depthBiasClamp,
				t.depthBiasSlopeFactor,
				t.lineWidth
			)
		end,
	}
)
mod.VkPipelineMultisampleStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ rasterizationSamples;
	$ sampleShadingEnable;
	float minSampleShading;
	const $* pSampleMask;
	$ alphaToCoverageEnable;
	$ alphaToOneEnable;
}]],
	mod.VkStructureType,
	mod.VkPipelineMultisampleStateCreateFlags,
	mod.VkSampleCountFlagBits,
	mod.VkBool32,
	mod.VkSampleMask,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPipelineMultisampleStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineMultisampleStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.rasterizationSamples,
				t.sampleShadingEnable,
				t.minSampleShading,
				t.pSampleMask,
				t.alphaToCoverageEnable,
				t.alphaToOneEnable
			)
		end,
	}
)
mod.VkStencilOpState = ffi.typeof(
	[[struct {
	$ failOp;
	$ passOp;
	$ depthFailOp;
	$ compareOp;
	uint32_t compareMask;
	uint32_t writeMask;
	uint32_t reference;
}]],
	mod.VkStencilOp,
	mod.VkStencilOp,
	mod.VkStencilOp,
	mod.VkCompareOp
)
ffi.metatype(
	mod.VkStencilOpState,
	{
		__tostring = function(s)
			return ("struct VkStencilOpState[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.failOp,
				t.passOp,
				t.depthFailOp,
				t.compareOp,
				t.compareMask,
				t.writeMask,
				t.reference
			)
		end,
	}
)
mod.VkPipelineDepthStencilStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ depthTestEnable;
	$ depthWriteEnable;
	$ depthCompareOp;
	$ depthBoundsTestEnable;
	$ stencilTestEnable;
	$ front;
	$ back;
	float minDepthBounds;
	float maxDepthBounds;
}]],
	mod.VkStructureType,
	mod.VkPipelineDepthStencilStateCreateFlags,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkCompareOp,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkStencilOpState,
	mod.VkStencilOpState
)
ffi.metatype(
	mod.VkPipelineDepthStencilStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineDepthStencilStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.depthTestEnable,
				t.depthWriteEnable,
				t.depthCompareOp,
				t.depthBoundsTestEnable,
				t.stencilTestEnable,
				t.front,
				t.back,
				t.minDepthBounds,
				t.maxDepthBounds
			)
		end,
	}
)
mod.VkPipelineColorBlendAttachmentState = ffi.typeof(
	[[struct {
	$ blendEnable;
	$ srcColorBlendFactor;
	$ dstColorBlendFactor;
	$ colorBlendOp;
	$ srcAlphaBlendFactor;
	$ dstAlphaBlendFactor;
	$ alphaBlendOp;
	$ colorWriteMask;
}]],
	mod.VkBool32,
	mod.VkBlendFactor,
	mod.VkBlendFactor,
	mod.VkBlendOp,
	mod.VkBlendFactor,
	mod.VkBlendFactor,
	mod.VkBlendOp,
	mod.VkColorComponentFlags
)
ffi.metatype(
	mod.VkPipelineColorBlendAttachmentState,
	{
		__tostring = function(s)
			return ("struct VkPipelineColorBlendAttachmentState[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.blendEnable,
				t.srcColorBlendFactor,
				t.dstColorBlendFactor,
				t.colorBlendOp,
				t.srcAlphaBlendFactor,
				t.dstAlphaBlendFactor,
				t.alphaBlendOp,
				t.colorWriteMask
			)
		end,
	}
)
mod.VkPipelineColorBlendStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ logicOpEnable;
	$ logicOp;
	uint32_t attachmentCount;
	const $* pAttachments;
	float blendConstants[4];
}]],
	mod.VkStructureType,
	mod.VkPipelineColorBlendStateCreateFlags,
	mod.VkBool32,
	mod.VkLogicOp,
	mod.VkPipelineColorBlendAttachmentState
)
ffi.metatype(
	mod.VkPipelineColorBlendStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineColorBlendStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.logicOpEnable,
				t.logicOp,
				t.attachmentCount,
				t.pAttachments,
				t.blendConstants
			)
		end,
	}
)
mod.VkPipelineDynamicStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t dynamicStateCount;
	const $* pDynamicStates;
}]],
	mod.VkStructureType,
	mod.VkPipelineDynamicStateCreateFlags,
	mod.VkDynamicState
)
ffi.metatype(
	mod.VkPipelineDynamicStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineDynamicStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.dynamicStateCount, t.pDynamicStates)
		end,
	}
)
mod.VkGraphicsPipelineCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t stageCount;
	const $* pStages;
	const $* pVertexInputState;
	const $* pInputAssemblyState;
	const $* pTessellationState;
	const $* pViewportState;
	const $* pRasterizationState;
	const $* pMultisampleState;
	const $* pDepthStencilState;
	const $* pColorBlendState;
	const $* pDynamicState;
	$ layout;
	$ renderPass;
	uint32_t subpass;
	$ basePipelineHandle;
	int32_t basePipelineIndex;
}]],
	mod.VkStructureType,
	mod.VkPipelineCreateFlags,
	mod.VkPipelineShaderStageCreateInfo,
	mod.VkPipelineVertexInputStateCreateInfo,
	mod.VkPipelineInputAssemblyStateCreateInfo,
	mod.VkPipelineTessellationStateCreateInfo,
	mod.VkPipelineViewportStateCreateInfo,
	mod.VkPipelineRasterizationStateCreateInfo,
	mod.VkPipelineMultisampleStateCreateInfo,
	mod.VkPipelineDepthStencilStateCreateInfo,
	mod.VkPipelineColorBlendStateCreateInfo,
	mod.VkPipelineDynamicStateCreateInfo,
	mod.VkPipelineLayout,
	mod.VkRenderPass,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkGraphicsPipelineCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkGraphicsPipelineCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.stageCount,
				t.pStages,
				t.pVertexInputState,
				t.pInputAssemblyState,
				t.pTessellationState,
				t.pViewportState,
				t.pRasterizationState,
				t.pMultisampleState,
				t.pDepthStencilState,
				t.pColorBlendState,
				t.pDynamicState,
				t.layout,
				t.renderPass,
				t.subpass,
				t.basePipelineHandle,
				t.basePipelineIndex
			)
		end,
	}
)
mod.VkPushConstantRange = ffi.typeof(
	[[struct {
	$ stageFlags;
	uint32_t offset;
	uint32_t size;
}]],
	mod.VkShaderStageFlags
)
ffi.metatype(
	mod.VkPushConstantRange,
	{
		__tostring = function(s)
			return ("struct VkPushConstantRange[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.stageFlags, t.offset, t.size)
		end,
	}
)
mod.VkPipelineLayoutCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t setLayoutCount;
	const $* pSetLayouts;
	uint32_t pushConstantRangeCount;
	const $* pPushConstantRanges;
}]],
	mod.VkStructureType,
	mod.VkPipelineLayoutCreateFlags,
	mod.VkDescriptorSetLayout,
	mod.VkPushConstantRange
)
ffi.metatype(
	mod.VkPipelineLayoutCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineLayoutCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.setLayoutCount,
				t.pSetLayouts,
				t.pushConstantRangeCount,
				t.pPushConstantRanges
			)
		end,
	}
)
mod.VkSamplerCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ magFilter;
	$ minFilter;
	$ mipmapMode;
	$ addressModeU;
	$ addressModeV;
	$ addressModeW;
	float mipLodBias;
	$ anisotropyEnable;
	float maxAnisotropy;
	$ compareEnable;
	$ compareOp;
	float minLod;
	float maxLod;
	$ borderColor;
	$ unnormalizedCoordinates;
}]],
	mod.VkStructureType,
	mod.VkSamplerCreateFlags,
	mod.VkFilter,
	mod.VkFilter,
	mod.VkSamplerMipmapMode,
	mod.VkSamplerAddressMode,
	mod.VkSamplerAddressMode,
	mod.VkSamplerAddressMode,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkCompareOp,
	mod.VkBorderColor,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSamplerCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkSamplerCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.magFilter,
				t.minFilter,
				t.mipmapMode,
				t.addressModeU,
				t.addressModeV,
				t.addressModeW,
				t.mipLodBias,
				t.anisotropyEnable,
				t.maxAnisotropy,
				t.compareEnable,
				t.compareOp,
				t.minLod,
				t.maxLod,
				t.borderColor,
				t.unnormalizedCoordinates
			)
		end,
	}
)
mod.VkCopyDescriptorSet = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcSet;
	uint32_t srcBinding;
	uint32_t srcArrayElement;
	$ dstSet;
	uint32_t dstBinding;
	uint32_t dstArrayElement;
	uint32_t descriptorCount;
}]],
	mod.VkStructureType,
	mod.VkDescriptorSet,
	mod.VkDescriptorSet
)
ffi.metatype(
	mod.VkCopyDescriptorSet,
	{
		__tostring = function(s)
			return ("struct VkCopyDescriptorSet[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcSet,
				t.srcBinding,
				t.srcArrayElement,
				t.dstSet,
				t.dstBinding,
				t.dstArrayElement,
				t.descriptorCount
			)
		end,
	}
)
mod.VkDescriptorBufferInfo = ffi.typeof(
	[[struct {
	$ buffer;
	$ offset;
	$ range;
}]],
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkDescriptorBufferInfo,
	{
		__tostring = function(s)
			return ("struct VkDescriptorBufferInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.buffer, t.offset, t.range)
		end,
	}
)
mod.VkDescriptorImageInfo = ffi.typeof(
	[[struct {
	$ sampler;
	$ imageView;
	$ imageLayout;
}]],
	mod.VkSampler,
	mod.VkImageView,
	mod.VkImageLayout
)
ffi.metatype(
	mod.VkDescriptorImageInfo,
	{
		__tostring = function(s)
			return ("struct VkDescriptorImageInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sampler, t.imageView, t.imageLayout)
		end,
	}
)
mod.VkDescriptorPoolSize = ffi.typeof([[struct {
	$ type;
	uint32_t descriptorCount;
}]], mod.VkDescriptorType)
ffi.metatype(
	mod.VkDescriptorPoolSize,
	{
		__tostring = function(s)
			return ("struct VkDescriptorPoolSize[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.type, t.descriptorCount)
		end,
	}
)
mod.VkDescriptorPoolCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t maxSets;
	uint32_t poolSizeCount;
	const $* pPoolSizes;
}]],
	mod.VkStructureType,
	mod.VkDescriptorPoolCreateFlags,
	mod.VkDescriptorPoolSize
)
ffi.metatype(
	mod.VkDescriptorPoolCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkDescriptorPoolCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.maxSets, t.poolSizeCount, t.pPoolSizes)
		end,
	}
)
mod.VkDescriptorSetAllocateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ descriptorPool;
	uint32_t descriptorSetCount;
	const $* pSetLayouts;
}]],
	mod.VkStructureType,
	mod.VkDescriptorPool,
	mod.VkDescriptorSetLayout
)
ffi.metatype(
	mod.VkDescriptorSetAllocateInfo,
	{
		__tostring = function(s)
			return ("struct VkDescriptorSetAllocateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.descriptorPool, t.descriptorSetCount, t.pSetLayouts)
		end,
	}
)
mod.VkDescriptorSetLayoutBinding = ffi.typeof(
	[[struct {
	uint32_t binding;
	$ descriptorType;
	uint32_t descriptorCount;
	$ stageFlags;
	const $* pImmutableSamplers;
}]],
	mod.VkDescriptorType,
	mod.VkShaderStageFlags,
	mod.VkSampler
)
ffi.metatype(
	mod.VkDescriptorSetLayoutBinding,
	{
		__tostring = function(s)
			return ("struct VkDescriptorSetLayoutBinding[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.binding,
				t.descriptorType,
				t.descriptorCount,
				t.stageFlags,
				t.pImmutableSamplers
			)
		end,
	}
)
mod.VkDescriptorSetLayoutCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t bindingCount;
	const $* pBindings;
}]],
	mod.VkStructureType,
	mod.VkDescriptorSetLayoutCreateFlags,
	mod.VkDescriptorSetLayoutBinding
)
ffi.metatype(
	mod.VkDescriptorSetLayoutCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkDescriptorSetLayoutCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.bindingCount, t.pBindings)
		end,
	}
)
mod.VkWriteDescriptorSet = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ dstSet;
	uint32_t dstBinding;
	uint32_t dstArrayElement;
	uint32_t descriptorCount;
	$ descriptorType;
	const $* pImageInfo;
	const $* pBufferInfo;
	const $* pTexelBufferView;
}]],
	mod.VkStructureType,
	mod.VkDescriptorSet,
	mod.VkDescriptorType,
	mod.VkDescriptorImageInfo,
	mod.VkDescriptorBufferInfo,
	mod.VkBufferView
)
ffi.metatype(
	mod.VkWriteDescriptorSet,
	{
		__tostring = function(s)
			return ("struct VkWriteDescriptorSet[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.dstSet,
				t.dstBinding,
				t.dstArrayElement,
				t.descriptorCount,
				t.descriptorType,
				t.pImageInfo,
				t.pBufferInfo,
				t.pTexelBufferView
			)
		end,
	}
)
mod.VkAttachmentDescription = ffi.typeof(
	[[struct {
	$ flags;
	$ format;
	$ samples;
	$ loadOp;
	$ storeOp;
	$ stencilLoadOp;
	$ stencilStoreOp;
	$ initialLayout;
	$ finalLayout;
}]],
	mod.VkAttachmentDescriptionFlags,
	mod.VkFormat,
	mod.VkSampleCountFlagBits,
	mod.VkAttachmentLoadOp,
	mod.VkAttachmentStoreOp,
	mod.VkAttachmentLoadOp,
	mod.VkAttachmentStoreOp,
	mod.VkImageLayout,
	mod.VkImageLayout
)
ffi.metatype(
	mod.VkAttachmentDescription,
	{
		__tostring = function(s)
			return ("struct VkAttachmentDescription[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.format,
				t.samples,
				t.loadOp,
				t.storeOp,
				t.stencilLoadOp,
				t.stencilStoreOp,
				t.initialLayout,
				t.finalLayout
			)
		end,
	}
)
mod.VkAttachmentReference = ffi.typeof([[struct {
	uint32_t attachment;
	$ layout;
}]], mod.VkImageLayout)
ffi.metatype(
	mod.VkAttachmentReference,
	{
		__tostring = function(s)
			return ("struct VkAttachmentReference[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.attachment, t.layout)
		end,
	}
)
mod.VkFramebufferCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ renderPass;
	uint32_t attachmentCount;
	const $* pAttachments;
	uint32_t width;
	uint32_t height;
	uint32_t layers;
}]],
	mod.VkStructureType,
	mod.VkFramebufferCreateFlags,
	mod.VkRenderPass,
	mod.VkImageView
)
ffi.metatype(
	mod.VkFramebufferCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkFramebufferCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.renderPass,
				t.attachmentCount,
				t.pAttachments,
				t.width,
				t.height,
				t.layers
			)
		end,
	}
)
mod.VkSubpassDescription = ffi.typeof(
	[[struct {
	$ flags;
	$ pipelineBindPoint;
	uint32_t inputAttachmentCount;
	const $* pInputAttachments;
	uint32_t colorAttachmentCount;
	const $* pColorAttachments;
	const $* pResolveAttachments;
	const $* pDepthStencilAttachment;
	uint32_t preserveAttachmentCount;
	const uint32_t* pPreserveAttachments;
}]],
	mod.VkSubpassDescriptionFlags,
	mod.VkPipelineBindPoint,
	mod.VkAttachmentReference,
	mod.VkAttachmentReference,
	mod.VkAttachmentReference,
	mod.VkAttachmentReference
)
ffi.metatype(
	mod.VkSubpassDescription,
	{
		__tostring = function(s)
			return ("struct VkSubpassDescription[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.pipelineBindPoint,
				t.inputAttachmentCount,
				t.pInputAttachments,
				t.colorAttachmentCount,
				t.pColorAttachments,
				t.pResolveAttachments,
				t.pDepthStencilAttachment,
				t.preserveAttachmentCount,
				t.pPreserveAttachments
			)
		end,
	}
)
mod.VkSubpassDependency = ffi.typeof(
	[[struct {
	uint32_t srcSubpass;
	uint32_t dstSubpass;
	$ srcStageMask;
	$ dstStageMask;
	$ srcAccessMask;
	$ dstAccessMask;
	$ dependencyFlags;
}]],
	mod.VkPipelineStageFlags,
	mod.VkPipelineStageFlags,
	mod.VkAccessFlags,
	mod.VkAccessFlags,
	mod.VkDependencyFlags
)
ffi.metatype(
	mod.VkSubpassDependency,
	{
		__tostring = function(s)
			return ("struct VkSubpassDependency[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.srcSubpass,
				t.dstSubpass,
				t.srcStageMask,
				t.dstStageMask,
				t.srcAccessMask,
				t.dstAccessMask,
				t.dependencyFlags
			)
		end,
	}
)
mod.VkRenderPassCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t attachmentCount;
	const $* pAttachments;
	uint32_t subpassCount;
	const $* pSubpasses;
	uint32_t dependencyCount;
	const $* pDependencies;
}]],
	mod.VkStructureType,
	mod.VkRenderPassCreateFlags,
	mod.VkAttachmentDescription,
	mod.VkSubpassDescription,
	mod.VkSubpassDependency
)
ffi.metatype(
	mod.VkRenderPassCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkRenderPassCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.attachmentCount,
				t.pAttachments,
				t.subpassCount,
				t.pSubpasses,
				t.dependencyCount,
				t.pDependencies
			)
		end,
	}
)
mod.VkCommandPoolCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t queueFamilyIndex;
}]],
	mod.VkStructureType,
	mod.VkCommandPoolCreateFlags
)
ffi.metatype(
	mod.VkCommandPoolCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkCommandPoolCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.queueFamilyIndex)
		end,
	}
)
mod.VkCommandBufferAllocateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ commandPool;
	$ level;
	uint32_t commandBufferCount;
}]],
	mod.VkStructureType,
	mod.VkCommandPool,
	mod.VkCommandBufferLevel
)
ffi.metatype(
	mod.VkCommandBufferAllocateInfo,
	{
		__tostring = function(s)
			return ("struct VkCommandBufferAllocateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.commandPool, t.level, t.commandBufferCount)
		end,
	}
)
mod.VkCommandBufferInheritanceInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ renderPass;
	uint32_t subpass;
	$ framebuffer;
	$ occlusionQueryEnable;
	$ queryFlags;
	$ pipelineStatistics;
}]],
	mod.VkStructureType,
	mod.VkRenderPass,
	mod.VkFramebuffer,
	mod.VkBool32,
	mod.VkQueryControlFlags,
	mod.VkQueryPipelineStatisticFlags
)
ffi.metatype(
	mod.VkCommandBufferInheritanceInfo,
	{
		__tostring = function(s)
			return ("struct VkCommandBufferInheritanceInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.renderPass,
				t.subpass,
				t.framebuffer,
				t.occlusionQueryEnable,
				t.queryFlags,
				t.pipelineStatistics
			)
		end,
	}
)
mod.VkCommandBufferBeginInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const $* pInheritanceInfo;
}]],
	mod.VkStructureType,
	mod.VkCommandBufferUsageFlags,
	mod.VkCommandBufferInheritanceInfo
)
ffi.metatype(
	mod.VkCommandBufferBeginInfo,
	{
		__tostring = function(s)
			return ("struct VkCommandBufferBeginInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.pInheritanceInfo)
		end,
	}
)
mod.VkBufferCopy = ffi.typeof(
	[[struct {
	$ srcOffset;
	$ dstOffset;
	$ size;
}]],
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkBufferCopy,
	{
		__tostring = function(s)
			return ("struct VkBufferCopy[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.srcOffset, t.dstOffset, t.size)
		end,
	}
)
mod.VkImageSubresourceLayers = ffi.typeof(
	[[struct {
	$ aspectMask;
	uint32_t mipLevel;
	uint32_t baseArrayLayer;
	uint32_t layerCount;
}]],
	mod.VkImageAspectFlags
)
ffi.metatype(
	mod.VkImageSubresourceLayers,
	{
		__tostring = function(s)
			return ("struct VkImageSubresourceLayers[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.aspectMask, t.mipLevel, t.baseArrayLayer, t.layerCount)
		end,
	}
)
mod.VkBufferImageCopy = ffi.typeof(
	[[struct {
	$ bufferOffset;
	uint32_t bufferRowLength;
	uint32_t bufferImageHeight;
	$ imageSubresource;
	$ imageOffset;
	$ imageExtent;
}]],
	mod.VkDeviceSize,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkExtent3D
)
ffi.metatype(
	mod.VkBufferImageCopy,
	{
		__tostring = function(s)
			return ("struct VkBufferImageCopy[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.bufferOffset,
				t.bufferRowLength,
				t.bufferImageHeight,
				t.imageSubresource,
				t.imageOffset,
				t.imageExtent
			)
		end,
	}
)
mod.VkClearColorValue = ffi.typeof([[union {
	float float32[4];
	int32_t int32[4];
	uint32_t uint32[4];
}]])
ffi.metatype(
	mod.VkClearColorValue,
	{
		__tostring = function(s)
			return ("struct VkClearColorValue[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.float32 ~= nil then obj.float32 = t.float32 end

			if t.int32 ~= nil then obj.int32 = t.int32 end

			if t.uint32 ~= nil then obj.uint32 = t.uint32 end

			return obj
		end,
	}
)
mod.VkClearDepthStencilValue = ffi.typeof([[struct {
	float depth;
	uint32_t stencil;
}]])
ffi.metatype(
	mod.VkClearDepthStencilValue,
	{
		__tostring = function(s)
			return ("struct VkClearDepthStencilValue[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.depth, t.stencil)
		end,
	}
)
mod.VkClearValue = ffi.typeof(
	[[union {
	$ color;
	$ depthStencil;
}]],
	mod.VkClearColorValue,
	mod.VkClearDepthStencilValue
)
ffi.metatype(
	mod.VkClearValue,
	{
		__tostring = function(s)
			return ("struct VkClearValue[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.color ~= nil then obj.color = t.color end

			if t.depthStencil ~= nil then obj.depthStencil = t.depthStencil end

			return obj
		end,
	}
)
mod.VkClearAttachment = ffi.typeof(
	[[struct {
	$ aspectMask;
	uint32_t colorAttachment;
	$ clearValue;
}]],
	mod.VkImageAspectFlags,
	mod.VkClearValue
)
ffi.metatype(
	mod.VkClearAttachment,
	{
		__tostring = function(s)
			return ("struct VkClearAttachment[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.aspectMask, t.colorAttachment, t.clearValue)
		end,
	}
)
mod.VkClearRect = ffi.typeof(
	[[struct {
	$ rect;
	uint32_t baseArrayLayer;
	uint32_t layerCount;
}]],
	mod.VkRect2D
)
ffi.metatype(
	mod.VkClearRect,
	{
		__tostring = function(s)
			return ("struct VkClearRect[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.rect, t.baseArrayLayer, t.layerCount)
		end,
	}
)
mod.VkImageBlit = ffi.typeof(
	[[struct {
	$ srcSubresource;
	$ srcOffsets[2];
	$ dstSubresource;
	$ dstOffsets[2];
}]],
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D
)
ffi.metatype(
	mod.VkImageBlit,
	{
		__tostring = function(s)
			return ("struct VkImageBlit[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.srcSubresource, t.srcOffsets, t.dstSubresource, t.dstOffsets)
		end,
	}
)
mod.VkImageCopy = ffi.typeof(
	[[struct {
	$ srcSubresource;
	$ srcOffset;
	$ dstSubresource;
	$ dstOffset;
	$ extent;
}]],
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkExtent3D
)
ffi.metatype(
	mod.VkImageCopy,
	{
		__tostring = function(s)
			return ("struct VkImageCopy[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.srcSubresource, t.srcOffset, t.dstSubresource, t.dstOffset, t.extent)
		end,
	}
)
mod.VkImageResolve = ffi.typeof(
	[[struct {
	$ srcSubresource;
	$ srcOffset;
	$ dstSubresource;
	$ dstOffset;
	$ extent;
}]],
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkExtent3D
)
ffi.metatype(
	mod.VkImageResolve,
	{
		__tostring = function(s)
			return ("struct VkImageResolve[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.srcSubresource, t.srcOffset, t.dstSubresource, t.dstOffset, t.extent)
		end,
	}
)
mod.VkRenderPassBeginInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ renderPass;
	$ framebuffer;
	$ renderArea;
	uint32_t clearValueCount;
	const $* pClearValues;
}]],
	mod.VkStructureType,
	mod.VkRenderPass,
	mod.VkFramebuffer,
	mod.VkRect2D,
	mod.VkClearValue
)
ffi.metatype(
	mod.VkRenderPassBeginInfo,
	{
		__tostring = function(s)
			return ("struct VkRenderPassBeginInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.renderPass,
				t.framebuffer,
				t.renderArea,
				t.clearValueCount,
				t.pClearValues
			)
		end,
	}
)
mod.PFN_vkCreateInstance = ffi.typeof(
	[[$ (*)(const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstanceCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkInstance
)
mod.PFN_vkDestroyInstance = ffi.typeof([[void (*)($ , const $*)]], mod.VkInstance, mod.VkAllocationCallbacks)
mod.PFN_vkEnumeratePhysicalDevices = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkInstance, mod.VkPhysicalDevice)
mod.PFN_vkGetPhysicalDeviceFeatures = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceFeatures)
mod.PFN_vkGetPhysicalDeviceFormatProperties = ffi.typeof(
	[[void (*)($ , $ , $*)]],
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkFormatProperties
)
mod.PFN_vkGetPhysicalDeviceImageFormatProperties = ffi.typeof(
	[[$ (*)($ , $ , $ , $ , $ , $ , $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkImageType,
	mod.VkImageTiling,
	mod.VkImageUsageFlags,
	mod.VkImageCreateFlags,
	mod.VkImageFormatProperties
)
mod.PFN_vkGetPhysicalDeviceProperties = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceProperties)
mod.PFN_vkGetPhysicalDeviceQueueFamilyProperties = ffi.typeof(
	[[void (*)($ , uint32_t*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkQueueFamilyProperties
)
mod.PFN_vkGetPhysicalDeviceMemoryProperties = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceMemoryProperties)
mod.PFN_vkGetInstanceProcAddr = ffi.typeof([[$ (*)($ , const char*)]], mod.PFN_vkVoidFunction, mod.VkInstance)
mod.PFN_vkGetDeviceProcAddr = ffi.typeof([[$ (*)($ , const char*)]], mod.PFN_vkVoidFunction, mod.VkDevice)
mod.PFN_vkCreateDevice = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDeviceCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDevice
)
mod.PFN_vkDestroyDevice = ffi.typeof([[void (*)($ , const $*)]], mod.VkDevice, mod.VkAllocationCallbacks)
mod.PFN_vkEnumerateInstanceExtensionProperties = ffi.typeof([[$ (*)(const char*, uint32_t*, $*)]], mod.VkResult, mod.VkExtensionProperties)
mod.PFN_vkEnumerateDeviceExtensionProperties = ffi.typeof(
	[[$ (*)($ , const char*, uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkExtensionProperties
)
mod.PFN_vkEnumerateInstanceLayerProperties = ffi.typeof([[$ (*)(uint32_t*, $*)]], mod.VkResult, mod.VkLayerProperties)
mod.PFN_vkEnumerateDeviceLayerProperties = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkLayerProperties
)
mod.PFN_vkGetDeviceQueue = ffi.typeof([[void (*)($ , uint32_t , uint32_t , $*)]], mod.VkDevice, mod.VkQueue)
mod.PFN_vkQueueSubmit = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*, $ )]],
	mod.VkResult,
	mod.VkQueue,
	mod.VkSubmitInfo,
	mod.VkFence
)
mod.PFN_vkQueueWaitIdle = ffi.typeof([[$ (*)($ )]], mod.VkResult, mod.VkQueue)
mod.PFN_vkDeviceWaitIdle = ffi.typeof([[$ (*)($ )]], mod.VkResult, mod.VkDevice)
mod.PFN_vkAllocateMemory = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryAllocateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDeviceMemory
)
mod.PFN_vkFreeMemory = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkDeviceMemory,
	mod.VkAllocationCallbacks
)
mod.PFN_vkMapMemory = ffi.typeof(
	[[$ (*)($ , $ , $ , $ , $ , void**)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeviceMemory,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkMemoryMapFlags
)
mod.PFN_vkUnmapMemory = ffi.typeof([[void (*)($ , $ )]], mod.VkDevice, mod.VkDeviceMemory)
mod.PFN_vkFlushMappedMemoryRanges = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMappedMemoryRange
)
mod.PFN_vkInvalidateMappedMemoryRanges = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMappedMemoryRange
)
mod.PFN_vkGetDeviceMemoryCommitment = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkDevice, mod.VkDeviceMemory, mod.VkDeviceSize)
mod.PFN_vkBindBufferMemory = ffi.typeof(
	[[$ (*)($ , $ , $ , $ )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBuffer,
	mod.VkDeviceMemory,
	mod.VkDeviceSize
)
mod.PFN_vkBindImageMemory = ffi.typeof(
	[[$ (*)($ , $ , $ , $ )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImage,
	mod.VkDeviceMemory,
	mod.VkDeviceSize
)
mod.PFN_vkGetBufferMemoryRequirements = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkDevice, mod.VkBuffer, mod.VkMemoryRequirements)
mod.PFN_vkGetImageMemoryRequirements = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkDevice, mod.VkImage, mod.VkMemoryRequirements)
mod.PFN_vkGetImageSparseMemoryRequirements = ffi.typeof(
	[[void (*)($ , $ , uint32_t*, $*)]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkSparseImageMemoryRequirements
)
mod.PFN_vkGetPhysicalDeviceSparseImageFormatProperties = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , $ , uint32_t*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkImageType,
	mod.VkSampleCountFlagBits,
	mod.VkImageUsageFlags,
	mod.VkImageTiling,
	mod.VkSparseImageFormatProperties
)
mod.PFN_vkQueueBindSparse = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*, $ )]],
	mod.VkResult,
	mod.VkQueue,
	mod.VkBindSparseInfo,
	mod.VkFence
)
mod.PFN_vkCreateFence = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkFenceCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkFence
)
mod.PFN_vkDestroyFence = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkFence,
	mod.VkAllocationCallbacks
)
mod.PFN_vkResetFences = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkFence)
mod.PFN_vkGetFenceStatus = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkFence)
mod.PFN_vkWaitForFences = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*, $ , uint64_t )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkFence,
	mod.VkBool32
)
mod.PFN_vkCreateSemaphore = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphoreCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkSemaphore
)
mod.PFN_vkDestroySemaphore = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkSemaphore,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreateEvent = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkEventCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkEvent
)
mod.PFN_vkDestroyEvent = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkEvent,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetEventStatus = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkEvent)
mod.PFN_vkSetEvent = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkEvent)
mod.PFN_vkResetEvent = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkEvent)
mod.PFN_vkCreateQueryPool = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkQueryPoolCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkQueryPool
)
mod.PFN_vkDestroyQueryPool = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkQueryPool,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetQueryPoolResults = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , uint32_t , size_t , void*, $ , $ )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkQueryPool,
	mod.VkDeviceSize,
	mod.VkQueryResultFlags
)
mod.PFN_vkCreateBuffer = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBufferCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkBuffer
)
mod.PFN_vkDestroyBuffer = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkBuffer,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreateBufferView = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBufferViewCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkBufferView
)
mod.PFN_vkDestroyBufferView = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkBufferView,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreateImage = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImageCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkImage
)
mod.PFN_vkDestroyImage = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetImageSubresourceLayout = ffi.typeof(
	[[void (*)($ , $ , const $*, $*)]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkImageSubresource,
	mod.VkSubresourceLayout
)
mod.PFN_vkCreateImageView = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImageViewCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkImageView
)
mod.PFN_vkDestroyImageView = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkImageView,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreateShaderModule = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkShaderModuleCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkShaderModule
)
mod.PFN_vkDestroyShaderModule = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkShaderModule,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreatePipelineCache = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCacheCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPipelineCache
)
mod.PFN_vkDestroyPipelineCache = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkPipelineCache,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetPipelineCacheData = ffi.typeof(
	[[$ (*)($ , $ , size_t*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCache
)
mod.PFN_vkMergePipelineCaches = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCache,
	mod.VkPipelineCache
)
mod.PFN_vkCreateGraphicsPipelines = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCache,
	mod.VkGraphicsPipelineCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPipeline
)
mod.PFN_vkCreateComputePipelines = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCache,
	mod.VkComputePipelineCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPipeline
)
mod.PFN_vkDestroyPipeline = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkPipeline,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreatePipelineLayout = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineLayoutCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPipelineLayout
)
mod.PFN_vkDestroyPipelineLayout = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkPipelineLayout,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreateSampler = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSamplerCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkSampler
)
mod.PFN_vkDestroySampler = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkSampler,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreateDescriptorSetLayout = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorSetLayoutCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDescriptorSetLayout
)
mod.PFN_vkDestroyDescriptorSetLayout = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkDescriptorSetLayout,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreateDescriptorPool = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorPoolCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDescriptorPool
)
mod.PFN_vkDestroyDescriptorPool = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkDescriptorPool,
	mod.VkAllocationCallbacks
)
mod.PFN_vkResetDescriptorPool = ffi.typeof(
	[[$ (*)($ , $ , $ )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorPool,
	mod.VkDescriptorPoolResetFlags
)
mod.PFN_vkAllocateDescriptorSets = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorSetAllocateInfo,
	mod.VkDescriptorSet
)
mod.PFN_vkFreeDescriptorSets = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorPool,
	mod.VkDescriptorSet
)
mod.PFN_vkUpdateDescriptorSets = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, uint32_t , const $*)]],
	mod.VkDevice,
	mod.VkWriteDescriptorSet,
	mod.VkCopyDescriptorSet
)
mod.PFN_vkCreateFramebuffer = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkFramebufferCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkFramebuffer
)
mod.PFN_vkDestroyFramebuffer = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkFramebuffer,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreateRenderPass = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkRenderPassCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkRenderPass
)
mod.PFN_vkDestroyRenderPass = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkRenderPass,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetRenderAreaGranularity = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkDevice, mod.VkRenderPass, mod.VkExtent2D)
mod.PFN_vkCreateCommandPool = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCommandPoolCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkCommandPool
)
mod.PFN_vkDestroyCommandPool = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkCommandPool,
	mod.VkAllocationCallbacks
)
mod.PFN_vkResetCommandPool = ffi.typeof(
	[[$ (*)($ , $ , $ )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCommandPool,
	mod.VkCommandPoolResetFlags
)
mod.PFN_vkAllocateCommandBuffers = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCommandBufferAllocateInfo,
	mod.VkCommandBuffer
)
mod.PFN_vkFreeCommandBuffers = ffi.typeof(
	[[void (*)($ , $ , uint32_t , const $*)]],
	mod.VkDevice,
	mod.VkCommandPool,
	mod.VkCommandBuffer
)
mod.PFN_vkBeginCommandBuffer = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkCommandBuffer,
	mod.VkCommandBufferBeginInfo
)
mod.PFN_vkEndCommandBuffer = ffi.typeof([[$ (*)($ )]], mod.VkResult, mod.VkCommandBuffer)
mod.PFN_vkResetCommandBuffer = ffi.typeof(
	[[$ (*)($ , $ )]],
	mod.VkResult,
	mod.VkCommandBuffer,
	mod.VkCommandBufferResetFlags
)
mod.PFN_vkCmdBindPipeline = ffi.typeof(
	[[void (*)($ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipeline
)
mod.PFN_vkCmdSetViewport = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkViewport
)
mod.PFN_vkCmdSetScissor = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkRect2D
)
mod.PFN_vkCmdSetLineWidth = ffi.typeof([[void (*)($ , float )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetDepthBias = ffi.typeof([[void (*)($ , float , float , float )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetBlendConstants = ffi.typeof([[void (*)($ , const float[4])]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetDepthBounds = ffi.typeof([[void (*)($ , float , float )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetStencilCompareMask = ffi.typeof([[void (*)($ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkStencilFaceFlags)
mod.PFN_vkCmdSetStencilWriteMask = ffi.typeof([[void (*)($ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkStencilFaceFlags)
mod.PFN_vkCmdSetStencilReference = ffi.typeof([[void (*)($ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkStencilFaceFlags)
mod.PFN_vkCmdBindDescriptorSets = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , uint32_t , const $*, uint32_t , const uint32_t*)]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipelineLayout,
	mod.VkDescriptorSet
)
mod.PFN_vkCmdBindIndexBuffer = ffi.typeof(
	[[void (*)($ , $ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkIndexType
)
mod.PFN_vkCmdBindVertexBuffers = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdDraw = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDrawIndexed = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , uint32_t , int32_t , uint32_t )]],
	mod.VkCommandBuffer
)
mod.PFN_vkCmdDrawIndirect = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdDrawIndexedIndirect = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdDispatch = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDispatchIndirect = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdCopyBuffer = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkBuffer,
	mod.VkBufferCopy
)
mod.PFN_vkCmdCopyImage = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageCopy
)
mod.PFN_vkCmdBlitImage = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , uint32_t , const $*, $ )]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageBlit,
	mod.VkFilter
)
mod.PFN_vkCmdCopyBufferToImage = ffi.typeof(
	[[void (*)($ , $ , $ , $ , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkBufferImageCopy
)
mod.PFN_vkCmdCopyImageToBuffer = ffi.typeof(
	[[void (*)($ , $ , $ , $ , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkBuffer,
	mod.VkBufferImageCopy
)
mod.PFN_vkCmdUpdateBuffer = ffi.typeof(
	[[void (*)($ , $ , $ , $ , const void*)]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
mod.PFN_vkCmdFillBuffer = ffi.typeof(
	[[void (*)($ , $ , $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
mod.PFN_vkCmdClearColorImage = ffi.typeof(
	[[void (*)($ , $ , $ , const $*, uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkClearColorValue,
	mod.VkImageSubresourceRange
)
mod.PFN_vkCmdClearDepthStencilImage = ffi.typeof(
	[[void (*)($ , $ , $ , const $*, uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkClearDepthStencilValue,
	mod.VkImageSubresourceRange
)
mod.PFN_vkCmdClearAttachments = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkClearAttachment,
	mod.VkClearRect
)
mod.PFN_vkCmdResolveImage = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageResolve
)
mod.PFN_vkCmdSetEvent = ffi.typeof(
	[[void (*)($ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkPipelineStageFlags
)
mod.PFN_vkCmdResetEvent = ffi.typeof(
	[[void (*)($ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkPipelineStageFlags
)
mod.PFN_vkCmdWaitEvents = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, $ , $ , uint32_t , const $*, uint32_t , const $*, uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkPipelineStageFlags,
	mod.VkPipelineStageFlags,
	mod.VkMemoryBarrier,
	mod.VkBufferMemoryBarrier,
	mod.VkImageMemoryBarrier
)
mod.PFN_vkCmdPipelineBarrier = ffi.typeof(
	[[void (*)($ , $ , $ , $ , uint32_t , const $*, uint32_t , const $*, uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlags,
	mod.VkPipelineStageFlags,
	mod.VkDependencyFlags,
	mod.VkMemoryBarrier,
	mod.VkBufferMemoryBarrier,
	mod.VkImageMemoryBarrier
)
mod.PFN_vkCmdBeginQuery = ffi.typeof(
	[[void (*)($ , $ , uint32_t , $ )]],
	mod.VkCommandBuffer,
	mod.VkQueryPool,
	mod.VkQueryControlFlags
)
mod.PFN_vkCmdEndQuery = ffi.typeof([[void (*)($ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkQueryPool)
mod.PFN_vkCmdResetQueryPool = ffi.typeof([[void (*)($ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkQueryPool)
mod.PFN_vkCmdWriteTimestamp = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlagBits,
	mod.VkQueryPool
)
mod.PFN_vkCmdCopyQueryPoolResults = ffi.typeof(
	[[void (*)($ , $ , uint32_t , uint32_t , $ , $ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkQueryPool,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkQueryResultFlags
)
mod.PFN_vkCmdPushConstants = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , uint32_t , const void*)]],
	mod.VkCommandBuffer,
	mod.VkPipelineLayout,
	mod.VkShaderStageFlags
)
mod.PFN_vkCmdBeginRenderPass = ffi.typeof(
	[[void (*)($ , const $*, $ )]],
	mod.VkCommandBuffer,
	mod.VkRenderPassBeginInfo,
	mod.VkSubpassContents
)
mod.PFN_vkCmdNextSubpass = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkSubpassContents)
mod.PFN_vkCmdEndRenderPass = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
mod.PFN_vkCmdExecuteCommands = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkCommandBuffer)
ffi.cdef(
	[[$  vkCreateInstance(const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstanceCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkInstance
)
ffi.cdef(
	[[void  vkDestroyInstance($ , const $*);]],
	mod.VkInstance,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkEnumeratePhysicalDevices($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkPhysicalDevice
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceFeatures($ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceFeatures
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceFormatProperties($ , $ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkFormatProperties
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceImageFormatProperties($ , $ , $ , $ , $ , $ , $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkImageType,
	mod.VkImageTiling,
	mod.VkImageUsageFlags,
	mod.VkImageCreateFlags,
	mod.VkImageFormatProperties
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceProperties($ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceProperties
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceQueueFamilyProperties($ , uint32_t*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkQueueFamilyProperties
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceMemoryProperties($ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceMemoryProperties
)
ffi.cdef(
	[[$  vkGetInstanceProcAddr($ , const char*);]],
	mod.PFN_vkVoidFunction,
	mod.VkInstance
)
ffi.cdef(
	[[$  vkGetDeviceProcAddr($ , const char*);]],
	mod.PFN_vkVoidFunction,
	mod.VkDevice
)
ffi.cdef(
	[[$  vkCreateDevice($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDeviceCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDevice
)
ffi.cdef([[void  vkDestroyDevice($ , const $*);]], mod.VkDevice, mod.VkAllocationCallbacks)
ffi.cdef(
	[[$  vkEnumerateInstanceExtensionProperties(const char*, uint32_t*, $*);]],
	mod.VkResult,
	mod.VkExtensionProperties
)
ffi.cdef(
	[[$  vkEnumerateDeviceExtensionProperties($ , const char*, uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkExtensionProperties
)
ffi.cdef(
	[[$  vkEnumerateInstanceLayerProperties(uint32_t*, $*);]],
	mod.VkResult,
	mod.VkLayerProperties
)
ffi.cdef(
	[[$  vkEnumerateDeviceLayerProperties($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkLayerProperties
)
ffi.cdef(
	[[void  vkGetDeviceQueue($ , uint32_t , uint32_t , $*);]],
	mod.VkDevice,
	mod.VkQueue
)
ffi.cdef(
	[[$  vkQueueSubmit($ , uint32_t , const $*, $ );]],
	mod.VkResult,
	mod.VkQueue,
	mod.VkSubmitInfo,
	mod.VkFence
)
ffi.cdef([[$  vkQueueWaitIdle($ );]], mod.VkResult, mod.VkQueue)
ffi.cdef([[$  vkDeviceWaitIdle($ );]], mod.VkResult, mod.VkDevice)
ffi.cdef(
	[[$  vkAllocateMemory($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryAllocateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDeviceMemory
)
ffi.cdef(
	[[void  vkFreeMemory($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkDeviceMemory,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkMapMemory($ , $ , $ , $ , $ , void**);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeviceMemory,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkMemoryMapFlags
)
ffi.cdef([[void  vkUnmapMemory($ , $ );]], mod.VkDevice, mod.VkDeviceMemory)
ffi.cdef(
	[[$  vkFlushMappedMemoryRanges($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMappedMemoryRange
)
ffi.cdef(
	[[$  vkInvalidateMappedMemoryRanges($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMappedMemoryRange
)
ffi.cdef(
	[[void  vkGetDeviceMemoryCommitment($ , $ , $*);]],
	mod.VkDevice,
	mod.VkDeviceMemory,
	mod.VkDeviceSize
)
ffi.cdef(
	[[$  vkBindBufferMemory($ , $ , $ , $ );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBuffer,
	mod.VkDeviceMemory,
	mod.VkDeviceSize
)
ffi.cdef(
	[[$  vkBindImageMemory($ , $ , $ , $ );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImage,
	mod.VkDeviceMemory,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkGetBufferMemoryRequirements($ , $ , $*);]],
	mod.VkDevice,
	mod.VkBuffer,
	mod.VkMemoryRequirements
)
ffi.cdef(
	[[void  vkGetImageMemoryRequirements($ , $ , $*);]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkMemoryRequirements
)
ffi.cdef(
	[[void  vkGetImageSparseMemoryRequirements($ , $ , uint32_t*, $*);]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkSparseImageMemoryRequirements
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceSparseImageFormatProperties($ , $ , $ , $ , $ , $ , uint32_t*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkImageType,
	mod.VkSampleCountFlagBits,
	mod.VkImageUsageFlags,
	mod.VkImageTiling,
	mod.VkSparseImageFormatProperties
)
ffi.cdef(
	[[$  vkQueueBindSparse($ , uint32_t , const $*, $ );]],
	mod.VkResult,
	mod.VkQueue,
	mod.VkBindSparseInfo,
	mod.VkFence
)
ffi.cdef(
	[[$  vkCreateFence($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkFenceCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkFence
)
ffi.cdef(
	[[void  vkDestroyFence($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkFence,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkResetFences($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkFence
)
ffi.cdef([[$  vkGetFenceStatus($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkFence)
ffi.cdef(
	[[$  vkWaitForFences($ , uint32_t , const $*, $ , uint64_t );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkFence,
	mod.VkBool32
)
ffi.cdef(
	[[$  vkCreateSemaphore($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphoreCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkSemaphore
)
ffi.cdef(
	[[void  vkDestroySemaphore($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkSemaphore,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateEvent($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkEventCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkEvent
)
ffi.cdef(
	[[void  vkDestroyEvent($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkEvent,
	mod.VkAllocationCallbacks
)
ffi.cdef([[$  vkGetEventStatus($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkEvent)
ffi.cdef([[$  vkSetEvent($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkEvent)
ffi.cdef([[$  vkResetEvent($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkEvent)
ffi.cdef(
	[[$  vkCreateQueryPool($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkQueryPoolCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkQueryPool
)
ffi.cdef(
	[[void  vkDestroyQueryPool($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkQueryPool,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkGetQueryPoolResults($ , $ , uint32_t , uint32_t , size_t , void*, $ , $ );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkQueryPool,
	mod.VkDeviceSize,
	mod.VkQueryResultFlags
)
ffi.cdef(
	[[$  vkCreateBuffer($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBufferCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkBuffer
)
ffi.cdef(
	[[void  vkDestroyBuffer($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkBuffer,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateBufferView($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBufferViewCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkBufferView
)
ffi.cdef(
	[[void  vkDestroyBufferView($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkBufferView,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateImage($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImageCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkImage
)
ffi.cdef(
	[[void  vkDestroyImage($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkGetImageSubresourceLayout($ , $ , const $*, $*);]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkImageSubresource,
	mod.VkSubresourceLayout
)
ffi.cdef(
	[[$  vkCreateImageView($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImageViewCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkImageView
)
ffi.cdef(
	[[void  vkDestroyImageView($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkImageView,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateShaderModule($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkShaderModuleCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkShaderModule
)
ffi.cdef(
	[[void  vkDestroyShaderModule($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkShaderModule,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreatePipelineCache($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCacheCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPipelineCache
)
ffi.cdef(
	[[void  vkDestroyPipelineCache($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkPipelineCache,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkGetPipelineCacheData($ , $ , size_t*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCache
)
ffi.cdef(
	[[$  vkMergePipelineCaches($ , $ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCache,
	mod.VkPipelineCache
)
ffi.cdef(
	[[$  vkCreateGraphicsPipelines($ , $ , uint32_t , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCache,
	mod.VkGraphicsPipelineCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPipeline
)
ffi.cdef(
	[[$  vkCreateComputePipelines($ , $ , uint32_t , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCache,
	mod.VkComputePipelineCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPipeline
)
ffi.cdef(
	[[void  vkDestroyPipeline($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkPipeline,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreatePipelineLayout($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineLayoutCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPipelineLayout
)
ffi.cdef(
	[[void  vkDestroyPipelineLayout($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkPipelineLayout,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateSampler($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSamplerCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkSampler
)
ffi.cdef(
	[[void  vkDestroySampler($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkSampler,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateDescriptorSetLayout($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorSetLayoutCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDescriptorSetLayout
)
ffi.cdef(
	[[void  vkDestroyDescriptorSetLayout($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkDescriptorSetLayout,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateDescriptorPool($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorPoolCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDescriptorPool
)
ffi.cdef(
	[[void  vkDestroyDescriptorPool($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkDescriptorPool,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkResetDescriptorPool($ , $ , $ );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorPool,
	mod.VkDescriptorPoolResetFlags
)
ffi.cdef(
	[[$  vkAllocateDescriptorSets($ , const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorSetAllocateInfo,
	mod.VkDescriptorSet
)
ffi.cdef(
	[[$  vkFreeDescriptorSets($ , $ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorPool,
	mod.VkDescriptorSet
)
ffi.cdef(
	[[void  vkUpdateDescriptorSets($ , uint32_t , const $*, uint32_t , const $*);]],
	mod.VkDevice,
	mod.VkWriteDescriptorSet,
	mod.VkCopyDescriptorSet
)
ffi.cdef(
	[[$  vkCreateFramebuffer($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkFramebufferCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkFramebuffer
)
ffi.cdef(
	[[void  vkDestroyFramebuffer($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkFramebuffer,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateRenderPass($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkRenderPassCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkRenderPass
)
ffi.cdef(
	[[void  vkDestroyRenderPass($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkRenderPass,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkGetRenderAreaGranularity($ , $ , $*);]],
	mod.VkDevice,
	mod.VkRenderPass,
	mod.VkExtent2D
)
ffi.cdef(
	[[$  vkCreateCommandPool($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCommandPoolCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkCommandPool
)
ffi.cdef(
	[[void  vkDestroyCommandPool($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkCommandPool,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkResetCommandPool($ , $ , $ );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCommandPool,
	mod.VkCommandPoolResetFlags
)
ffi.cdef(
	[[$  vkAllocateCommandBuffers($ , const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCommandBufferAllocateInfo,
	mod.VkCommandBuffer
)
ffi.cdef(
	[[void  vkFreeCommandBuffers($ , $ , uint32_t , const $*);]],
	mod.VkDevice,
	mod.VkCommandPool,
	mod.VkCommandBuffer
)
ffi.cdef(
	[[$  vkBeginCommandBuffer($ , const $*);]],
	mod.VkResult,
	mod.VkCommandBuffer,
	mod.VkCommandBufferBeginInfo
)
ffi.cdef([[$  vkEndCommandBuffer($ );]], mod.VkResult, mod.VkCommandBuffer)
ffi.cdef(
	[[$  vkResetCommandBuffer($ , $ );]],
	mod.VkResult,
	mod.VkCommandBuffer,
	mod.VkCommandBufferResetFlags
)
ffi.cdef(
	[[void  vkCmdBindPipeline($ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipeline
)
ffi.cdef(
	[[void  vkCmdSetViewport($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkViewport
)
ffi.cdef(
	[[void  vkCmdSetScissor($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRect2D
)
ffi.cdef([[void  vkCmdSetLineWidth($ , float );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetDepthBias($ , float , float , float );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetBlendConstants($ , const float[4]);]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetDepthBounds($ , float , float );]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdSetStencilCompareMask($ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkStencilFaceFlags
)
ffi.cdef(
	[[void  vkCmdSetStencilWriteMask($ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkStencilFaceFlags
)
ffi.cdef(
	[[void  vkCmdSetStencilReference($ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkStencilFaceFlags
)
ffi.cdef(
	[[void  vkCmdBindDescriptorSets($ , $ , $ , uint32_t , uint32_t , const $*, uint32_t , const uint32_t*);]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipelineLayout,
	mod.VkDescriptorSet
)
ffi.cdef(
	[[void  vkCmdBindIndexBuffer($ , $ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkIndexType
)
ffi.cdef(
	[[void  vkCmdBindVertexBuffers($ , uint32_t , uint32_t , const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdDraw($ , uint32_t , uint32_t , uint32_t , uint32_t );]],
	mod.VkCommandBuffer
)
ffi.cdef(
	[[void  vkCmdDrawIndexed($ , uint32_t , uint32_t , uint32_t , int32_t , uint32_t );]],
	mod.VkCommandBuffer
)
ffi.cdef(
	[[void  vkCmdDrawIndirect($ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdDrawIndexedIndirect($ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdDispatch($ , uint32_t , uint32_t , uint32_t );]],
	mod.VkCommandBuffer
)
ffi.cdef(
	[[void  vkCmdDispatchIndirect($ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdCopyBuffer($ , $ , $ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkBuffer,
	mod.VkBufferCopy
)
ffi.cdef(
	[[void  vkCmdCopyImage($ , $ , $ , $ , $ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageCopy
)
ffi.cdef(
	[[void  vkCmdBlitImage($ , $ , $ , $ , $ , uint32_t , const $*, $ );]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageBlit,
	mod.VkFilter
)
ffi.cdef(
	[[void  vkCmdCopyBufferToImage($ , $ , $ , $ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkBufferImageCopy
)
ffi.cdef(
	[[void  vkCmdCopyImageToBuffer($ , $ , $ , $ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkBuffer,
	mod.VkBufferImageCopy
)
ffi.cdef(
	[[void  vkCmdUpdateBuffer($ , $ , $ , $ , const void*);]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdFillBuffer($ , $ , $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdClearColorImage($ , $ , $ , const $*, uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkClearColorValue,
	mod.VkImageSubresourceRange
)
ffi.cdef(
	[[void  vkCmdClearDepthStencilImage($ , $ , $ , const $*, uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkClearDepthStencilValue,
	mod.VkImageSubresourceRange
)
ffi.cdef(
	[[void  vkCmdClearAttachments($ , uint32_t , const $*, uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkClearAttachment,
	mod.VkClearRect
)
ffi.cdef(
	[[void  vkCmdResolveImage($ , $ , $ , $ , $ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageResolve
)
ffi.cdef(
	[[void  vkCmdSetEvent($ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkPipelineStageFlags
)
ffi.cdef(
	[[void  vkCmdResetEvent($ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkPipelineStageFlags
)
ffi.cdef(
	[[void  vkCmdWaitEvents($ , uint32_t , const $*, $ , $ , uint32_t , const $*, uint32_t , const $*, uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkPipelineStageFlags,
	mod.VkPipelineStageFlags,
	mod.VkMemoryBarrier,
	mod.VkBufferMemoryBarrier,
	mod.VkImageMemoryBarrier
)
ffi.cdef(
	[[void  vkCmdPipelineBarrier($ , $ , $ , $ , uint32_t , const $*, uint32_t , const $*, uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlags,
	mod.VkPipelineStageFlags,
	mod.VkDependencyFlags,
	mod.VkMemoryBarrier,
	mod.VkBufferMemoryBarrier,
	mod.VkImageMemoryBarrier
)
ffi.cdef(
	[[void  vkCmdBeginQuery($ , $ , uint32_t , $ );]],
	mod.VkCommandBuffer,
	mod.VkQueryPool,
	mod.VkQueryControlFlags
)
ffi.cdef([[void  vkCmdEndQuery($ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkQueryPool)
ffi.cdef(
	[[void  vkCmdResetQueryPool($ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkQueryPool
)
ffi.cdef(
	[[void  vkCmdWriteTimestamp($ , $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlagBits,
	mod.VkQueryPool
)
ffi.cdef(
	[[void  vkCmdCopyQueryPoolResults($ , $ , uint32_t , uint32_t , $ , $ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkQueryPool,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkQueryResultFlags
)
ffi.cdef(
	[[void  vkCmdPushConstants($ , $ , $ , uint32_t , uint32_t , const void*);]],
	mod.VkCommandBuffer,
	mod.VkPipelineLayout,
	mod.VkShaderStageFlags
)
ffi.cdef(
	[[void  vkCmdBeginRenderPass($ , const $*, $ );]],
	mod.VkCommandBuffer,
	mod.VkRenderPassBeginInfo,
	mod.VkSubpassContents
)
ffi.cdef([[void  vkCmdNextSubpass($ , $ );]], mod.VkCommandBuffer, mod.VkSubpassContents)
ffi.cdef([[void  vkCmdEndRenderPass($ );]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdExecuteCommands($ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCommandBuffer
)
mod.VkPointClippingBehavior = ffi.typeof([[enum {
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
	VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkTessellationDomainOrigin = ffi.typeof([[enum {
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
	VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerYcbcrModelConversion = ffi.typeof([[enum {
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerYcbcrRange = ffi.typeof([[enum {
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
	VK_SAMPLER_YCBCR_RANGE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkChromaLocation = ffi.typeof([[enum {
	VK_CHROMA_LOCATION_COSITED_EVEN = 0,
	VK_CHROMA_LOCATION_MIDPOINT = 1,
	VK_CHROMA_LOCATION_COSITED_EVEN_KHR = VK_CHROMA_LOCATION_COSITED_EVEN,
	VK_CHROMA_LOCATION_MIDPOINT_KHR = VK_CHROMA_LOCATION_MIDPOINT,
	VK_CHROMA_LOCATION_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDescriptorUpdateTemplateType = ffi.typeof([[enum {
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS = 1,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSubgroupFeatureFlagBits = ffi.typeof([[enum {
	VK_SUBGROUP_FEATURE_BASIC_BIT = 0x00000001,
	VK_SUBGROUP_FEATURE_VOTE_BIT = 0x00000002,
	VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x00000004,
	VK_SUBGROUP_FEATURE_BALLOT_BIT = 0x00000008,
	VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 0x00000010,
	VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020,
	VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040,
	VK_SUBGROUP_FEATURE_QUAD_BIT = 0x00000080,
	VK_SUBGROUP_FEATURE_ROTATE_BIT = 0x00000200,
	VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT = 0x00000400,
	VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100,
	VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR = VK_SUBGROUP_FEATURE_ROTATE_BIT,
	VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR = VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT,
	VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSubgroupFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPeerMemoryFeatureFlagBits = ffi.typeof([[enum {
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x00000001,
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x00000002,
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x00000004,
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x00000008,
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
	VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPeerMemoryFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMemoryAllocateFlagBits = ffi.typeof([[enum {
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x00000001,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 0x00000002,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000004,
	VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT = 0x00000008,
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
	VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryAllocateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkCommandPoolTrimFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDescriptorUpdateTemplateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalMemoryHandleTypeFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x00000008,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x00000010,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x00000020,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x00000400,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = 0x00000800,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = 0x00001000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX = 0x00004000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT = 0x00010000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT = 0x00020000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT = 0x00040000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalMemoryHandleTypeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalMemoryFeatureFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x00000001,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x00000004,
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
	VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalMemoryFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalFenceHandleTypeFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalFenceHandleTypeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalFenceFeatureFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x00000001,
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
	VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalFenceFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkFenceImportFlagBits = ffi.typeof([[enum {
	VK_FENCE_IMPORT_TEMPORARY_BIT = 0x00000001,
	VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = VK_FENCE_IMPORT_TEMPORARY_BIT,
	VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFenceImportFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSemaphoreImportFlagBits = ffi.typeof([[enum {
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x00000001,
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
	VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSemaphoreImportFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalSemaphoreHandleTypeFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x00000008,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000010,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = 0x00000080,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalSemaphoreHandleTypeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalSemaphoreFeatureFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x00000001,
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
	VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalSemaphoreFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceSubgroupProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t subgroupSize;
	$ supportedStages;
	$ supportedOperations;
	$ quadOperationsInAllStages;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags,
	mod.VkSubgroupFeatureFlags,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSubgroupProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSubgroupProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.subgroupSize,
				t.supportedStages,
				t.supportedOperations,
				t.quadOperationsInAllStages
			)
		end,
	}
)
mod.VkBindBufferMemoryInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ buffer;
	$ memory;
	$ memoryOffset;
}]],
	mod.VkStructureType,
	mod.VkBuffer,
	mod.VkDeviceMemory,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkBindBufferMemoryInfo,
	{
		__tostring = function(s)
			return ("struct VkBindBufferMemoryInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.buffer, t.memory, t.memoryOffset)
		end,
	}
)
mod.VkBindImageMemoryInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ memory;
	$ memoryOffset;
}]],
	mod.VkStructureType,
	mod.VkImage,
	mod.VkDeviceMemory,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkBindImageMemoryInfo,
	{
		__tostring = function(s)
			return ("struct VkBindImageMemoryInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.image, t.memory, t.memoryOffset)
		end,
	}
)
mod.VkPhysicalDevice16BitStorageFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ storageBuffer16BitAccess;
	$ uniformAndStorageBuffer16BitAccess;
	$ storagePushConstant16;
	$ storageInputOutput16;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevice16BitStorageFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevice16BitStorageFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.storageBuffer16BitAccess,
				t.uniformAndStorageBuffer16BitAccess,
				t.storagePushConstant16,
				t.storageInputOutput16
			)
		end,
	}
)
mod.VkMemoryDedicatedRequirements = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ prefersDedicatedAllocation;
	$ requiresDedicatedAllocation;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkMemoryDedicatedRequirements,
	{
		__tostring = function(s)
			return ("struct VkMemoryDedicatedRequirements[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.prefersDedicatedAllocation,
				t.requiresDedicatedAllocation
			)
		end,
	}
)
mod.VkMemoryDedicatedAllocateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ buffer;
}]],
	mod.VkStructureType,
	mod.VkImage,
	mod.VkBuffer
)
ffi.metatype(
	mod.VkMemoryDedicatedAllocateInfo,
	{
		__tostring = function(s)
			return ("struct VkMemoryDedicatedAllocateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.image, t.buffer)
		end,
	}
)
mod.VkMemoryAllocateFlagsInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t deviceMask;
}]],
	mod.VkStructureType,
	mod.VkMemoryAllocateFlags
)
ffi.metatype(
	mod.VkMemoryAllocateFlagsInfo,
	{
		__tostring = function(s)
			return ("struct VkMemoryAllocateFlagsInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.deviceMask)
		end,
	}
)
mod.VkDeviceGroupRenderPassBeginInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t deviceMask;
	uint32_t deviceRenderAreaCount;
	const $* pDeviceRenderAreas;
}]],
	mod.VkStructureType,
	mod.VkRect2D
)
ffi.metatype(
	mod.VkDeviceGroupRenderPassBeginInfo,
	{
		__tostring = function(s)
			return ("struct VkDeviceGroupRenderPassBeginInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.deviceMask,
				t.deviceRenderAreaCount,
				t.pDeviceRenderAreas
			)
		end,
	}
)
mod.VkDeviceGroupCommandBufferBeginInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t deviceMask;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDeviceGroupCommandBufferBeginInfo,
	{
		__tostring = function(s)
			return ("struct VkDeviceGroupCommandBufferBeginInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.deviceMask)
		end,
	}
)
mod.VkDeviceGroupSubmitInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t waitSemaphoreCount;
	const uint32_t* pWaitSemaphoreDeviceIndices;
	uint32_t commandBufferCount;
	const uint32_t* pCommandBufferDeviceMasks;
	uint32_t signalSemaphoreCount;
	const uint32_t* pSignalSemaphoreDeviceIndices;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDeviceGroupSubmitInfo,
	{
		__tostring = function(s)
			return ("struct VkDeviceGroupSubmitInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.waitSemaphoreCount,
				t.pWaitSemaphoreDeviceIndices,
				t.commandBufferCount,
				t.pCommandBufferDeviceMasks,
				t.signalSemaphoreCount,
				t.pSignalSemaphoreDeviceIndices
			)
		end,
	}
)
mod.VkDeviceGroupBindSparseInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t resourceDeviceIndex;
	uint32_t memoryDeviceIndex;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDeviceGroupBindSparseInfo,
	{
		__tostring = function(s)
			return ("struct VkDeviceGroupBindSparseInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.resourceDeviceIndex, t.memoryDeviceIndex)
		end,
	}
)
mod.VkBindBufferMemoryDeviceGroupInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t deviceIndexCount;
	const uint32_t* pDeviceIndices;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkBindBufferMemoryDeviceGroupInfo,
	{
		__tostring = function(s)
			return ("struct VkBindBufferMemoryDeviceGroupInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.deviceIndexCount, t.pDeviceIndices)
		end,
	}
)
mod.VkBindImageMemoryDeviceGroupInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t deviceIndexCount;
	const uint32_t* pDeviceIndices;
	uint32_t splitInstanceBindRegionCount;
	const $* pSplitInstanceBindRegions;
}]],
	mod.VkStructureType,
	mod.VkRect2D
)
ffi.metatype(
	mod.VkBindImageMemoryDeviceGroupInfo,
	{
		__tostring = function(s)
			return ("struct VkBindImageMemoryDeviceGroupInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.deviceIndexCount,
				t.pDeviceIndices,
				t.splitInstanceBindRegionCount,
				t.pSplitInstanceBindRegions
			)
		end,
	}
)
mod.VkPhysicalDeviceGroupProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t physicalDeviceCount;
	$ physicalDevices[32U];
	$ subsetAllocation;
}]],
	mod.VkStructureType,
	mod.VkPhysicalDevice,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceGroupProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceGroupProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.physicalDeviceCount,
				t.physicalDevices,
				t.subsetAllocation
			)
		end,
	}
)
mod.VkDeviceGroupDeviceCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t physicalDeviceCount;
	const $* pPhysicalDevices;
}]],
	mod.VkStructureType,
	mod.VkPhysicalDevice
)
ffi.metatype(
	mod.VkDeviceGroupDeviceCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkDeviceGroupDeviceCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.physicalDeviceCount, t.pPhysicalDevices)
		end,
	}
)
mod.VkBufferMemoryRequirementsInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ buffer;
}]],
	mod.VkStructureType,
	mod.VkBuffer
)
ffi.metatype(
	mod.VkBufferMemoryRequirementsInfo2,
	{
		__tostring = function(s)
			return ("struct VkBufferMemoryRequirementsInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.buffer)
		end,
	}
)
mod.VkImageMemoryRequirementsInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ image;
}]],
	mod.VkStructureType,
	mod.VkImage
)
ffi.metatype(
	mod.VkImageMemoryRequirementsInfo2,
	{
		__tostring = function(s)
			return ("struct VkImageMemoryRequirementsInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.image)
		end,
	}
)
mod.VkImageSparseMemoryRequirementsInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ image;
}]],
	mod.VkStructureType,
	mod.VkImage
)
ffi.metatype(
	mod.VkImageSparseMemoryRequirementsInfo2,
	{
		__tostring = function(s)
			return ("struct VkImageSparseMemoryRequirementsInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.image)
		end,
	}
)
mod.VkMemoryRequirements2 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ memoryRequirements;
}]],
	mod.VkStructureType,
	mod.VkMemoryRequirements
)
ffi.metatype(
	mod.VkMemoryRequirements2,
	{
		__tostring = function(s)
			return ("struct VkMemoryRequirements2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memoryRequirements)
		end,
	}
)
mod.VkSparseImageMemoryRequirements2 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ memoryRequirements;
}]],
	mod.VkStructureType,
	mod.VkSparseImageMemoryRequirements
)
ffi.metatype(
	mod.VkSparseImageMemoryRequirements2,
	{
		__tostring = function(s)
			return ("struct VkSparseImageMemoryRequirements2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memoryRequirements)
		end,
	}
)
mod.VkPhysicalDeviceFeatures2 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ features;
}]],
	mod.VkStructureType,
	mod.VkPhysicalDeviceFeatures
)
ffi.metatype(
	mod.VkPhysicalDeviceFeatures2,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFeatures2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.features)
		end,
	}
)
mod.VkPhysicalDeviceProperties2 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ properties;
}]],
	mod.VkStructureType,
	mod.VkPhysicalDeviceProperties
)
ffi.metatype(
	mod.VkPhysicalDeviceProperties2,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceProperties2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.properties)
		end,
	}
)
mod.VkFormatProperties2 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ formatProperties;
}]],
	mod.VkStructureType,
	mod.VkFormatProperties
)
ffi.metatype(
	mod.VkFormatProperties2,
	{
		__tostring = function(s)
			return ("struct VkFormatProperties2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.formatProperties)
		end,
	}
)
mod.VkImageFormatProperties2 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ imageFormatProperties;
}]],
	mod.VkStructureType,
	mod.VkImageFormatProperties
)
ffi.metatype(
	mod.VkImageFormatProperties2,
	{
		__tostring = function(s)
			return ("struct VkImageFormatProperties2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageFormatProperties)
		end,
	}
)
mod.VkPhysicalDeviceImageFormatInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ format;
	$ type;
	$ tiling;
	$ usage;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkImageType,
	mod.VkImageTiling,
	mod.VkImageUsageFlags,
	mod.VkImageCreateFlags
)
ffi.metatype(
	mod.VkPhysicalDeviceImageFormatInfo2,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageFormatInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.format, t.type, t.tiling, t.usage, t.flags)
		end,
	}
)
mod.VkQueueFamilyProperties2 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ queueFamilyProperties;
}]],
	mod.VkStructureType,
	mod.VkQueueFamilyProperties
)
ffi.metatype(
	mod.VkQueueFamilyProperties2,
	{
		__tostring = function(s)
			return ("struct VkQueueFamilyProperties2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.queueFamilyProperties)
		end,
	}
)
mod.VkPhysicalDeviceMemoryProperties2 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ memoryProperties;
}]],
	mod.VkStructureType,
	mod.VkPhysicalDeviceMemoryProperties
)
ffi.metatype(
	mod.VkPhysicalDeviceMemoryProperties2,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMemoryProperties2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memoryProperties)
		end,
	}
)
mod.VkSparseImageFormatProperties2 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ properties;
}]],
	mod.VkStructureType,
	mod.VkSparseImageFormatProperties
)
ffi.metatype(
	mod.VkSparseImageFormatProperties2,
	{
		__tostring = function(s)
			return ("struct VkSparseImageFormatProperties2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.properties)
		end,
	}
)
mod.VkPhysicalDeviceSparseImageFormatInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ format;
	$ type;
	$ samples;
	$ usage;
	$ tiling;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkImageType,
	mod.VkSampleCountFlagBits,
	mod.VkImageUsageFlags,
	mod.VkImageTiling
)
ffi.metatype(
	mod.VkPhysicalDeviceSparseImageFormatInfo2,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSparseImageFormatInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.format, t.type, t.samples, t.usage, t.tiling)
		end,
	}
)
mod.VkPhysicalDevicePointClippingProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pointClippingBehavior;
}]],
	mod.VkStructureType,
	mod.VkPointClippingBehavior
)
ffi.metatype(
	mod.VkPhysicalDevicePointClippingProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePointClippingProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pointClippingBehavior)
		end,
	}
)
mod.VkInputAttachmentAspectReference = ffi.typeof(
	[[struct {
	uint32_t subpass;
	uint32_t inputAttachmentIndex;
	$ aspectMask;
}]],
	mod.VkImageAspectFlags
)
ffi.metatype(
	mod.VkInputAttachmentAspectReference,
	{
		__tostring = function(s)
			return ("struct VkInputAttachmentAspectReference[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.subpass, t.inputAttachmentIndex, t.aspectMask)
		end,
	}
)
mod.VkRenderPassInputAttachmentAspectCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t aspectReferenceCount;
	const $* pAspectReferences;
}]],
	mod.VkStructureType,
	mod.VkInputAttachmentAspectReference
)
ffi.metatype(
	mod.VkRenderPassInputAttachmentAspectCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkRenderPassInputAttachmentAspectCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.aspectReferenceCount, t.pAspectReferences)
		end,
	}
)
mod.VkImageViewUsageCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ usage;
}]],
	mod.VkStructureType,
	mod.VkImageUsageFlags
)
ffi.metatype(
	mod.VkImageViewUsageCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkImageViewUsageCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.usage)
		end,
	}
)
mod.VkPipelineTessellationDomainOriginStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ domainOrigin;
}]],
	mod.VkStructureType,
	mod.VkTessellationDomainOrigin
)
ffi.metatype(
	mod.VkPipelineTessellationDomainOriginStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineTessellationDomainOriginStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.domainOrigin)
		end,
	}
)
mod.VkRenderPassMultiviewCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t subpassCount;
	const uint32_t* pViewMasks;
	uint32_t dependencyCount;
	const int32_t* pViewOffsets;
	uint32_t correlationMaskCount;
	const uint32_t* pCorrelationMasks;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkRenderPassMultiviewCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkRenderPassMultiviewCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.subpassCount,
				t.pViewMasks,
				t.dependencyCount,
				t.pViewOffsets,
				t.correlationMaskCount,
				t.pCorrelationMasks
			)
		end,
	}
)
mod.VkPhysicalDeviceMultiviewFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ multiview;
	$ multiviewGeometryShader;
	$ multiviewTessellationShader;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMultiviewFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMultiviewFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.multiview,
				t.multiviewGeometryShader,
				t.multiviewTessellationShader
			)
		end,
	}
)
mod.VkPhysicalDeviceMultiviewProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxMultiviewViewCount;
	uint32_t maxMultiviewInstanceIndex;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceMultiviewProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMultiviewProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxMultiviewViewCount, t.maxMultiviewInstanceIndex)
		end,
	}
)
mod.VkPhysicalDeviceVariablePointersFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ variablePointersStorageBuffer;
	$ variablePointers;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVariablePointersFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVariablePointersFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.variablePointersStorageBuffer, t.variablePointers)
		end,
	}
)
mod.VkPhysicalDeviceVariablePointerFeatures = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVariablePointersFeatures)
mod.VkPhysicalDeviceProtectedMemoryFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ protectedMemory;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceProtectedMemoryFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceProtectedMemoryFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.protectedMemory)
		end,
	}
)
mod.VkPhysicalDeviceProtectedMemoryProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ protectedNoFault;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceProtectedMemoryProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceProtectedMemoryProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.protectedNoFault)
		end,
	}
)
mod.VkDeviceQueueInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t queueFamilyIndex;
	uint32_t queueIndex;
}]],
	mod.VkStructureType,
	mod.VkDeviceQueueCreateFlags
)
ffi.metatype(
	mod.VkDeviceQueueInfo2,
	{
		__tostring = function(s)
			return ("struct VkDeviceQueueInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.queueFamilyIndex, t.queueIndex)
		end,
	}
)
mod.VkProtectedSubmitInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ protectedSubmit;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkProtectedSubmitInfo,
	{
		__tostring = function(s)
			return ("struct VkProtectedSubmitInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.protectedSubmit)
		end,
	}
)
mod.VkSamplerYcbcrConversionCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ format;
	$ ycbcrModel;
	$ ycbcrRange;
	$ components;
	$ xChromaOffset;
	$ yChromaOffset;
	$ chromaFilter;
	$ forceExplicitReconstruction;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkSamplerYcbcrModelConversion,
	mod.VkSamplerYcbcrRange,
	mod.VkComponentMapping,
	mod.VkChromaLocation,
	mod.VkChromaLocation,
	mod.VkFilter,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSamplerYcbcrConversionCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkSamplerYcbcrConversionCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.format,
				t.ycbcrModel,
				t.ycbcrRange,
				t.components,
				t.xChromaOffset,
				t.yChromaOffset,
				t.chromaFilter,
				t.forceExplicitReconstruction
			)
		end,
	}
)
mod.VkSamplerYcbcrConversionInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ conversion;
}]],
	mod.VkStructureType,
	mod.VkSamplerYcbcrConversion
)
ffi.metatype(
	mod.VkSamplerYcbcrConversionInfo,
	{
		__tostring = function(s)
			return ("struct VkSamplerYcbcrConversionInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.conversion)
		end,
	}
)
mod.VkBindImagePlaneMemoryInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ planeAspect;
}]],
	mod.VkStructureType,
	mod.VkImageAspectFlagBits
)
ffi.metatype(
	mod.VkBindImagePlaneMemoryInfo,
	{
		__tostring = function(s)
			return ("struct VkBindImagePlaneMemoryInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.planeAspect)
		end,
	}
)
mod.VkImagePlaneMemoryRequirementsInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ planeAspect;
}]],
	mod.VkStructureType,
	mod.VkImageAspectFlagBits
)
ffi.metatype(
	mod.VkImagePlaneMemoryRequirementsInfo,
	{
		__tostring = function(s)
			return ("struct VkImagePlaneMemoryRequirementsInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.planeAspect)
		end,
	}
)
mod.VkPhysicalDeviceSamplerYcbcrConversionFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ samplerYcbcrConversion;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSamplerYcbcrConversionFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSamplerYcbcrConversionFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.samplerYcbcrConversion)
		end,
	}
)
mod.VkSamplerYcbcrConversionImageFormatProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t combinedImageSamplerDescriptorCount;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkSamplerYcbcrConversionImageFormatProperties,
	{
		__tostring = function(s)
			return ("struct VkSamplerYcbcrConversionImageFormatProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.combinedImageSamplerDescriptorCount)
		end,
	}
)
mod.VkDescriptorUpdateTemplateEntry = ffi.typeof(
	[[struct {
	uint32_t dstBinding;
	uint32_t dstArrayElement;
	uint32_t descriptorCount;
	$ descriptorType;
	size_t offset;
	size_t stride;
}]],
	mod.VkDescriptorType
)
ffi.metatype(
	mod.VkDescriptorUpdateTemplateEntry,
	{
		__tostring = function(s)
			return ("struct VkDescriptorUpdateTemplateEntry[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.dstBinding,
				t.dstArrayElement,
				t.descriptorCount,
				t.descriptorType,
				t.offset,
				t.stride
			)
		end,
	}
)
mod.VkDescriptorUpdateTemplateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t descriptorUpdateEntryCount;
	const $* pDescriptorUpdateEntries;
	$ templateType;
	$ descriptorSetLayout;
	$ pipelineBindPoint;
	$ pipelineLayout;
	uint32_t set;
}]],
	mod.VkStructureType,
	mod.VkDescriptorUpdateTemplateCreateFlags,
	mod.VkDescriptorUpdateTemplateEntry,
	mod.VkDescriptorUpdateTemplateType,
	mod.VkDescriptorSetLayout,
	mod.VkPipelineBindPoint,
	mod.VkPipelineLayout
)
ffi.metatype(
	mod.VkDescriptorUpdateTemplateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkDescriptorUpdateTemplateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.descriptorUpdateEntryCount,
				t.pDescriptorUpdateEntries,
				t.templateType,
				t.descriptorSetLayout,
				t.pipelineBindPoint,
				t.pipelineLayout,
				t.set
			)
		end,
	}
)
mod.VkExternalMemoryProperties = ffi.typeof(
	[[struct {
	$ externalMemoryFeatures;
	$ exportFromImportedHandleTypes;
	$ compatibleHandleTypes;
}]],
	mod.VkExternalMemoryFeatureFlags,
	mod.VkExternalMemoryHandleTypeFlags,
	mod.VkExternalMemoryHandleTypeFlags
)
ffi.metatype(
	mod.VkExternalMemoryProperties,
	{
		__tostring = function(s)
			return ("struct VkExternalMemoryProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.externalMemoryFeatures,
				t.exportFromImportedHandleTypes,
				t.compatibleHandleTypes
			)
		end,
	}
)
mod.VkPhysicalDeviceExternalImageFormatInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleType;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryHandleTypeFlagBits
)
ffi.metatype(
	mod.VkPhysicalDeviceExternalImageFormatInfo,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExternalImageFormatInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleType)
		end,
	}
)
mod.VkExternalImageFormatProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ externalMemoryProperties;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryProperties
)
ffi.metatype(
	mod.VkExternalImageFormatProperties,
	{
		__tostring = function(s)
			return ("struct VkExternalImageFormatProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.externalMemoryProperties)
		end,
	}
)
mod.VkPhysicalDeviceExternalBufferInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ usage;
	$ handleType;
}]],
	mod.VkStructureType,
	mod.VkBufferCreateFlags,
	mod.VkBufferUsageFlags,
	mod.VkExternalMemoryHandleTypeFlagBits
)
ffi.metatype(
	mod.VkPhysicalDeviceExternalBufferInfo,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExternalBufferInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.usage, t.handleType)
		end,
	}
)
mod.VkExternalBufferProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ externalMemoryProperties;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryProperties
)
ffi.metatype(
	mod.VkExternalBufferProperties,
	{
		__tostring = function(s)
			return ("struct VkExternalBufferProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.externalMemoryProperties)
		end,
	}
)
mod.VkPhysicalDeviceIDProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint8_t deviceUUID[16U];
	uint8_t driverUUID[16U];
	uint8_t deviceLUID[8U];
	uint32_t deviceNodeMask;
	$ deviceLUIDValid;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceIDProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceIDProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.deviceUUID,
				t.driverUUID,
				t.deviceLUID,
				t.deviceNodeMask,
				t.deviceLUIDValid
			)
		end,
	}
)
mod.VkExternalMemoryImageCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryHandleTypeFlags
)
ffi.metatype(
	mod.VkExternalMemoryImageCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkExternalMemoryImageCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleTypes)
		end,
	}
)
mod.VkExternalMemoryBufferCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryHandleTypeFlags
)
ffi.metatype(
	mod.VkExternalMemoryBufferCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkExternalMemoryBufferCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleTypes)
		end,
	}
)
mod.VkExportMemoryAllocateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryHandleTypeFlags
)
ffi.metatype(
	mod.VkExportMemoryAllocateInfo,
	{
		__tostring = function(s)
			return ("struct VkExportMemoryAllocateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleTypes)
		end,
	}
)
mod.VkPhysicalDeviceExternalFenceInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleType;
}]],
	mod.VkStructureType,
	mod.VkExternalFenceHandleTypeFlagBits
)
ffi.metatype(
	mod.VkPhysicalDeviceExternalFenceInfo,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExternalFenceInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleType)
		end,
	}
)
mod.VkExternalFenceProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ exportFromImportedHandleTypes;
	$ compatibleHandleTypes;
	$ externalFenceFeatures;
}]],
	mod.VkStructureType,
	mod.VkExternalFenceHandleTypeFlags,
	mod.VkExternalFenceHandleTypeFlags,
	mod.VkExternalFenceFeatureFlags
)
ffi.metatype(
	mod.VkExternalFenceProperties,
	{
		__tostring = function(s)
			return ("struct VkExternalFenceProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.exportFromImportedHandleTypes,
				t.compatibleHandleTypes,
				t.externalFenceFeatures
			)
		end,
	}
)
mod.VkExportFenceCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]],
	mod.VkStructureType,
	mod.VkExternalFenceHandleTypeFlags
)
ffi.metatype(
	mod.VkExportFenceCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkExportFenceCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleTypes)
		end,
	}
)
mod.VkExportSemaphoreCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]],
	mod.VkStructureType,
	mod.VkExternalSemaphoreHandleTypeFlags
)
ffi.metatype(
	mod.VkExportSemaphoreCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkExportSemaphoreCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleTypes)
		end,
	}
)
mod.VkPhysicalDeviceExternalSemaphoreInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleType;
}]],
	mod.VkStructureType,
	mod.VkExternalSemaphoreHandleTypeFlagBits
)
ffi.metatype(
	mod.VkPhysicalDeviceExternalSemaphoreInfo,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExternalSemaphoreInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleType)
		end,
	}
)
mod.VkExternalSemaphoreProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ exportFromImportedHandleTypes;
	$ compatibleHandleTypes;
	$ externalSemaphoreFeatures;
}]],
	mod.VkStructureType,
	mod.VkExternalSemaphoreHandleTypeFlags,
	mod.VkExternalSemaphoreHandleTypeFlags,
	mod.VkExternalSemaphoreFeatureFlags
)
ffi.metatype(
	mod.VkExternalSemaphoreProperties,
	{
		__tostring = function(s)
			return ("struct VkExternalSemaphoreProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.exportFromImportedHandleTypes,
				t.compatibleHandleTypes,
				t.externalSemaphoreFeatures
			)
		end,
	}
)
mod.VkPhysicalDeviceMaintenance3Properties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxPerSetDescriptors;
	$ maxMemoryAllocationSize;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance3Properties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance3Properties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxPerSetDescriptors, t.maxMemoryAllocationSize)
		end,
	}
)
mod.VkDescriptorSetLayoutSupport = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ supported;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkDescriptorSetLayoutSupport,
	{
		__tostring = function(s)
			return ("struct VkDescriptorSetLayoutSupport[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.supported)
		end,
	}
)
mod.VkPhysicalDeviceShaderDrawParametersFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderDrawParameters;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderDrawParametersFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderDrawParametersFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderDrawParameters)
		end,
	}
)
mod.VkPhysicalDeviceShaderDrawParameterFeatures = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderDrawParametersFeatures)
mod.PFN_vkEnumerateInstanceVersion = ffi.typeof([[$ (*)(uint32_t*)]], mod.VkResult)
mod.PFN_vkBindBufferMemory2 = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindBufferMemoryInfo
)
mod.PFN_vkBindImageMemory2 = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindImageMemoryInfo
)
mod.PFN_vkGetDeviceGroupPeerMemoryFeatures = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , uint32_t , $*)]],
	mod.VkDevice,
	mod.VkPeerMemoryFeatureFlags
)
mod.PFN_vkCmdSetDeviceMask = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDispatchBase = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t )]],
	mod.VkCommandBuffer
)
mod.PFN_vkEnumeratePhysicalDeviceGroups = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkPhysicalDeviceGroupProperties
)
mod.PFN_vkGetImageMemoryRequirements2 = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkImageMemoryRequirementsInfo2,
	mod.VkMemoryRequirements2
)
mod.PFN_vkGetBufferMemoryRequirements2 = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkBufferMemoryRequirementsInfo2,
	mod.VkMemoryRequirements2
)
mod.PFN_vkGetImageSparseMemoryRequirements2 = ffi.typeof(
	[[void (*)($ , const $*, uint32_t*, $*)]],
	mod.VkDevice,
	mod.VkImageSparseMemoryRequirementsInfo2,
	mod.VkSparseImageMemoryRequirements2
)
mod.PFN_vkGetPhysicalDeviceFeatures2 = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceFeatures2)
mod.PFN_vkGetPhysicalDeviceProperties2 = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceProperties2)
mod.PFN_vkGetPhysicalDeviceFormatProperties2 = ffi.typeof(
	[[void (*)($ , $ , $*)]],
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkFormatProperties2
)
mod.PFN_vkGetPhysicalDeviceImageFormatProperties2 = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceImageFormatInfo2,
	mod.VkImageFormatProperties2
)
mod.PFN_vkGetPhysicalDeviceQueueFamilyProperties2 = ffi.typeof(
	[[void (*)($ , uint32_t*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkQueueFamilyProperties2
)
mod.PFN_vkGetPhysicalDeviceMemoryProperties2 = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceMemoryProperties2)
mod.PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 = ffi.typeof(
	[[void (*)($ , const $*, uint32_t*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceSparseImageFormatInfo2,
	mod.VkSparseImageFormatProperties2
)
mod.PFN_vkTrimCommandPool = ffi.typeof(
	[[void (*)($ , $ , $ )]],
	mod.VkDevice,
	mod.VkCommandPool,
	mod.VkCommandPoolTrimFlags
)
mod.PFN_vkGetDeviceQueue2 = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDeviceQueueInfo2, mod.VkQueue)
mod.PFN_vkCreateSamplerYcbcrConversion = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSamplerYcbcrConversionCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkSamplerYcbcrConversion
)
mod.PFN_vkDestroySamplerYcbcrConversion = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkSamplerYcbcrConversion,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreateDescriptorUpdateTemplate = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorUpdateTemplateCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDescriptorUpdateTemplate
)
mod.PFN_vkDestroyDescriptorUpdateTemplate = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkDescriptorUpdateTemplate,
	mod.VkAllocationCallbacks
)
mod.PFN_vkUpdateDescriptorSetWithTemplate = ffi.typeof(
	[[void (*)($ , $ , $ , const void*)]],
	mod.VkDevice,
	mod.VkDescriptorSet,
	mod.VkDescriptorUpdateTemplate
)
mod.PFN_vkGetPhysicalDeviceExternalBufferProperties = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalBufferInfo,
	mod.VkExternalBufferProperties
)
mod.PFN_vkGetPhysicalDeviceExternalFenceProperties = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalFenceInfo,
	mod.VkExternalFenceProperties
)
mod.PFN_vkGetPhysicalDeviceExternalSemaphoreProperties = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalSemaphoreInfo,
	mod.VkExternalSemaphoreProperties
)
mod.PFN_vkGetDescriptorSetLayoutSupport = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkDescriptorSetLayoutCreateInfo,
	mod.VkDescriptorSetLayoutSupport
)
ffi.cdef([[$  vkEnumerateInstanceVersion(uint32_t*);]], mod.VkResult)
ffi.cdef(
	[[$  vkBindBufferMemory2($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindBufferMemoryInfo
)
ffi.cdef(
	[[$  vkBindImageMemory2($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindImageMemoryInfo
)
ffi.cdef(
	[[void  vkGetDeviceGroupPeerMemoryFeatures($ , uint32_t , uint32_t , uint32_t , $*);]],
	mod.VkDevice,
	mod.VkPeerMemoryFeatureFlags
)
ffi.cdef([[void  vkCmdSetDeviceMask($ , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdDispatchBase($ , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t );]],
	mod.VkCommandBuffer
)
ffi.cdef(
	[[$  vkEnumeratePhysicalDeviceGroups($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkPhysicalDeviceGroupProperties
)
ffi.cdef(
	[[void  vkGetImageMemoryRequirements2($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkImageMemoryRequirementsInfo2,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkGetBufferMemoryRequirements2($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkBufferMemoryRequirementsInfo2,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkGetImageSparseMemoryRequirements2($ , const $*, uint32_t*, $*);]],
	mod.VkDevice,
	mod.VkImageSparseMemoryRequirementsInfo2,
	mod.VkSparseImageMemoryRequirements2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceFeatures2($ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceFeatures2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceProperties2($ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceProperties2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceFormatProperties2($ , $ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkFormatProperties2
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceImageFormatProperties2($ , const $*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceImageFormatInfo2,
	mod.VkImageFormatProperties2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceQueueFamilyProperties2($ , uint32_t*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkQueueFamilyProperties2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceMemoryProperties2($ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceMemoryProperties2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceSparseImageFormatProperties2($ , const $*, uint32_t*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceSparseImageFormatInfo2,
	mod.VkSparseImageFormatProperties2
)
ffi.cdef(
	[[void  vkTrimCommandPool($ , $ , $ );]],
	mod.VkDevice,
	mod.VkCommandPool,
	mod.VkCommandPoolTrimFlags
)
ffi.cdef(
	[[void  vkGetDeviceQueue2($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDeviceQueueInfo2,
	mod.VkQueue
)
ffi.cdef(
	[[$  vkCreateSamplerYcbcrConversion($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSamplerYcbcrConversionCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkSamplerYcbcrConversion
)
ffi.cdef(
	[[void  vkDestroySamplerYcbcrConversion($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkSamplerYcbcrConversion,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateDescriptorUpdateTemplate($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorUpdateTemplateCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDescriptorUpdateTemplate
)
ffi.cdef(
	[[void  vkDestroyDescriptorUpdateTemplate($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkDescriptorUpdateTemplate,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkUpdateDescriptorSetWithTemplate($ , $ , $ , const void*);]],
	mod.VkDevice,
	mod.VkDescriptorSet,
	mod.VkDescriptorUpdateTemplate
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceExternalBufferProperties($ , const $*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalBufferInfo,
	mod.VkExternalBufferProperties
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceExternalFenceProperties($ , const $*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalFenceInfo,
	mod.VkExternalFenceProperties
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceExternalSemaphoreProperties($ , const $*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalSemaphoreInfo,
	mod.VkExternalSemaphoreProperties
)
ffi.cdef(
	[[void  vkGetDescriptorSetLayoutSupport($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDescriptorSetLayoutCreateInfo,
	mod.VkDescriptorSetLayoutSupport
)
mod.VkDriverId = ffi.typeof([[enum {
	VK_DRIVER_ID_AMD_PROPRIETARY = 1,
	VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
	VK_DRIVER_ID_MESA_RADV = 3,
	VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
	VK_DRIVER_ID_ARM_PROPRIETARY = 9,
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
	VK_DRIVER_ID_GGP_PROPRIETARY = 11,
	VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
	VK_DRIVER_ID_MESA_LLVMPIPE = 13,
	VK_DRIVER_ID_MOLTENVK = 14,
	VK_DRIVER_ID_COREAVI_PROPRIETARY = 15,
	VK_DRIVER_ID_JUICE_PROPRIETARY = 16,
	VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17,
	VK_DRIVER_ID_MESA_TURNIP = 18,
	VK_DRIVER_ID_MESA_V3DV = 19,
	VK_DRIVER_ID_MESA_PANVK = 20,
	VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21,
	VK_DRIVER_ID_MESA_VENUS = 22,
	VK_DRIVER_ID_MESA_DOZEN = 23,
	VK_DRIVER_ID_MESA_NVK = 24,
	VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25,
	VK_DRIVER_ID_MESA_HONEYKRISP = 26,
	VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN = 27,
	VK_DRIVER_ID_AMD_PROPRIETARY_KHR = VK_DRIVER_ID_AMD_PROPRIETARY,
	VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR = VK_DRIVER_ID_AMD_OPEN_SOURCE,
	VK_DRIVER_ID_MESA_RADV_KHR = VK_DRIVER_ID_MESA_RADV,
	VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR = VK_DRIVER_ID_NVIDIA_PROPRIETARY,
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
	VK_DRIVER_ID_ARM_PROPRIETARY_KHR = VK_DRIVER_ID_ARM_PROPRIETARY,
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
	VK_DRIVER_ID_GGP_PROPRIETARY_KHR = VK_DRIVER_ID_GGP_PROPRIETARY,
	VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR = VK_DRIVER_ID_BROADCOM_PROPRIETARY,
	VK_DRIVER_ID_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkShaderFloatControlsIndependence = ffi.typeof([[enum {
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerReductionMode = ffi.typeof([[enum {
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
	VK_SAMPLER_REDUCTION_MODE_MIN = 1,
	VK_SAMPLER_REDUCTION_MODE_MAX = 2,
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM = 1000521000,
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
	VK_SAMPLER_REDUCTION_MODE_MIN_EXT = VK_SAMPLER_REDUCTION_MODE_MIN,
	VK_SAMPLER_REDUCTION_MODE_MAX_EXT = VK_SAMPLER_REDUCTION_MODE_MAX,
	VK_SAMPLER_REDUCTION_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSemaphoreType = ffi.typeof([[enum {
	VK_SEMAPHORE_TYPE_BINARY = 0,
	VK_SEMAPHORE_TYPE_TIMELINE = 1,
	VK_SEMAPHORE_TYPE_BINARY_KHR = VK_SEMAPHORE_TYPE_BINARY,
	VK_SEMAPHORE_TYPE_TIMELINE_KHR = VK_SEMAPHORE_TYPE_TIMELINE,
	VK_SEMAPHORE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkResolveModeFlagBits = ffi.typeof([[enum {
	VK_RESOLVE_MODE_NONE = 0,
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 0x00000001,
	VK_RESOLVE_MODE_AVERAGE_BIT = 0x00000002,
	VK_RESOLVE_MODE_MIN_BIT = 0x00000004,
	VK_RESOLVE_MODE_MAX_BIT = 0x00000008,
	VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID = 0x00000010,
	VK_RESOLVE_MODE_NONE_KHR = VK_RESOLVE_MODE_NONE,
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT,
	VK_RESOLVE_MODE_AVERAGE_BIT_KHR = VK_RESOLVE_MODE_AVERAGE_BIT,
	VK_RESOLVE_MODE_MIN_BIT_KHR = VK_RESOLVE_MODE_MIN_BIT,
	VK_RESOLVE_MODE_MAX_BIT_KHR = VK_RESOLVE_MODE_MAX_BIT,
	VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID = VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID,
	VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkResolveModeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDescriptorBindingFlagBits = ffi.typeof([[enum {
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 0x00000001,
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 0x00000002,
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 0x00000004,
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 0x00000008,
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT,
	VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDescriptorBindingFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSemaphoreWaitFlagBits = ffi.typeof([[enum {
	VK_SEMAPHORE_WAIT_ANY_BIT = 0x00000001,
	VK_SEMAPHORE_WAIT_ANY_BIT_KHR = VK_SEMAPHORE_WAIT_ANY_BIT,
	VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSemaphoreWaitFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceVulkan11Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ storageBuffer16BitAccess;
	$ uniformAndStorageBuffer16BitAccess;
	$ storagePushConstant16;
	$ storageInputOutput16;
	$ multiview;
	$ multiviewGeometryShader;
	$ multiviewTessellationShader;
	$ variablePointersStorageBuffer;
	$ variablePointers;
	$ protectedMemory;
	$ samplerYcbcrConversion;
	$ shaderDrawParameters;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVulkan11Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVulkan11Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.storageBuffer16BitAccess,
				t.uniformAndStorageBuffer16BitAccess,
				t.storagePushConstant16,
				t.storageInputOutput16,
				t.multiview,
				t.multiviewGeometryShader,
				t.multiviewTessellationShader,
				t.variablePointersStorageBuffer,
				t.variablePointers,
				t.protectedMemory,
				t.samplerYcbcrConversion,
				t.shaderDrawParameters
			)
		end,
	}
)
mod.VkPhysicalDeviceVulkan11Properties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint8_t deviceUUID[16U];
	uint8_t driverUUID[16U];
	uint8_t deviceLUID[8U];
	uint32_t deviceNodeMask;
	$ deviceLUIDValid;
	uint32_t subgroupSize;
	$ subgroupSupportedStages;
	$ subgroupSupportedOperations;
	$ subgroupQuadOperationsInAllStages;
	$ pointClippingBehavior;
	uint32_t maxMultiviewViewCount;
	uint32_t maxMultiviewInstanceIndex;
	$ protectedNoFault;
	uint32_t maxPerSetDescriptors;
	$ maxMemoryAllocationSize;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkShaderStageFlags,
	mod.VkSubgroupFeatureFlags,
	mod.VkBool32,
	mod.VkPointClippingBehavior,
	mod.VkBool32,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkPhysicalDeviceVulkan11Properties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVulkan11Properties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.deviceUUID,
				t.driverUUID,
				t.deviceLUID,
				t.deviceNodeMask,
				t.deviceLUIDValid,
				t.subgroupSize,
				t.subgroupSupportedStages,
				t.subgroupSupportedOperations,
				t.subgroupQuadOperationsInAllStages,
				t.pointClippingBehavior,
				t.maxMultiviewViewCount,
				t.maxMultiviewInstanceIndex,
				t.protectedNoFault,
				t.maxPerSetDescriptors,
				t.maxMemoryAllocationSize
			)
		end,
	}
)
mod.VkPhysicalDeviceVulkan12Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ samplerMirrorClampToEdge;
	$ drawIndirectCount;
	$ storageBuffer8BitAccess;
	$ uniformAndStorageBuffer8BitAccess;
	$ storagePushConstant8;
	$ shaderBufferInt64Atomics;
	$ shaderSharedInt64Atomics;
	$ shaderFloat16;
	$ shaderInt8;
	$ descriptorIndexing;
	$ shaderInputAttachmentArrayDynamicIndexing;
	$ shaderUniformTexelBufferArrayDynamicIndexing;
	$ shaderStorageTexelBufferArrayDynamicIndexing;
	$ shaderUniformBufferArrayNonUniformIndexing;
	$ shaderSampledImageArrayNonUniformIndexing;
	$ shaderStorageBufferArrayNonUniformIndexing;
	$ shaderStorageImageArrayNonUniformIndexing;
	$ shaderInputAttachmentArrayNonUniformIndexing;
	$ shaderUniformTexelBufferArrayNonUniformIndexing;
	$ shaderStorageTexelBufferArrayNonUniformIndexing;
	$ descriptorBindingUniformBufferUpdateAfterBind;
	$ descriptorBindingSampledImageUpdateAfterBind;
	$ descriptorBindingStorageImageUpdateAfterBind;
	$ descriptorBindingStorageBufferUpdateAfterBind;
	$ descriptorBindingUniformTexelBufferUpdateAfterBind;
	$ descriptorBindingStorageTexelBufferUpdateAfterBind;
	$ descriptorBindingUpdateUnusedWhilePending;
	$ descriptorBindingPartiallyBound;
	$ descriptorBindingVariableDescriptorCount;
	$ runtimeDescriptorArray;
	$ samplerFilterMinmax;
	$ scalarBlockLayout;
	$ imagelessFramebuffer;
	$ uniformBufferStandardLayout;
	$ shaderSubgroupExtendedTypes;
	$ separateDepthStencilLayouts;
	$ hostQueryReset;
	$ timelineSemaphore;
	$ bufferDeviceAddress;
	$ bufferDeviceAddressCaptureReplay;
	$ bufferDeviceAddressMultiDevice;
	$ vulkanMemoryModel;
	$ vulkanMemoryModelDeviceScope;
	$ vulkanMemoryModelAvailabilityVisibilityChains;
	$ shaderOutputViewportIndex;
	$ shaderOutputLayer;
	$ subgroupBroadcastDynamicId;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVulkan12Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVulkan12Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.samplerMirrorClampToEdge,
				t.drawIndirectCount,
				t.storageBuffer8BitAccess,
				t.uniformAndStorageBuffer8BitAccess,
				t.storagePushConstant8,
				t.shaderBufferInt64Atomics,
				t.shaderSharedInt64Atomics,
				t.shaderFloat16,
				t.shaderInt8,
				t.descriptorIndexing,
				t.shaderInputAttachmentArrayDynamicIndexing,
				t.shaderUniformTexelBufferArrayDynamicIndexing,
				t.shaderStorageTexelBufferArrayDynamicIndexing,
				t.shaderUniformBufferArrayNonUniformIndexing,
				t.shaderSampledImageArrayNonUniformIndexing,
				t.shaderStorageBufferArrayNonUniformIndexing,
				t.shaderStorageImageArrayNonUniformIndexing,
				t.shaderInputAttachmentArrayNonUniformIndexing,
				t.shaderUniformTexelBufferArrayNonUniformIndexing,
				t.shaderStorageTexelBufferArrayNonUniformIndexing,
				t.descriptorBindingUniformBufferUpdateAfterBind,
				t.descriptorBindingSampledImageUpdateAfterBind,
				t.descriptorBindingStorageImageUpdateAfterBind,
				t.descriptorBindingStorageBufferUpdateAfterBind,
				t.descriptorBindingUniformTexelBufferUpdateAfterBind,
				t.descriptorBindingStorageTexelBufferUpdateAfterBind,
				t.descriptorBindingUpdateUnusedWhilePending,
				t.descriptorBindingPartiallyBound,
				t.descriptorBindingVariableDescriptorCount,
				t.runtimeDescriptorArray,
				t.samplerFilterMinmax,
				t.scalarBlockLayout,
				t.imagelessFramebuffer,
				t.uniformBufferStandardLayout,
				t.shaderSubgroupExtendedTypes,
				t.separateDepthStencilLayouts,
				t.hostQueryReset,
				t.timelineSemaphore,
				t.bufferDeviceAddress,
				t.bufferDeviceAddressCaptureReplay,
				t.bufferDeviceAddressMultiDevice,
				t.vulkanMemoryModel,
				t.vulkanMemoryModelDeviceScope,
				t.vulkanMemoryModelAvailabilityVisibilityChains,
				t.shaderOutputViewportIndex,
				t.shaderOutputLayer,
				t.subgroupBroadcastDynamicId
			)
		end,
	}
)
mod.VkConformanceVersion = ffi.typeof([[struct {
	uint8_t major;
	uint8_t minor;
	uint8_t subminor;
	uint8_t patch;
}]])
ffi.metatype(
	mod.VkConformanceVersion,
	{
		__tostring = function(s)
			return ("struct VkConformanceVersion[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.major, t.minor, t.subminor, t.patch)
		end,
	}
)
mod.VkPhysicalDeviceVulkan12Properties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ driverID;
	char driverName[256U];
	char driverInfo[256U];
	$ conformanceVersion;
	$ denormBehaviorIndependence;
	$ roundingModeIndependence;
	$ shaderSignedZeroInfNanPreserveFloat16;
	$ shaderSignedZeroInfNanPreserveFloat32;
	$ shaderSignedZeroInfNanPreserveFloat64;
	$ shaderDenormPreserveFloat16;
	$ shaderDenormPreserveFloat32;
	$ shaderDenormPreserveFloat64;
	$ shaderDenormFlushToZeroFloat16;
	$ shaderDenormFlushToZeroFloat32;
	$ shaderDenormFlushToZeroFloat64;
	$ shaderRoundingModeRTEFloat16;
	$ shaderRoundingModeRTEFloat32;
	$ shaderRoundingModeRTEFloat64;
	$ shaderRoundingModeRTZFloat16;
	$ shaderRoundingModeRTZFloat32;
	$ shaderRoundingModeRTZFloat64;
	uint32_t maxUpdateAfterBindDescriptorsInAllPools;
	$ shaderUniformBufferArrayNonUniformIndexingNative;
	$ shaderSampledImageArrayNonUniformIndexingNative;
	$ shaderStorageBufferArrayNonUniformIndexingNative;
	$ shaderStorageImageArrayNonUniformIndexingNative;
	$ shaderInputAttachmentArrayNonUniformIndexingNative;
	$ robustBufferAccessUpdateAfterBind;
	$ quadDivergentImplicitLod;
	uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
	uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
	uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
	uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
	uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
	uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
	uint32_t maxPerStageUpdateAfterBindResources;
	uint32_t maxDescriptorSetUpdateAfterBindSamplers;
	uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
	uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
	uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
	uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
	uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
	$ supportedDepthResolveModes;
	$ supportedStencilResolveModes;
	$ independentResolveNone;
	$ independentResolve;
	$ filterMinmaxSingleComponentFormats;
	$ filterMinmaxImageComponentMapping;
	uint64_t maxTimelineSemaphoreValueDifference;
	$ framebufferIntegerColorSampleCounts;
}]],
	mod.VkStructureType,
	mod.VkDriverId,
	mod.VkConformanceVersion,
	mod.VkShaderFloatControlsIndependence,
	mod.VkShaderFloatControlsIndependence,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkResolveModeFlags,
	mod.VkResolveModeFlags,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkSampleCountFlags
)
ffi.metatype(
	mod.VkPhysicalDeviceVulkan12Properties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVulkan12Properties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.driverID,
				t.driverName,
				t.driverInfo,
				t.conformanceVersion,
				t.denormBehaviorIndependence,
				t.roundingModeIndependence,
				t.shaderSignedZeroInfNanPreserveFloat16,
				t.shaderSignedZeroInfNanPreserveFloat32,
				t.shaderSignedZeroInfNanPreserveFloat64,
				t.shaderDenormPreserveFloat16,
				t.shaderDenormPreserveFloat32,
				t.shaderDenormPreserveFloat64,
				t.shaderDenormFlushToZeroFloat16,
				t.shaderDenormFlushToZeroFloat32,
				t.shaderDenormFlushToZeroFloat64,
				t.shaderRoundingModeRTEFloat16,
				t.shaderRoundingModeRTEFloat32,
				t.shaderRoundingModeRTEFloat64,
				t.shaderRoundingModeRTZFloat16,
				t.shaderRoundingModeRTZFloat32,
				t.shaderRoundingModeRTZFloat64,
				t.maxUpdateAfterBindDescriptorsInAllPools,
				t.shaderUniformBufferArrayNonUniformIndexingNative,
				t.shaderSampledImageArrayNonUniformIndexingNative,
				t.shaderStorageBufferArrayNonUniformIndexingNative,
				t.shaderStorageImageArrayNonUniformIndexingNative,
				t.shaderInputAttachmentArrayNonUniformIndexingNative,
				t.robustBufferAccessUpdateAfterBind,
				t.quadDivergentImplicitLod,
				t.maxPerStageDescriptorUpdateAfterBindSamplers,
				t.maxPerStageDescriptorUpdateAfterBindUniformBuffers,
				t.maxPerStageDescriptorUpdateAfterBindStorageBuffers,
				t.maxPerStageDescriptorUpdateAfterBindSampledImages,
				t.maxPerStageDescriptorUpdateAfterBindStorageImages,
				t.maxPerStageDescriptorUpdateAfterBindInputAttachments,
				t.maxPerStageUpdateAfterBindResources,
				t.maxDescriptorSetUpdateAfterBindSamplers,
				t.maxDescriptorSetUpdateAfterBindUniformBuffers,
				t.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic,
				t.maxDescriptorSetUpdateAfterBindStorageBuffers,
				t.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic,
				t.maxDescriptorSetUpdateAfterBindSampledImages,
				t.maxDescriptorSetUpdateAfterBindStorageImages,
				t.maxDescriptorSetUpdateAfterBindInputAttachments,
				t.supportedDepthResolveModes,
				t.supportedStencilResolveModes,
				t.independentResolveNone,
				t.independentResolve,
				t.filterMinmaxSingleComponentFormats,
				t.filterMinmaxImageComponentMapping,
				t.maxTimelineSemaphoreValueDifference,
				t.framebufferIntegerColorSampleCounts
			)
		end,
	}
)
mod.VkImageFormatListCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t viewFormatCount;
	const $* pViewFormats;
}]],
	mod.VkStructureType,
	mod.VkFormat
)
ffi.metatype(
	mod.VkImageFormatListCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkImageFormatListCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.viewFormatCount, t.pViewFormats)
		end,
	}
)
mod.VkAttachmentDescription2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ format;
	$ samples;
	$ loadOp;
	$ storeOp;
	$ stencilLoadOp;
	$ stencilStoreOp;
	$ initialLayout;
	$ finalLayout;
}]],
	mod.VkStructureType,
	mod.VkAttachmentDescriptionFlags,
	mod.VkFormat,
	mod.VkSampleCountFlagBits,
	mod.VkAttachmentLoadOp,
	mod.VkAttachmentStoreOp,
	mod.VkAttachmentLoadOp,
	mod.VkAttachmentStoreOp,
	mod.VkImageLayout,
	mod.VkImageLayout
)
ffi.metatype(
	mod.VkAttachmentDescription2,
	{
		__tostring = function(s)
			return ("struct VkAttachmentDescription2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.format,
				t.samples,
				t.loadOp,
				t.storeOp,
				t.stencilLoadOp,
				t.stencilStoreOp,
				t.initialLayout,
				t.finalLayout
			)
		end,
	}
)
mod.VkAttachmentReference2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t attachment;
	$ layout;
	$ aspectMask;
}]],
	mod.VkStructureType,
	mod.VkImageLayout,
	mod.VkImageAspectFlags
)
ffi.metatype(
	mod.VkAttachmentReference2,
	{
		__tostring = function(s)
			return ("struct VkAttachmentReference2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.attachment, t.layout, t.aspectMask)
		end,
	}
)
mod.VkSubpassDescription2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ pipelineBindPoint;
	uint32_t viewMask;
	uint32_t inputAttachmentCount;
	const $* pInputAttachments;
	uint32_t colorAttachmentCount;
	const $* pColorAttachments;
	const $* pResolveAttachments;
	const $* pDepthStencilAttachment;
	uint32_t preserveAttachmentCount;
	const uint32_t* pPreserveAttachments;
}]],
	mod.VkStructureType,
	mod.VkSubpassDescriptionFlags,
	mod.VkPipelineBindPoint,
	mod.VkAttachmentReference2,
	mod.VkAttachmentReference2,
	mod.VkAttachmentReference2,
	mod.VkAttachmentReference2
)
ffi.metatype(
	mod.VkSubpassDescription2,
	{
		__tostring = function(s)
			return ("struct VkSubpassDescription2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.pipelineBindPoint,
				t.viewMask,
				t.inputAttachmentCount,
				t.pInputAttachments,
				t.colorAttachmentCount,
				t.pColorAttachments,
				t.pResolveAttachments,
				t.pDepthStencilAttachment,
				t.preserveAttachmentCount,
				t.pPreserveAttachments
			)
		end,
	}
)
mod.VkSubpassDependency2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t srcSubpass;
	uint32_t dstSubpass;
	$ srcStageMask;
	$ dstStageMask;
	$ srcAccessMask;
	$ dstAccessMask;
	$ dependencyFlags;
	int32_t viewOffset;
}]],
	mod.VkStructureType,
	mod.VkPipelineStageFlags,
	mod.VkPipelineStageFlags,
	mod.VkAccessFlags,
	mod.VkAccessFlags,
	mod.VkDependencyFlags
)
ffi.metatype(
	mod.VkSubpassDependency2,
	{
		__tostring = function(s)
			return ("struct VkSubpassDependency2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcSubpass,
				t.dstSubpass,
				t.srcStageMask,
				t.dstStageMask,
				t.srcAccessMask,
				t.dstAccessMask,
				t.dependencyFlags,
				t.viewOffset
			)
		end,
	}
)
mod.VkRenderPassCreateInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t attachmentCount;
	const $* pAttachments;
	uint32_t subpassCount;
	const $* pSubpasses;
	uint32_t dependencyCount;
	const $* pDependencies;
	uint32_t correlatedViewMaskCount;
	const uint32_t* pCorrelatedViewMasks;
}]],
	mod.VkStructureType,
	mod.VkRenderPassCreateFlags,
	mod.VkAttachmentDescription2,
	mod.VkSubpassDescription2,
	mod.VkSubpassDependency2
)
ffi.metatype(
	mod.VkRenderPassCreateInfo2,
	{
		__tostring = function(s)
			return ("struct VkRenderPassCreateInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.attachmentCount,
				t.pAttachments,
				t.subpassCount,
				t.pSubpasses,
				t.dependencyCount,
				t.pDependencies,
				t.correlatedViewMaskCount,
				t.pCorrelatedViewMasks
			)
		end,
	}
)
mod.VkSubpassBeginInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ contents;
}]],
	mod.VkStructureType,
	mod.VkSubpassContents
)
ffi.metatype(
	mod.VkSubpassBeginInfo,
	{
		__tostring = function(s)
			return ("struct VkSubpassBeginInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.contents)
		end,
	}
)
mod.VkSubpassEndInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
ffi.metatype(
	mod.VkSubpassEndInfo,
	{
		__tostring = function(s)
			return ("struct VkSubpassEndInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext)
		end,
	}
)
mod.VkPhysicalDevice8BitStorageFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ storageBuffer8BitAccess;
	$ uniformAndStorageBuffer8BitAccess;
	$ storagePushConstant8;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevice8BitStorageFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevice8BitStorageFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.storageBuffer8BitAccess,
				t.uniformAndStorageBuffer8BitAccess,
				t.storagePushConstant8
			)
		end,
	}
)
mod.VkPhysicalDeviceDriverProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ driverID;
	char driverName[256U];
	char driverInfo[256U];
	$ conformanceVersion;
}]],
	mod.VkStructureType,
	mod.VkDriverId,
	mod.VkConformanceVersion
)
ffi.metatype(
	mod.VkPhysicalDeviceDriverProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDriverProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.driverID,
				t.driverName,
				t.driverInfo,
				t.conformanceVersion
			)
		end,
	}
)
mod.VkPhysicalDeviceShaderAtomicInt64Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderBufferInt64Atomics;
	$ shaderSharedInt64Atomics;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderAtomicInt64Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderAtomicInt64Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderBufferInt64Atomics, t.shaderSharedInt64Atomics)
		end,
	}
)
mod.VkPhysicalDeviceShaderFloat16Int8Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderFloat16;
	$ shaderInt8;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderFloat16Int8Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderFloat16Int8Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderFloat16, t.shaderInt8)
		end,
	}
)
mod.VkPhysicalDeviceFloatControlsProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ denormBehaviorIndependence;
	$ roundingModeIndependence;
	$ shaderSignedZeroInfNanPreserveFloat16;
	$ shaderSignedZeroInfNanPreserveFloat32;
	$ shaderSignedZeroInfNanPreserveFloat64;
	$ shaderDenormPreserveFloat16;
	$ shaderDenormPreserveFloat32;
	$ shaderDenormPreserveFloat64;
	$ shaderDenormFlushToZeroFloat16;
	$ shaderDenormFlushToZeroFloat32;
	$ shaderDenormFlushToZeroFloat64;
	$ shaderRoundingModeRTEFloat16;
	$ shaderRoundingModeRTEFloat32;
	$ shaderRoundingModeRTEFloat64;
	$ shaderRoundingModeRTZFloat16;
	$ shaderRoundingModeRTZFloat32;
	$ shaderRoundingModeRTZFloat64;
}]],
	mod.VkStructureType,
	mod.VkShaderFloatControlsIndependence,
	mod.VkShaderFloatControlsIndependence,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFloatControlsProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFloatControlsProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.denormBehaviorIndependence,
				t.roundingModeIndependence,
				t.shaderSignedZeroInfNanPreserveFloat16,
				t.shaderSignedZeroInfNanPreserveFloat32,
				t.shaderSignedZeroInfNanPreserveFloat64,
				t.shaderDenormPreserveFloat16,
				t.shaderDenormPreserveFloat32,
				t.shaderDenormPreserveFloat64,
				t.shaderDenormFlushToZeroFloat16,
				t.shaderDenormFlushToZeroFloat32,
				t.shaderDenormFlushToZeroFloat64,
				t.shaderRoundingModeRTEFloat16,
				t.shaderRoundingModeRTEFloat32,
				t.shaderRoundingModeRTEFloat64,
				t.shaderRoundingModeRTZFloat16,
				t.shaderRoundingModeRTZFloat32,
				t.shaderRoundingModeRTZFloat64
			)
		end,
	}
)
mod.VkDescriptorSetLayoutBindingFlagsCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t bindingCount;
	const $* pBindingFlags;
}]],
	mod.VkStructureType,
	mod.VkDescriptorBindingFlags
)
ffi.metatype(
	mod.VkDescriptorSetLayoutBindingFlagsCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkDescriptorSetLayoutBindingFlagsCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.bindingCount, t.pBindingFlags)
		end,
	}
)
mod.VkPhysicalDeviceDescriptorIndexingFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderInputAttachmentArrayDynamicIndexing;
	$ shaderUniformTexelBufferArrayDynamicIndexing;
	$ shaderStorageTexelBufferArrayDynamicIndexing;
	$ shaderUniformBufferArrayNonUniformIndexing;
	$ shaderSampledImageArrayNonUniformIndexing;
	$ shaderStorageBufferArrayNonUniformIndexing;
	$ shaderStorageImageArrayNonUniformIndexing;
	$ shaderInputAttachmentArrayNonUniformIndexing;
	$ shaderUniformTexelBufferArrayNonUniformIndexing;
	$ shaderStorageTexelBufferArrayNonUniformIndexing;
	$ descriptorBindingUniformBufferUpdateAfterBind;
	$ descriptorBindingSampledImageUpdateAfterBind;
	$ descriptorBindingStorageImageUpdateAfterBind;
	$ descriptorBindingStorageBufferUpdateAfterBind;
	$ descriptorBindingUniformTexelBufferUpdateAfterBind;
	$ descriptorBindingStorageTexelBufferUpdateAfterBind;
	$ descriptorBindingUpdateUnusedWhilePending;
	$ descriptorBindingPartiallyBound;
	$ descriptorBindingVariableDescriptorCount;
	$ runtimeDescriptorArray;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDescriptorIndexingFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDescriptorIndexingFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderInputAttachmentArrayDynamicIndexing,
				t.shaderUniformTexelBufferArrayDynamicIndexing,
				t.shaderStorageTexelBufferArrayDynamicIndexing,
				t.shaderUniformBufferArrayNonUniformIndexing,
				t.shaderSampledImageArrayNonUniformIndexing,
				t.shaderStorageBufferArrayNonUniformIndexing,
				t.shaderStorageImageArrayNonUniformIndexing,
				t.shaderInputAttachmentArrayNonUniformIndexing,
				t.shaderUniformTexelBufferArrayNonUniformIndexing,
				t.shaderStorageTexelBufferArrayNonUniformIndexing,
				t.descriptorBindingUniformBufferUpdateAfterBind,
				t.descriptorBindingSampledImageUpdateAfterBind,
				t.descriptorBindingStorageImageUpdateAfterBind,
				t.descriptorBindingStorageBufferUpdateAfterBind,
				t.descriptorBindingUniformTexelBufferUpdateAfterBind,
				t.descriptorBindingStorageTexelBufferUpdateAfterBind,
				t.descriptorBindingUpdateUnusedWhilePending,
				t.descriptorBindingPartiallyBound,
				t.descriptorBindingVariableDescriptorCount,
				t.runtimeDescriptorArray
			)
		end,
	}
)
mod.VkPhysicalDeviceDescriptorIndexingProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxUpdateAfterBindDescriptorsInAllPools;
	$ shaderUniformBufferArrayNonUniformIndexingNative;
	$ shaderSampledImageArrayNonUniformIndexingNative;
	$ shaderStorageBufferArrayNonUniformIndexingNative;
	$ shaderStorageImageArrayNonUniformIndexingNative;
	$ shaderInputAttachmentArrayNonUniformIndexingNative;
	$ robustBufferAccessUpdateAfterBind;
	$ quadDivergentImplicitLod;
	uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
	uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
	uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
	uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
	uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
	uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
	uint32_t maxPerStageUpdateAfterBindResources;
	uint32_t maxDescriptorSetUpdateAfterBindSamplers;
	uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
	uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
	uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
	uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
	uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDescriptorIndexingProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDescriptorIndexingProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxUpdateAfterBindDescriptorsInAllPools,
				t.shaderUniformBufferArrayNonUniformIndexingNative,
				t.shaderSampledImageArrayNonUniformIndexingNative,
				t.shaderStorageBufferArrayNonUniformIndexingNative,
				t.shaderStorageImageArrayNonUniformIndexingNative,
				t.shaderInputAttachmentArrayNonUniformIndexingNative,
				t.robustBufferAccessUpdateAfterBind,
				t.quadDivergentImplicitLod,
				t.maxPerStageDescriptorUpdateAfterBindSamplers,
				t.maxPerStageDescriptorUpdateAfterBindUniformBuffers,
				t.maxPerStageDescriptorUpdateAfterBindStorageBuffers,
				t.maxPerStageDescriptorUpdateAfterBindSampledImages,
				t.maxPerStageDescriptorUpdateAfterBindStorageImages,
				t.maxPerStageDescriptorUpdateAfterBindInputAttachments,
				t.maxPerStageUpdateAfterBindResources,
				t.maxDescriptorSetUpdateAfterBindSamplers,
				t.maxDescriptorSetUpdateAfterBindUniformBuffers,
				t.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic,
				t.maxDescriptorSetUpdateAfterBindStorageBuffers,
				t.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic,
				t.maxDescriptorSetUpdateAfterBindSampledImages,
				t.maxDescriptorSetUpdateAfterBindStorageImages,
				t.maxDescriptorSetUpdateAfterBindInputAttachments
			)
		end,
	}
)
mod.VkDescriptorSetVariableDescriptorCountAllocateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t descriptorSetCount;
	const uint32_t* pDescriptorCounts;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDescriptorSetVariableDescriptorCountAllocateInfo,
	{
		__tostring = function(s)
			return ("struct VkDescriptorSetVariableDescriptorCountAllocateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.descriptorSetCount, t.pDescriptorCounts)
		end,
	}
)
mod.VkDescriptorSetVariableDescriptorCountLayoutSupport = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxVariableDescriptorCount;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDescriptorSetVariableDescriptorCountLayoutSupport,
	{
		__tostring = function(s)
			return ("struct VkDescriptorSetVariableDescriptorCountLayoutSupport[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxVariableDescriptorCount)
		end,
	}
)
mod.VkSubpassDescriptionDepthStencilResolve = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ depthResolveMode;
	$ stencilResolveMode;
	const $* pDepthStencilResolveAttachment;
}]],
	mod.VkStructureType,
	mod.VkResolveModeFlagBits,
	mod.VkResolveModeFlagBits,
	mod.VkAttachmentReference2
)
ffi.metatype(
	mod.VkSubpassDescriptionDepthStencilResolve,
	{
		__tostring = function(s)
			return ("struct VkSubpassDescriptionDepthStencilResolve[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.depthResolveMode,
				t.stencilResolveMode,
				t.pDepthStencilResolveAttachment
			)
		end,
	}
)
mod.VkPhysicalDeviceDepthStencilResolveProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ supportedDepthResolveModes;
	$ supportedStencilResolveModes;
	$ independentResolveNone;
	$ independentResolve;
}]],
	mod.VkStructureType,
	mod.VkResolveModeFlags,
	mod.VkResolveModeFlags,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDepthStencilResolveProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDepthStencilResolveProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.supportedDepthResolveModes,
				t.supportedStencilResolveModes,
				t.independentResolveNone,
				t.independentResolve
			)
		end,
	}
)
mod.VkPhysicalDeviceScalarBlockLayoutFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ scalarBlockLayout;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceScalarBlockLayoutFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceScalarBlockLayoutFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.scalarBlockLayout)
		end,
	}
)
mod.VkImageStencilUsageCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stencilUsage;
}]],
	mod.VkStructureType,
	mod.VkImageUsageFlags
)
ffi.metatype(
	mod.VkImageStencilUsageCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkImageStencilUsageCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stencilUsage)
		end,
	}
)
mod.VkSamplerReductionModeCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ reductionMode;
}]],
	mod.VkStructureType,
	mod.VkSamplerReductionMode
)
ffi.metatype(
	mod.VkSamplerReductionModeCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkSamplerReductionModeCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.reductionMode)
		end,
	}
)
mod.VkPhysicalDeviceSamplerFilterMinmaxProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ filterMinmaxSingleComponentFormats;
	$ filterMinmaxImageComponentMapping;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSamplerFilterMinmaxProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSamplerFilterMinmaxProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.filterMinmaxSingleComponentFormats,
				t.filterMinmaxImageComponentMapping
			)
		end,
	}
)
mod.VkPhysicalDeviceVulkanMemoryModelFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ vulkanMemoryModel;
	$ vulkanMemoryModelDeviceScope;
	$ vulkanMemoryModelAvailabilityVisibilityChains;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVulkanMemoryModelFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVulkanMemoryModelFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.vulkanMemoryModel,
				t.vulkanMemoryModelDeviceScope,
				t.vulkanMemoryModelAvailabilityVisibilityChains
			)
		end,
	}
)
mod.VkPhysicalDeviceImagelessFramebufferFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ imagelessFramebuffer;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceImagelessFramebufferFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImagelessFramebufferFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imagelessFramebuffer)
		end,
	}
)
mod.VkFramebufferAttachmentImageInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ usage;
	uint32_t width;
	uint32_t height;
	uint32_t layerCount;
	uint32_t viewFormatCount;
	const $* pViewFormats;
}]],
	mod.VkStructureType,
	mod.VkImageCreateFlags,
	mod.VkImageUsageFlags,
	mod.VkFormat
)
ffi.metatype(
	mod.VkFramebufferAttachmentImageInfo,
	{
		__tostring = function(s)
			return ("struct VkFramebufferAttachmentImageInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.usage,
				t.width,
				t.height,
				t.layerCount,
				t.viewFormatCount,
				t.pViewFormats
			)
		end,
	}
)
mod.VkFramebufferAttachmentsCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t attachmentImageInfoCount;
	const $* pAttachmentImageInfos;
}]],
	mod.VkStructureType,
	mod.VkFramebufferAttachmentImageInfo
)
ffi.metatype(
	mod.VkFramebufferAttachmentsCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkFramebufferAttachmentsCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.attachmentImageInfoCount, t.pAttachmentImageInfos)
		end,
	}
)
mod.VkRenderPassAttachmentBeginInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t attachmentCount;
	const $* pAttachments;
}]],
	mod.VkStructureType,
	mod.VkImageView
)
ffi.metatype(
	mod.VkRenderPassAttachmentBeginInfo,
	{
		__tostring = function(s)
			return ("struct VkRenderPassAttachmentBeginInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.attachmentCount, t.pAttachments)
		end,
	}
)
mod.VkPhysicalDeviceUniformBufferStandardLayoutFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ uniformBufferStandardLayout;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceUniformBufferStandardLayoutFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.uniformBufferStandardLayout)
		end,
	}
)
mod.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderSubgroupExtendedTypes;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderSubgroupExtendedTypes)
		end,
	}
)
mod.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ separateDepthStencilLayouts;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.separateDepthStencilLayouts)
		end,
	}
)
mod.VkAttachmentReferenceStencilLayout = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ stencilLayout;
}]],
	mod.VkStructureType,
	mod.VkImageLayout
)
ffi.metatype(
	mod.VkAttachmentReferenceStencilLayout,
	{
		__tostring = function(s)
			return ("struct VkAttachmentReferenceStencilLayout[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stencilLayout)
		end,
	}
)
mod.VkAttachmentDescriptionStencilLayout = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ stencilInitialLayout;
	$ stencilFinalLayout;
}]],
	mod.VkStructureType,
	mod.VkImageLayout,
	mod.VkImageLayout
)
ffi.metatype(
	mod.VkAttachmentDescriptionStencilLayout,
	{
		__tostring = function(s)
			return ("struct VkAttachmentDescriptionStencilLayout[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stencilInitialLayout, t.stencilFinalLayout)
		end,
	}
)
mod.VkPhysicalDeviceHostQueryResetFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ hostQueryReset;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceHostQueryResetFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceHostQueryResetFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.hostQueryReset)
		end,
	}
)
mod.VkPhysicalDeviceTimelineSemaphoreFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ timelineSemaphore;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceTimelineSemaphoreFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTimelineSemaphoreFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.timelineSemaphore)
		end,
	}
)
mod.VkPhysicalDeviceTimelineSemaphoreProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint64_t maxTimelineSemaphoreValueDifference;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceTimelineSemaphoreProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTimelineSemaphoreProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxTimelineSemaphoreValueDifference)
		end,
	}
)
mod.VkSemaphoreTypeCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ semaphoreType;
	uint64_t initialValue;
}]],
	mod.VkStructureType,
	mod.VkSemaphoreType
)
ffi.metatype(
	mod.VkSemaphoreTypeCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkSemaphoreTypeCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.semaphoreType, t.initialValue)
		end,
	}
)
mod.VkTimelineSemaphoreSubmitInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t waitSemaphoreValueCount;
	const uint64_t* pWaitSemaphoreValues;
	uint32_t signalSemaphoreValueCount;
	const uint64_t* pSignalSemaphoreValues;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkTimelineSemaphoreSubmitInfo,
	{
		__tostring = function(s)
			return ("struct VkTimelineSemaphoreSubmitInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.waitSemaphoreValueCount,
				t.pWaitSemaphoreValues,
				t.signalSemaphoreValueCount,
				t.pSignalSemaphoreValues
			)
		end,
	}
)
mod.VkSemaphoreWaitInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t semaphoreCount;
	const $* pSemaphores;
	const uint64_t* pValues;
}]],
	mod.VkStructureType,
	mod.VkSemaphoreWaitFlags,
	mod.VkSemaphore
)
ffi.metatype(
	mod.VkSemaphoreWaitInfo,
	{
		__tostring = function(s)
			return ("struct VkSemaphoreWaitInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.semaphoreCount, t.pSemaphores, t.pValues)
		end,
	}
)
mod.VkSemaphoreSignalInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ semaphore;
	uint64_t value;
}]],
	mod.VkStructureType,
	mod.VkSemaphore
)
ffi.metatype(
	mod.VkSemaphoreSignalInfo,
	{
		__tostring = function(s)
			return ("struct VkSemaphoreSignalInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.semaphore, t.value)
		end,
	}
)
mod.VkPhysicalDeviceBufferDeviceAddressFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ bufferDeviceAddress;
	$ bufferDeviceAddressCaptureReplay;
	$ bufferDeviceAddressMultiDevice;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceBufferDeviceAddressFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceBufferDeviceAddressFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.bufferDeviceAddress,
				t.bufferDeviceAddressCaptureReplay,
				t.bufferDeviceAddressMultiDevice
			)
		end,
	}
)
mod.VkBufferDeviceAddressInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ buffer;
}]],
	mod.VkStructureType,
	mod.VkBuffer
)
ffi.metatype(
	mod.VkBufferDeviceAddressInfo,
	{
		__tostring = function(s)
			return ("struct VkBufferDeviceAddressInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.buffer)
		end,
	}
)
mod.VkBufferOpaqueCaptureAddressCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint64_t opaqueCaptureAddress;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkBufferOpaqueCaptureAddressCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkBufferOpaqueCaptureAddressCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.opaqueCaptureAddress)
		end,
	}
)
mod.VkMemoryOpaqueCaptureAddressAllocateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint64_t opaqueCaptureAddress;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkMemoryOpaqueCaptureAddressAllocateInfo,
	{
		__tostring = function(s)
			return ("struct VkMemoryOpaqueCaptureAddressAllocateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.opaqueCaptureAddress)
		end,
	}
)
mod.VkDeviceMemoryOpaqueCaptureAddressInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ memory;
}]],
	mod.VkStructureType,
	mod.VkDeviceMemory
)
ffi.metatype(
	mod.VkDeviceMemoryOpaqueCaptureAddressInfo,
	{
		__tostring = function(s)
			return ("struct VkDeviceMemoryOpaqueCaptureAddressInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memory)
		end,
	}
)
mod.PFN_vkCmdDrawIndirectCount = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdDrawIndexedIndirectCount = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCreateRenderPass2 = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkRenderPassCreateInfo2,
	mod.VkAllocationCallbacks,
	mod.VkRenderPass
)
mod.PFN_vkCmdBeginRenderPass2 = ffi.typeof(
	[[void (*)($ , const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkRenderPassBeginInfo,
	mod.VkSubpassBeginInfo
)
mod.PFN_vkCmdNextSubpass2 = ffi.typeof(
	[[void (*)($ , const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkSubpassBeginInfo,
	mod.VkSubpassEndInfo
)
mod.PFN_vkCmdEndRenderPass2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkSubpassEndInfo)
mod.PFN_vkResetQueryPool = ffi.typeof([[void (*)($ , $ , uint32_t , uint32_t )]], mod.VkDevice, mod.VkQueryPool)
mod.PFN_vkGetSemaphoreCounterValue = ffi.typeof([[$ (*)($ , $ , uint64_t*)]], mod.VkResult, mod.VkDevice, mod.VkSemaphore)
mod.PFN_vkWaitSemaphores = ffi.typeof(
	[[$ (*)($ , const $*, uint64_t )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphoreWaitInfo
)
mod.PFN_vkSignalSemaphore = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreSignalInfo)
mod.PFN_vkGetBufferDeviceAddress = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkDeviceAddress,
	mod.VkDevice,
	mod.VkBufferDeviceAddressInfo
)
mod.PFN_vkGetBufferOpaqueCaptureAddress = ffi.typeof([[uint64_t (*)($ , const $*)]], mod.VkDevice, mod.VkBufferDeviceAddressInfo)
mod.PFN_vkGetDeviceMemoryOpaqueCaptureAddress = ffi.typeof(
	[[uint64_t (*)($ , const $*)]],
	mod.VkDevice,
	mod.VkDeviceMemoryOpaqueCaptureAddressInfo
)
ffi.cdef(
	[[void  vkCmdDrawIndirectCount($ , $ , $ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdDrawIndexedIndirectCount($ , $ , $ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[$  vkCreateRenderPass2($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkRenderPassCreateInfo2,
	mod.VkAllocationCallbacks,
	mod.VkRenderPass
)
ffi.cdef(
	[[void  vkCmdBeginRenderPass2($ , const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkRenderPassBeginInfo,
	mod.VkSubpassBeginInfo
)
ffi.cdef(
	[[void  vkCmdNextSubpass2($ , const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkSubpassBeginInfo,
	mod.VkSubpassEndInfo
)
ffi.cdef(
	[[void  vkCmdEndRenderPass2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkSubpassEndInfo
)
ffi.cdef(
	[[void  vkResetQueryPool($ , $ , uint32_t , uint32_t );]],
	mod.VkDevice,
	mod.VkQueryPool
)
ffi.cdef(
	[[$  vkGetSemaphoreCounterValue($ , $ , uint64_t*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphore
)
ffi.cdef(
	[[$  vkWaitSemaphores($ , const $*, uint64_t );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphoreWaitInfo
)
ffi.cdef(
	[[$  vkSignalSemaphore($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphoreSignalInfo
)
ffi.cdef(
	[[$  vkGetBufferDeviceAddress($ , const $*);]],
	mod.VkDeviceAddress,
	mod.VkDevice,
	mod.VkBufferDeviceAddressInfo
)
ffi.cdef(
	[[uint64_t  vkGetBufferOpaqueCaptureAddress($ , const $*);]],
	mod.VkDevice,
	mod.VkBufferDeviceAddressInfo
)
ffi.cdef(
	[[uint64_t  vkGetDeviceMemoryOpaqueCaptureAddress($ , const $*);]],
	mod.VkDevice,
	mod.VkDeviceMemoryOpaqueCaptureAddressInfo
)
mod.VkFlags64 = ffi.typeof([[uint64_t ]])
mod.VkPrivateDataSlot = ffi.typeof([[void*]])
mod.VkPipelineCreationFeedbackFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = 0x00000001,
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 0x00000002,
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 0x00000004,
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT,
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT,
	VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineCreationFeedbackFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkToolPurposeFlagBits = ffi.typeof([[enum {
	VK_TOOL_PURPOSE_VALIDATION_BIT = 0x00000001,
	VK_TOOL_PURPOSE_PROFILING_BIT = 0x00000002,
	VK_TOOL_PURPOSE_TRACING_BIT = 0x00000004,
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 0x00000008,
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 0x00000010,
	VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x00000020,
	VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x00000040,
	VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = VK_TOOL_PURPOSE_VALIDATION_BIT,
	VK_TOOL_PURPOSE_PROFILING_BIT_EXT = VK_TOOL_PURPOSE_PROFILING_BIT,
	VK_TOOL_PURPOSE_TRACING_BIT_EXT = VK_TOOL_PURPOSE_TRACING_BIT,
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT,
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT,
	VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkToolPurposeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPrivateDataSlotCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineStageFlags2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkPipelineStageFlagBits2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_PIPELINE_STAGE_2_NONE = 0ULL
mod.VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 0x00000001ULL
mod.VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 0x00000002ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 0x00000004ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 0x00000008ULL
mod.VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010ULL
mod.VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020ULL
mod.VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 0x00000040ULL
mod.VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 0x00000080ULL
mod.VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = 0x00000100ULL
mod.VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = 0x00000200ULL
mod.VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400ULL
mod.VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 0x00000800ULL
mod.VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 0x00001000ULL
mod.VK_PIPELINE_STAGE_2_TRANSFER_BIT = 0x00001000ULL
mod.VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 0x00002000ULL
mod.VK_PIPELINE_STAGE_2_HOST_BIT = 0x00004000ULL
mod.VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 0x00008000ULL
mod.VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 0x00010000ULL
mod.VK_PIPELINE_STAGE_2_COPY_BIT = 0x100000000ULL
mod.VK_PIPELINE_STAGE_2_RESOLVE_BIT = 0x200000000ULL
mod.VK_PIPELINE_STAGE_2_BLIT_BIT = 0x400000000ULL
mod.VK_PIPELINE_STAGE_2_CLEAR_BIT = 0x800000000ULL
mod.VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = 0x1000000000ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = 0x2000000000ULL
mod.VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = 0x4000000000ULL
mod.VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 0x04000000ULL
mod.VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 0x08000000ULL
mod.VK_PIPELINE_STAGE_2_NONE_KHR = 0ULL
mod.VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 0x00000001ULL
mod.VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 0x00000002ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 0x00000004ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 0x00000008ULL
mod.VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 0x00000010ULL
mod.VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 0x00000020ULL
mod.VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 0x00000040ULL
mod.VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 0x00000080ULL
mod.VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 0x00000100ULL
mod.VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 0x00000200ULL
mod.VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 0x00000400ULL
mod.VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 0x00000800ULL
mod.VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 0x00001000ULL
mod.VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 0x00001000ULL
mod.VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 0x00002000ULL
mod.VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 0x00004000ULL
mod.VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 0x00008000ULL
mod.VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 0x00010000ULL
mod.VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 0x100000000ULL
mod.VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 0x200000000ULL
mod.VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 0x400000000ULL
mod.VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 0x800000000ULL
mod.VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 0x1000000000ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 0x2000000000ULL
mod.VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 0x4000000000ULL
mod.VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000ULL
mod.VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000ULL
mod.VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = 0x00020000ULL
mod.VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT = 0x00020000ULL
mod.VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000ULL
mod.VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV = 0x00400000ULL
mod.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000ULL
mod.VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = 0x00200000ULL
mod.VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV = 0x00200000ULL
mod.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x02000000ULL
mod.VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000ULL
mod.VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 0x00080000ULL
mod.VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 0x00100000ULL
mod.VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT = 0x00080000ULL
mod.VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT = 0x00100000ULL
mod.VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI = 0x8000000000ULL
mod.VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI = 0x8000000000ULL
mod.VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = 0x10000000000ULL
mod.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR = 0x10000000ULL
mod.VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT = 0x40000000ULL
mod.VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI = 0x20000000000ULL
mod.VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV = 0x20000000ULL
mod.VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV = 0x100000000000ULL
mod.VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM = 0x40000000000ULL
mod.VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR = 0x400000000000ULL
mod.VkAccessFlags2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkAccessFlagBits2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_ACCESS_2_NONE = 0ULL
mod.VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = 0x00000001ULL
mod.VK_ACCESS_2_INDEX_READ_BIT = 0x00000002ULL
mod.VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004ULL
mod.VK_ACCESS_2_UNIFORM_READ_BIT = 0x00000008ULL
mod.VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 0x00000010ULL
mod.VK_ACCESS_2_SHADER_READ_BIT = 0x00000020ULL
mod.VK_ACCESS_2_SHADER_WRITE_BIT = 0x00000040ULL
mod.VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 0x00000080ULL
mod.VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100ULL
mod.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200ULL
mod.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400ULL
mod.VK_ACCESS_2_TRANSFER_READ_BIT = 0x00000800ULL
mod.VK_ACCESS_2_TRANSFER_WRITE_BIT = 0x00001000ULL
mod.VK_ACCESS_2_HOST_READ_BIT = 0x00002000ULL
mod.VK_ACCESS_2_HOST_WRITE_BIT = 0x00004000ULL
mod.VK_ACCESS_2_MEMORY_READ_BIT = 0x00008000ULL
mod.VK_ACCESS_2_MEMORY_WRITE_BIT = 0x00010000ULL
mod.VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = 0x100000000ULL
mod.VK_ACCESS_2_SHADER_STORAGE_READ_BIT = 0x200000000ULL
mod.VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = 0x400000000ULL
mod.VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 0x800000000ULL
mod.VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 0x1000000000ULL
mod.VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 0x2000000000ULL
mod.VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 0x4000000000ULL
mod.VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM = 0x8000000000000ULL
mod.VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM = 0x10000000000000ULL
mod.VK_ACCESS_2_NONE_KHR = 0ULL
mod.VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 0x00000001ULL
mod.VK_ACCESS_2_INDEX_READ_BIT_KHR = 0x00000002ULL
mod.VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 0x00000004ULL
mod.VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 0x00000008ULL
mod.VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 0x00000010ULL
mod.VK_ACCESS_2_SHADER_READ_BIT_KHR = 0x00000020ULL
mod.VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 0x00000040ULL
mod.VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 0x00000080ULL
mod.VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 0x00000100ULL
mod.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 0x00000200ULL
mod.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 0x00000400ULL
mod.VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 0x00000800ULL
mod.VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 0x00001000ULL
mod.VK_ACCESS_2_HOST_READ_BIT_KHR = 0x00002000ULL
mod.VK_ACCESS_2_HOST_WRITE_BIT_KHR = 0x00004000ULL
mod.VK_ACCESS_2_MEMORY_READ_BIT_KHR = 0x00008000ULL
mod.VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 0x00010000ULL
mod.VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 0x100000000ULL
mod.VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 0x200000000ULL
mod.VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 0x400000000ULL
mod.VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000ULL
mod.VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000ULL
mod.VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000ULL
mod.VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000ULL
mod.VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000ULL
mod.VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000ULL
mod.VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT = 0x00020000ULL
mod.VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT = 0x00040000ULL
mod.VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000ULL
mod.VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000ULL
mod.VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000ULL
mod.VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000ULL
mod.VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000ULL
mod.VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000ULL
mod.VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000ULL
mod.VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000ULL
mod.VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT = 0x20000000000ULL
mod.VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = 0x8000000000ULL
mod.VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR = 0x10000000000ULL
mod.VK_ACCESS_2_MICROMAP_READ_BIT_EXT = 0x100000000000ULL
mod.VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT = 0x200000000000ULL
mod.VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV = 0x40000000000ULL
mod.VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV = 0x80000000000ULL
mod.VK_ACCESS_2_DATA_GRAPH_READ_BIT_ARM = 0x800000000000ULL
mod.VK_ACCESS_2_DATA_GRAPH_WRITE_BIT_ARM = 0x1000000000000ULL
mod.VkSubmitFlagBits = ffi.typeof([[enum {
	VK_SUBMIT_PROTECTED_BIT = 0x00000001,
	VK_SUBMIT_PROTECTED_BIT_KHR = VK_SUBMIT_PROTECTED_BIT,
	VK_SUBMIT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSubmitFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkRenderingFlagBits = ffi.typeof([[enum {
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 0x00000001,
	VK_RENDERING_SUSPENDING_BIT = 0x00000002,
	VK_RENDERING_RESUMING_BIT = 0x00000004,
	VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x00000008,
	VK_RENDERING_CONTENTS_INLINE_BIT_KHR = 0x00000010,
	VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = 0x00000020,
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR = VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT,
	VK_RENDERING_SUSPENDING_BIT_KHR = VK_RENDERING_SUSPENDING_BIT,
	VK_RENDERING_RESUMING_BIT_KHR = VK_RENDERING_RESUMING_BIT,
	VK_RENDERING_CONTENTS_INLINE_BIT_EXT = VK_RENDERING_CONTENTS_INLINE_BIT_KHR,
	VK_RENDERING_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkRenderingFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkFormatFeatureFlags2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkFormatFeatureFlagBits2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT = 0x00000001ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT = 0x00000002ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004ULL
mod.VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT = 0x00000010ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020ULL
mod.VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT = 0x00000040ULL
mod.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT = 0x00000080ULL
mod.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100ULL
mod.VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200ULL
mod.VK_FORMAT_FEATURE_2_BLIT_SRC_BIT = 0x00000400ULL
mod.VK_FORMAT_FEATURE_2_BLIT_DST_BIT = 0x00000800ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000ULL
mod.VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT = 0x00004000ULL
mod.VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT = 0x00008000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000ULL
mod.VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000ULL
mod.VK_FORMAT_FEATURE_2_DISJOINT_BIT = 0x00400000ULL
mod.VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT = 0x00800000ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT = 0x80000000ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT = 0x100000000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT = 0x200000000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT = 0x00002000ULL
mod.VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT = 0x400000000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000ULL
mod.VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000ULL
mod.VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000ULL
mod.VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000ULL
mod.VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT = 0x400000000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = 0x00000001ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = 0x00000002ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR = 0x00000004ULL
mod.VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 0x00000008ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 0x00000010ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR = 0x00000020ULL
mod.VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = 0x00000040ULL
mod.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR = 0x00000080ULL
mod.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR = 0x00000100ULL
mod.VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR = 0x00000200ULL
mod.VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = 0x00000400ULL
mod.VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = 0x00000800ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR = 0x00001000ULL
mod.VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = 0x00004000ULL
mod.VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = 0x00008000ULL
mod.VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 0x00020000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 0x00040000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 0x00080000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 0x00100000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 0x00200000ULL
mod.VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR = 0x00400000ULL
mod.VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR = 0x00800000ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR = 0x80000000ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR = 0x100000000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR = 0x200000000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR = 0x00010000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x00002000ULL
mod.VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV = 0x8000000000000ULL
mod.VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV = 0x4000000000ULL
mod.VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM = 0x400000000ULL
mod.VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM = 0x800000000ULL
mod.VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM = 0x1000000000ULL
mod.VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM = 0x2000000000ULL
mod.VK_FORMAT_FEATURE_2_TENSOR_SHADER_BIT_ARM = 0x8000000000ULL
mod.VK_FORMAT_FEATURE_2_TENSOR_IMAGE_ALIASING_BIT_ARM = 0x80000000000ULL
mod.VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV = 0x10000000000ULL
mod.VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV = 0x20000000000ULL
mod.VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV = 0x40000000000ULL
mod.VK_FORMAT_FEATURE_2_TENSOR_DATA_GRAPH_BIT_ARM = 0x1000000000000ULL
mod.VK_FORMAT_FEATURE_2_COPY_IMAGE_INDIRECT_DST_BIT_KHR = 0x800000000000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x2000000000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x4000000000000ULL
mod.VkPhysicalDeviceVulkan13Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ robustImageAccess;
	$ inlineUniformBlock;
	$ descriptorBindingInlineUniformBlockUpdateAfterBind;
	$ pipelineCreationCacheControl;
	$ privateData;
	$ shaderDemoteToHelperInvocation;
	$ shaderTerminateInvocation;
	$ subgroupSizeControl;
	$ computeFullSubgroups;
	$ synchronization2;
	$ textureCompressionASTC_HDR;
	$ shaderZeroInitializeWorkgroupMemory;
	$ dynamicRendering;
	$ shaderIntegerDotProduct;
	$ maintenance4;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVulkan13Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVulkan13Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.robustImageAccess,
				t.inlineUniformBlock,
				t.descriptorBindingInlineUniformBlockUpdateAfterBind,
				t.pipelineCreationCacheControl,
				t.privateData,
				t.shaderDemoteToHelperInvocation,
				t.shaderTerminateInvocation,
				t.subgroupSizeControl,
				t.computeFullSubgroups,
				t.synchronization2,
				t.textureCompressionASTC_HDR,
				t.shaderZeroInitializeWorkgroupMemory,
				t.dynamicRendering,
				t.shaderIntegerDotProduct,
				t.maintenance4
			)
		end,
	}
)
mod.VkPhysicalDeviceVulkan13Properties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t minSubgroupSize;
	uint32_t maxSubgroupSize;
	uint32_t maxComputeWorkgroupSubgroups;
	$ requiredSubgroupSizeStages;
	uint32_t maxInlineUniformBlockSize;
	uint32_t maxPerStageDescriptorInlineUniformBlocks;
	uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
	uint32_t maxDescriptorSetInlineUniformBlocks;
	uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
	uint32_t maxInlineUniformTotalSize;
	$ integerDotProduct8BitUnsignedAccelerated;
	$ integerDotProduct8BitSignedAccelerated;
	$ integerDotProduct8BitMixedSignednessAccelerated;
	$ integerDotProduct4x8BitPackedUnsignedAccelerated;
	$ integerDotProduct4x8BitPackedSignedAccelerated;
	$ integerDotProduct4x8BitPackedMixedSignednessAccelerated;
	$ integerDotProduct16BitUnsignedAccelerated;
	$ integerDotProduct16BitSignedAccelerated;
	$ integerDotProduct16BitMixedSignednessAccelerated;
	$ integerDotProduct32BitUnsignedAccelerated;
	$ integerDotProduct32BitSignedAccelerated;
	$ integerDotProduct32BitMixedSignednessAccelerated;
	$ integerDotProduct64BitUnsignedAccelerated;
	$ integerDotProduct64BitSignedAccelerated;
	$ integerDotProduct64BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating8BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating16BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating32BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating64BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
	$ storageTexelBufferOffsetAlignmentBytes;
	$ storageTexelBufferOffsetSingleTexelAlignment;
	$ uniformTexelBufferOffsetAlignmentBytes;
	$ uniformTexelBufferOffsetSingleTexelAlignment;
	$ maxBufferSize;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkDeviceSize,
	mod.VkBool32,
	mod.VkDeviceSize,
	mod.VkBool32,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkPhysicalDeviceVulkan13Properties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVulkan13Properties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.minSubgroupSize,
				t.maxSubgroupSize,
				t.maxComputeWorkgroupSubgroups,
				t.requiredSubgroupSizeStages,
				t.maxInlineUniformBlockSize,
				t.maxPerStageDescriptorInlineUniformBlocks,
				t.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks,
				t.maxDescriptorSetInlineUniformBlocks,
				t.maxDescriptorSetUpdateAfterBindInlineUniformBlocks,
				t.maxInlineUniformTotalSize,
				t.integerDotProduct8BitUnsignedAccelerated,
				t.integerDotProduct8BitSignedAccelerated,
				t.integerDotProduct8BitMixedSignednessAccelerated,
				t.integerDotProduct4x8BitPackedUnsignedAccelerated,
				t.integerDotProduct4x8BitPackedSignedAccelerated,
				t.integerDotProduct4x8BitPackedMixedSignednessAccelerated,
				t.integerDotProduct16BitUnsignedAccelerated,
				t.integerDotProduct16BitSignedAccelerated,
				t.integerDotProduct16BitMixedSignednessAccelerated,
				t.integerDotProduct32BitUnsignedAccelerated,
				t.integerDotProduct32BitSignedAccelerated,
				t.integerDotProduct32BitMixedSignednessAccelerated,
				t.integerDotProduct64BitUnsignedAccelerated,
				t.integerDotProduct64BitSignedAccelerated,
				t.integerDotProduct64BitMixedSignednessAccelerated,
				t.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated,
				t.integerDotProductAccumulatingSaturating8BitSignedAccelerated,
				t.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated,
				t.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated,
				t.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated,
				t.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated,
				t.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated,
				t.integerDotProductAccumulatingSaturating16BitSignedAccelerated,
				t.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated,
				t.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated,
				t.integerDotProductAccumulatingSaturating32BitSignedAccelerated,
				t.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated,
				t.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated,
				t.integerDotProductAccumulatingSaturating64BitSignedAccelerated,
				t.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated,
				t.storageTexelBufferOffsetAlignmentBytes,
				t.storageTexelBufferOffsetSingleTexelAlignment,
				t.uniformTexelBufferOffsetAlignmentBytes,
				t.uniformTexelBufferOffsetSingleTexelAlignment,
				t.maxBufferSize
			)
		end,
	}
)
mod.VkPipelineCreationFeedback = ffi.typeof([[struct {
	$ flags;
	uint64_t duration;
}]], mod.VkPipelineCreationFeedbackFlags)
ffi.metatype(
	mod.VkPipelineCreationFeedback,
	{
		__tostring = function(s)
			return ("struct VkPipelineCreationFeedback[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.flags, t.duration)
		end,
	}
)
mod.VkPipelineCreationFeedbackCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$* pPipelineCreationFeedback;
	uint32_t pipelineStageCreationFeedbackCount;
	$* pPipelineStageCreationFeedbacks;
}]],
	mod.VkStructureType,
	mod.VkPipelineCreationFeedback,
	mod.VkPipelineCreationFeedback
)
ffi.metatype(
	mod.VkPipelineCreationFeedbackCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineCreationFeedbackCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pPipelineCreationFeedback,
				t.pipelineStageCreationFeedbackCount,
				t.pPipelineStageCreationFeedbacks
			)
		end,
	}
)
mod.VkPhysicalDeviceShaderTerminateInvocationFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderTerminateInvocation;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderTerminateInvocationFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderTerminateInvocationFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderTerminateInvocation)
		end,
	}
)
mod.VkPhysicalDeviceToolProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	char name[256U];
	char version[256U];
	$ purposes;
	char description[256U];
	char layer[256U];
}]],
	mod.VkStructureType,
	mod.VkToolPurposeFlags
)
ffi.metatype(
	mod.VkPhysicalDeviceToolProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceToolProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.name, t.version, t.purposes, t.description, t.layer)
		end,
	}
)
mod.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderDemoteToHelperInvocation;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderDemoteToHelperInvocation)
		end,
	}
)
mod.VkPhysicalDevicePrivateDataFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ privateData;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePrivateDataFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePrivateDataFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.privateData)
		end,
	}
)
mod.VkDevicePrivateDataCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t privateDataSlotRequestCount;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDevicePrivateDataCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkDevicePrivateDataCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.privateDataSlotRequestCount)
		end,
	}
)
mod.VkPrivateDataSlotCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkPrivateDataSlotCreateFlags
)
ffi.metatype(
	mod.VkPrivateDataSlotCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPrivateDataSlotCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.VkPhysicalDevicePipelineCreationCacheControlFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelineCreationCacheControl;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePipelineCreationCacheControlFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePipelineCreationCacheControlFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineCreationCacheControl)
		end,
	}
)
mod.VkMemoryBarrier2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcStageMask;
	$ srcAccessMask;
	$ dstStageMask;
	$ dstAccessMask;
}]],
	mod.VkStructureType,
	mod.VkPipelineStageFlags2,
	mod.VkAccessFlags2,
	mod.VkPipelineStageFlags2,
	mod.VkAccessFlags2
)
ffi.metatype(
	mod.VkMemoryBarrier2,
	{
		__tostring = function(s)
			return ("struct VkMemoryBarrier2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcStageMask,
				t.srcAccessMask,
				t.dstStageMask,
				t.dstAccessMask
			)
		end,
	}
)
mod.VkBufferMemoryBarrier2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcStageMask;
	$ srcAccessMask;
	$ dstStageMask;
	$ dstAccessMask;
	uint32_t srcQueueFamilyIndex;
	uint32_t dstQueueFamilyIndex;
	$ buffer;
	$ offset;
	$ size;
}]],
	mod.VkStructureType,
	mod.VkPipelineStageFlags2,
	mod.VkAccessFlags2,
	mod.VkPipelineStageFlags2,
	mod.VkAccessFlags2,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkBufferMemoryBarrier2,
	{
		__tostring = function(s)
			return ("struct VkBufferMemoryBarrier2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcStageMask,
				t.srcAccessMask,
				t.dstStageMask,
				t.dstAccessMask,
				t.srcQueueFamilyIndex,
				t.dstQueueFamilyIndex,
				t.buffer,
				t.offset,
				t.size
			)
		end,
	}
)
mod.VkImageMemoryBarrier2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcStageMask;
	$ srcAccessMask;
	$ dstStageMask;
	$ dstAccessMask;
	$ oldLayout;
	$ newLayout;
	uint32_t srcQueueFamilyIndex;
	uint32_t dstQueueFamilyIndex;
	$ image;
	$ subresourceRange;
}]],
	mod.VkStructureType,
	mod.VkPipelineStageFlags2,
	mod.VkAccessFlags2,
	mod.VkPipelineStageFlags2,
	mod.VkAccessFlags2,
	mod.VkImageLayout,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageSubresourceRange
)
ffi.metatype(
	mod.VkImageMemoryBarrier2,
	{
		__tostring = function(s)
			return ("struct VkImageMemoryBarrier2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcStageMask,
				t.srcAccessMask,
				t.dstStageMask,
				t.dstAccessMask,
				t.oldLayout,
				t.newLayout,
				t.srcQueueFamilyIndex,
				t.dstQueueFamilyIndex,
				t.image,
				t.subresourceRange
			)
		end,
	}
)
mod.VkDependencyInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ dependencyFlags;
	uint32_t memoryBarrierCount;
	const $* pMemoryBarriers;
	uint32_t bufferMemoryBarrierCount;
	const $* pBufferMemoryBarriers;
	uint32_t imageMemoryBarrierCount;
	const $* pImageMemoryBarriers;
}]],
	mod.VkStructureType,
	mod.VkDependencyFlags,
	mod.VkMemoryBarrier2,
	mod.VkBufferMemoryBarrier2,
	mod.VkImageMemoryBarrier2
)
ffi.metatype(
	mod.VkDependencyInfo,
	{
		__tostring = function(s)
			return ("struct VkDependencyInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.dependencyFlags,
				t.memoryBarrierCount,
				t.pMemoryBarriers,
				t.bufferMemoryBarrierCount,
				t.pBufferMemoryBarriers,
				t.imageMemoryBarrierCount,
				t.pImageMemoryBarriers
			)
		end,
	}
)
mod.VkSemaphoreSubmitInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ semaphore;
	uint64_t value;
	$ stageMask;
	uint32_t deviceIndex;
}]],
	mod.VkStructureType,
	mod.VkSemaphore,
	mod.VkPipelineStageFlags2
)
ffi.metatype(
	mod.VkSemaphoreSubmitInfo,
	{
		__tostring = function(s)
			return ("struct VkSemaphoreSubmitInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.semaphore, t.value, t.stageMask, t.deviceIndex)
		end,
	}
)
mod.VkCommandBufferSubmitInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ commandBuffer;
	uint32_t deviceMask;
}]],
	mod.VkStructureType,
	mod.VkCommandBuffer
)
ffi.metatype(
	mod.VkCommandBufferSubmitInfo,
	{
		__tostring = function(s)
			return ("struct VkCommandBufferSubmitInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.commandBuffer, t.deviceMask)
		end,
	}
)
mod.VkSubmitInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t waitSemaphoreInfoCount;
	const $* pWaitSemaphoreInfos;
	uint32_t commandBufferInfoCount;
	const $* pCommandBufferInfos;
	uint32_t signalSemaphoreInfoCount;
	const $* pSignalSemaphoreInfos;
}]],
	mod.VkStructureType,
	mod.VkSubmitFlags,
	mod.VkSemaphoreSubmitInfo,
	mod.VkCommandBufferSubmitInfo,
	mod.VkSemaphoreSubmitInfo
)
ffi.metatype(
	mod.VkSubmitInfo2,
	{
		__tostring = function(s)
			return ("struct VkSubmitInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.waitSemaphoreInfoCount,
				t.pWaitSemaphoreInfos,
				t.commandBufferInfoCount,
				t.pCommandBufferInfos,
				t.signalSemaphoreInfoCount,
				t.pSignalSemaphoreInfos
			)
		end,
	}
)
mod.VkPhysicalDeviceSynchronization2Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ synchronization2;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSynchronization2Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSynchronization2Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.synchronization2)
		end,
	}
)
mod.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderZeroInitializeWorkgroupMemory;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderZeroInitializeWorkgroupMemory)
		end,
	}
)
mod.VkPhysicalDeviceImageRobustnessFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ robustImageAccess;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceImageRobustnessFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageRobustnessFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.robustImageAccess)
		end,
	}
)
mod.VkBufferCopy2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcOffset;
	$ dstOffset;
	$ size;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkBufferCopy2,
	{
		__tostring = function(s)
			return ("struct VkBufferCopy2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.srcOffset, t.dstOffset, t.size)
		end,
	}
)
mod.VkCopyBufferInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcBuffer;
	$ dstBuffer;
	uint32_t regionCount;
	const $* pRegions;
}]],
	mod.VkStructureType,
	mod.VkBuffer,
	mod.VkBuffer,
	mod.VkBufferCopy2
)
ffi.metatype(
	mod.VkCopyBufferInfo2,
	{
		__tostring = function(s)
			return ("struct VkCopyBufferInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.srcBuffer, t.dstBuffer, t.regionCount, t.pRegions)
		end,
	}
)
mod.VkImageCopy2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcSubresource;
	$ srcOffset;
	$ dstSubresource;
	$ dstOffset;
	$ extent;
}]],
	mod.VkStructureType,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkExtent3D
)
ffi.metatype(
	mod.VkImageCopy2,
	{
		__tostring = function(s)
			return ("struct VkImageCopy2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcSubresource,
				t.srcOffset,
				t.dstSubresource,
				t.dstOffset,
				t.extent
			)
		end,
	}
)
mod.VkCopyImageInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcImage;
	$ srcImageLayout;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]],
	mod.VkStructureType,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageCopy2
)
ffi.metatype(
	mod.VkCopyImageInfo2,
	{
		__tostring = function(s)
			return ("struct VkCopyImageInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcImage,
				t.srcImageLayout,
				t.dstImage,
				t.dstImageLayout,
				t.regionCount,
				t.pRegions
			)
		end,
	}
)
mod.VkBufferImageCopy2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ bufferOffset;
	uint32_t bufferRowLength;
	uint32_t bufferImageHeight;
	$ imageSubresource;
	$ imageOffset;
	$ imageExtent;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkExtent3D
)
ffi.metatype(
	mod.VkBufferImageCopy2,
	{
		__tostring = function(s)
			return ("struct VkBufferImageCopy2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.bufferOffset,
				t.bufferRowLength,
				t.bufferImageHeight,
				t.imageSubresource,
				t.imageOffset,
				t.imageExtent
			)
		end,
	}
)
mod.VkCopyBufferToImageInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcBuffer;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]],
	mod.VkStructureType,
	mod.VkBuffer,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkBufferImageCopy2
)
ffi.metatype(
	mod.VkCopyBufferToImageInfo2,
	{
		__tostring = function(s)
			return ("struct VkCopyBufferToImageInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcBuffer,
				t.dstImage,
				t.dstImageLayout,
				t.regionCount,
				t.pRegions
			)
		end,
	}
)
mod.VkCopyImageToBufferInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcImage;
	$ srcImageLayout;
	$ dstBuffer;
	uint32_t regionCount;
	const $* pRegions;
}]],
	mod.VkStructureType,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkBuffer,
	mod.VkBufferImageCopy2
)
ffi.metatype(
	mod.VkCopyImageToBufferInfo2,
	{
		__tostring = function(s)
			return ("struct VkCopyImageToBufferInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcImage,
				t.srcImageLayout,
				t.dstBuffer,
				t.regionCount,
				t.pRegions
			)
		end,
	}
)
mod.VkImageBlit2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcSubresource;
	$ srcOffsets[2];
	$ dstSubresource;
	$ dstOffsets[2];
}]],
	mod.VkStructureType,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D
)
ffi.metatype(
	mod.VkImageBlit2,
	{
		__tostring = function(s)
			return ("struct VkImageBlit2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcSubresource,
				t.srcOffsets,
				t.dstSubresource,
				t.dstOffsets
			)
		end,
	}
)
mod.VkBlitImageInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcImage;
	$ srcImageLayout;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
	$ filter;
}]],
	mod.VkStructureType,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageBlit2,
	mod.VkFilter
)
ffi.metatype(
	mod.VkBlitImageInfo2,
	{
		__tostring = function(s)
			return ("struct VkBlitImageInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcImage,
				t.srcImageLayout,
				t.dstImage,
				t.dstImageLayout,
				t.regionCount,
				t.pRegions,
				t.filter
			)
		end,
	}
)
mod.VkImageResolve2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcSubresource;
	$ srcOffset;
	$ dstSubresource;
	$ dstOffset;
	$ extent;
}]],
	mod.VkStructureType,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkExtent3D
)
ffi.metatype(
	mod.VkImageResolve2,
	{
		__tostring = function(s)
			return ("struct VkImageResolve2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcSubresource,
				t.srcOffset,
				t.dstSubresource,
				t.dstOffset,
				t.extent
			)
		end,
	}
)
mod.VkResolveImageInfo2 = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcImage;
	$ srcImageLayout;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]],
	mod.VkStructureType,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageResolve2
)
ffi.metatype(
	mod.VkResolveImageInfo2,
	{
		__tostring = function(s)
			return ("struct VkResolveImageInfo2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcImage,
				t.srcImageLayout,
				t.dstImage,
				t.dstImageLayout,
				t.regionCount,
				t.pRegions
			)
		end,
	}
)
mod.VkPhysicalDeviceSubgroupSizeControlFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ subgroupSizeControl;
	$ computeFullSubgroups;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSubgroupSizeControlFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSubgroupSizeControlFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.subgroupSizeControl, t.computeFullSubgroups)
		end,
	}
)
mod.VkPhysicalDeviceSubgroupSizeControlProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t minSubgroupSize;
	uint32_t maxSubgroupSize;
	uint32_t maxComputeWorkgroupSubgroups;
	$ requiredSubgroupSizeStages;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags
)
ffi.metatype(
	mod.VkPhysicalDeviceSubgroupSizeControlProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSubgroupSizeControlProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.minSubgroupSize,
				t.maxSubgroupSize,
				t.maxComputeWorkgroupSubgroups,
				t.requiredSubgroupSizeStages
			)
		end,
	}
)
mod.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t requiredSubgroupSize;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.requiredSubgroupSize)
		end,
	}
)
mod.VkPhysicalDeviceInlineUniformBlockFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ inlineUniformBlock;
	$ descriptorBindingInlineUniformBlockUpdateAfterBind;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceInlineUniformBlockFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceInlineUniformBlockFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.inlineUniformBlock,
				t.descriptorBindingInlineUniformBlockUpdateAfterBind
			)
		end,
	}
)
mod.VkPhysicalDeviceInlineUniformBlockProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxInlineUniformBlockSize;
	uint32_t maxPerStageDescriptorInlineUniformBlocks;
	uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
	uint32_t maxDescriptorSetInlineUniformBlocks;
	uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceInlineUniformBlockProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceInlineUniformBlockProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxInlineUniformBlockSize,
				t.maxPerStageDescriptorInlineUniformBlocks,
				t.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks,
				t.maxDescriptorSetInlineUniformBlocks,
				t.maxDescriptorSetUpdateAfterBindInlineUniformBlocks
			)
		end,
	}
)
mod.VkWriteDescriptorSetInlineUniformBlock = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t dataSize;
	const void* pData;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkWriteDescriptorSetInlineUniformBlock,
	{
		__tostring = function(s)
			return ("struct VkWriteDescriptorSetInlineUniformBlock[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dataSize, t.pData)
		end,
	}
)
mod.VkDescriptorPoolInlineUniformBlockCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t maxInlineUniformBlockBindings;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDescriptorPoolInlineUniformBlockCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkDescriptorPoolInlineUniformBlockCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxInlineUniformBlockBindings)
		end,
	}
)
mod.VkPhysicalDeviceTextureCompressionASTCHDRFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ textureCompressionASTC_HDR;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceTextureCompressionASTCHDRFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTextureCompressionASTCHDRFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.textureCompressionASTC_HDR)
		end,
	}
)
mod.VkRenderingAttachmentInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ imageView;
	$ imageLayout;
	$ resolveMode;
	$ resolveImageView;
	$ resolveImageLayout;
	$ loadOp;
	$ storeOp;
	$ clearValue;
}]],
	mod.VkStructureType,
	mod.VkImageView,
	mod.VkImageLayout,
	mod.VkResolveModeFlagBits,
	mod.VkImageView,
	mod.VkImageLayout,
	mod.VkAttachmentLoadOp,
	mod.VkAttachmentStoreOp,
	mod.VkClearValue
)
ffi.metatype(
	mod.VkRenderingAttachmentInfo,
	{
		__tostring = function(s)
			return ("struct VkRenderingAttachmentInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.imageView,
				t.imageLayout,
				t.resolveMode,
				t.resolveImageView,
				t.resolveImageLayout,
				t.loadOp,
				t.storeOp,
				t.clearValue
			)
		end,
	}
)
mod.VkRenderingInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ renderArea;
	uint32_t layerCount;
	uint32_t viewMask;
	uint32_t colorAttachmentCount;
	const $* pColorAttachments;
	const $* pDepthAttachment;
	const $* pStencilAttachment;
}]],
	mod.VkStructureType,
	mod.VkRenderingFlags,
	mod.VkRect2D,
	mod.VkRenderingAttachmentInfo,
	mod.VkRenderingAttachmentInfo,
	mod.VkRenderingAttachmentInfo
)
ffi.metatype(
	mod.VkRenderingInfo,
	{
		__tostring = function(s)
			return ("struct VkRenderingInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.renderArea,
				t.layerCount,
				t.viewMask,
				t.colorAttachmentCount,
				t.pColorAttachments,
				t.pDepthAttachment,
				t.pStencilAttachment
			)
		end,
	}
)
mod.VkPipelineRenderingCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t viewMask;
	uint32_t colorAttachmentCount;
	const $* pColorAttachmentFormats;
	$ depthAttachmentFormat;
	$ stencilAttachmentFormat;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkFormat,
	mod.VkFormat
)
ffi.metatype(
	mod.VkPipelineRenderingCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineRenderingCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.viewMask,
				t.colorAttachmentCount,
				t.pColorAttachmentFormats,
				t.depthAttachmentFormat,
				t.stencilAttachmentFormat
			)
		end,
	}
)
mod.VkPhysicalDeviceDynamicRenderingFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ dynamicRendering;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDynamicRenderingFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDynamicRenderingFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dynamicRendering)
		end,
	}
)
mod.VkCommandBufferInheritanceRenderingInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t viewMask;
	uint32_t colorAttachmentCount;
	const $* pColorAttachmentFormats;
	$ depthAttachmentFormat;
	$ stencilAttachmentFormat;
	$ rasterizationSamples;
}]],
	mod.VkStructureType,
	mod.VkRenderingFlags,
	mod.VkFormat,
	mod.VkFormat,
	mod.VkFormat,
	mod.VkSampleCountFlagBits
)
ffi.metatype(
	mod.VkCommandBufferInheritanceRenderingInfo,
	{
		__tostring = function(s)
			return ("struct VkCommandBufferInheritanceRenderingInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.viewMask,
				t.colorAttachmentCount,
				t.pColorAttachmentFormats,
				t.depthAttachmentFormat,
				t.stencilAttachmentFormat,
				t.rasterizationSamples
			)
		end,
	}
)
mod.VkPhysicalDeviceShaderIntegerDotProductFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderIntegerDotProduct;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderIntegerDotProductFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderIntegerDotProductFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderIntegerDotProduct)
		end,
	}
)
mod.VkPhysicalDeviceShaderIntegerDotProductProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ integerDotProduct8BitUnsignedAccelerated;
	$ integerDotProduct8BitSignedAccelerated;
	$ integerDotProduct8BitMixedSignednessAccelerated;
	$ integerDotProduct4x8BitPackedUnsignedAccelerated;
	$ integerDotProduct4x8BitPackedSignedAccelerated;
	$ integerDotProduct4x8BitPackedMixedSignednessAccelerated;
	$ integerDotProduct16BitUnsignedAccelerated;
	$ integerDotProduct16BitSignedAccelerated;
	$ integerDotProduct16BitMixedSignednessAccelerated;
	$ integerDotProduct32BitUnsignedAccelerated;
	$ integerDotProduct32BitSignedAccelerated;
	$ integerDotProduct32BitMixedSignednessAccelerated;
	$ integerDotProduct64BitUnsignedAccelerated;
	$ integerDotProduct64BitSignedAccelerated;
	$ integerDotProduct64BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating8BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating16BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating32BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating64BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderIntegerDotProductProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderIntegerDotProductProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.integerDotProduct8BitUnsignedAccelerated,
				t.integerDotProduct8BitSignedAccelerated,
				t.integerDotProduct8BitMixedSignednessAccelerated,
				t.integerDotProduct4x8BitPackedUnsignedAccelerated,
				t.integerDotProduct4x8BitPackedSignedAccelerated,
				t.integerDotProduct4x8BitPackedMixedSignednessAccelerated,
				t.integerDotProduct16BitUnsignedAccelerated,
				t.integerDotProduct16BitSignedAccelerated,
				t.integerDotProduct16BitMixedSignednessAccelerated,
				t.integerDotProduct32BitUnsignedAccelerated,
				t.integerDotProduct32BitSignedAccelerated,
				t.integerDotProduct32BitMixedSignednessAccelerated,
				t.integerDotProduct64BitUnsignedAccelerated,
				t.integerDotProduct64BitSignedAccelerated,
				t.integerDotProduct64BitMixedSignednessAccelerated,
				t.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated,
				t.integerDotProductAccumulatingSaturating8BitSignedAccelerated,
				t.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated,
				t.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated,
				t.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated,
				t.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated,
				t.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated,
				t.integerDotProductAccumulatingSaturating16BitSignedAccelerated,
				t.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated,
				t.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated,
				t.integerDotProductAccumulatingSaturating32BitSignedAccelerated,
				t.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated,
				t.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated,
				t.integerDotProductAccumulatingSaturating64BitSignedAccelerated,
				t.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated
			)
		end,
	}
)
mod.VkPhysicalDeviceTexelBufferAlignmentProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ storageTexelBufferOffsetAlignmentBytes;
	$ storageTexelBufferOffsetSingleTexelAlignment;
	$ uniformTexelBufferOffsetAlignmentBytes;
	$ uniformTexelBufferOffsetSingleTexelAlignment;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize,
	mod.VkBool32,
	mod.VkDeviceSize,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceTexelBufferAlignmentProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTexelBufferAlignmentProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.storageTexelBufferOffsetAlignmentBytes,
				t.storageTexelBufferOffsetSingleTexelAlignment,
				t.uniformTexelBufferOffsetAlignmentBytes,
				t.uniformTexelBufferOffsetSingleTexelAlignment
			)
		end,
	}
)
mod.VkFormatProperties3 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ linearTilingFeatures;
	$ optimalTilingFeatures;
	$ bufferFeatures;
}]],
	mod.VkStructureType,
	mod.VkFormatFeatureFlags2,
	mod.VkFormatFeatureFlags2,
	mod.VkFormatFeatureFlags2
)
ffi.metatype(
	mod.VkFormatProperties3,
	{
		__tostring = function(s)
			return ("struct VkFormatProperties3[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.linearTilingFeatures,
				t.optimalTilingFeatures,
				t.bufferFeatures
			)
		end,
	}
)
mod.VkPhysicalDeviceMaintenance4Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maintenance4;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance4Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance4Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maintenance4)
		end,
	}
)
mod.VkPhysicalDeviceMaintenance4Properties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maxBufferSize;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance4Properties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance4Properties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxBufferSize)
		end,
	}
)
mod.VkDeviceBufferMemoryRequirements = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pCreateInfo;
}]],
	mod.VkStructureType,
	mod.VkBufferCreateInfo
)
ffi.metatype(
	mod.VkDeviceBufferMemoryRequirements,
	{
		__tostring = function(s)
			return ("struct VkDeviceBufferMemoryRequirements[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pCreateInfo)
		end,
	}
)
mod.VkDeviceImageMemoryRequirements = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pCreateInfo;
	$ planeAspect;
}]],
	mod.VkStructureType,
	mod.VkImageCreateInfo,
	mod.VkImageAspectFlagBits
)
ffi.metatype(
	mod.VkDeviceImageMemoryRequirements,
	{
		__tostring = function(s)
			return ("struct VkDeviceImageMemoryRequirements[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pCreateInfo, t.planeAspect)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceToolProperties = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceToolProperties
)
mod.PFN_vkCreatePrivateDataSlot = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPrivateDataSlotCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPrivateDataSlot
)
mod.PFN_vkDestroyPrivateDataSlot = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkPrivateDataSlot,
	mod.VkAllocationCallbacks
)
mod.PFN_vkSetPrivateData = ffi.typeof(
	[[$ (*)($ , $ , uint64_t , $ , uint64_t )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkObjectType,
	mod.VkPrivateDataSlot
)
mod.PFN_vkGetPrivateData = ffi.typeof(
	[[void (*)($ , $ , uint64_t , $ , uint64_t*)]],
	mod.VkDevice,
	mod.VkObjectType,
	mod.VkPrivateDataSlot
)
mod.PFN_vkCmdSetEvent2 = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkDependencyInfo
)
mod.PFN_vkCmdResetEvent2 = ffi.typeof(
	[[void (*)($ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkPipelineStageFlags2
)
mod.PFN_vkCmdWaitEvents2 = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkDependencyInfo
)
mod.PFN_vkCmdPipelineBarrier2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDependencyInfo)
mod.PFN_vkCmdWriteTimestamp2 = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlags2,
	mod.VkQueryPool
)
mod.PFN_vkQueueSubmit2 = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*, $ )]],
	mod.VkResult,
	mod.VkQueue,
	mod.VkSubmitInfo2,
	mod.VkFence
)
mod.PFN_vkCmdCopyBuffer2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyBufferInfo2)
mod.PFN_vkCmdCopyImage2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyImageInfo2)
mod.PFN_vkCmdCopyBufferToImage2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyBufferToImageInfo2)
mod.PFN_vkCmdCopyImageToBuffer2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyImageToBufferInfo2)
mod.PFN_vkCmdBlitImage2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkBlitImageInfo2)
mod.PFN_vkCmdResolveImage2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkResolveImageInfo2)
mod.PFN_vkCmdBeginRendering = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkRenderingInfo)
mod.PFN_vkCmdEndRendering = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetCullMode = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCullModeFlags)
mod.PFN_vkCmdSetFrontFace = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkFrontFace)
mod.PFN_vkCmdSetPrimitiveTopology = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkPrimitiveTopology)
mod.PFN_vkCmdSetViewportWithCount = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkViewport)
mod.PFN_vkCmdSetScissorWithCount = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkRect2D)
mod.PFN_vkCmdBindVertexBuffers2 = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*, const $*, const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
mod.PFN_vkCmdSetDepthTestEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthWriteEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthCompareOp = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCompareOp)
mod.PFN_vkCmdSetDepthBoundsTestEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetStencilTestEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetStencilOp = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkStencilFaceFlags,
	mod.VkStencilOp,
	mod.VkStencilOp,
	mod.VkStencilOp,
	mod.VkCompareOp
)
mod.PFN_vkCmdSetRasterizerDiscardEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthBiasEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetPrimitiveRestartEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkGetDeviceBufferMemoryRequirements = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkDeviceBufferMemoryRequirements,
	mod.VkMemoryRequirements2
)
mod.PFN_vkGetDeviceImageMemoryRequirements = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkDeviceImageMemoryRequirements,
	mod.VkMemoryRequirements2
)
mod.PFN_vkGetDeviceImageSparseMemoryRequirements = ffi.typeof(
	[[void (*)($ , const $*, uint32_t*, $*)]],
	mod.VkDevice,
	mod.VkDeviceImageMemoryRequirements,
	mod.VkSparseImageMemoryRequirements2
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceToolProperties($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceToolProperties
)
ffi.cdef(
	[[$  vkCreatePrivateDataSlot($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPrivateDataSlotCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPrivateDataSlot
)
ffi.cdef(
	[[void  vkDestroyPrivateDataSlot($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkPrivateDataSlot,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkSetPrivateData($ , $ , uint64_t , $ , uint64_t );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkObjectType,
	mod.VkPrivateDataSlot
)
ffi.cdef(
	[[void  vkGetPrivateData($ , $ , uint64_t , $ , uint64_t*);]],
	mod.VkDevice,
	mod.VkObjectType,
	mod.VkPrivateDataSlot
)
ffi.cdef(
	[[void  vkCmdSetEvent2($ , $ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkDependencyInfo
)
ffi.cdef(
	[[void  vkCmdResetEvent2($ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkPipelineStageFlags2
)
ffi.cdef(
	[[void  vkCmdWaitEvents2($ , uint32_t , const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkDependencyInfo
)
ffi.cdef(
	[[void  vkCmdPipelineBarrier2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDependencyInfo
)
ffi.cdef(
	[[void  vkCmdWriteTimestamp2($ , $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlags2,
	mod.VkQueryPool
)
ffi.cdef(
	[[$  vkQueueSubmit2($ , uint32_t , const $*, $ );]],
	mod.VkResult,
	mod.VkQueue,
	mod.VkSubmitInfo2,
	mod.VkFence
)
ffi.cdef(
	[[void  vkCmdCopyBuffer2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyBufferInfo2
)
ffi.cdef(
	[[void  vkCmdCopyImage2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyImageInfo2
)
ffi.cdef(
	[[void  vkCmdCopyBufferToImage2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyBufferToImageInfo2
)
ffi.cdef(
	[[void  vkCmdCopyImageToBuffer2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyImageToBufferInfo2
)
ffi.cdef(
	[[void  vkCmdBlitImage2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBlitImageInfo2
)
ffi.cdef(
	[[void  vkCmdResolveImage2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkResolveImageInfo2
)
ffi.cdef(
	[[void  vkCmdBeginRendering($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRenderingInfo
)
ffi.cdef([[void  vkCmdEndRendering($ );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetCullMode($ , $ );]], mod.VkCommandBuffer, mod.VkCullModeFlags)
ffi.cdef([[void  vkCmdSetFrontFace($ , $ );]], mod.VkCommandBuffer, mod.VkFrontFace)
ffi.cdef(
	[[void  vkCmdSetPrimitiveTopology($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkPrimitiveTopology
)
ffi.cdef(
	[[void  vkCmdSetViewportWithCount($ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkViewport
)
ffi.cdef(
	[[void  vkCmdSetScissorWithCount($ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRect2D
)
ffi.cdef(
	[[void  vkCmdBindVertexBuffers2($ , uint32_t , uint32_t , const $*, const $*, const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.cdef([[void  vkCmdSetDepthTestEnable($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetDepthWriteEnable($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetDepthCompareOp($ , $ );]], mod.VkCommandBuffer, mod.VkCompareOp)
ffi.cdef(
	[[void  vkCmdSetDepthBoundsTestEnable($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef([[void  vkCmdSetStencilTestEnable($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef(
	[[void  vkCmdSetStencilOp($ , $ , $ , $ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkStencilFaceFlags,
	mod.VkStencilOp,
	mod.VkStencilOp,
	mod.VkStencilOp,
	mod.VkCompareOp
)
ffi.cdef(
	[[void  vkCmdSetRasterizerDiscardEnable($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef([[void  vkCmdSetDepthBiasEnable($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef(
	[[void  vkCmdSetPrimitiveRestartEnable($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkGetDeviceBufferMemoryRequirements($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDeviceBufferMemoryRequirements,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkGetDeviceImageMemoryRequirements($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDeviceImageMemoryRequirements,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkGetDeviceImageSparseMemoryRequirements($ , const $*, uint32_t*, $*);]],
	mod.VkDevice,
	mod.VkDeviceImageMemoryRequirements,
	mod.VkSparseImageMemoryRequirements2
)
mod.VkPipelineRobustnessBufferBehavior = ffi.typeof([[enum {
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT = 0,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED = 1,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS = 2,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 = 3,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineRobustnessImageBehavior = ffi.typeof([[enum {
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT = 0,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED = 1,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS = 2,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2 = 3,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueueGlobalPriority = ffi.typeof([[enum {
	VK_QUEUE_GLOBAL_PRIORITY_LOW = 128,
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM = 256,
	VK_QUEUE_GLOBAL_PRIORITY_HIGH = 512,
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME = 1024,
	VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = VK_QUEUE_GLOBAL_PRIORITY_LOW,
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
	VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = VK_QUEUE_GLOBAL_PRIORITY_HIGH,
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
	VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR = VK_QUEUE_GLOBAL_PRIORITY_LOW,
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
	VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR = VK_QUEUE_GLOBAL_PRIORITY_HIGH,
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR = VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
	VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkLineRasterizationMode = ffi.typeof([[enum {
	VK_LINE_RASTERIZATION_MODE_DEFAULT = 0,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR = 1,
	VK_LINE_RASTERIZATION_MODE_BRESENHAM = 2,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH = 3,
	VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = VK_LINE_RASTERIZATION_MODE_DEFAULT,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
	VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = VK_LINE_RASTERIZATION_MODE_BRESENHAM,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
	VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR = VK_LINE_RASTERIZATION_MODE_DEFAULT,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR = VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
	VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR = VK_LINE_RASTERIZATION_MODE_BRESENHAM,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
	VK_LINE_RASTERIZATION_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryUnmapFlagBits = ffi.typeof([[enum {
	VK_MEMORY_UNMAP_RESERVE_BIT_EXT = 0x00000001,
	VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryUnmapFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCreateFlags2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkPipelineCreateFlagBits2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT = 0x00000001ULL
mod.VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT = 0x00000002ULL
mod.VK_PIPELINE_CREATE_2_DERIVATIVE_BIT = 0x00000004ULL
mod.VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008ULL
mod.VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT = 0x00000010ULL
mod.VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100ULL
mod.VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200ULL
mod.VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT = 0x08000000ULL
mod.VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT = 0x40000000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_BUILT_IN_PRIMITIVES_BIT_KHR = 0x00001000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV = 0x200000000ULL
mod.VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x400000000ULL
mod.VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR = 0x00000001ULL
mod.VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR = 0x00000002ULL
mod.VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR = 0x00000004ULL
mod.VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 0x00000008ULL
mod.VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR = 0x00000010ULL
mod.VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV = 0x00000020ULL
mod.VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR = 0x00000040ULL
mod.VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080ULL
mod.VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR = 0x00000100ULL
mod.VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR = 0x00000200ULL
mod.VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x00000400ULL
mod.VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x00800000ULL
mod.VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR = 0x00000800ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000ULL
mod.VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV = 0x00040000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000ULL
mod.VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000ULL
mod.VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x01000000ULL
mod.VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x02000000ULL
mod.VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x04000000ULL
mod.VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT = 0x08000000ULL
mod.VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT = 0x40000000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = 0x10000000ULL
mod.VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT = 0x20000000ULL
mod.VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM = 0x2000000000ULL
mod.VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR = 0x80000000ULL
mod.VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT = 0x4000000000ULL
mod.VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = 0x10000000000ULL
mod.VkBufferUsageFlags2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkBufferUsageFlagBits2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT = 0x00000001ULL
mod.VK_BUFFER_USAGE_2_TRANSFER_DST_BIT = 0x00000002ULL
mod.VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004ULL
mod.VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT = 0x00000008ULL
mod.VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT = 0x00000010ULL
mod.VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT = 0x00000020ULL
mod.VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT = 0x00000040ULL
mod.VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT = 0x00000080ULL
mod.VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT = 0x00000100ULL
mod.VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT = 0x00020000ULL
mod.VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR = 0x00000001ULL
mod.VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR = 0x00000002ULL
mod.VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 0x00000004ULL
mod.VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 0x00000008ULL
mod.VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR = 0x00000010ULL
mod.VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR = 0x00000020ULL
mod.VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR = 0x00000040ULL
mod.VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR = 0x00000080ULL
mod.VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR = 0x00000100ULL
mod.VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200ULL
mod.VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400ULL
mod.VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV = 0x00000400ULL
mod.VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800ULL
mod.VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000ULL
mod.VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000ULL
mod.VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR = 0x00004000ULL
mod.VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000ULL
mod.VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000ULL
mod.VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR = 0x00020000ULL
mod.VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000ULL
mod.VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000ULL
mod.VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x00200000ULL
mod.VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00400000ULL
mod.VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000ULL
mod.VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x00800000ULL
mod.VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT = 0x01000000ULL
mod.VK_BUFFER_USAGE_2_DATA_GRAPH_FOREIGN_DESCRIPTOR_BIT_ARM = 0x20000000ULL
mod.VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM = 0x08000000ULL
mod.VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT = 0x80000000ULL
mod.VkHostImageCopyFlagBits = ffi.typeof([[enum {
	VK_HOST_IMAGE_COPY_MEMCPY_BIT = 0x00000001,
	VK_HOST_IMAGE_COPY_MEMCPY = VK_HOST_IMAGE_COPY_MEMCPY_BIT,
	VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT = VK_HOST_IMAGE_COPY_MEMCPY_BIT,
	VK_HOST_IMAGE_COPY_MEMCPY_EXT = VK_HOST_IMAGE_COPY_MEMCPY_BIT,
	VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkHostImageCopyFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceVulkan14Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ globalPriorityQuery;
	$ shaderSubgroupRotate;
	$ shaderSubgroupRotateClustered;
	$ shaderFloatControls2;
	$ shaderExpectAssume;
	$ rectangularLines;
	$ bresenhamLines;
	$ smoothLines;
	$ stippledRectangularLines;
	$ stippledBresenhamLines;
	$ stippledSmoothLines;
	$ vertexAttributeInstanceRateDivisor;
	$ vertexAttributeInstanceRateZeroDivisor;
	$ indexTypeUint8;
	$ dynamicRenderingLocalRead;
	$ maintenance5;
	$ maintenance6;
	$ pipelineProtectedAccess;
	$ pipelineRobustness;
	$ hostImageCopy;
	$ pushDescriptor;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVulkan14Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVulkan14Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.globalPriorityQuery,
				t.shaderSubgroupRotate,
				t.shaderSubgroupRotateClustered,
				t.shaderFloatControls2,
				t.shaderExpectAssume,
				t.rectangularLines,
				t.bresenhamLines,
				t.smoothLines,
				t.stippledRectangularLines,
				t.stippledBresenhamLines,
				t.stippledSmoothLines,
				t.vertexAttributeInstanceRateDivisor,
				t.vertexAttributeInstanceRateZeroDivisor,
				t.indexTypeUint8,
				t.dynamicRenderingLocalRead,
				t.maintenance5,
				t.maintenance6,
				t.pipelineProtectedAccess,
				t.pipelineRobustness,
				t.hostImageCopy,
				t.pushDescriptor
			)
		end,
	}
)
mod.VkPhysicalDeviceVulkan14Properties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t lineSubPixelPrecisionBits;
	uint32_t maxVertexAttribDivisor;
	$ supportsNonZeroFirstInstance;
	uint32_t maxPushDescriptors;
	$ dynamicRenderingLocalReadDepthStencilAttachments;
	$ dynamicRenderingLocalReadMultisampledAttachments;
	$ earlyFragmentMultisampleCoverageAfterSampleCounting;
	$ earlyFragmentSampleMaskTestBeforeSampleCounting;
	$ depthStencilSwizzleOneSupport;
	$ polygonModePointSize;
	$ nonStrictSinglePixelWideLinesUseParallelogram;
	$ nonStrictWideLinesUseParallelogram;
	$ blockTexelViewCompatibleMultipleLayers;
	uint32_t maxCombinedImageSamplerDescriptorCount;
	$ fragmentShadingRateClampCombinerInputs;
	$ defaultRobustnessStorageBuffers;
	$ defaultRobustnessUniformBuffers;
	$ defaultRobustnessVertexInputs;
	$ defaultRobustnessImages;
	uint32_t copySrcLayoutCount;
	$* pCopySrcLayouts;
	uint32_t copyDstLayoutCount;
	$* pCopyDstLayouts;
	uint8_t optimalTilingLayoutUUID[16U];
	$ identicalMemoryTypeRequirements;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkPipelineRobustnessBufferBehavior,
	mod.VkPipelineRobustnessBufferBehavior,
	mod.VkPipelineRobustnessBufferBehavior,
	mod.VkPipelineRobustnessImageBehavior,
	mod.VkImageLayout,
	mod.VkImageLayout,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVulkan14Properties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVulkan14Properties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.lineSubPixelPrecisionBits,
				t.maxVertexAttribDivisor,
				t.supportsNonZeroFirstInstance,
				t.maxPushDescriptors,
				t.dynamicRenderingLocalReadDepthStencilAttachments,
				t.dynamicRenderingLocalReadMultisampledAttachments,
				t.earlyFragmentMultisampleCoverageAfterSampleCounting,
				t.earlyFragmentSampleMaskTestBeforeSampleCounting,
				t.depthStencilSwizzleOneSupport,
				t.polygonModePointSize,
				t.nonStrictSinglePixelWideLinesUseParallelogram,
				t.nonStrictWideLinesUseParallelogram,
				t.blockTexelViewCompatibleMultipleLayers,
				t.maxCombinedImageSamplerDescriptorCount,
				t.fragmentShadingRateClampCombinerInputs,
				t.defaultRobustnessStorageBuffers,
				t.defaultRobustnessUniformBuffers,
				t.defaultRobustnessVertexInputs,
				t.defaultRobustnessImages,
				t.copySrcLayoutCount,
				t.pCopySrcLayouts,
				t.copyDstLayoutCount,
				t.pCopyDstLayouts,
				t.optimalTilingLayoutUUID,
				t.identicalMemoryTypeRequirements
			)
		end,
	}
)
mod.VkDeviceQueueGlobalPriorityCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ globalPriority;
}]],
	mod.VkStructureType,
	mod.VkQueueGlobalPriority
)
ffi.metatype(
	mod.VkDeviceQueueGlobalPriorityCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkDeviceQueueGlobalPriorityCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.globalPriority)
		end,
	}
)
mod.VkPhysicalDeviceGlobalPriorityQueryFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ globalPriorityQuery;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceGlobalPriorityQueryFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceGlobalPriorityQueryFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.globalPriorityQuery)
		end,
	}
)
mod.VkQueueFamilyGlobalPriorityProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t priorityCount;
	$ priorities[16U];
}]],
	mod.VkStructureType,
	mod.VkQueueGlobalPriority
)
ffi.metatype(
	mod.VkQueueFamilyGlobalPriorityProperties,
	{
		__tostring = function(s)
			return ("struct VkQueueFamilyGlobalPriorityProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.priorityCount, t.priorities)
		end,
	}
)
mod.VkPhysicalDeviceShaderSubgroupRotateFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderSubgroupRotate;
	$ shaderSubgroupRotateClustered;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderSubgroupRotateFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderSubgroupRotateFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderSubgroupRotate, t.shaderSubgroupRotateClustered)
		end,
	}
)
mod.VkPhysicalDeviceShaderFloatControls2Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderFloatControls2;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderFloatControls2Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderFloatControls2Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderFloatControls2)
		end,
	}
)
mod.VkPhysicalDeviceShaderExpectAssumeFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderExpectAssume;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderExpectAssumeFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderExpectAssumeFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderExpectAssume)
		end,
	}
)
mod.VkPhysicalDeviceLineRasterizationFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ rectangularLines;
	$ bresenhamLines;
	$ smoothLines;
	$ stippledRectangularLines;
	$ stippledBresenhamLines;
	$ stippledSmoothLines;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceLineRasterizationFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceLineRasterizationFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.rectangularLines,
				t.bresenhamLines,
				t.smoothLines,
				t.stippledRectangularLines,
				t.stippledBresenhamLines,
				t.stippledSmoothLines
			)
		end,
	}
)
mod.VkPhysicalDeviceLineRasterizationProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t lineSubPixelPrecisionBits;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceLineRasterizationProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceLineRasterizationProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.lineSubPixelPrecisionBits)
		end,
	}
)
mod.VkPipelineRasterizationLineStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ lineRasterizationMode;
	$ stippledLineEnable;
	uint32_t lineStippleFactor;
	uint16_t lineStipplePattern;
}]],
	mod.VkStructureType,
	mod.VkLineRasterizationMode,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPipelineRasterizationLineStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineRasterizationLineStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.lineRasterizationMode,
				t.stippledLineEnable,
				t.lineStippleFactor,
				t.lineStipplePattern
			)
		end,
	}
)
mod.VkPhysicalDeviceVertexAttributeDivisorProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxVertexAttribDivisor;
	$ supportsNonZeroFirstInstance;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVertexAttributeDivisorProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVertexAttributeDivisorProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxVertexAttribDivisor, t.supportsNonZeroFirstInstance)
		end,
	}
)
mod.VkVertexInputBindingDivisorDescription = ffi.typeof([[struct {
	uint32_t binding;
	uint32_t divisor;
}]])
ffi.metatype(
	mod.VkVertexInputBindingDivisorDescription,
	{
		__tostring = function(s)
			return ("struct VkVertexInputBindingDivisorDescription[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.binding, t.divisor)
		end,
	}
)
mod.VkPipelineVertexInputDivisorStateCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t vertexBindingDivisorCount;
	const $* pVertexBindingDivisors;
}]],
	mod.VkStructureType,
	mod.VkVertexInputBindingDivisorDescription
)
ffi.metatype(
	mod.VkPipelineVertexInputDivisorStateCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineVertexInputDivisorStateCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.vertexBindingDivisorCount, t.pVertexBindingDivisors)
		end,
	}
)
mod.VkPhysicalDeviceVertexAttributeDivisorFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ vertexAttributeInstanceRateDivisor;
	$ vertexAttributeInstanceRateZeroDivisor;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVertexAttributeDivisorFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVertexAttributeDivisorFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.vertexAttributeInstanceRateDivisor,
				t.vertexAttributeInstanceRateZeroDivisor
			)
		end,
	}
)
mod.VkPhysicalDeviceIndexTypeUint8Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ indexTypeUint8;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceIndexTypeUint8Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceIndexTypeUint8Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.indexTypeUint8)
		end,
	}
)
mod.VkMemoryMapInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ memory;
	$ offset;
	$ size;
}]],
	mod.VkStructureType,
	mod.VkMemoryMapFlags,
	mod.VkDeviceMemory,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkMemoryMapInfo,
	{
		__tostring = function(s)
			return ("struct VkMemoryMapInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.memory, t.offset, t.size)
		end,
	}
)
mod.VkMemoryUnmapInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ memory;
}]],
	mod.VkStructureType,
	mod.VkMemoryUnmapFlags,
	mod.VkDeviceMemory
)
ffi.metatype(
	mod.VkMemoryUnmapInfo,
	{
		__tostring = function(s)
			return ("struct VkMemoryUnmapInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.memory)
		end,
	}
)
mod.VkPhysicalDeviceMaintenance5Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maintenance5;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance5Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance5Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maintenance5)
		end,
	}
)
mod.VkPhysicalDeviceMaintenance5Properties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ earlyFragmentMultisampleCoverageAfterSampleCounting;
	$ earlyFragmentSampleMaskTestBeforeSampleCounting;
	$ depthStencilSwizzleOneSupport;
	$ polygonModePointSize;
	$ nonStrictSinglePixelWideLinesUseParallelogram;
	$ nonStrictWideLinesUseParallelogram;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance5Properties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance5Properties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.earlyFragmentMultisampleCoverageAfterSampleCounting,
				t.earlyFragmentSampleMaskTestBeforeSampleCounting,
				t.depthStencilSwizzleOneSupport,
				t.polygonModePointSize,
				t.nonStrictSinglePixelWideLinesUseParallelogram,
				t.nonStrictWideLinesUseParallelogram
			)
		end,
	}
)
mod.VkRenderingAreaInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t viewMask;
	uint32_t colorAttachmentCount;
	const $* pColorAttachmentFormats;
	$ depthAttachmentFormat;
	$ stencilAttachmentFormat;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkFormat,
	mod.VkFormat
)
ffi.metatype(
	mod.VkRenderingAreaInfo,
	{
		__tostring = function(s)
			return ("struct VkRenderingAreaInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.viewMask,
				t.colorAttachmentCount,
				t.pColorAttachmentFormats,
				t.depthAttachmentFormat,
				t.stencilAttachmentFormat
			)
		end,
	}
)
mod.VkImageSubresource2 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ imageSubresource;
}]],
	mod.VkStructureType,
	mod.VkImageSubresource
)
ffi.metatype(
	mod.VkImageSubresource2,
	{
		__tostring = function(s)
			return ("struct VkImageSubresource2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageSubresource)
		end,
	}
)
mod.VkDeviceImageSubresourceInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pCreateInfo;
	const $* pSubresource;
}]],
	mod.VkStructureType,
	mod.VkImageCreateInfo,
	mod.VkImageSubresource2
)
ffi.metatype(
	mod.VkDeviceImageSubresourceInfo,
	{
		__tostring = function(s)
			return ("struct VkDeviceImageSubresourceInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pCreateInfo, t.pSubresource)
		end,
	}
)
mod.VkSubresourceLayout2 = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ subresourceLayout;
}]],
	mod.VkStructureType,
	mod.VkSubresourceLayout
)
ffi.metatype(
	mod.VkSubresourceLayout2,
	{
		__tostring = function(s)
			return ("struct VkSubresourceLayout2[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.subresourceLayout)
		end,
	}
)
mod.VkPipelineCreateFlags2CreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkPipelineCreateFlags2
)
ffi.metatype(
	mod.VkPipelineCreateFlags2CreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineCreateFlags2CreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.VkBufferUsageFlags2CreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ usage;
}]],
	mod.VkStructureType,
	mod.VkBufferUsageFlags2
)
ffi.metatype(
	mod.VkBufferUsageFlags2CreateInfo,
	{
		__tostring = function(s)
			return ("struct VkBufferUsageFlags2CreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.usage)
		end,
	}
)
mod.VkPhysicalDevicePushDescriptorProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxPushDescriptors;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDevicePushDescriptorProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePushDescriptorProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxPushDescriptors)
		end,
	}
)
mod.VkPhysicalDeviceDynamicRenderingLocalReadFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ dynamicRenderingLocalRead;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDynamicRenderingLocalReadFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDynamicRenderingLocalReadFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dynamicRenderingLocalRead)
		end,
	}
)
mod.VkRenderingAttachmentLocationInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t colorAttachmentCount;
	const uint32_t* pColorAttachmentLocations;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkRenderingAttachmentLocationInfo,
	{
		__tostring = function(s)
			return ("struct VkRenderingAttachmentLocationInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.colorAttachmentCount, t.pColorAttachmentLocations)
		end,
	}
)
mod.VkRenderingInputAttachmentIndexInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t colorAttachmentCount;
	const uint32_t* pColorAttachmentInputIndices;
	const uint32_t* pDepthInputAttachmentIndex;
	const uint32_t* pStencilInputAttachmentIndex;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkRenderingInputAttachmentIndexInfo,
	{
		__tostring = function(s)
			return ("struct VkRenderingInputAttachmentIndexInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.colorAttachmentCount,
				t.pColorAttachmentInputIndices,
				t.pDepthInputAttachmentIndex,
				t.pStencilInputAttachmentIndex
			)
		end,
	}
)
mod.VkPhysicalDeviceMaintenance6Features = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maintenance6;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance6Features,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance6Features[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maintenance6)
		end,
	}
)
mod.VkPhysicalDeviceMaintenance6Properties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ blockTexelViewCompatibleMultipleLayers;
	uint32_t maxCombinedImageSamplerDescriptorCount;
	$ fragmentShadingRateClampCombinerInputs;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance6Properties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance6Properties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.blockTexelViewCompatibleMultipleLayers,
				t.maxCombinedImageSamplerDescriptorCount,
				t.fragmentShadingRateClampCombinerInputs
			)
		end,
	}
)
mod.VkBindMemoryStatus = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$* pResult;
}]],
	mod.VkStructureType,
	mod.VkResult
)
ffi.metatype(
	mod.VkBindMemoryStatus,
	{
		__tostring = function(s)
			return ("struct VkBindMemoryStatus[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pResult)
		end,
	}
)
mod.VkBindDescriptorSetsInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stageFlags;
	$ layout;
	uint32_t firstSet;
	uint32_t descriptorSetCount;
	const $* pDescriptorSets;
	uint32_t dynamicOffsetCount;
	const uint32_t* pDynamicOffsets;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags,
	mod.VkPipelineLayout,
	mod.VkDescriptorSet
)
ffi.metatype(
	mod.VkBindDescriptorSetsInfo,
	{
		__tostring = function(s)
			return ("struct VkBindDescriptorSetsInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.stageFlags,
				t.layout,
				t.firstSet,
				t.descriptorSetCount,
				t.pDescriptorSets,
				t.dynamicOffsetCount,
				t.pDynamicOffsets
			)
		end,
	}
)
mod.VkPushConstantsInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ layout;
	$ stageFlags;
	uint32_t offset;
	uint32_t size;
	const void* pValues;
}]],
	mod.VkStructureType,
	mod.VkPipelineLayout,
	mod.VkShaderStageFlags
)
ffi.metatype(
	mod.VkPushConstantsInfo,
	{
		__tostring = function(s)
			return ("struct VkPushConstantsInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.layout, t.stageFlags, t.offset, t.size, t.pValues)
		end,
	}
)
mod.VkPushDescriptorSetInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stageFlags;
	$ layout;
	uint32_t set;
	uint32_t descriptorWriteCount;
	const $* pDescriptorWrites;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags,
	mod.VkPipelineLayout,
	mod.VkWriteDescriptorSet
)
ffi.metatype(
	mod.VkPushDescriptorSetInfo,
	{
		__tostring = function(s)
			return ("struct VkPushDescriptorSetInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.stageFlags,
				t.layout,
				t.set,
				t.descriptorWriteCount,
				t.pDescriptorWrites
			)
		end,
	}
)
mod.VkPushDescriptorSetWithTemplateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ descriptorUpdateTemplate;
	$ layout;
	uint32_t set;
	const void* pData;
}]],
	mod.VkStructureType,
	mod.VkDescriptorUpdateTemplate,
	mod.VkPipelineLayout
)
ffi.metatype(
	mod.VkPushDescriptorSetWithTemplateInfo,
	{
		__tostring = function(s)
			return ("struct VkPushDescriptorSetWithTemplateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.descriptorUpdateTemplate, t.layout, t.set, t.pData)
		end,
	}
)
mod.VkPhysicalDevicePipelineProtectedAccessFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelineProtectedAccess;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePipelineProtectedAccessFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePipelineProtectedAccessFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineProtectedAccess)
		end,
	}
)
mod.VkPhysicalDevicePipelineRobustnessFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelineRobustness;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePipelineRobustnessFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePipelineRobustnessFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineRobustness)
		end,
	}
)
mod.VkPhysicalDevicePipelineRobustnessProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ defaultRobustnessStorageBuffers;
	$ defaultRobustnessUniformBuffers;
	$ defaultRobustnessVertexInputs;
	$ defaultRobustnessImages;
}]],
	mod.VkStructureType,
	mod.VkPipelineRobustnessBufferBehavior,
	mod.VkPipelineRobustnessBufferBehavior,
	mod.VkPipelineRobustnessBufferBehavior,
	mod.VkPipelineRobustnessImageBehavior
)
ffi.metatype(
	mod.VkPhysicalDevicePipelineRobustnessProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePipelineRobustnessProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.defaultRobustnessStorageBuffers,
				t.defaultRobustnessUniformBuffers,
				t.defaultRobustnessVertexInputs,
				t.defaultRobustnessImages
			)
		end,
	}
)
mod.VkPipelineRobustnessCreateInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ storageBuffers;
	$ uniformBuffers;
	$ vertexInputs;
	$ images;
}]],
	mod.VkStructureType,
	mod.VkPipelineRobustnessBufferBehavior,
	mod.VkPipelineRobustnessBufferBehavior,
	mod.VkPipelineRobustnessBufferBehavior,
	mod.VkPipelineRobustnessImageBehavior
)
ffi.metatype(
	mod.VkPipelineRobustnessCreateInfo,
	{
		__tostring = function(s)
			return ("struct VkPipelineRobustnessCreateInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.storageBuffers,
				t.uniformBuffers,
				t.vertexInputs,
				t.images
			)
		end,
	}
)
mod.VkPhysicalDeviceHostImageCopyFeatures = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ hostImageCopy;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceHostImageCopyFeatures,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceHostImageCopyFeatures[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.hostImageCopy)
		end,
	}
)
mod.VkPhysicalDeviceHostImageCopyProperties = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t copySrcLayoutCount;
	$* pCopySrcLayouts;
	uint32_t copyDstLayoutCount;
	$* pCopyDstLayouts;
	uint8_t optimalTilingLayoutUUID[16U];
	$ identicalMemoryTypeRequirements;
}]],
	mod.VkStructureType,
	mod.VkImageLayout,
	mod.VkImageLayout,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceHostImageCopyProperties,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceHostImageCopyProperties[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.copySrcLayoutCount,
				t.pCopySrcLayouts,
				t.copyDstLayoutCount,
				t.pCopyDstLayouts,
				t.optimalTilingLayoutUUID,
				t.identicalMemoryTypeRequirements
			)
		end,
	}
)
mod.VkMemoryToImageCopy = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const void* pHostPointer;
	uint32_t memoryRowLength;
	uint32_t memoryImageHeight;
	$ imageSubresource;
	$ imageOffset;
	$ imageExtent;
}]],
	mod.VkStructureType,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkExtent3D
)
ffi.metatype(
	mod.VkMemoryToImageCopy,
	{
		__tostring = function(s)
			return ("struct VkMemoryToImageCopy[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pHostPointer,
				t.memoryRowLength,
				t.memoryImageHeight,
				t.imageSubresource,
				t.imageOffset,
				t.imageExtent
			)
		end,
	}
)
mod.VkImageToMemoryCopy = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	void* pHostPointer;
	uint32_t memoryRowLength;
	uint32_t memoryImageHeight;
	$ imageSubresource;
	$ imageOffset;
	$ imageExtent;
}]],
	mod.VkStructureType,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkExtent3D
)
ffi.metatype(
	mod.VkImageToMemoryCopy,
	{
		__tostring = function(s)
			return ("struct VkImageToMemoryCopy[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pHostPointer,
				t.memoryRowLength,
				t.memoryImageHeight,
				t.imageSubresource,
				t.imageOffset,
				t.imageExtent
			)
		end,
	}
)
mod.VkCopyMemoryToImageInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]],
	mod.VkStructureType,
	mod.VkHostImageCopyFlags,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkMemoryToImageCopy
)
ffi.metatype(
	mod.VkCopyMemoryToImageInfo,
	{
		__tostring = function(s)
			return ("struct VkCopyMemoryToImageInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.dstImage,
				t.dstImageLayout,
				t.regionCount,
				t.pRegions
			)
		end,
	}
)
mod.VkCopyImageToMemoryInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ srcImage;
	$ srcImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]],
	mod.VkStructureType,
	mod.VkHostImageCopyFlags,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageToMemoryCopy
)
ffi.metatype(
	mod.VkCopyImageToMemoryInfo,
	{
		__tostring = function(s)
			return ("struct VkCopyImageToMemoryInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.srcImage,
				t.srcImageLayout,
				t.regionCount,
				t.pRegions
			)
		end,
	}
)
mod.VkCopyImageToImageInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ srcImage;
	$ srcImageLayout;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]],
	mod.VkStructureType,
	mod.VkHostImageCopyFlags,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageCopy2
)
ffi.metatype(
	mod.VkCopyImageToImageInfo,
	{
		__tostring = function(s)
			return ("struct VkCopyImageToImageInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.srcImage,
				t.srcImageLayout,
				t.dstImage,
				t.dstImageLayout,
				t.regionCount,
				t.pRegions
			)
		end,
	}
)
mod.VkHostImageLayoutTransitionInfo = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ oldLayout;
	$ newLayout;
	$ subresourceRange;
}]],
	mod.VkStructureType,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageLayout,
	mod.VkImageSubresourceRange
)
ffi.metatype(
	mod.VkHostImageLayoutTransitionInfo,
	{
		__tostring = function(s)
			return ("struct VkHostImageLayoutTransitionInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.image, t.oldLayout, t.newLayout, t.subresourceRange)
		end,
	}
)
mod.VkSubresourceHostMemcpySize = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ size;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkSubresourceHostMemcpySize,
	{
		__tostring = function(s)
			return ("struct VkSubresourceHostMemcpySize[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.size)
		end,
	}
)
mod.VkHostImageCopyDevicePerformanceQuery = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ optimalDeviceAccess;
	$ identicalMemoryLayout;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkHostImageCopyDevicePerformanceQuery,
	{
		__tostring = function(s)
			return ("struct VkHostImageCopyDevicePerformanceQuery[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.optimalDeviceAccess, t.identicalMemoryLayout)
		end,
	}
)
mod.PFN_vkCmdSetLineStipple = ffi.typeof([[void (*)($ , uint32_t , uint16_t )]], mod.VkCommandBuffer)
mod.PFN_vkMapMemory2 = ffi.typeof([[$ (*)($ , const $*, void**)]], mod.VkResult, mod.VkDevice, mod.VkMemoryMapInfo)
mod.PFN_vkUnmapMemory2 = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkMemoryUnmapInfo)
mod.PFN_vkCmdBindIndexBuffer2 = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkIndexType
)
mod.PFN_vkGetRenderingAreaGranularity = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkRenderingAreaInfo,
	mod.VkExtent2D
)
mod.PFN_vkGetDeviceImageSubresourceLayout = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkDeviceImageSubresourceInfo,
	mod.VkSubresourceLayout2
)
mod.PFN_vkGetImageSubresourceLayout2 = ffi.typeof(
	[[void (*)($ , $ , const $*, $*)]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkImageSubresource2,
	mod.VkSubresourceLayout2
)
mod.PFN_vkCmdPushDescriptorSet = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipelineLayout,
	mod.VkWriteDescriptorSet
)
mod.PFN_vkCmdPushDescriptorSetWithTemplate = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , const void*)]],
	mod.VkCommandBuffer,
	mod.VkDescriptorUpdateTemplate,
	mod.VkPipelineLayout
)
mod.PFN_vkCmdSetRenderingAttachmentLocations = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkRenderingAttachmentLocationInfo
)
mod.PFN_vkCmdSetRenderingInputAttachmentIndices = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkRenderingInputAttachmentIndexInfo
)
mod.PFN_vkCmdBindDescriptorSets2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkBindDescriptorSetsInfo)
mod.PFN_vkCmdPushConstants2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPushConstantsInfo)
mod.PFN_vkCmdPushDescriptorSet2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPushDescriptorSetInfo)
mod.PFN_vkCmdPushDescriptorSetWithTemplate2 = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkPushDescriptorSetWithTemplateInfo
)
mod.PFN_vkCopyMemoryToImage = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyMemoryToImageInfo)
mod.PFN_vkCopyImageToMemory = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToMemoryInfo)
mod.PFN_vkCopyImageToImage = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToImageInfo)
mod.PFN_vkTransitionImageLayout = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkHostImageLayoutTransitionInfo
)
ffi.cdef([[void  vkCmdSetLineStipple($ , uint32_t , uint16_t );]], mod.VkCommandBuffer)
ffi.cdef(
	[[$  vkMapMemory2($ , const $*, void**);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryMapInfo
)
ffi.cdef(
	[[$  vkUnmapMemory2($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryUnmapInfo
)
ffi.cdef(
	[[void  vkCmdBindIndexBuffer2($ , $ , $ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkIndexType
)
ffi.cdef(
	[[void  vkGetRenderingAreaGranularity($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkRenderingAreaInfo,
	mod.VkExtent2D
)
ffi.cdef(
	[[void  vkGetDeviceImageSubresourceLayout($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDeviceImageSubresourceInfo,
	mod.VkSubresourceLayout2
)
ffi.cdef(
	[[void  vkGetImageSubresourceLayout2($ , $ , const $*, $*);]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkImageSubresource2,
	mod.VkSubresourceLayout2
)
ffi.cdef(
	[[void  vkCmdPushDescriptorSet($ , $ , $ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipelineLayout,
	mod.VkWriteDescriptorSet
)
ffi.cdef(
	[[void  vkCmdPushDescriptorSetWithTemplate($ , $ , $ , uint32_t , const void*);]],
	mod.VkCommandBuffer,
	mod.VkDescriptorUpdateTemplate,
	mod.VkPipelineLayout
)
ffi.cdef(
	[[void  vkCmdSetRenderingAttachmentLocations($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRenderingAttachmentLocationInfo
)
ffi.cdef(
	[[void  vkCmdSetRenderingInputAttachmentIndices($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRenderingInputAttachmentIndexInfo
)
ffi.cdef(
	[[void  vkCmdBindDescriptorSets2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBindDescriptorSetsInfo
)
ffi.cdef(
	[[void  vkCmdPushConstants2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkPushConstantsInfo
)
ffi.cdef(
	[[void  vkCmdPushDescriptorSet2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkPushDescriptorSetInfo
)
ffi.cdef(
	[[void  vkCmdPushDescriptorSetWithTemplate2($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkPushDescriptorSetWithTemplateInfo
)
ffi.cdef(
	[[$  vkCopyMemoryToImage($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCopyMemoryToImageInfo
)
ffi.cdef(
	[[$  vkCopyImageToMemory($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCopyImageToMemoryInfo
)
ffi.cdef(
	[[$  vkCopyImageToImage($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCopyImageToImageInfo
)
ffi.cdef(
	[[$  vkTransitionImageLayout($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkHostImageLayoutTransitionInfo
)
mod.VkSurfaceKHR = ffi.typeof([[void*]])
mod.VkPresentModeKHR = ffi.typeof([[enum {
	VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
	VK_PRESENT_MODE_MAILBOX_KHR = 1,
	VK_PRESENT_MODE_FIFO_KHR = 2,
	VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
	VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
	VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
	VK_PRESENT_MODE_FIFO_LATEST_READY_KHR = 1000361000,
	VK_PRESENT_MODE_FIFO_LATEST_READY_EXT = VK_PRESENT_MODE_FIFO_LATEST_READY_KHR,
	VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkColorSpaceKHR = ffi.typeof([[enum {
	VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
	VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
	VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
	VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
	VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
	VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
	VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
	VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
	VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
	VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
	VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
	VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
	VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
	VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
	VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
	VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
	VK_COLORSPACE_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
	VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
	VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkSurfaceTransformFlagBitsKHR = ffi.typeof([[enum {
	VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
	VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
	VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
	VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
	VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
	VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkCompositeAlphaFlagBitsKHR = ffi.typeof([[enum {
	VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
	VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
	VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
	VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
	VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkCompositeAlphaFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSurfaceTransformFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSurfaceCapabilitiesKHR = ffi.typeof(
	[[struct {
	uint32_t minImageCount;
	uint32_t maxImageCount;
	$ currentExtent;
	$ minImageExtent;
	$ maxImageExtent;
	uint32_t maxImageArrayLayers;
	$ supportedTransforms;
	$ currentTransform;
	$ supportedCompositeAlpha;
	$ supportedUsageFlags;
}]],
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkSurfaceTransformFlagsKHR,
	mod.VkSurfaceTransformFlagBitsKHR,
	mod.VkCompositeAlphaFlagsKHR,
	mod.VkImageUsageFlags
)
ffi.metatype(
	mod.VkSurfaceCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkSurfaceCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.minImageCount,
				t.maxImageCount,
				t.currentExtent,
				t.minImageExtent,
				t.maxImageExtent,
				t.maxImageArrayLayers,
				t.supportedTransforms,
				t.currentTransform,
				t.supportedCompositeAlpha,
				t.supportedUsageFlags
			)
		end,
	}
)
mod.VkSurfaceFormatKHR = ffi.typeof([[struct {
	$ format;
	$ colorSpace;
}]], mod.VkFormat, mod.VkColorSpaceKHR)
ffi.metatype(
	mod.VkSurfaceFormatKHR,
	{
		__tostring = function(s)
			return ("struct VkSurfaceFormatKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.format, t.colorSpace)
		end,
	}
)
mod.PFN_vkDestroySurfaceKHR = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkInstance,
	mod.VkSurfaceKHR,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetPhysicalDeviceSurfaceSupportKHR = ffi.typeof(
	[[$ (*)($ , uint32_t , $ , $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkBool32
)
mod.PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = ffi.typeof(
	[[$ (*)($ , $ , $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkSurfaceCapabilitiesKHR
)
mod.PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkSurfaceFormatKHR
)
mod.PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkPresentModeKHR
)
ffi.cdef(
	[[void  vkDestroySurfaceKHR($ , $ , const $*);]],
	mod.VkInstance,
	mod.VkSurfaceKHR,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceSurfaceSupportKHR($ , uint32_t , $ , $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkBool32
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceSurfaceCapabilitiesKHR($ , $ , $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkSurfaceCapabilitiesKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceSurfaceFormatsKHR($ , $ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkSurfaceFormatKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceSurfacePresentModesKHR($ , $ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkPresentModeKHR
)
mod.VkSwapchainKHR = ffi.typeof([[void*]])
mod.VkSwapchainCreateFlagBitsKHR = ffi.typeof([[enum {
	VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x00000001,
	VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x00000002,
	VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x00000004,
	VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR = 0x00000040,
	VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR = 0x00000080,
	VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR = 0x00000008,
	VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT = VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR,
	VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkSwapchainCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDeviceGroupPresentModeFlagBitsKHR = ffi.typeof([[enum {
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x00000001,
	VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x00000002,
	VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x00000004,
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x00000008,
	VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkDeviceGroupPresentModeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSwapchainCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ surface;
	uint32_t minImageCount;
	$ imageFormat;
	$ imageColorSpace;
	$ imageExtent;
	uint32_t imageArrayLayers;
	$ imageUsage;
	$ imageSharingMode;
	uint32_t queueFamilyIndexCount;
	const uint32_t* pQueueFamilyIndices;
	$ preTransform;
	$ compositeAlpha;
	$ presentMode;
	$ clipped;
	$ oldSwapchain;
}]],
	mod.VkStructureType,
	mod.VkSwapchainCreateFlagsKHR,
	mod.VkSurfaceKHR,
	mod.VkFormat,
	mod.VkColorSpaceKHR,
	mod.VkExtent2D,
	mod.VkImageUsageFlags,
	mod.VkSharingMode,
	mod.VkSurfaceTransformFlagBitsKHR,
	mod.VkCompositeAlphaFlagBitsKHR,
	mod.VkPresentModeKHR,
	mod.VkBool32,
	mod.VkSwapchainKHR
)
ffi.metatype(
	mod.VkSwapchainCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkSwapchainCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.surface,
				t.minImageCount,
				t.imageFormat,
				t.imageColorSpace,
				t.imageExtent,
				t.imageArrayLayers,
				t.imageUsage,
				t.imageSharingMode,
				t.queueFamilyIndexCount,
				t.pQueueFamilyIndices,
				t.preTransform,
				t.compositeAlpha,
				t.presentMode,
				t.clipped,
				t.oldSwapchain
			)
		end,
	}
)
mod.VkPresentInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t waitSemaphoreCount;
	const $* pWaitSemaphores;
	uint32_t swapchainCount;
	const $* pSwapchains;
	const uint32_t* pImageIndices;
	$* pResults;
}]],
	mod.VkStructureType,
	mod.VkSemaphore,
	mod.VkSwapchainKHR,
	mod.VkResult
)
ffi.metatype(
	mod.VkPresentInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPresentInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.waitSemaphoreCount,
				t.pWaitSemaphores,
				t.swapchainCount,
				t.pSwapchains,
				t.pImageIndices,
				t.pResults
			)
		end,
	}
)
mod.VkImageSwapchainCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ swapchain;
}]],
	mod.VkStructureType,
	mod.VkSwapchainKHR
)
ffi.metatype(
	mod.VkImageSwapchainCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkImageSwapchainCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.swapchain)
		end,
	}
)
mod.VkBindImageMemorySwapchainInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ swapchain;
	uint32_t imageIndex;
}]],
	mod.VkStructureType,
	mod.VkSwapchainKHR
)
ffi.metatype(
	mod.VkBindImageMemorySwapchainInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkBindImageMemorySwapchainInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.swapchain, t.imageIndex)
		end,
	}
)
mod.VkAcquireNextImageInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ swapchain;
	uint64_t timeout;
	$ semaphore;
	$ fence;
	uint32_t deviceMask;
}]],
	mod.VkStructureType,
	mod.VkSwapchainKHR,
	mod.VkSemaphore,
	mod.VkFence
)
ffi.metatype(
	mod.VkAcquireNextImageInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkAcquireNextImageInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.swapchain,
				t.timeout,
				t.semaphore,
				t.fence,
				t.deviceMask
			)
		end,
	}
)
mod.VkDeviceGroupPresentCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t presentMask[32U];
	$ modes;
}]],
	mod.VkStructureType,
	mod.VkDeviceGroupPresentModeFlagsKHR
)
ffi.metatype(
	mod.VkDeviceGroupPresentCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkDeviceGroupPresentCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentMask, t.modes)
		end,
	}
)
mod.VkDeviceGroupPresentInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const uint32_t* pDeviceMasks;
	$ mode;
}]],
	mod.VkStructureType,
	mod.VkDeviceGroupPresentModeFlagBitsKHR
)
ffi.metatype(
	mod.VkDeviceGroupPresentInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkDeviceGroupPresentInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.swapchainCount, t.pDeviceMasks, t.mode)
		end,
	}
)
mod.VkDeviceGroupSwapchainCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ modes;
}]],
	mod.VkStructureType,
	mod.VkDeviceGroupPresentModeFlagsKHR
)
ffi.metatype(
	mod.VkDeviceGroupSwapchainCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkDeviceGroupSwapchainCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.modes)
		end,
	}
)
mod.PFN_vkCreateSwapchainKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSwapchainKHR
)
mod.PFN_vkDestroySwapchainKHR = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetSwapchainImagesKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkImage
)
mod.PFN_vkAcquireNextImageKHR = ffi.typeof(
	[[$ (*)($ , $ , uint64_t , $ , $ , uint32_t*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkSemaphore,
	mod.VkFence
)
mod.PFN_vkQueuePresentKHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkQueue, mod.VkPresentInfoKHR)
mod.PFN_vkGetDeviceGroupPresentCapabilitiesKHR = ffi.typeof(
	[[$ (*)($ , $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeviceGroupPresentCapabilitiesKHR
)
mod.PFN_vkGetDeviceGroupSurfacePresentModesKHR = ffi.typeof(
	[[$ (*)($ , $ , $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSurfaceKHR,
	mod.VkDeviceGroupPresentModeFlagsKHR
)
mod.PFN_vkGetPhysicalDevicePresentRectanglesKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkRect2D
)
mod.PFN_vkAcquireNextImage2KHR = ffi.typeof(
	[[$ (*)($ , const $*, uint32_t*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAcquireNextImageInfoKHR
)
ffi.cdef(
	[[$  vkCreateSwapchainKHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSwapchainKHR
)
ffi.cdef(
	[[void  vkDestroySwapchainKHR($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkGetSwapchainImagesKHR($ , $ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkImage
)
ffi.cdef(
	[[$  vkAcquireNextImageKHR($ , $ , uint64_t , $ , $ , uint32_t*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkSemaphore,
	mod.VkFence
)
ffi.cdef(
	[[$  vkQueuePresentKHR($ , const $*);]],
	mod.VkResult,
	mod.VkQueue,
	mod.VkPresentInfoKHR
)
ffi.cdef(
	[[$  vkGetDeviceGroupPresentCapabilitiesKHR($ , $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeviceGroupPresentCapabilitiesKHR
)
ffi.cdef(
	[[$  vkGetDeviceGroupSurfacePresentModesKHR($ , $ , $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSurfaceKHR,
	mod.VkDeviceGroupPresentModeFlagsKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDevicePresentRectanglesKHR($ , $ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkRect2D
)
ffi.cdef(
	[[$  vkAcquireNextImage2KHR($ , const $*, uint32_t*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAcquireNextImageInfoKHR
)
mod.VkDisplayKHR = ffi.typeof([[void*]])
mod.VkDisplayModeKHR = ffi.typeof([[void*]])
mod.VkDisplayModeCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDisplayPlaneAlphaFlagBitsKHR = ffi.typeof([[enum {
	VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
	VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
	VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkDisplayPlaneAlphaFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDisplaySurfaceCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDisplayModeParametersKHR = ffi.typeof([[struct {
	$ visibleRegion;
	uint32_t refreshRate;
}]], mod.VkExtent2D)
ffi.metatype(
	mod.VkDisplayModeParametersKHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayModeParametersKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.visibleRegion, t.refreshRate)
		end,
	}
)
mod.VkDisplayModeCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ parameters;
}]],
	mod.VkStructureType,
	mod.VkDisplayModeCreateFlagsKHR,
	mod.VkDisplayModeParametersKHR
)
ffi.metatype(
	mod.VkDisplayModeCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayModeCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.parameters)
		end,
	}
)
mod.VkDisplayModePropertiesKHR = ffi.typeof(
	[[struct {
	$ displayMode;
	$ parameters;
}]],
	mod.VkDisplayModeKHR,
	mod.VkDisplayModeParametersKHR
)
ffi.metatype(
	mod.VkDisplayModePropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayModePropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.displayMode, t.parameters)
		end,
	}
)
mod.VkDisplayPlaneCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ supportedAlpha;
	$ minSrcPosition;
	$ maxSrcPosition;
	$ minSrcExtent;
	$ maxSrcExtent;
	$ minDstPosition;
	$ maxDstPosition;
	$ minDstExtent;
	$ maxDstExtent;
}]],
	mod.VkDisplayPlaneAlphaFlagsKHR,
	mod.VkOffset2D,
	mod.VkOffset2D,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkOffset2D,
	mod.VkOffset2D,
	mod.VkExtent2D,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkDisplayPlaneCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayPlaneCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.supportedAlpha,
				t.minSrcPosition,
				t.maxSrcPosition,
				t.minSrcExtent,
				t.maxSrcExtent,
				t.minDstPosition,
				t.maxDstPosition,
				t.minDstExtent,
				t.maxDstExtent
			)
		end,
	}
)
mod.VkDisplayPlanePropertiesKHR = ffi.typeof([[struct {
	$ currentDisplay;
	uint32_t currentStackIndex;
}]], mod.VkDisplayKHR)
ffi.metatype(
	mod.VkDisplayPlanePropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayPlanePropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.currentDisplay, t.currentStackIndex)
		end,
	}
)
mod.VkDisplayPropertiesKHR = ffi.typeof(
	[[struct {
	$ display;
	const char* displayName;
	$ physicalDimensions;
	$ physicalResolution;
	$ supportedTransforms;
	$ planeReorderPossible;
	$ persistentContent;
}]],
	mod.VkDisplayKHR,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkSurfaceTransformFlagsKHR,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkDisplayPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.display,
				t.displayName,
				t.physicalDimensions,
				t.physicalResolution,
				t.supportedTransforms,
				t.planeReorderPossible,
				t.persistentContent
			)
		end,
	}
)
mod.VkDisplaySurfaceCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ displayMode;
	uint32_t planeIndex;
	uint32_t planeStackIndex;
	$ transform;
	float globalAlpha;
	$ alphaMode;
	$ imageExtent;
}]],
	mod.VkStructureType,
	mod.VkDisplaySurfaceCreateFlagsKHR,
	mod.VkDisplayModeKHR,
	mod.VkSurfaceTransformFlagBitsKHR,
	mod.VkDisplayPlaneAlphaFlagBitsKHR,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkDisplaySurfaceCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkDisplaySurfaceCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.displayMode,
				t.planeIndex,
				t.planeStackIndex,
				t.transform,
				t.globalAlpha,
				t.alphaMode,
				t.imageExtent
			)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayPropertiesKHR
)
mod.PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayPlanePropertiesKHR
)
mod.PFN_vkGetDisplayPlaneSupportedDisplaysKHR = ffi.typeof(
	[[$ (*)($ , uint32_t , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR
)
mod.PFN_vkGetDisplayModePropertiesKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR,
	mod.VkDisplayModePropertiesKHR
)
mod.PFN_vkCreateDisplayModeKHR = ffi.typeof(
	[[$ (*)($ , $ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR,
	mod.VkDisplayModeCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkDisplayModeKHR
)
mod.PFN_vkGetDisplayPlaneCapabilitiesKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayModeKHR,
	mod.VkDisplayPlaneCapabilitiesKHR
)
mod.PFN_vkCreateDisplayPlaneSurfaceKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkDisplaySurfaceCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceDisplayPropertiesKHR($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayPropertiesKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceDisplayPlanePropertiesKHR($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayPlanePropertiesKHR
)
ffi.cdef(
	[[$  vkGetDisplayPlaneSupportedDisplaysKHR($ , uint32_t , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR
)
ffi.cdef(
	[[$  vkGetDisplayModePropertiesKHR($ , $ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR,
	mod.VkDisplayModePropertiesKHR
)
ffi.cdef(
	[[$  vkCreateDisplayModeKHR($ , $ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR,
	mod.VkDisplayModeCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkDisplayModeKHR
)
ffi.cdef(
	[[$  vkGetDisplayPlaneCapabilitiesKHR($ , $ , uint32_t , $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayModeKHR,
	mod.VkDisplayPlaneCapabilitiesKHR
)
ffi.cdef(
	[[$  vkCreateDisplayPlaneSurfaceKHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkDisplaySurfaceCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.VkDisplayPresentInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcRect;
	$ dstRect;
	$ persistent;
}]],
	mod.VkStructureType,
	mod.VkRect2D,
	mod.VkRect2D,
	mod.VkBool32
)
ffi.metatype(
	mod.VkDisplayPresentInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayPresentInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.srcRect, t.dstRect, t.persistent)
		end,
	}
)
mod.PFN_vkCreateSharedSwapchainsKHR = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSwapchainKHR
)
ffi.cdef(
	[[$  vkCreateSharedSwapchainsKHR($ , uint32_t , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSwapchainKHR
)
mod.VkVideoSessionKHR = ffi.typeof([[void*]])
mod.VkVideoSessionParametersKHR = ffi.typeof([[void*]])
mod.VkQueryResultStatusKHR = ffi.typeof([[enum {
	VK_QUERY_RESULT_STATUS_ERROR_KHR = -1,
	VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
	VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
	VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR = -1000299000,
	VK_QUERY_RESULT_STATUS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoCodecOperationFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_CODEC_OPERATION_NONE_KHR = 0,
	VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR = 0x00010000,
	VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR = 0x00020000,
	VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR = 0x00000001,
	VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR = 0x00000002,
	VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR = 0x00000004,
	VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR = 0x00040000,
	VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR = 0x00000008,
	VK_VIDEO_CODEC_OPERATION_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoCodecOperationFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoChromaSubsamplingFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR = 0,
	VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 0x00000001,
	VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 0x00000002,
	VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 0x00000004,
	VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 0x00000008,
	VK_VIDEO_CHROMA_SUBSAMPLING_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoChromaSubsamplingFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoComponentBitDepthFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0,
	VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 0x00000001,
	VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 0x00000004,
	VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 0x00000010,
	VK_VIDEO_COMPONENT_BIT_DEPTH_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoComponentBitDepthFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoCapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 0x00000001,
	VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 0x00000002,
	VK_VIDEO_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoCapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoSessionCreateFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 0x00000001,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR = 0x00000002,
	VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR = 0x00000004,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000008,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x00000010,
	VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR = 0x00000020,
	VK_VIDEO_SESSION_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoSessionCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoSessionParametersCreateFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR = 0x00000001,
	VK_VIDEO_SESSION_PARAMETERS_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoSessionParametersCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoBeginCodingFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEndCodingFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoCodingControlFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR = 0x00000001,
	VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR = 0x00000002,
	VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR = 0x00000004,
	VK_VIDEO_CODING_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoCodingControlFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueueFamilyQueryResultStatusPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ queryResultStatusSupport;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkQueueFamilyQueryResultStatusPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkQueueFamilyQueryResultStatusPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.queryResultStatusSupport)
		end,
	}
)
mod.VkQueueFamilyVideoPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ videoCodecOperations;
}]],
	mod.VkStructureType,
	mod.VkVideoCodecOperationFlagsKHR
)
ffi.metatype(
	mod.VkQueueFamilyVideoPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkQueueFamilyVideoPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.videoCodecOperations)
		end,
	}
)
mod.VkVideoProfileInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ videoCodecOperation;
	$ chromaSubsampling;
	$ lumaBitDepth;
	$ chromaBitDepth;
}]],
	mod.VkStructureType,
	mod.VkVideoCodecOperationFlagBitsKHR,
	mod.VkVideoChromaSubsamplingFlagsKHR,
	mod.VkVideoComponentBitDepthFlagsKHR,
	mod.VkVideoComponentBitDepthFlagsKHR
)
ffi.metatype(
	mod.VkVideoProfileInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoProfileInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.videoCodecOperation,
				t.chromaSubsampling,
				t.lumaBitDepth,
				t.chromaBitDepth
			)
		end,
	}
)
mod.VkVideoProfileListInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t profileCount;
	const $* pProfiles;
}]],
	mod.VkStructureType,
	mod.VkVideoProfileInfoKHR
)
ffi.metatype(
	mod.VkVideoProfileListInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoProfileListInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.profileCount, t.pProfiles)
		end,
	}
)
mod.VkVideoCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ minBitstreamBufferOffsetAlignment;
	$ minBitstreamBufferSizeAlignment;
	$ pictureAccessGranularity;
	$ minCodedExtent;
	$ maxCodedExtent;
	uint32_t maxDpbSlots;
	uint32_t maxActiveReferencePictures;
	$ stdHeaderVersion;
}]],
	mod.VkStructureType,
	mod.VkVideoCapabilityFlagsKHR,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkExtensionProperties
)
ffi.metatype(
	mod.VkVideoCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.minBitstreamBufferOffsetAlignment,
				t.minBitstreamBufferSizeAlignment,
				t.pictureAccessGranularity,
				t.minCodedExtent,
				t.maxCodedExtent,
				t.maxDpbSlots,
				t.maxActiveReferencePictures,
				t.stdHeaderVersion
			)
		end,
	}
)
mod.VkPhysicalDeviceVideoFormatInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ imageUsage;
}]],
	mod.VkStructureType,
	mod.VkImageUsageFlags
)
ffi.metatype(
	mod.VkPhysicalDeviceVideoFormatInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVideoFormatInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageUsage)
		end,
	}
)
mod.VkVideoFormatPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ format;
	$ componentMapping;
	$ imageCreateFlags;
	$ imageType;
	$ imageTiling;
	$ imageUsageFlags;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkComponentMapping,
	mod.VkImageCreateFlags,
	mod.VkImageType,
	mod.VkImageTiling,
	mod.VkImageUsageFlags
)
ffi.metatype(
	mod.VkVideoFormatPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoFormatPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.format,
				t.componentMapping,
				t.imageCreateFlags,
				t.imageType,
				t.imageTiling,
				t.imageUsageFlags
			)
		end,
	}
)
mod.VkVideoPictureResourceInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ codedOffset;
	$ codedExtent;
	uint32_t baseArrayLayer;
	$ imageViewBinding;
}]],
	mod.VkStructureType,
	mod.VkOffset2D,
	mod.VkExtent2D,
	mod.VkImageView
)
ffi.metatype(
	mod.VkVideoPictureResourceInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoPictureResourceInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.codedOffset,
				t.codedExtent,
				t.baseArrayLayer,
				t.imageViewBinding
			)
		end,
	}
)
mod.VkVideoReferenceSlotInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	int32_t slotIndex;
	const $* pPictureResource;
}]],
	mod.VkStructureType,
	mod.VkVideoPictureResourceInfoKHR
)
ffi.metatype(
	mod.VkVideoReferenceSlotInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoReferenceSlotInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.slotIndex, t.pPictureResource)
		end,
	}
)
mod.VkVideoSessionMemoryRequirementsKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t memoryBindIndex;
	$ memoryRequirements;
}]],
	mod.VkStructureType,
	mod.VkMemoryRequirements
)
ffi.metatype(
	mod.VkVideoSessionMemoryRequirementsKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoSessionMemoryRequirementsKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memoryBindIndex, t.memoryRequirements)
		end,
	}
)
mod.VkBindVideoSessionMemoryInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t memoryBindIndex;
	$ memory;
	$ memoryOffset;
	$ memorySize;
}]],
	mod.VkStructureType,
	mod.VkDeviceMemory,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkBindVideoSessionMemoryInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkBindVideoSessionMemoryInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.memoryBindIndex,
				t.memory,
				t.memoryOffset,
				t.memorySize
			)
		end,
	}
)
mod.VkVideoSessionCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t queueFamilyIndex;
	$ flags;
	const $* pVideoProfile;
	$ pictureFormat;
	$ maxCodedExtent;
	$ referencePictureFormat;
	uint32_t maxDpbSlots;
	uint32_t maxActiveReferencePictures;
	const $* pStdHeaderVersion;
}]],
	mod.VkStructureType,
	mod.VkVideoSessionCreateFlagsKHR,
	mod.VkVideoProfileInfoKHR,
	mod.VkFormat,
	mod.VkExtent2D,
	mod.VkFormat,
	mod.VkExtensionProperties
)
ffi.metatype(
	mod.VkVideoSessionCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoSessionCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.queueFamilyIndex,
				t.flags,
				t.pVideoProfile,
				t.pictureFormat,
				t.maxCodedExtent,
				t.referencePictureFormat,
				t.maxDpbSlots,
				t.maxActiveReferencePictures,
				t.pStdHeaderVersion
			)
		end,
	}
)
mod.VkVideoSessionParametersCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ videoSessionParametersTemplate;
	$ videoSession;
}]],
	mod.VkStructureType,
	mod.VkVideoSessionParametersCreateFlagsKHR,
	mod.VkVideoSessionParametersKHR,
	mod.VkVideoSessionKHR
)
ffi.metatype(
	mod.VkVideoSessionParametersCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoSessionParametersCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.videoSessionParametersTemplate,
				t.videoSession
			)
		end,
	}
)
mod.VkVideoSessionParametersUpdateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t updateSequenceCount;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkVideoSessionParametersUpdateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoSessionParametersUpdateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.updateSequenceCount)
		end,
	}
)
mod.VkVideoBeginCodingInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ videoSession;
	$ videoSessionParameters;
	uint32_t referenceSlotCount;
	const $* pReferenceSlots;
}]],
	mod.VkStructureType,
	mod.VkVideoBeginCodingFlagsKHR,
	mod.VkVideoSessionKHR,
	mod.VkVideoSessionParametersKHR,
	mod.VkVideoReferenceSlotInfoKHR
)
ffi.metatype(
	mod.VkVideoBeginCodingInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoBeginCodingInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.videoSession,
				t.videoSessionParameters,
				t.referenceSlotCount,
				t.pReferenceSlots
			)
		end,
	}
)
mod.VkVideoEndCodingInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkVideoEndCodingFlagsKHR
)
ffi.metatype(
	mod.VkVideoEndCodingInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEndCodingInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.VkVideoCodingControlInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkVideoCodingControlFlagsKHR
)
ffi.metatype(
	mod.VkVideoCodingControlInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoCodingControlInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkVideoProfileInfoKHR,
	mod.VkVideoCapabilitiesKHR
)
mod.PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR = ffi.typeof(
	[[$ (*)($ , const $*, uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceVideoFormatInfoKHR,
	mod.VkVideoFormatPropertiesKHR
)
mod.PFN_vkCreateVideoSessionKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoSessionCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkVideoSessionKHR
)
mod.PFN_vkDestroyVideoSessionKHR = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkVideoSessionKHR,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetVideoSessionMemoryRequirementsKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoSessionKHR,
	mod.VkVideoSessionMemoryRequirementsKHR
)
mod.PFN_vkBindVideoSessionMemoryKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoSessionKHR,
	mod.VkBindVideoSessionMemoryInfoKHR
)
mod.PFN_vkCreateVideoSessionParametersKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoSessionParametersCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkVideoSessionParametersKHR
)
mod.PFN_vkUpdateVideoSessionParametersKHR = ffi.typeof(
	[[$ (*)($ , $ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoSessionParametersKHR,
	mod.VkVideoSessionParametersUpdateInfoKHR
)
mod.PFN_vkDestroyVideoSessionParametersKHR = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkVideoSessionParametersKHR,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCmdBeginVideoCodingKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkVideoBeginCodingInfoKHR)
mod.PFN_vkCmdEndVideoCodingKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkVideoEndCodingInfoKHR)
mod.PFN_vkCmdControlVideoCodingKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkVideoCodingControlInfoKHR)
ffi.cdef(
	[[$  vkGetPhysicalDeviceVideoCapabilitiesKHR($ , const $*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkVideoProfileInfoKHR,
	mod.VkVideoCapabilitiesKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceVideoFormatPropertiesKHR($ , const $*, uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceVideoFormatInfoKHR,
	mod.VkVideoFormatPropertiesKHR
)
ffi.cdef(
	[[$  vkCreateVideoSessionKHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoSessionCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkVideoSessionKHR
)
ffi.cdef(
	[[void  vkDestroyVideoSessionKHR($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkVideoSessionKHR,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkGetVideoSessionMemoryRequirementsKHR($ , $ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoSessionKHR,
	mod.VkVideoSessionMemoryRequirementsKHR
)
ffi.cdef(
	[[$  vkBindVideoSessionMemoryKHR($ , $ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoSessionKHR,
	mod.VkBindVideoSessionMemoryInfoKHR
)
ffi.cdef(
	[[$  vkCreateVideoSessionParametersKHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoSessionParametersCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkVideoSessionParametersKHR
)
ffi.cdef(
	[[$  vkUpdateVideoSessionParametersKHR($ , $ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoSessionParametersKHR,
	mod.VkVideoSessionParametersUpdateInfoKHR
)
ffi.cdef(
	[[void  vkDestroyVideoSessionParametersKHR($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkVideoSessionParametersKHR,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkCmdBeginVideoCodingKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkVideoBeginCodingInfoKHR
)
ffi.cdef(
	[[void  vkCmdEndVideoCodingKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkVideoEndCodingInfoKHR
)
ffi.cdef(
	[[void  vkCmdControlVideoCodingKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkVideoCodingControlInfoKHR
)
mod.VkVideoDecodeCapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoDecodeCapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoDecodeUsageFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_DECODE_USAGE_DEFAULT_KHR = 0,
	VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR = 0x00000004,
	VK_VIDEO_DECODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoDecodeUsageFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoDecodeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoDecodeCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkVideoDecodeCapabilityFlagsKHR
)
ffi.metatype(
	mod.VkVideoDecodeCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.VkVideoDecodeUsageInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ videoUsageHints;
}]],
	mod.VkStructureType,
	mod.VkVideoDecodeUsageFlagsKHR
)
ffi.metatype(
	mod.VkVideoDecodeUsageInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeUsageInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.videoUsageHints)
		end,
	}
)
mod.VkVideoDecodeInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ srcBuffer;
	$ srcBufferOffset;
	$ srcBufferRange;
	$ dstPictureResource;
	const $* pSetupReferenceSlot;
	uint32_t referenceSlotCount;
	const $* pReferenceSlots;
}]],
	mod.VkStructureType,
	mod.VkVideoDecodeFlagsKHR,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkVideoPictureResourceInfoKHR,
	mod.VkVideoReferenceSlotInfoKHR,
	mod.VkVideoReferenceSlotInfoKHR
)
ffi.metatype(
	mod.VkVideoDecodeInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.srcBuffer,
				t.srcBufferOffset,
				t.srcBufferRange,
				t.dstPictureResource,
				t.pSetupReferenceSlot,
				t.referenceSlotCount,
				t.pReferenceSlots
			)
		end,
	}
)
mod.PFN_vkCmdDecodeVideoKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkVideoDecodeInfoKHR)
ffi.cdef(
	[[void  vkCmdDecodeVideoKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkVideoDecodeInfoKHR
)
mod.StdVideoH264ChromaFormatIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_MONOCHROME = 0,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_420 = 1,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_422 = 2,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_444 = 3,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264ProfileIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_PROFILE_IDC_BASELINE = 66,
	STD_VIDEO_H264_PROFILE_IDC_MAIN = 77,
	STD_VIDEO_H264_PROFILE_IDC_HIGH = 100,
	STD_VIDEO_H264_PROFILE_IDC_HIGH_444_PREDICTIVE = 244,
	STD_VIDEO_H264_PROFILE_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_PROFILE_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264LevelIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_LEVEL_IDC_1_0 = 0,
	STD_VIDEO_H264_LEVEL_IDC_1_1 = 1,
	STD_VIDEO_H264_LEVEL_IDC_1_2 = 2,
	STD_VIDEO_H264_LEVEL_IDC_1_3 = 3,
	STD_VIDEO_H264_LEVEL_IDC_2_0 = 4,
	STD_VIDEO_H264_LEVEL_IDC_2_1 = 5,
	STD_VIDEO_H264_LEVEL_IDC_2_2 = 6,
	STD_VIDEO_H264_LEVEL_IDC_3_0 = 7,
	STD_VIDEO_H264_LEVEL_IDC_3_1 = 8,
	STD_VIDEO_H264_LEVEL_IDC_3_2 = 9,
	STD_VIDEO_H264_LEVEL_IDC_4_0 = 10,
	STD_VIDEO_H264_LEVEL_IDC_4_1 = 11,
	STD_VIDEO_H264_LEVEL_IDC_4_2 = 12,
	STD_VIDEO_H264_LEVEL_IDC_5_0 = 13,
	STD_VIDEO_H264_LEVEL_IDC_5_1 = 14,
	STD_VIDEO_H264_LEVEL_IDC_5_2 = 15,
	STD_VIDEO_H264_LEVEL_IDC_6_0 = 16,
	STD_VIDEO_H264_LEVEL_IDC_6_1 = 17,
	STD_VIDEO_H264_LEVEL_IDC_6_2 = 18,
	STD_VIDEO_H264_LEVEL_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_LEVEL_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264PocType = ffi.typeof([[enum {
	STD_VIDEO_H264_POC_TYPE_0 = 0,
	STD_VIDEO_H264_POC_TYPE_1 = 1,
	STD_VIDEO_H264_POC_TYPE_2 = 2,
	STD_VIDEO_H264_POC_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_POC_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264AspectRatioIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_SQUARE = 1,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_12_11 = 2,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_10_11 = 3,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_16_11 = 4,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_40_33 = 5,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_24_11 = 6,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_20_11 = 7,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_32_11 = 8,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_80_33 = 9,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_18_11 = 10,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_15_11 = 11,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_64_33 = 12,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_160_99 = 13,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_4_3 = 14,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_3_2 = 15,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_2_1 = 16,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264WeightedBipredIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_DEFAULT = 0,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT = 1,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_IMPLICIT = 2,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264ModificationOfPicNumsIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_SUBTRACT = 0,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_ADD = 1,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_LONG_TERM = 2,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_END = 3,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264MemMgmtControlOp = ffi.typeof([[enum {
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_END = 0,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_SHORT_TERM = 1,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_LONG_TERM = 2,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_LONG_TERM = 3,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_SET_MAX_LONG_TERM_INDEX = 4,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_ALL = 5,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_CURRENT_AS_LONG_TERM = 6,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264CabacInitIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_CABAC_INIT_IDC_0 = 0,
	STD_VIDEO_H264_CABAC_INIT_IDC_1 = 1,
	STD_VIDEO_H264_CABAC_INIT_IDC_2 = 2,
	STD_VIDEO_H264_CABAC_INIT_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_CABAC_INIT_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264DisableDeblockingFilterIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_DISABLED = 0,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_ENABLED = 1,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_PARTIAL = 2,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264SliceType = ffi.typeof([[enum {
	STD_VIDEO_H264_SLICE_TYPE_P = 0,
	STD_VIDEO_H264_SLICE_TYPE_B = 1,
	STD_VIDEO_H264_SLICE_TYPE_I = 2,
	STD_VIDEO_H264_SLICE_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_SLICE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264PictureType = ffi.typeof([[enum {
	STD_VIDEO_H264_PICTURE_TYPE_P = 0,
	STD_VIDEO_H264_PICTURE_TYPE_B = 1,
	STD_VIDEO_H264_PICTURE_TYPE_I = 2,
	STD_VIDEO_H264_PICTURE_TYPE_IDR = 5,
	STD_VIDEO_H264_PICTURE_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_PICTURE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264NonVclNaluType = ffi.typeof([[enum {
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_SPS = 0,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PPS = 1,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_AUD = 2,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PREFIX = 3,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_SEQUENCE = 4,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_STREAM = 5,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PRECODED = 6,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264SpsVuiFlags = ffi.typeof([[struct {
	uint32_t aspect_ratio_info_present_flag;
	uint32_t overscan_info_present_flag;
	uint32_t overscan_appropriate_flag;
	uint32_t video_signal_type_present_flag;
	uint32_t video_full_range_flag;
	uint32_t color_description_present_flag;
	uint32_t chroma_loc_info_present_flag;
	uint32_t timing_info_present_flag;
	uint32_t fixed_frame_rate_flag;
	uint32_t bitstream_restriction_flag;
	uint32_t nal_hrd_parameters_present_flag;
	uint32_t vcl_hrd_parameters_present_flag;
}]])
ffi.metatype(
	mod.StdVideoH264SpsVuiFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoH264SpsVuiFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.aspect_ratio_info_present_flag,
				t.overscan_info_present_flag,
				t.overscan_appropriate_flag,
				t.video_signal_type_present_flag,
				t.video_full_range_flag,
				t.color_description_present_flag,
				t.chroma_loc_info_present_flag,
				t.timing_info_present_flag,
				t.fixed_frame_rate_flag,
				t.bitstream_restriction_flag,
				t.nal_hrd_parameters_present_flag,
				t.vcl_hrd_parameters_present_flag
			)
		end,
	}
)
mod.StdVideoH264HrdParameters = ffi.typeof([[struct {
	uint8_t cpb_cnt_minus1;
	uint8_t bit_rate_scale;
	uint8_t cpb_size_scale;
	uint8_t reserved1;
	uint32_t bit_rate_value_minus1[32U];
	uint32_t cpb_size_value_minus1[32U];
	uint8_t cbr_flag[32U];
	uint32_t initial_cpb_removal_delay_length_minus1;
	uint32_t cpb_removal_delay_length_minus1;
	uint32_t dpb_output_delay_length_minus1;
	uint32_t time_offset_length;
}]])
ffi.metatype(
	mod.StdVideoH264HrdParameters,
	{
		__tostring = function(s)
			return ("struct StdVideoH264HrdParameters[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.cpb_cnt_minus1,
				t.bit_rate_scale,
				t.cpb_size_scale,
				t.reserved1,
				t.bit_rate_value_minus1,
				t.cpb_size_value_minus1,
				t.cbr_flag,
				t.initial_cpb_removal_delay_length_minus1,
				t.cpb_removal_delay_length_minus1,
				t.dpb_output_delay_length_minus1,
				t.time_offset_length
			)
		end,
	}
)
mod.StdVideoH264SequenceParameterSetVui = ffi.typeof(
	[[struct {
	$ flags;
	$ aspect_ratio_idc;
	uint16_t sar_width;
	uint16_t sar_height;
	uint8_t video_format;
	uint8_t colour_primaries;
	uint8_t transfer_characteristics;
	uint8_t matrix_coefficients;
	uint32_t num_units_in_tick;
	uint32_t time_scale;
	uint8_t max_num_reorder_frames;
	uint8_t max_dec_frame_buffering;
	uint8_t chroma_sample_loc_type_top_field;
	uint8_t chroma_sample_loc_type_bottom_field;
	uint32_t reserved1;
	const $* pHrdParameters;
}]],
	mod.StdVideoH264SpsVuiFlags,
	mod.StdVideoH264AspectRatioIdc,
	mod.StdVideoH264HrdParameters
)
ffi.metatype(
	mod.StdVideoH264SequenceParameterSetVui,
	{
		__tostring = function(s)
			return ("struct StdVideoH264SequenceParameterSetVui[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.aspect_ratio_idc,
				t.sar_width,
				t.sar_height,
				t.video_format,
				t.colour_primaries,
				t.transfer_characteristics,
				t.matrix_coefficients,
				t.num_units_in_tick,
				t.time_scale,
				t.max_num_reorder_frames,
				t.max_dec_frame_buffering,
				t.chroma_sample_loc_type_top_field,
				t.chroma_sample_loc_type_bottom_field,
				t.reserved1,
				t.pHrdParameters
			)
		end,
	}
)
mod.StdVideoH264SpsFlags = ffi.typeof([[struct {
	uint32_t constraint_set0_flag;
	uint32_t constraint_set1_flag;
	uint32_t constraint_set2_flag;
	uint32_t constraint_set3_flag;
	uint32_t constraint_set4_flag;
	uint32_t constraint_set5_flag;
	uint32_t direct_8x8_inference_flag;
	uint32_t mb_adaptive_frame_field_flag;
	uint32_t frame_mbs_only_flag;
	uint32_t delta_pic_order_always_zero_flag;
	uint32_t separate_colour_plane_flag;
	uint32_t gaps_in_frame_num_value_allowed_flag;
	uint32_t qpprime_y_zero_transform_bypass_flag;
	uint32_t frame_cropping_flag;
	uint32_t seq_scaling_matrix_present_flag;
	uint32_t vui_parameters_present_flag;
}]])
ffi.metatype(
	mod.StdVideoH264SpsFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoH264SpsFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.constraint_set0_flag,
				t.constraint_set1_flag,
				t.constraint_set2_flag,
				t.constraint_set3_flag,
				t.constraint_set4_flag,
				t.constraint_set5_flag,
				t.direct_8x8_inference_flag,
				t.mb_adaptive_frame_field_flag,
				t.frame_mbs_only_flag,
				t.delta_pic_order_always_zero_flag,
				t.separate_colour_plane_flag,
				t.gaps_in_frame_num_value_allowed_flag,
				t.qpprime_y_zero_transform_bypass_flag,
				t.frame_cropping_flag,
				t.seq_scaling_matrix_present_flag,
				t.vui_parameters_present_flag
			)
		end,
	}
)
mod.StdVideoH264ScalingLists = ffi.typeof([[struct {
	uint16_t scaling_list_present_mask;
	uint16_t use_default_scaling_matrix_mask;
	uint8_t ScalingList4x4[16U][6U];
	uint8_t ScalingList8x8[64U][6U];
}]])
ffi.metatype(
	mod.StdVideoH264ScalingLists,
	{
		__tostring = function(s)
			return ("struct StdVideoH264ScalingLists[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.scaling_list_present_mask,
				t.use_default_scaling_matrix_mask,
				t.ScalingList4x4,
				t.ScalingList8x8
			)
		end,
	}
)
mod.StdVideoH264SequenceParameterSet = ffi.typeof(
	[[struct {
	$ flags;
	$ profile_idc;
	$ level_idc;
	$ chroma_format_idc;
	uint8_t seq_parameter_set_id;
	uint8_t bit_depth_luma_minus8;
	uint8_t bit_depth_chroma_minus8;
	uint8_t log2_max_frame_num_minus4;
	$ pic_order_cnt_type;
	int32_t offset_for_non_ref_pic;
	int32_t offset_for_top_to_bottom_field;
	uint8_t log2_max_pic_order_cnt_lsb_minus4;
	uint8_t num_ref_frames_in_pic_order_cnt_cycle;
	uint8_t max_num_ref_frames;
	uint8_t reserved1;
	uint32_t pic_width_in_mbs_minus1;
	uint32_t pic_height_in_map_units_minus1;
	uint32_t frame_crop_left_offset;
	uint32_t frame_crop_right_offset;
	uint32_t frame_crop_top_offset;
	uint32_t frame_crop_bottom_offset;
	uint32_t reserved2;
	const int32_t* pOffsetForRefFrame;
	const $* pScalingLists;
	const $* pSequenceParameterSetVui;
}]],
	mod.StdVideoH264SpsFlags,
	mod.StdVideoH264ProfileIdc,
	mod.StdVideoH264LevelIdc,
	mod.StdVideoH264ChromaFormatIdc,
	mod.StdVideoH264PocType,
	mod.StdVideoH264ScalingLists,
	mod.StdVideoH264SequenceParameterSetVui
)
ffi.metatype(
	mod.StdVideoH264SequenceParameterSet,
	{
		__tostring = function(s)
			return ("struct StdVideoH264SequenceParameterSet[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.profile_idc,
				t.level_idc,
				t.chroma_format_idc,
				t.seq_parameter_set_id,
				t.bit_depth_luma_minus8,
				t.bit_depth_chroma_minus8,
				t.log2_max_frame_num_minus4,
				t.pic_order_cnt_type,
				t.offset_for_non_ref_pic,
				t.offset_for_top_to_bottom_field,
				t.log2_max_pic_order_cnt_lsb_minus4,
				t.num_ref_frames_in_pic_order_cnt_cycle,
				t.max_num_ref_frames,
				t.reserved1,
				t.pic_width_in_mbs_minus1,
				t.pic_height_in_map_units_minus1,
				t.frame_crop_left_offset,
				t.frame_crop_right_offset,
				t.frame_crop_top_offset,
				t.frame_crop_bottom_offset,
				t.reserved2,
				t.pOffsetForRefFrame,
				t.pScalingLists,
				t.pSequenceParameterSetVui
			)
		end,
	}
)
mod.StdVideoH264PpsFlags = ffi.typeof([[struct {
	uint32_t transform_8x8_mode_flag;
	uint32_t redundant_pic_cnt_present_flag;
	uint32_t constrained_intra_pred_flag;
	uint32_t deblocking_filter_control_present_flag;
	uint32_t weighted_pred_flag;
	uint32_t bottom_field_pic_order_in_frame_present_flag;
	uint32_t entropy_coding_mode_flag;
	uint32_t pic_scaling_matrix_present_flag;
}]])
ffi.metatype(
	mod.StdVideoH264PpsFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoH264PpsFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.transform_8x8_mode_flag,
				t.redundant_pic_cnt_present_flag,
				t.constrained_intra_pred_flag,
				t.deblocking_filter_control_present_flag,
				t.weighted_pred_flag,
				t.bottom_field_pic_order_in_frame_present_flag,
				t.entropy_coding_mode_flag,
				t.pic_scaling_matrix_present_flag
			)
		end,
	}
)
mod.StdVideoH264PictureParameterSet = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t seq_parameter_set_id;
	uint8_t pic_parameter_set_id;
	uint8_t num_ref_idx_l0_default_active_minus1;
	uint8_t num_ref_idx_l1_default_active_minus1;
	$ weighted_bipred_idc;
	int8_t pic_init_qp_minus26;
	int8_t pic_init_qs_minus26;
	int8_t chroma_qp_index_offset;
	int8_t second_chroma_qp_index_offset;
	const $* pScalingLists;
}]],
	mod.StdVideoH264PpsFlags,
	mod.StdVideoH264WeightedBipredIdc,
	mod.StdVideoH264ScalingLists
)
ffi.metatype(
	mod.StdVideoH264PictureParameterSet,
	{
		__tostring = function(s)
			return ("struct StdVideoH264PictureParameterSet[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.seq_parameter_set_id,
				t.pic_parameter_set_id,
				t.num_ref_idx_l0_default_active_minus1,
				t.num_ref_idx_l1_default_active_minus1,
				t.weighted_bipred_idc,
				t.pic_init_qp_minus26,
				t.pic_init_qs_minus26,
				t.chroma_qp_index_offset,
				t.second_chroma_qp_index_offset,
				t.pScalingLists
			)
		end,
	}
)
mod.StdVideoEncodeH264WeightTableFlags = ffi.typeof([[struct {
	uint32_t luma_weight_l0_flag;
	uint32_t chroma_weight_l0_flag;
	uint32_t luma_weight_l1_flag;
	uint32_t chroma_weight_l1_flag;
}]])
ffi.metatype(
	mod.StdVideoEncodeH264WeightTableFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264WeightTableFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.luma_weight_l0_flag,
				t.chroma_weight_l0_flag,
				t.luma_weight_l1_flag,
				t.chroma_weight_l1_flag
			)
		end,
	}
)
mod.StdVideoEncodeH264WeightTable = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t luma_log2_weight_denom;
	uint8_t chroma_log2_weight_denom;
	int8_t luma_weight_l0[32U];
	int8_t luma_offset_l0[32U];
	int8_t chroma_weight_l0[2U][32U];
	int8_t chroma_offset_l0[2U][32U];
	int8_t luma_weight_l1[32U];
	int8_t luma_offset_l1[32U];
	int8_t chroma_weight_l1[2U][32U];
	int8_t chroma_offset_l1[2U][32U];
}]],
	mod.StdVideoEncodeH264WeightTableFlags
)
ffi.metatype(
	mod.StdVideoEncodeH264WeightTable,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264WeightTable[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.luma_log2_weight_denom,
				t.chroma_log2_weight_denom,
				t.luma_weight_l0,
				t.luma_offset_l0,
				t.chroma_weight_l0,
				t.chroma_offset_l0,
				t.luma_weight_l1,
				t.luma_offset_l1,
				t.chroma_weight_l1,
				t.chroma_offset_l1
			)
		end,
	}
)
mod.StdVideoEncodeH264SliceHeaderFlags = ffi.typeof([[struct {
	uint32_t direct_spatial_mv_pred_flag;
	uint32_t num_ref_idx_active_override_flag;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoEncodeH264SliceHeaderFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264SliceHeaderFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.direct_spatial_mv_pred_flag,
				t.num_ref_idx_active_override_flag,
				t.reserved
			)
		end,
	}
)
mod.StdVideoEncodeH264PictureInfoFlags = ffi.typeof([[struct {
	uint32_t IdrPicFlag;
	uint32_t is_reference;
	uint32_t no_output_of_prior_pics_flag;
	uint32_t long_term_reference_flag;
	uint32_t adaptive_ref_pic_marking_mode_flag;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoEncodeH264PictureInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264PictureInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.IdrPicFlag,
				t.is_reference,
				t.no_output_of_prior_pics_flag,
				t.long_term_reference_flag,
				t.adaptive_ref_pic_marking_mode_flag,
				t.reserved
			)
		end,
	}
)
mod.StdVideoEncodeH264ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t used_for_long_term_reference;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoEncodeH264ReferenceInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264ReferenceInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.used_for_long_term_reference, t.reserved)
		end,
	}
)
mod.StdVideoEncodeH264ReferenceListsInfoFlags = ffi.typeof([[struct {
	uint32_t ref_pic_list_modification_flag_l0;
	uint32_t ref_pic_list_modification_flag_l1;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoEncodeH264ReferenceListsInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264ReferenceListsInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.ref_pic_list_modification_flag_l0,
				t.ref_pic_list_modification_flag_l1,
				t.reserved
			)
		end,
	}
)
mod.StdVideoEncodeH264RefListModEntry = ffi.typeof(
	[[struct {
	$ modification_of_pic_nums_idc;
	uint16_t abs_diff_pic_num_minus1;
	uint16_t long_term_pic_num;
}]],
	mod.StdVideoH264ModificationOfPicNumsIdc
)
ffi.metatype(
	mod.StdVideoEncodeH264RefListModEntry,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264RefListModEntry[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.modification_of_pic_nums_idc,
				t.abs_diff_pic_num_minus1,
				t.long_term_pic_num
			)
		end,
	}
)
mod.StdVideoEncodeH264RefPicMarkingEntry = ffi.typeof(
	[[struct {
	$ memory_management_control_operation;
	uint16_t difference_of_pic_nums_minus1;
	uint16_t long_term_pic_num;
	uint16_t long_term_frame_idx;
	uint16_t max_long_term_frame_idx_plus1;
}]],
	mod.StdVideoH264MemMgmtControlOp
)
ffi.metatype(
	mod.StdVideoEncodeH264RefPicMarkingEntry,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264RefPicMarkingEntry[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.memory_management_control_operation,
				t.difference_of_pic_nums_minus1,
				t.long_term_pic_num,
				t.long_term_frame_idx,
				t.max_long_term_frame_idx_plus1
			)
		end,
	}
)
mod.StdVideoEncodeH264ReferenceListsInfo = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t num_ref_idx_l0_active_minus1;
	uint8_t num_ref_idx_l1_active_minus1;
	uint8_t RefPicList0[32U];
	uint8_t RefPicList1[32U];
	uint8_t refList0ModOpCount;
	uint8_t refList1ModOpCount;
	uint8_t refPicMarkingOpCount;
	uint8_t reserved1[7];
	const $* pRefList0ModOperations;
	const $* pRefList1ModOperations;
	const $* pRefPicMarkingOperations;
}]],
	mod.StdVideoEncodeH264ReferenceListsInfoFlags,
	mod.StdVideoEncodeH264RefListModEntry,
	mod.StdVideoEncodeH264RefListModEntry,
	mod.StdVideoEncodeH264RefPicMarkingEntry
)
ffi.metatype(
	mod.StdVideoEncodeH264ReferenceListsInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264ReferenceListsInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.num_ref_idx_l0_active_minus1,
				t.num_ref_idx_l1_active_minus1,
				t.RefPicList0,
				t.RefPicList1,
				t.refList0ModOpCount,
				t.refList1ModOpCount,
				t.refPicMarkingOpCount,
				t.reserved1,
				t.pRefList0ModOperations,
				t.pRefList1ModOperations,
				t.pRefPicMarkingOperations
			)
		end,
	}
)
mod.StdVideoEncodeH264PictureInfo = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t seq_parameter_set_id;
	uint8_t pic_parameter_set_id;
	uint16_t idr_pic_id;
	$ primary_pic_type;
	uint32_t frame_num;
	int32_t PicOrderCnt;
	uint8_t temporal_id;
	uint8_t reserved1[3];
	const $* pRefLists;
}]],
	mod.StdVideoEncodeH264PictureInfoFlags,
	mod.StdVideoH264PictureType,
	mod.StdVideoEncodeH264ReferenceListsInfo
)
ffi.metatype(
	mod.StdVideoEncodeH264PictureInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264PictureInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.seq_parameter_set_id,
				t.pic_parameter_set_id,
				t.idr_pic_id,
				t.primary_pic_type,
				t.frame_num,
				t.PicOrderCnt,
				t.temporal_id,
				t.reserved1,
				t.pRefLists
			)
		end,
	}
)
mod.StdVideoEncodeH264ReferenceInfo = ffi.typeof(
	[[struct {
	$ flags;
	$ primary_pic_type;
	uint32_t FrameNum;
	int32_t PicOrderCnt;
	uint16_t long_term_pic_num;
	uint16_t long_term_frame_idx;
	uint8_t temporal_id;
}]],
	mod.StdVideoEncodeH264ReferenceInfoFlags,
	mod.StdVideoH264PictureType
)
ffi.metatype(
	mod.StdVideoEncodeH264ReferenceInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264ReferenceInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.primary_pic_type,
				t.FrameNum,
				t.PicOrderCnt,
				t.long_term_pic_num,
				t.long_term_frame_idx,
				t.temporal_id
			)
		end,
	}
)
mod.StdVideoEncodeH264SliceHeader = ffi.typeof(
	[[struct {
	$ flags;
	uint32_t first_mb_in_slice;
	$ slice_type;
	int8_t slice_alpha_c0_offset_div2;
	int8_t slice_beta_offset_div2;
	int8_t slice_qp_delta;
	uint8_t reserved1;
	$ cabac_init_idc;
	$ disable_deblocking_filter_idc;
	const $* pWeightTable;
}]],
	mod.StdVideoEncodeH264SliceHeaderFlags,
	mod.StdVideoH264SliceType,
	mod.StdVideoH264CabacInitIdc,
	mod.StdVideoH264DisableDeblockingFilterIdc,
	mod.StdVideoEncodeH264WeightTable
)
ffi.metatype(
	mod.StdVideoEncodeH264SliceHeader,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH264SliceHeader[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.first_mb_in_slice,
				t.slice_type,
				t.slice_alpha_c0_offset_div2,
				t.slice_beta_offset_div2,
				t.slice_qp_delta,
				t.reserved1,
				t.cabac_init_idc,
				t.disable_deblocking_filter_idc,
				t.pWeightTable
			)
		end,
	}
)
mod.VkVideoEncodeH264CapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH264CapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH264StdFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR = 0x00001000,
	VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR = 0x00002000,
	VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = 0x00004000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR = 0x00008000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR = 0x00010000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR = 0x00020000,
	VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR = 0x00080000,
	VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = 0x00100000,
	VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH264StdFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH264RateControlFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH264RateControlFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH264CapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ maxLevelIdc;
	uint32_t maxSliceCount;
	uint32_t maxPPictureL0ReferenceCount;
	uint32_t maxBPictureL0ReferenceCount;
	uint32_t maxL1ReferenceCount;
	uint32_t maxTemporalLayerCount;
	$ expectDyadicTemporalLayerPattern;
	int32_t minQp;
	int32_t maxQp;
	$ prefersGopRemainingFrames;
	$ requiresGopRemainingFrames;
	$ stdSyntaxFlags;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeH264CapabilityFlagsKHR,
	mod.StdVideoH264LevelIdc,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkVideoEncodeH264StdFlagsKHR
)
ffi.metatype(
	mod.VkVideoEncodeH264CapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264CapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.maxLevelIdc,
				t.maxSliceCount,
				t.maxPPictureL0ReferenceCount,
				t.maxBPictureL0ReferenceCount,
				t.maxL1ReferenceCount,
				t.maxTemporalLayerCount,
				t.expectDyadicTemporalLayerPattern,
				t.minQp,
				t.maxQp,
				t.prefersGopRemainingFrames,
				t.requiresGopRemainingFrames,
				t.stdSyntaxFlags
			)
		end,
	}
)
mod.VkVideoEncodeH264QpKHR = ffi.typeof([[struct {
	int32_t qpI;
	int32_t qpP;
	int32_t qpB;
}]])
ffi.metatype(
	mod.VkVideoEncodeH264QpKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264QpKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.qpI, t.qpP, t.qpB)
		end,
	}
)
mod.VkVideoEncodeH264QualityLevelPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ preferredRateControlFlags;
	uint32_t preferredGopFrameCount;
	uint32_t preferredIdrPeriod;
	uint32_t preferredConsecutiveBFrameCount;
	uint32_t preferredTemporalLayerCount;
	$ preferredConstantQp;
	uint32_t preferredMaxL0ReferenceCount;
	uint32_t preferredMaxL1ReferenceCount;
	$ preferredStdEntropyCodingModeFlag;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeH264RateControlFlagsKHR,
	mod.VkVideoEncodeH264QpKHR,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeH264QualityLevelPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264QualityLevelPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.preferredRateControlFlags,
				t.preferredGopFrameCount,
				t.preferredIdrPeriod,
				t.preferredConsecutiveBFrameCount,
				t.preferredTemporalLayerCount,
				t.preferredConstantQp,
				t.preferredMaxL0ReferenceCount,
				t.preferredMaxL1ReferenceCount,
				t.preferredStdEntropyCodingModeFlag
			)
		end,
	}
)
mod.VkVideoEncodeH264SessionCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ useMaxLevelIdc;
	$ maxLevelIdc;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.StdVideoH264LevelIdc
)
ffi.metatype(
	mod.VkVideoEncodeH264SessionCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264SessionCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.useMaxLevelIdc, t.maxLevelIdc)
		end,
	}
)
mod.VkVideoEncodeH264SessionParametersAddInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t stdSPSCount;
	const $* pStdSPSs;
	uint32_t stdPPSCount;
	const $* pStdPPSs;
}]],
	mod.VkStructureType,
	mod.StdVideoH264SequenceParameterSet,
	mod.StdVideoH264PictureParameterSet
)
ffi.metatype(
	mod.VkVideoEncodeH264SessionParametersAddInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264SessionParametersAddInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stdSPSCount, t.pStdSPSs, t.stdPPSCount, t.pStdPPSs)
		end,
	}
)
mod.VkVideoEncodeH264SessionParametersCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t maxStdSPSCount;
	uint32_t maxStdPPSCount;
	const $* pParametersAddInfo;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeH264SessionParametersAddInfoKHR
)
ffi.metatype(
	mod.VkVideoEncodeH264SessionParametersCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264SessionParametersCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxStdSPSCount,
				t.maxStdPPSCount,
				t.pParametersAddInfo
			)
		end,
	}
)
mod.VkVideoEncodeH264SessionParametersGetInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ writeStdSPS;
	$ writeStdPPS;
	uint32_t stdSPSId;
	uint32_t stdPPSId;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeH264SessionParametersGetInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264SessionParametersGetInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.writeStdSPS, t.writeStdPPS, t.stdSPSId, t.stdPPSId)
		end,
	}
)
mod.VkVideoEncodeH264SessionParametersFeedbackInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ hasStdSPSOverrides;
	$ hasStdPPSOverrides;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeH264SessionParametersFeedbackInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264SessionParametersFeedbackInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.hasStdSPSOverrides, t.hasStdPPSOverrides)
		end,
	}
)
mod.VkVideoEncodeH264NaluSliceInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	int32_t constantQp;
	const $* pStdSliceHeader;
}]],
	mod.VkStructureType,
	mod.StdVideoEncodeH264SliceHeader
)
ffi.metatype(
	mod.VkVideoEncodeH264NaluSliceInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264NaluSliceInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.constantQp, t.pStdSliceHeader)
		end,
	}
)
mod.VkVideoEncodeH264PictureInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t naluSliceEntryCount;
	const $* pNaluSliceEntries;
	const $* pStdPictureInfo;
	$ generatePrefixNalu;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeH264NaluSliceInfoKHR,
	mod.StdVideoEncodeH264PictureInfo,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeH264PictureInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264PictureInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.naluSliceEntryCount,
				t.pNaluSliceEntries,
				t.pStdPictureInfo,
				t.generatePrefixNalu
			)
		end,
	}
)
mod.VkVideoEncodeH264DpbSlotInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]],
	mod.VkStructureType,
	mod.StdVideoEncodeH264ReferenceInfo
)
ffi.metatype(
	mod.VkVideoEncodeH264DpbSlotInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264DpbSlotInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pStdReferenceInfo)
		end,
	}
)
mod.VkVideoEncodeH264ProfileInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stdProfileIdc;
}]],
	mod.VkStructureType,
	mod.StdVideoH264ProfileIdc
)
ffi.metatype(
	mod.VkVideoEncodeH264ProfileInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264ProfileInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stdProfileIdc)
		end,
	}
)
mod.VkVideoEncodeH264RateControlInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t gopFrameCount;
	uint32_t idrPeriod;
	uint32_t consecutiveBFrameCount;
	uint32_t temporalLayerCount;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeH264RateControlFlagsKHR
)
ffi.metatype(
	mod.VkVideoEncodeH264RateControlInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264RateControlInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.gopFrameCount,
				t.idrPeriod,
				t.consecutiveBFrameCount,
				t.temporalLayerCount
			)
		end,
	}
)
mod.VkVideoEncodeH264FrameSizeKHR = ffi.typeof([[struct {
	uint32_t frameISize;
	uint32_t framePSize;
	uint32_t frameBSize;
}]])
ffi.metatype(
	mod.VkVideoEncodeH264FrameSizeKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264FrameSizeKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.frameISize, t.framePSize, t.frameBSize)
		end,
	}
)
mod.VkVideoEncodeH264RateControlLayerInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ useMinQp;
	$ minQp;
	$ useMaxQp;
	$ maxQp;
	$ useMaxFrameSize;
	$ maxFrameSize;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkVideoEncodeH264QpKHR,
	mod.VkBool32,
	mod.VkVideoEncodeH264QpKHR,
	mod.VkBool32,
	mod.VkVideoEncodeH264FrameSizeKHR
)
ffi.metatype(
	mod.VkVideoEncodeH264RateControlLayerInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264RateControlLayerInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.useMinQp,
				t.minQp,
				t.useMaxQp,
				t.maxQp,
				t.useMaxFrameSize,
				t.maxFrameSize
			)
		end,
	}
)
mod.VkVideoEncodeH264GopRemainingFrameInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ useGopRemainingFrames;
	uint32_t gopRemainingI;
	uint32_t gopRemainingP;
	uint32_t gopRemainingB;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeH264GopRemainingFrameInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264GopRemainingFrameInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.useGopRemainingFrames,
				t.gopRemainingI,
				t.gopRemainingP,
				t.gopRemainingB
			)
		end,
	}
)
mod.StdVideoH265ChromaFormatIdc = ffi.typeof([[enum {
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_MONOCHROME = 0,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_420 = 1,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_422 = 2,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_444 = 3,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265ProfileIdc = ffi.typeof([[enum {
	STD_VIDEO_H265_PROFILE_IDC_MAIN = 1,
	STD_VIDEO_H265_PROFILE_IDC_MAIN_10 = 2,
	STD_VIDEO_H265_PROFILE_IDC_MAIN_STILL_PICTURE = 3,
	STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS = 4,
	STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS = 9,
	STD_VIDEO_H265_PROFILE_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_PROFILE_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265LevelIdc = ffi.typeof([[enum {
	STD_VIDEO_H265_LEVEL_IDC_1_0 = 0,
	STD_VIDEO_H265_LEVEL_IDC_2_0 = 1,
	STD_VIDEO_H265_LEVEL_IDC_2_1 = 2,
	STD_VIDEO_H265_LEVEL_IDC_3_0 = 3,
	STD_VIDEO_H265_LEVEL_IDC_3_1 = 4,
	STD_VIDEO_H265_LEVEL_IDC_4_0 = 5,
	STD_VIDEO_H265_LEVEL_IDC_4_1 = 6,
	STD_VIDEO_H265_LEVEL_IDC_5_0 = 7,
	STD_VIDEO_H265_LEVEL_IDC_5_1 = 8,
	STD_VIDEO_H265_LEVEL_IDC_5_2 = 9,
	STD_VIDEO_H265_LEVEL_IDC_6_0 = 10,
	STD_VIDEO_H265_LEVEL_IDC_6_1 = 11,
	STD_VIDEO_H265_LEVEL_IDC_6_2 = 12,
	STD_VIDEO_H265_LEVEL_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_LEVEL_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265SliceType = ffi.typeof([[enum {
	STD_VIDEO_H265_SLICE_TYPE_B = 0,
	STD_VIDEO_H265_SLICE_TYPE_P = 1,
	STD_VIDEO_H265_SLICE_TYPE_I = 2,
	STD_VIDEO_H265_SLICE_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_SLICE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265PictureType = ffi.typeof([[enum {
	STD_VIDEO_H265_PICTURE_TYPE_P = 0,
	STD_VIDEO_H265_PICTURE_TYPE_B = 1,
	STD_VIDEO_H265_PICTURE_TYPE_I = 2,
	STD_VIDEO_H265_PICTURE_TYPE_IDR = 3,
	STD_VIDEO_H265_PICTURE_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_PICTURE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265AspectRatioIdc = ffi.typeof([[enum {
	STD_VIDEO_H265_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_SQUARE = 1,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_12_11 = 2,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_10_11 = 3,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_16_11 = 4,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_40_33 = 5,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_24_11 = 6,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_20_11 = 7,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_32_11 = 8,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_80_33 = 9,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_18_11 = 10,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_15_11 = 11,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_64_33 = 12,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_160_99 = 13,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_4_3 = 14,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_3_2 = 15,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_2_1 = 16,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265DecPicBufMgr = ffi.typeof([[struct {
	uint32_t max_latency_increase_plus1[7U];
	uint8_t max_dec_pic_buffering_minus1[7U];
	uint8_t max_num_reorder_pics[7U];
}]])
ffi.metatype(
	mod.StdVideoH265DecPicBufMgr,
	{
		__tostring = function(s)
			return ("struct StdVideoH265DecPicBufMgr[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.max_latency_increase_plus1,
				t.max_dec_pic_buffering_minus1,
				t.max_num_reorder_pics
			)
		end,
	}
)
mod.StdVideoH265SubLayerHrdParameters = ffi.typeof([[struct {
	uint32_t bit_rate_value_minus1[32U];
	uint32_t cpb_size_value_minus1[32U];
	uint32_t cpb_size_du_value_minus1[32U];
	uint32_t bit_rate_du_value_minus1[32U];
	uint32_t cbr_flag;
}]])
ffi.metatype(
	mod.StdVideoH265SubLayerHrdParameters,
	{
		__tostring = function(s)
			return ("struct StdVideoH265SubLayerHrdParameters[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.bit_rate_value_minus1,
				t.cpb_size_value_minus1,
				t.cpb_size_du_value_minus1,
				t.bit_rate_du_value_minus1,
				t.cbr_flag
			)
		end,
	}
)
mod.StdVideoH265HrdFlags = ffi.typeof([[struct {
	uint32_t nal_hrd_parameters_present_flag;
	uint32_t vcl_hrd_parameters_present_flag;
	uint32_t sub_pic_hrd_params_present_flag;
	uint32_t sub_pic_cpb_params_in_pic_timing_sei_flag;
	uint32_t fixed_pic_rate_general_flag;
	uint32_t fixed_pic_rate_within_cvs_flag;
	uint32_t low_delay_hrd_flag;
}]])
ffi.metatype(
	mod.StdVideoH265HrdFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoH265HrdFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.nal_hrd_parameters_present_flag,
				t.vcl_hrd_parameters_present_flag,
				t.sub_pic_hrd_params_present_flag,
				t.sub_pic_cpb_params_in_pic_timing_sei_flag,
				t.fixed_pic_rate_general_flag,
				t.fixed_pic_rate_within_cvs_flag,
				t.low_delay_hrd_flag
			)
		end,
	}
)
mod.StdVideoH265HrdParameters = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t tick_divisor_minus2;
	uint8_t du_cpb_removal_delay_increment_length_minus1;
	uint8_t dpb_output_delay_du_length_minus1;
	uint8_t bit_rate_scale;
	uint8_t cpb_size_scale;
	uint8_t cpb_size_du_scale;
	uint8_t initial_cpb_removal_delay_length_minus1;
	uint8_t au_cpb_removal_delay_length_minus1;
	uint8_t dpb_output_delay_length_minus1;
	uint8_t cpb_cnt_minus1[7U];
	uint16_t elemental_duration_in_tc_minus1[7U];
	uint16_t reserved[3];
	const $* pSubLayerHrdParametersNal;
	const $* pSubLayerHrdParametersVcl;
}]],
	mod.StdVideoH265HrdFlags,
	mod.StdVideoH265SubLayerHrdParameters,
	mod.StdVideoH265SubLayerHrdParameters
)
ffi.metatype(
	mod.StdVideoH265HrdParameters,
	{
		__tostring = function(s)
			return ("struct StdVideoH265HrdParameters[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.tick_divisor_minus2,
				t.du_cpb_removal_delay_increment_length_minus1,
				t.dpb_output_delay_du_length_minus1,
				t.bit_rate_scale,
				t.cpb_size_scale,
				t.cpb_size_du_scale,
				t.initial_cpb_removal_delay_length_minus1,
				t.au_cpb_removal_delay_length_minus1,
				t.dpb_output_delay_length_minus1,
				t.cpb_cnt_minus1,
				t.elemental_duration_in_tc_minus1,
				t.reserved,
				t.pSubLayerHrdParametersNal,
				t.pSubLayerHrdParametersVcl
			)
		end,
	}
)
mod.StdVideoH265VpsFlags = ffi.typeof([[struct {
	uint32_t vps_temporal_id_nesting_flag;
	uint32_t vps_sub_layer_ordering_info_present_flag;
	uint32_t vps_timing_info_present_flag;
	uint32_t vps_poc_proportional_to_timing_flag;
}]])
ffi.metatype(
	mod.StdVideoH265VpsFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoH265VpsFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.vps_temporal_id_nesting_flag,
				t.vps_sub_layer_ordering_info_present_flag,
				t.vps_timing_info_present_flag,
				t.vps_poc_proportional_to_timing_flag
			)
		end,
	}
)
mod.StdVideoH265ProfileTierLevelFlags = ffi.typeof([[struct {
	uint32_t general_tier_flag;
	uint32_t general_progressive_source_flag;
	uint32_t general_interlaced_source_flag;
	uint32_t general_non_packed_constraint_flag;
	uint32_t general_frame_only_constraint_flag;
}]])
ffi.metatype(
	mod.StdVideoH265ProfileTierLevelFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoH265ProfileTierLevelFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.general_tier_flag,
				t.general_progressive_source_flag,
				t.general_interlaced_source_flag,
				t.general_non_packed_constraint_flag,
				t.general_frame_only_constraint_flag
			)
		end,
	}
)
mod.StdVideoH265ProfileTierLevel = ffi.typeof(
	[[struct {
	$ flags;
	$ general_profile_idc;
	$ general_level_idc;
}]],
	mod.StdVideoH265ProfileTierLevelFlags,
	mod.StdVideoH265ProfileIdc,
	mod.StdVideoH265LevelIdc
)
ffi.metatype(
	mod.StdVideoH265ProfileTierLevel,
	{
		__tostring = function(s)
			return ("struct StdVideoH265ProfileTierLevel[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.flags, t.general_profile_idc, t.general_level_idc)
		end,
	}
)
mod.StdVideoH265VideoParameterSet = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t vps_video_parameter_set_id;
	uint8_t vps_max_sub_layers_minus1;
	uint8_t reserved1;
	uint8_t reserved2;
	uint32_t vps_num_units_in_tick;
	uint32_t vps_time_scale;
	uint32_t vps_num_ticks_poc_diff_one_minus1;
	uint32_t reserved3;
	const $* pDecPicBufMgr;
	const $* pHrdParameters;
	const $* pProfileTierLevel;
}]],
	mod.StdVideoH265VpsFlags,
	mod.StdVideoH265DecPicBufMgr,
	mod.StdVideoH265HrdParameters,
	mod.StdVideoH265ProfileTierLevel
)
ffi.metatype(
	mod.StdVideoH265VideoParameterSet,
	{
		__tostring = function(s)
			return ("struct StdVideoH265VideoParameterSet[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.vps_video_parameter_set_id,
				t.vps_max_sub_layers_minus1,
				t.reserved1,
				t.reserved2,
				t.vps_num_units_in_tick,
				t.vps_time_scale,
				t.vps_num_ticks_poc_diff_one_minus1,
				t.reserved3,
				t.pDecPicBufMgr,
				t.pHrdParameters,
				t.pProfileTierLevel
			)
		end,
	}
)
mod.StdVideoH265ScalingLists = ffi.typeof([[struct {
	uint8_t ScalingList4x4[16U][6U];
	uint8_t ScalingList8x8[64U][6U];
	uint8_t ScalingList16x16[64U][6U];
	uint8_t ScalingList32x32[64U][2U];
	uint8_t ScalingListDCCoef16x16[6U];
	uint8_t ScalingListDCCoef32x32[2U];
}]])
ffi.metatype(
	mod.StdVideoH265ScalingLists,
	{
		__tostring = function(s)
			return ("struct StdVideoH265ScalingLists[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.ScalingList4x4,
				t.ScalingList8x8,
				t.ScalingList16x16,
				t.ScalingList32x32,
				t.ScalingListDCCoef16x16,
				t.ScalingListDCCoef32x32
			)
		end,
	}
)
mod.StdVideoH265SpsVuiFlags = ffi.typeof([[struct {
	uint32_t aspect_ratio_info_present_flag;
	uint32_t overscan_info_present_flag;
	uint32_t overscan_appropriate_flag;
	uint32_t video_signal_type_present_flag;
	uint32_t video_full_range_flag;
	uint32_t colour_description_present_flag;
	uint32_t chroma_loc_info_present_flag;
	uint32_t neutral_chroma_indication_flag;
	uint32_t field_seq_flag;
	uint32_t frame_field_info_present_flag;
	uint32_t default_display_window_flag;
	uint32_t vui_timing_info_present_flag;
	uint32_t vui_poc_proportional_to_timing_flag;
	uint32_t vui_hrd_parameters_present_flag;
	uint32_t bitstream_restriction_flag;
	uint32_t tiles_fixed_structure_flag;
	uint32_t motion_vectors_over_pic_boundaries_flag;
	uint32_t restricted_ref_pic_lists_flag;
}]])
ffi.metatype(
	mod.StdVideoH265SpsVuiFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoH265SpsVuiFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.aspect_ratio_info_present_flag,
				t.overscan_info_present_flag,
				t.overscan_appropriate_flag,
				t.video_signal_type_present_flag,
				t.video_full_range_flag,
				t.colour_description_present_flag,
				t.chroma_loc_info_present_flag,
				t.neutral_chroma_indication_flag,
				t.field_seq_flag,
				t.frame_field_info_present_flag,
				t.default_display_window_flag,
				t.vui_timing_info_present_flag,
				t.vui_poc_proportional_to_timing_flag,
				t.vui_hrd_parameters_present_flag,
				t.bitstream_restriction_flag,
				t.tiles_fixed_structure_flag,
				t.motion_vectors_over_pic_boundaries_flag,
				t.restricted_ref_pic_lists_flag
			)
		end,
	}
)
mod.StdVideoH265SequenceParameterSetVui = ffi.typeof(
	[[struct {
	$ flags;
	$ aspect_ratio_idc;
	uint16_t sar_width;
	uint16_t sar_height;
	uint8_t video_format;
	uint8_t colour_primaries;
	uint8_t transfer_characteristics;
	uint8_t matrix_coeffs;
	uint8_t chroma_sample_loc_type_top_field;
	uint8_t chroma_sample_loc_type_bottom_field;
	uint8_t reserved1;
	uint8_t reserved2;
	uint16_t def_disp_win_left_offset;
	uint16_t def_disp_win_right_offset;
	uint16_t def_disp_win_top_offset;
	uint16_t def_disp_win_bottom_offset;
	uint32_t vui_num_units_in_tick;
	uint32_t vui_time_scale;
	uint32_t vui_num_ticks_poc_diff_one_minus1;
	uint16_t min_spatial_segmentation_idc;
	uint16_t reserved3;
	uint8_t max_bytes_per_pic_denom;
	uint8_t max_bits_per_min_cu_denom;
	uint8_t log2_max_mv_length_horizontal;
	uint8_t log2_max_mv_length_vertical;
	const $* pHrdParameters;
}]],
	mod.StdVideoH265SpsVuiFlags,
	mod.StdVideoH265AspectRatioIdc,
	mod.StdVideoH265HrdParameters
)
ffi.metatype(
	mod.StdVideoH265SequenceParameterSetVui,
	{
		__tostring = function(s)
			return ("struct StdVideoH265SequenceParameterSetVui[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.aspect_ratio_idc,
				t.sar_width,
				t.sar_height,
				t.video_format,
				t.colour_primaries,
				t.transfer_characteristics,
				t.matrix_coeffs,
				t.chroma_sample_loc_type_top_field,
				t.chroma_sample_loc_type_bottom_field,
				t.reserved1,
				t.reserved2,
				t.def_disp_win_left_offset,
				t.def_disp_win_right_offset,
				t.def_disp_win_top_offset,
				t.def_disp_win_bottom_offset,
				t.vui_num_units_in_tick,
				t.vui_time_scale,
				t.vui_num_ticks_poc_diff_one_minus1,
				t.min_spatial_segmentation_idc,
				t.reserved3,
				t.max_bytes_per_pic_denom,
				t.max_bits_per_min_cu_denom,
				t.log2_max_mv_length_horizontal,
				t.log2_max_mv_length_vertical,
				t.pHrdParameters
			)
		end,
	}
)
mod.StdVideoH265PredictorPaletteEntries = ffi.typeof([[struct {
	uint16_t PredictorPaletteEntries[128U][3U];
}]])
ffi.metatype(
	mod.StdVideoH265PredictorPaletteEntries,
	{
		__tostring = function(s)
			return ("struct StdVideoH265PredictorPaletteEntries[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.PredictorPaletteEntries)
		end,
	}
)
mod.StdVideoH265SpsFlags = ffi.typeof([[struct {
	uint32_t sps_temporal_id_nesting_flag;
	uint32_t separate_colour_plane_flag;
	uint32_t conformance_window_flag;
	uint32_t sps_sub_layer_ordering_info_present_flag;
	uint32_t scaling_list_enabled_flag;
	uint32_t sps_scaling_list_data_present_flag;
	uint32_t amp_enabled_flag;
	uint32_t sample_adaptive_offset_enabled_flag;
	uint32_t pcm_enabled_flag;
	uint32_t pcm_loop_filter_disabled_flag;
	uint32_t long_term_ref_pics_present_flag;
	uint32_t sps_temporal_mvp_enabled_flag;
	uint32_t strong_intra_smoothing_enabled_flag;
	uint32_t vui_parameters_present_flag;
	uint32_t sps_extension_present_flag;
	uint32_t sps_range_extension_flag;
	uint32_t transform_skip_rotation_enabled_flag;
	uint32_t transform_skip_context_enabled_flag;
	uint32_t implicit_rdpcm_enabled_flag;
	uint32_t explicit_rdpcm_enabled_flag;
	uint32_t extended_precision_processing_flag;
	uint32_t intra_smoothing_disabled_flag;
	uint32_t high_precision_offsets_enabled_flag;
	uint32_t persistent_rice_adaptation_enabled_flag;
	uint32_t cabac_bypass_alignment_enabled_flag;
	uint32_t sps_scc_extension_flag;
	uint32_t sps_curr_pic_ref_enabled_flag;
	uint32_t palette_mode_enabled_flag;
	uint32_t sps_palette_predictor_initializers_present_flag;
	uint32_t intra_boundary_filtering_disabled_flag;
}]])
ffi.metatype(
	mod.StdVideoH265SpsFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoH265SpsFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sps_temporal_id_nesting_flag,
				t.separate_colour_plane_flag,
				t.conformance_window_flag,
				t.sps_sub_layer_ordering_info_present_flag,
				t.scaling_list_enabled_flag,
				t.sps_scaling_list_data_present_flag,
				t.amp_enabled_flag,
				t.sample_adaptive_offset_enabled_flag,
				t.pcm_enabled_flag,
				t.pcm_loop_filter_disabled_flag,
				t.long_term_ref_pics_present_flag,
				t.sps_temporal_mvp_enabled_flag,
				t.strong_intra_smoothing_enabled_flag,
				t.vui_parameters_present_flag,
				t.sps_extension_present_flag,
				t.sps_range_extension_flag,
				t.transform_skip_rotation_enabled_flag,
				t.transform_skip_context_enabled_flag,
				t.implicit_rdpcm_enabled_flag,
				t.explicit_rdpcm_enabled_flag,
				t.extended_precision_processing_flag,
				t.intra_smoothing_disabled_flag,
				t.high_precision_offsets_enabled_flag,
				t.persistent_rice_adaptation_enabled_flag,
				t.cabac_bypass_alignment_enabled_flag,
				t.sps_scc_extension_flag,
				t.sps_curr_pic_ref_enabled_flag,
				t.palette_mode_enabled_flag,
				t.sps_palette_predictor_initializers_present_flag,
				t.intra_boundary_filtering_disabled_flag
			)
		end,
	}
)
mod.StdVideoH265ShortTermRefPicSetFlags = ffi.typeof([[struct {
	uint32_t inter_ref_pic_set_prediction_flag;
	uint32_t delta_rps_sign;
}]])
ffi.metatype(
	mod.StdVideoH265ShortTermRefPicSetFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoH265ShortTermRefPicSetFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.inter_ref_pic_set_prediction_flag, t.delta_rps_sign)
		end,
	}
)
mod.StdVideoH265ShortTermRefPicSet = ffi.typeof(
	[[struct {
	$ flags;
	uint32_t delta_idx_minus1;
	uint16_t use_delta_flag;
	uint16_t abs_delta_rps_minus1;
	uint16_t used_by_curr_pic_flag;
	uint16_t used_by_curr_pic_s0_flag;
	uint16_t used_by_curr_pic_s1_flag;
	uint16_t reserved1;
	uint8_t reserved2;
	uint8_t reserved3;
	uint8_t num_negative_pics;
	uint8_t num_positive_pics;
	uint16_t delta_poc_s0_minus1[16U];
	uint16_t delta_poc_s1_minus1[16U];
}]],
	mod.StdVideoH265ShortTermRefPicSetFlags
)
ffi.metatype(
	mod.StdVideoH265ShortTermRefPicSet,
	{
		__tostring = function(s)
			return ("struct StdVideoH265ShortTermRefPicSet[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.delta_idx_minus1,
				t.use_delta_flag,
				t.abs_delta_rps_minus1,
				t.used_by_curr_pic_flag,
				t.used_by_curr_pic_s0_flag,
				t.used_by_curr_pic_s1_flag,
				t.reserved1,
				t.reserved2,
				t.reserved3,
				t.num_negative_pics,
				t.num_positive_pics,
				t.delta_poc_s0_minus1,
				t.delta_poc_s1_minus1
			)
		end,
	}
)
mod.StdVideoH265LongTermRefPicsSps = ffi.typeof([[struct {
	uint32_t used_by_curr_pic_lt_sps_flag;
	uint32_t lt_ref_pic_poc_lsb_sps[32U];
}]])
ffi.metatype(
	mod.StdVideoH265LongTermRefPicsSps,
	{
		__tostring = function(s)
			return ("struct StdVideoH265LongTermRefPicsSps[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.used_by_curr_pic_lt_sps_flag, t.lt_ref_pic_poc_lsb_sps)
		end,
	}
)
mod.StdVideoH265SequenceParameterSet = ffi.typeof(
	[[struct {
	$ flags;
	$ chroma_format_idc;
	uint32_t pic_width_in_luma_samples;
	uint32_t pic_height_in_luma_samples;
	uint8_t sps_video_parameter_set_id;
	uint8_t sps_max_sub_layers_minus1;
	uint8_t sps_seq_parameter_set_id;
	uint8_t bit_depth_luma_minus8;
	uint8_t bit_depth_chroma_minus8;
	uint8_t log2_max_pic_order_cnt_lsb_minus4;
	uint8_t log2_min_luma_coding_block_size_minus3;
	uint8_t log2_diff_max_min_luma_coding_block_size;
	uint8_t log2_min_luma_transform_block_size_minus2;
	uint8_t log2_diff_max_min_luma_transform_block_size;
	uint8_t max_transform_hierarchy_depth_inter;
	uint8_t max_transform_hierarchy_depth_intra;
	uint8_t num_short_term_ref_pic_sets;
	uint8_t num_long_term_ref_pics_sps;
	uint8_t pcm_sample_bit_depth_luma_minus1;
	uint8_t pcm_sample_bit_depth_chroma_minus1;
	uint8_t log2_min_pcm_luma_coding_block_size_minus3;
	uint8_t log2_diff_max_min_pcm_luma_coding_block_size;
	uint8_t reserved1;
	uint8_t reserved2;
	uint8_t palette_max_size;
	uint8_t delta_palette_max_predictor_size;
	uint8_t motion_vector_resolution_control_idc;
	uint8_t sps_num_palette_predictor_initializers_minus1;
	uint32_t conf_win_left_offset;
	uint32_t conf_win_right_offset;
	uint32_t conf_win_top_offset;
	uint32_t conf_win_bottom_offset;
	const $* pProfileTierLevel;
	const $* pDecPicBufMgr;
	const $* pScalingLists;
	const $* pShortTermRefPicSet;
	const $* pLongTermRefPicsSps;
	const $* pSequenceParameterSetVui;
	const $* pPredictorPaletteEntries;
}]],
	mod.StdVideoH265SpsFlags,
	mod.StdVideoH265ChromaFormatIdc,
	mod.StdVideoH265ProfileTierLevel,
	mod.StdVideoH265DecPicBufMgr,
	mod.StdVideoH265ScalingLists,
	mod.StdVideoH265ShortTermRefPicSet,
	mod.StdVideoH265LongTermRefPicsSps,
	mod.StdVideoH265SequenceParameterSetVui,
	mod.StdVideoH265PredictorPaletteEntries
)
ffi.metatype(
	mod.StdVideoH265SequenceParameterSet,
	{
		__tostring = function(s)
			return ("struct StdVideoH265SequenceParameterSet[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.chroma_format_idc,
				t.pic_width_in_luma_samples,
				t.pic_height_in_luma_samples,
				t.sps_video_parameter_set_id,
				t.sps_max_sub_layers_minus1,
				t.sps_seq_parameter_set_id,
				t.bit_depth_luma_minus8,
				t.bit_depth_chroma_minus8,
				t.log2_max_pic_order_cnt_lsb_minus4,
				t.log2_min_luma_coding_block_size_minus3,
				t.log2_diff_max_min_luma_coding_block_size,
				t.log2_min_luma_transform_block_size_minus2,
				t.log2_diff_max_min_luma_transform_block_size,
				t.max_transform_hierarchy_depth_inter,
				t.max_transform_hierarchy_depth_intra,
				t.num_short_term_ref_pic_sets,
				t.num_long_term_ref_pics_sps,
				t.pcm_sample_bit_depth_luma_minus1,
				t.pcm_sample_bit_depth_chroma_minus1,
				t.log2_min_pcm_luma_coding_block_size_minus3,
				t.log2_diff_max_min_pcm_luma_coding_block_size,
				t.reserved1,
				t.reserved2,
				t.palette_max_size,
				t.delta_palette_max_predictor_size,
				t.motion_vector_resolution_control_idc,
				t.sps_num_palette_predictor_initializers_minus1,
				t.conf_win_left_offset,
				t.conf_win_right_offset,
				t.conf_win_top_offset,
				t.conf_win_bottom_offset,
				t.pProfileTierLevel,
				t.pDecPicBufMgr,
				t.pScalingLists,
				t.pShortTermRefPicSet,
				t.pLongTermRefPicsSps,
				t.pSequenceParameterSetVui,
				t.pPredictorPaletteEntries
			)
		end,
	}
)
mod.StdVideoH265PpsFlags = ffi.typeof([[struct {
	uint32_t dependent_slice_segments_enabled_flag;
	uint32_t output_flag_present_flag;
	uint32_t sign_data_hiding_enabled_flag;
	uint32_t cabac_init_present_flag;
	uint32_t constrained_intra_pred_flag;
	uint32_t transform_skip_enabled_flag;
	uint32_t cu_qp_delta_enabled_flag;
	uint32_t pps_slice_chroma_qp_offsets_present_flag;
	uint32_t weighted_pred_flag;
	uint32_t weighted_bipred_flag;
	uint32_t transquant_bypass_enabled_flag;
	uint32_t tiles_enabled_flag;
	uint32_t entropy_coding_sync_enabled_flag;
	uint32_t uniform_spacing_flag;
	uint32_t loop_filter_across_tiles_enabled_flag;
	uint32_t pps_loop_filter_across_slices_enabled_flag;
	uint32_t deblocking_filter_control_present_flag;
	uint32_t deblocking_filter_override_enabled_flag;
	uint32_t pps_deblocking_filter_disabled_flag;
	uint32_t pps_scaling_list_data_present_flag;
	uint32_t lists_modification_present_flag;
	uint32_t slice_segment_header_extension_present_flag;
	uint32_t pps_extension_present_flag;
	uint32_t cross_component_prediction_enabled_flag;
	uint32_t chroma_qp_offset_list_enabled_flag;
	uint32_t pps_curr_pic_ref_enabled_flag;
	uint32_t residual_adaptive_colour_transform_enabled_flag;
	uint32_t pps_slice_act_qp_offsets_present_flag;
	uint32_t pps_palette_predictor_initializers_present_flag;
	uint32_t monochrome_palette_flag;
	uint32_t pps_range_extension_flag;
}]])
ffi.metatype(
	mod.StdVideoH265PpsFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoH265PpsFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.dependent_slice_segments_enabled_flag,
				t.output_flag_present_flag,
				t.sign_data_hiding_enabled_flag,
				t.cabac_init_present_flag,
				t.constrained_intra_pred_flag,
				t.transform_skip_enabled_flag,
				t.cu_qp_delta_enabled_flag,
				t.pps_slice_chroma_qp_offsets_present_flag,
				t.weighted_pred_flag,
				t.weighted_bipred_flag,
				t.transquant_bypass_enabled_flag,
				t.tiles_enabled_flag,
				t.entropy_coding_sync_enabled_flag,
				t.uniform_spacing_flag,
				t.loop_filter_across_tiles_enabled_flag,
				t.pps_loop_filter_across_slices_enabled_flag,
				t.deblocking_filter_control_present_flag,
				t.deblocking_filter_override_enabled_flag,
				t.pps_deblocking_filter_disabled_flag,
				t.pps_scaling_list_data_present_flag,
				t.lists_modification_present_flag,
				t.slice_segment_header_extension_present_flag,
				t.pps_extension_present_flag,
				t.cross_component_prediction_enabled_flag,
				t.chroma_qp_offset_list_enabled_flag,
				t.pps_curr_pic_ref_enabled_flag,
				t.residual_adaptive_colour_transform_enabled_flag,
				t.pps_slice_act_qp_offsets_present_flag,
				t.pps_palette_predictor_initializers_present_flag,
				t.monochrome_palette_flag,
				t.pps_range_extension_flag
			)
		end,
	}
)
mod.StdVideoH265PictureParameterSet = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t pps_pic_parameter_set_id;
	uint8_t pps_seq_parameter_set_id;
	uint8_t sps_video_parameter_set_id;
	uint8_t num_extra_slice_header_bits;
	uint8_t num_ref_idx_l0_default_active_minus1;
	uint8_t num_ref_idx_l1_default_active_minus1;
	int8_t init_qp_minus26;
	uint8_t diff_cu_qp_delta_depth;
	int8_t pps_cb_qp_offset;
	int8_t pps_cr_qp_offset;
	int8_t pps_beta_offset_div2;
	int8_t pps_tc_offset_div2;
	uint8_t log2_parallel_merge_level_minus2;
	uint8_t log2_max_transform_skip_block_size_minus2;
	uint8_t diff_cu_chroma_qp_offset_depth;
	uint8_t chroma_qp_offset_list_len_minus1;
	int8_t cb_qp_offset_list[6U];
	int8_t cr_qp_offset_list[6U];
	uint8_t log2_sao_offset_scale_luma;
	uint8_t log2_sao_offset_scale_chroma;
	int8_t pps_act_y_qp_offset_plus5;
	int8_t pps_act_cb_qp_offset_plus5;
	int8_t pps_act_cr_qp_offset_plus3;
	uint8_t pps_num_palette_predictor_initializers;
	uint8_t luma_bit_depth_entry_minus8;
	uint8_t chroma_bit_depth_entry_minus8;
	uint8_t num_tile_columns_minus1;
	uint8_t num_tile_rows_minus1;
	uint8_t reserved1;
	uint8_t reserved2;
	uint16_t column_width_minus1[19U];
	uint16_t row_height_minus1[21U];
	uint32_t reserved3;
	const $* pScalingLists;
	const $* pPredictorPaletteEntries;
}]],
	mod.StdVideoH265PpsFlags,
	mod.StdVideoH265ScalingLists,
	mod.StdVideoH265PredictorPaletteEntries
)
ffi.metatype(
	mod.StdVideoH265PictureParameterSet,
	{
		__tostring = function(s)
			return ("struct StdVideoH265PictureParameterSet[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.pps_pic_parameter_set_id,
				t.pps_seq_parameter_set_id,
				t.sps_video_parameter_set_id,
				t.num_extra_slice_header_bits,
				t.num_ref_idx_l0_default_active_minus1,
				t.num_ref_idx_l1_default_active_minus1,
				t.init_qp_minus26,
				t.diff_cu_qp_delta_depth,
				t.pps_cb_qp_offset,
				t.pps_cr_qp_offset,
				t.pps_beta_offset_div2,
				t.pps_tc_offset_div2,
				t.log2_parallel_merge_level_minus2,
				t.log2_max_transform_skip_block_size_minus2,
				t.diff_cu_chroma_qp_offset_depth,
				t.chroma_qp_offset_list_len_minus1,
				t.cb_qp_offset_list,
				t.cr_qp_offset_list,
				t.log2_sao_offset_scale_luma,
				t.log2_sao_offset_scale_chroma,
				t.pps_act_y_qp_offset_plus5,
				t.pps_act_cb_qp_offset_plus5,
				t.pps_act_cr_qp_offset_plus3,
				t.pps_num_palette_predictor_initializers,
				t.luma_bit_depth_entry_minus8,
				t.chroma_bit_depth_entry_minus8,
				t.num_tile_columns_minus1,
				t.num_tile_rows_minus1,
				t.reserved1,
				t.reserved2,
				t.column_width_minus1,
				t.row_height_minus1,
				t.reserved3,
				t.pScalingLists,
				t.pPredictorPaletteEntries
			)
		end,
	}
)
mod.StdVideoEncodeH265WeightTableFlags = ffi.typeof([[struct {
	uint16_t luma_weight_l0_flag;
	uint16_t chroma_weight_l0_flag;
	uint16_t luma_weight_l1_flag;
	uint16_t chroma_weight_l1_flag;
}]])
ffi.metatype(
	mod.StdVideoEncodeH265WeightTableFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH265WeightTableFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.luma_weight_l0_flag,
				t.chroma_weight_l0_flag,
				t.luma_weight_l1_flag,
				t.chroma_weight_l1_flag
			)
		end,
	}
)
mod.StdVideoEncodeH265WeightTable = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t luma_log2_weight_denom;
	int8_t delta_chroma_log2_weight_denom;
	int8_t delta_luma_weight_l0[15U];
	int8_t luma_offset_l0[15U];
	int8_t delta_chroma_weight_l0[2U][15U];
	int8_t delta_chroma_offset_l0[2U][15U];
	int8_t delta_luma_weight_l1[15U];
	int8_t luma_offset_l1[15U];
	int8_t delta_chroma_weight_l1[2U][15U];
	int8_t delta_chroma_offset_l1[2U][15U];
}]],
	mod.StdVideoEncodeH265WeightTableFlags
)
ffi.metatype(
	mod.StdVideoEncodeH265WeightTable,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH265WeightTable[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.luma_log2_weight_denom,
				t.delta_chroma_log2_weight_denom,
				t.delta_luma_weight_l0,
				t.luma_offset_l0,
				t.delta_chroma_weight_l0,
				t.delta_chroma_offset_l0,
				t.delta_luma_weight_l1,
				t.luma_offset_l1,
				t.delta_chroma_weight_l1,
				t.delta_chroma_offset_l1
			)
		end,
	}
)
mod.StdVideoEncodeH265SliceSegmentHeaderFlags = ffi.typeof([[struct {
	uint32_t first_slice_segment_in_pic_flag;
	uint32_t dependent_slice_segment_flag;
	uint32_t slice_sao_luma_flag;
	uint32_t slice_sao_chroma_flag;
	uint32_t num_ref_idx_active_override_flag;
	uint32_t mvd_l1_zero_flag;
	uint32_t cabac_init_flag;
	uint32_t cu_chroma_qp_offset_enabled_flag;
	uint32_t deblocking_filter_override_flag;
	uint32_t slice_deblocking_filter_disabled_flag;
	uint32_t collocated_from_l0_flag;
	uint32_t slice_loop_filter_across_slices_enabled_flag;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoEncodeH265SliceSegmentHeaderFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH265SliceSegmentHeaderFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.first_slice_segment_in_pic_flag,
				t.dependent_slice_segment_flag,
				t.slice_sao_luma_flag,
				t.slice_sao_chroma_flag,
				t.num_ref_idx_active_override_flag,
				t.mvd_l1_zero_flag,
				t.cabac_init_flag,
				t.cu_chroma_qp_offset_enabled_flag,
				t.deblocking_filter_override_flag,
				t.slice_deblocking_filter_disabled_flag,
				t.collocated_from_l0_flag,
				t.slice_loop_filter_across_slices_enabled_flag,
				t.reserved
			)
		end,
	}
)
mod.StdVideoEncodeH265SliceSegmentHeader = ffi.typeof(
	[[struct {
	$ flags;
	$ slice_type;
	uint32_t slice_segment_address;
	uint8_t collocated_ref_idx;
	uint8_t MaxNumMergeCand;
	int8_t slice_cb_qp_offset;
	int8_t slice_cr_qp_offset;
	int8_t slice_beta_offset_div2;
	int8_t slice_tc_offset_div2;
	int8_t slice_act_y_qp_offset;
	int8_t slice_act_cb_qp_offset;
	int8_t slice_act_cr_qp_offset;
	int8_t slice_qp_delta;
	uint16_t reserved1;
	const $* pWeightTable;
}]],
	mod.StdVideoEncodeH265SliceSegmentHeaderFlags,
	mod.StdVideoH265SliceType,
	mod.StdVideoEncodeH265WeightTable
)
ffi.metatype(
	mod.StdVideoEncodeH265SliceSegmentHeader,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH265SliceSegmentHeader[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.slice_type,
				t.slice_segment_address,
				t.collocated_ref_idx,
				t.MaxNumMergeCand,
				t.slice_cb_qp_offset,
				t.slice_cr_qp_offset,
				t.slice_beta_offset_div2,
				t.slice_tc_offset_div2,
				t.slice_act_y_qp_offset,
				t.slice_act_cb_qp_offset,
				t.slice_act_cr_qp_offset,
				t.slice_qp_delta,
				t.reserved1,
				t.pWeightTable
			)
		end,
	}
)
mod.StdVideoEncodeH265ReferenceListsInfoFlags = ffi.typeof([[struct {
	uint32_t ref_pic_list_modification_flag_l0;
	uint32_t ref_pic_list_modification_flag_l1;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoEncodeH265ReferenceListsInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH265ReferenceListsInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.ref_pic_list_modification_flag_l0,
				t.ref_pic_list_modification_flag_l1,
				t.reserved
			)
		end,
	}
)
mod.StdVideoEncodeH265ReferenceListsInfo = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t num_ref_idx_l0_active_minus1;
	uint8_t num_ref_idx_l1_active_minus1;
	uint8_t RefPicList0[15U];
	uint8_t RefPicList1[15U];
	uint8_t list_entry_l0[15U];
	uint8_t list_entry_l1[15U];
}]],
	mod.StdVideoEncodeH265ReferenceListsInfoFlags
)
ffi.metatype(
	mod.StdVideoEncodeH265ReferenceListsInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH265ReferenceListsInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.num_ref_idx_l0_active_minus1,
				t.num_ref_idx_l1_active_minus1,
				t.RefPicList0,
				t.RefPicList1,
				t.list_entry_l0,
				t.list_entry_l1
			)
		end,
	}
)
mod.StdVideoEncodeH265PictureInfoFlags = ffi.typeof([[struct {
	uint32_t is_reference;
	uint32_t IrapPicFlag;
	uint32_t used_for_long_term_reference;
	uint32_t discardable_flag;
	uint32_t cross_layer_bla_flag;
	uint32_t pic_output_flag;
	uint32_t no_output_of_prior_pics_flag;
	uint32_t short_term_ref_pic_set_sps_flag;
	uint32_t slice_temporal_mvp_enabled_flag;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoEncodeH265PictureInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH265PictureInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.is_reference,
				t.IrapPicFlag,
				t.used_for_long_term_reference,
				t.discardable_flag,
				t.cross_layer_bla_flag,
				t.pic_output_flag,
				t.no_output_of_prior_pics_flag,
				t.short_term_ref_pic_set_sps_flag,
				t.slice_temporal_mvp_enabled_flag,
				t.reserved
			)
		end,
	}
)
mod.StdVideoEncodeH265LongTermRefPics = ffi.typeof([[struct {
	uint8_t num_long_term_sps;
	uint8_t num_long_term_pics;
	uint8_t lt_idx_sps[32U];
	uint8_t poc_lsb_lt[16U];
	uint16_t used_by_curr_pic_lt_flag;
	uint8_t delta_poc_msb_present_flag[48U];
	uint8_t delta_poc_msb_cycle_lt[48U];
}]])
ffi.metatype(
	mod.StdVideoEncodeH265LongTermRefPics,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH265LongTermRefPics[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.num_long_term_sps,
				t.num_long_term_pics,
				t.lt_idx_sps,
				t.poc_lsb_lt,
				t.used_by_curr_pic_lt_flag,
				t.delta_poc_msb_present_flag,
				t.delta_poc_msb_cycle_lt
			)
		end,
	}
)
mod.StdVideoEncodeH265PictureInfo = ffi.typeof(
	[[struct {
	$ flags;
	$ pic_type;
	uint8_t sps_video_parameter_set_id;
	uint8_t pps_seq_parameter_set_id;
	uint8_t pps_pic_parameter_set_id;
	uint8_t short_term_ref_pic_set_idx;
	int32_t PicOrderCntVal;
	uint8_t TemporalId;
	uint8_t reserved1[7];
	const $* pRefLists;
	const $* pShortTermRefPicSet;
	const $* pLongTermRefPics;
}]],
	mod.StdVideoEncodeH265PictureInfoFlags,
	mod.StdVideoH265PictureType,
	mod.StdVideoEncodeH265ReferenceListsInfo,
	mod.StdVideoH265ShortTermRefPicSet,
	mod.StdVideoEncodeH265LongTermRefPics
)
ffi.metatype(
	mod.StdVideoEncodeH265PictureInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH265PictureInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.pic_type,
				t.sps_video_parameter_set_id,
				t.pps_seq_parameter_set_id,
				t.pps_pic_parameter_set_id,
				t.short_term_ref_pic_set_idx,
				t.PicOrderCntVal,
				t.TemporalId,
				t.reserved1,
				t.pRefLists,
				t.pShortTermRefPicSet,
				t.pLongTermRefPics
			)
		end,
	}
)
mod.StdVideoEncodeH265ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t used_for_long_term_reference;
	uint32_t unused_for_reference;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoEncodeH265ReferenceInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH265ReferenceInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.used_for_long_term_reference, t.unused_for_reference, t.reserved)
		end,
	}
)
mod.StdVideoEncodeH265ReferenceInfo = ffi.typeof(
	[[struct {
	$ flags;
	$ pic_type;
	int32_t PicOrderCntVal;
	uint8_t TemporalId;
}]],
	mod.StdVideoEncodeH265ReferenceInfoFlags,
	mod.StdVideoH265PictureType
)
ffi.metatype(
	mod.StdVideoEncodeH265ReferenceInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeH265ReferenceInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.flags, t.pic_type, t.PicOrderCntVal, t.TemporalId)
		end,
	}
)
mod.VkVideoEncodeH265CapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH265CapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH265StdFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR = 0x00001000,
	VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR = 0x00002000,
	VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = 0x00004000,
	VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR = 0x00008000,
	VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR = 0x00010000,
	VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR = 0x00020000,
	VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR = 0x00040000,
	VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR = 0x00080000,
	VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = 0x00100000,
	VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH265StdFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH265CtbSizeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH265CtbSizeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH265TransformBlockSizeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH265TransformBlockSizeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH265RateControlFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH265RateControlFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH265CapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ maxLevelIdc;
	uint32_t maxSliceSegmentCount;
	$ maxTiles;
	$ ctbSizes;
	$ transformBlockSizes;
	uint32_t maxPPictureL0ReferenceCount;
	uint32_t maxBPictureL0ReferenceCount;
	uint32_t maxL1ReferenceCount;
	uint32_t maxSubLayerCount;
	$ expectDyadicTemporalSubLayerPattern;
	int32_t minQp;
	int32_t maxQp;
	$ prefersGopRemainingFrames;
	$ requiresGopRemainingFrames;
	$ stdSyntaxFlags;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeH265CapabilityFlagsKHR,
	mod.StdVideoH265LevelIdc,
	mod.VkExtent2D,
	mod.VkVideoEncodeH265CtbSizeFlagsKHR,
	mod.VkVideoEncodeH265TransformBlockSizeFlagsKHR,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkVideoEncodeH265StdFlagsKHR
)
ffi.metatype(
	mod.VkVideoEncodeH265CapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265CapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.maxLevelIdc,
				t.maxSliceSegmentCount,
				t.maxTiles,
				t.ctbSizes,
				t.transformBlockSizes,
				t.maxPPictureL0ReferenceCount,
				t.maxBPictureL0ReferenceCount,
				t.maxL1ReferenceCount,
				t.maxSubLayerCount,
				t.expectDyadicTemporalSubLayerPattern,
				t.minQp,
				t.maxQp,
				t.prefersGopRemainingFrames,
				t.requiresGopRemainingFrames,
				t.stdSyntaxFlags
			)
		end,
	}
)
mod.VkVideoEncodeH265SessionCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ useMaxLevelIdc;
	$ maxLevelIdc;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.StdVideoH265LevelIdc
)
ffi.metatype(
	mod.VkVideoEncodeH265SessionCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265SessionCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.useMaxLevelIdc, t.maxLevelIdc)
		end,
	}
)
mod.VkVideoEncodeH265QpKHR = ffi.typeof([[struct {
	int32_t qpI;
	int32_t qpP;
	int32_t qpB;
}]])
ffi.metatype(
	mod.VkVideoEncodeH265QpKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265QpKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.qpI, t.qpP, t.qpB)
		end,
	}
)
mod.VkVideoEncodeH265QualityLevelPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ preferredRateControlFlags;
	uint32_t preferredGopFrameCount;
	uint32_t preferredIdrPeriod;
	uint32_t preferredConsecutiveBFrameCount;
	uint32_t preferredSubLayerCount;
	$ preferredConstantQp;
	uint32_t preferredMaxL0ReferenceCount;
	uint32_t preferredMaxL1ReferenceCount;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeH265RateControlFlagsKHR,
	mod.VkVideoEncodeH265QpKHR
)
ffi.metatype(
	mod.VkVideoEncodeH265QualityLevelPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265QualityLevelPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.preferredRateControlFlags,
				t.preferredGopFrameCount,
				t.preferredIdrPeriod,
				t.preferredConsecutiveBFrameCount,
				t.preferredSubLayerCount,
				t.preferredConstantQp,
				t.preferredMaxL0ReferenceCount,
				t.preferredMaxL1ReferenceCount
			)
		end,
	}
)
mod.VkVideoEncodeH265SessionParametersAddInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t stdVPSCount;
	const $* pStdVPSs;
	uint32_t stdSPSCount;
	const $* pStdSPSs;
	uint32_t stdPPSCount;
	const $* pStdPPSs;
}]],
	mod.VkStructureType,
	mod.StdVideoH265VideoParameterSet,
	mod.StdVideoH265SequenceParameterSet,
	mod.StdVideoH265PictureParameterSet
)
ffi.metatype(
	mod.VkVideoEncodeH265SessionParametersAddInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265SessionParametersAddInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.stdVPSCount,
				t.pStdVPSs,
				t.stdSPSCount,
				t.pStdSPSs,
				t.stdPPSCount,
				t.pStdPPSs
			)
		end,
	}
)
mod.VkVideoEncodeH265SessionParametersCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t maxStdVPSCount;
	uint32_t maxStdSPSCount;
	uint32_t maxStdPPSCount;
	const $* pParametersAddInfo;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeH265SessionParametersAddInfoKHR
)
ffi.metatype(
	mod.VkVideoEncodeH265SessionParametersCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265SessionParametersCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxStdVPSCount,
				t.maxStdSPSCount,
				t.maxStdPPSCount,
				t.pParametersAddInfo
			)
		end,
	}
)
mod.VkVideoEncodeH265SessionParametersGetInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ writeStdVPS;
	$ writeStdSPS;
	$ writeStdPPS;
	uint32_t stdVPSId;
	uint32_t stdSPSId;
	uint32_t stdPPSId;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeH265SessionParametersGetInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265SessionParametersGetInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.writeStdVPS,
				t.writeStdSPS,
				t.writeStdPPS,
				t.stdVPSId,
				t.stdSPSId,
				t.stdPPSId
			)
		end,
	}
)
mod.VkVideoEncodeH265SessionParametersFeedbackInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ hasStdVPSOverrides;
	$ hasStdSPSOverrides;
	$ hasStdPPSOverrides;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeH265SessionParametersFeedbackInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265SessionParametersFeedbackInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.hasStdVPSOverrides,
				t.hasStdSPSOverrides,
				t.hasStdPPSOverrides
			)
		end,
	}
)
mod.VkVideoEncodeH265NaluSliceSegmentInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	int32_t constantQp;
	const $* pStdSliceSegmentHeader;
}]],
	mod.VkStructureType,
	mod.StdVideoEncodeH265SliceSegmentHeader
)
ffi.metatype(
	mod.VkVideoEncodeH265NaluSliceSegmentInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265NaluSliceSegmentInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.constantQp, t.pStdSliceSegmentHeader)
		end,
	}
)
mod.VkVideoEncodeH265PictureInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t naluSliceSegmentEntryCount;
	const $* pNaluSliceSegmentEntries;
	const $* pStdPictureInfo;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeH265NaluSliceSegmentInfoKHR,
	mod.StdVideoEncodeH265PictureInfo
)
ffi.metatype(
	mod.VkVideoEncodeH265PictureInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265PictureInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.naluSliceSegmentEntryCount,
				t.pNaluSliceSegmentEntries,
				t.pStdPictureInfo
			)
		end,
	}
)
mod.VkVideoEncodeH265DpbSlotInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]],
	mod.VkStructureType,
	mod.StdVideoEncodeH265ReferenceInfo
)
ffi.metatype(
	mod.VkVideoEncodeH265DpbSlotInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265DpbSlotInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pStdReferenceInfo)
		end,
	}
)
mod.VkVideoEncodeH265ProfileInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stdProfileIdc;
}]],
	mod.VkStructureType,
	mod.StdVideoH265ProfileIdc
)
ffi.metatype(
	mod.VkVideoEncodeH265ProfileInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265ProfileInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stdProfileIdc)
		end,
	}
)
mod.VkVideoEncodeH265RateControlInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t gopFrameCount;
	uint32_t idrPeriod;
	uint32_t consecutiveBFrameCount;
	uint32_t subLayerCount;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeH265RateControlFlagsKHR
)
ffi.metatype(
	mod.VkVideoEncodeH265RateControlInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265RateControlInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.gopFrameCount,
				t.idrPeriod,
				t.consecutiveBFrameCount,
				t.subLayerCount
			)
		end,
	}
)
mod.VkVideoEncodeH265FrameSizeKHR = ffi.typeof([[struct {
	uint32_t frameISize;
	uint32_t framePSize;
	uint32_t frameBSize;
}]])
ffi.metatype(
	mod.VkVideoEncodeH265FrameSizeKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265FrameSizeKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.frameISize, t.framePSize, t.frameBSize)
		end,
	}
)
mod.VkVideoEncodeH265RateControlLayerInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ useMinQp;
	$ minQp;
	$ useMaxQp;
	$ maxQp;
	$ useMaxFrameSize;
	$ maxFrameSize;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkVideoEncodeH265QpKHR,
	mod.VkBool32,
	mod.VkVideoEncodeH265QpKHR,
	mod.VkBool32,
	mod.VkVideoEncodeH265FrameSizeKHR
)
ffi.metatype(
	mod.VkVideoEncodeH265RateControlLayerInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265RateControlLayerInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.useMinQp,
				t.minQp,
				t.useMaxQp,
				t.maxQp,
				t.useMaxFrameSize,
				t.maxFrameSize
			)
		end,
	}
)
mod.VkVideoEncodeH265GopRemainingFrameInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ useGopRemainingFrames;
	uint32_t gopRemainingI;
	uint32_t gopRemainingP;
	uint32_t gopRemainingB;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeH265GopRemainingFrameInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265GopRemainingFrameInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.useGopRemainingFrames,
				t.gopRemainingI,
				t.gopRemainingP,
				t.gopRemainingB
			)
		end,
	}
)
mod.StdVideoDecodeH264FieldOrderCount = ffi.typeof([[enum {
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_TOP = 0,
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_BOTTOM = 1,
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_INVALID = 0x7FFFFFFF,
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoDecodeH264PictureInfoFlags = ffi.typeof([[struct {
	uint32_t field_pic_flag;
	uint32_t is_intra;
	uint32_t IdrPicFlag;
	uint32_t bottom_field_flag;
	uint32_t is_reference;
	uint32_t complementary_field_pair;
}]])
ffi.metatype(
	mod.StdVideoDecodeH264PictureInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeH264PictureInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.field_pic_flag,
				t.is_intra,
				t.IdrPicFlag,
				t.bottom_field_flag,
				t.is_reference,
				t.complementary_field_pair
			)
		end,
	}
)
mod.StdVideoDecodeH264PictureInfo = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t seq_parameter_set_id;
	uint8_t pic_parameter_set_id;
	uint8_t reserved1;
	uint8_t reserved2;
	uint16_t frame_num;
	uint16_t idr_pic_id;
	int32_t PicOrderCnt[2U];
}]],
	mod.StdVideoDecodeH264PictureInfoFlags
)
ffi.metatype(
	mod.StdVideoDecodeH264PictureInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeH264PictureInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.seq_parameter_set_id,
				t.pic_parameter_set_id,
				t.reserved1,
				t.reserved2,
				t.frame_num,
				t.idr_pic_id,
				t.PicOrderCnt
			)
		end,
	}
)
mod.StdVideoDecodeH264ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t top_field_flag;
	uint32_t bottom_field_flag;
	uint32_t used_for_long_term_reference;
	uint32_t is_non_existing;
}]])
ffi.metatype(
	mod.StdVideoDecodeH264ReferenceInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeH264ReferenceInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.top_field_flag,
				t.bottom_field_flag,
				t.used_for_long_term_reference,
				t.is_non_existing
			)
		end,
	}
)
mod.StdVideoDecodeH264ReferenceInfo = ffi.typeof(
	[[struct {
	$ flags;
	uint16_t FrameNum;
	uint16_t reserved;
	int32_t PicOrderCnt[2U];
}]],
	mod.StdVideoDecodeH264ReferenceInfoFlags
)
ffi.metatype(
	mod.StdVideoDecodeH264ReferenceInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeH264ReferenceInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.flags, t.FrameNum, t.reserved, t.PicOrderCnt)
		end,
	}
)
mod.VkVideoDecodeH264PictureLayoutFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR = 0,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoDecodeH264PictureLayoutFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoDecodeH264ProfileInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stdProfileIdc;
	$ pictureLayout;
}]],
	mod.VkStructureType,
	mod.StdVideoH264ProfileIdc,
	mod.VkVideoDecodeH264PictureLayoutFlagBitsKHR
)
ffi.metatype(
	mod.VkVideoDecodeH264ProfileInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH264ProfileInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stdProfileIdc, t.pictureLayout)
		end,
	}
)
mod.VkVideoDecodeH264CapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maxLevelIdc;
	$ fieldOffsetGranularity;
}]],
	mod.VkStructureType,
	mod.StdVideoH264LevelIdc,
	mod.VkOffset2D
)
ffi.metatype(
	mod.VkVideoDecodeH264CapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH264CapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxLevelIdc, t.fieldOffsetGranularity)
		end,
	}
)
mod.VkVideoDecodeH264SessionParametersAddInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t stdSPSCount;
	const $* pStdSPSs;
	uint32_t stdPPSCount;
	const $* pStdPPSs;
}]],
	mod.VkStructureType,
	mod.StdVideoH264SequenceParameterSet,
	mod.StdVideoH264PictureParameterSet
)
ffi.metatype(
	mod.VkVideoDecodeH264SessionParametersAddInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH264SessionParametersAddInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stdSPSCount, t.pStdSPSs, t.stdPPSCount, t.pStdPPSs)
		end,
	}
)
mod.VkVideoDecodeH264SessionParametersCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t maxStdSPSCount;
	uint32_t maxStdPPSCount;
	const $* pParametersAddInfo;
}]],
	mod.VkStructureType,
	mod.VkVideoDecodeH264SessionParametersAddInfoKHR
)
ffi.metatype(
	mod.VkVideoDecodeH264SessionParametersCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH264SessionParametersCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxStdSPSCount,
				t.maxStdPPSCount,
				t.pParametersAddInfo
			)
		end,
	}
)
mod.VkVideoDecodeH264PictureInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdPictureInfo;
	uint32_t sliceCount;
	const uint32_t* pSliceOffsets;
}]],
	mod.VkStructureType,
	mod.StdVideoDecodeH264PictureInfo
)
ffi.metatype(
	mod.VkVideoDecodeH264PictureInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH264PictureInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pStdPictureInfo, t.sliceCount, t.pSliceOffsets)
		end,
	}
)
mod.VkVideoDecodeH264DpbSlotInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]],
	mod.VkStructureType,
	mod.StdVideoDecodeH264ReferenceInfo
)
ffi.metatype(
	mod.VkVideoDecodeH264DpbSlotInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH264DpbSlotInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pStdReferenceInfo)
		end,
	}
)
mod.VkRenderingFlagsKHR = ffi.typeof([[$ ]], mod.VkRenderingFlags)
mod.VkRenderingFlagBitsKHR = ffi.typeof([[$ ]], mod.VkRenderingFlagBits)
mod.VkRenderingInfoKHR = ffi.typeof([[$ ]], mod.VkRenderingInfo)
mod.VkRenderingAttachmentInfoKHR = ffi.typeof([[$ ]], mod.VkRenderingAttachmentInfo)
mod.VkPipelineRenderingCreateInfoKHR = ffi.typeof([[$ ]], mod.VkPipelineRenderingCreateInfo)
mod.VkPhysicalDeviceDynamicRenderingFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDynamicRenderingFeatures)
mod.VkCommandBufferInheritanceRenderingInfoKHR = ffi.typeof([[$ ]], mod.VkCommandBufferInheritanceRenderingInfo)
mod.PFN_vkCmdBeginRenderingKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkRenderingInfo)
mod.PFN_vkCmdEndRenderingKHR = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdBeginRenderingKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRenderingInfo
)
ffi.cdef([[void  vkCmdEndRenderingKHR($ );]], mod.VkCommandBuffer)
mod.VkRenderPassMultiviewCreateInfoKHR = ffi.typeof([[$ ]], mod.VkRenderPassMultiviewCreateInfo)
mod.VkPhysicalDeviceMultiviewFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMultiviewFeatures)
mod.VkPhysicalDeviceMultiviewPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMultiviewProperties)
mod.VkPhysicalDeviceFeatures2KHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceFeatures2)
mod.VkPhysicalDeviceProperties2KHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceProperties2)
mod.VkFormatProperties2KHR = ffi.typeof([[$ ]], mod.VkFormatProperties2)
mod.VkImageFormatProperties2KHR = ffi.typeof([[$ ]], mod.VkImageFormatProperties2)
mod.VkPhysicalDeviceImageFormatInfo2KHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceImageFormatInfo2)
mod.VkQueueFamilyProperties2KHR = ffi.typeof([[$ ]], mod.VkQueueFamilyProperties2)
mod.VkPhysicalDeviceMemoryProperties2KHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMemoryProperties2)
mod.VkSparseImageFormatProperties2KHR = ffi.typeof([[$ ]], mod.VkSparseImageFormatProperties2)
mod.VkPhysicalDeviceSparseImageFormatInfo2KHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSparseImageFormatInfo2)
mod.PFN_vkGetPhysicalDeviceFeatures2KHR = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceFeatures2)
mod.PFN_vkGetPhysicalDeviceProperties2KHR = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceProperties2)
mod.PFN_vkGetPhysicalDeviceFormatProperties2KHR = ffi.typeof(
	[[void (*)($ , $ , $*)]],
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkFormatProperties2
)
mod.PFN_vkGetPhysicalDeviceImageFormatProperties2KHR = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceImageFormatInfo2,
	mod.VkImageFormatProperties2
)
mod.PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR = ffi.typeof(
	[[void (*)($ , uint32_t*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkQueueFamilyProperties2
)
mod.PFN_vkGetPhysicalDeviceMemoryProperties2KHR = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceMemoryProperties2)
mod.PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = ffi.typeof(
	[[void (*)($ , const $*, uint32_t*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceSparseImageFormatInfo2,
	mod.VkSparseImageFormatProperties2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceFeatures2KHR($ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceFeatures2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceProperties2KHR($ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceProperties2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceFormatProperties2KHR($ , $ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkFormatProperties2
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceImageFormatProperties2KHR($ , const $*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceImageFormatInfo2,
	mod.VkImageFormatProperties2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceQueueFamilyProperties2KHR($ , uint32_t*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkQueueFamilyProperties2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceMemoryProperties2KHR($ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceMemoryProperties2
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceSparseImageFormatProperties2KHR($ , const $*, uint32_t*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceSparseImageFormatInfo2,
	mod.VkSparseImageFormatProperties2
)
mod.VkPeerMemoryFeatureFlagsKHR = ffi.typeof([[$ ]], mod.VkPeerMemoryFeatureFlags)
mod.VkPeerMemoryFeatureFlagBitsKHR = ffi.typeof([[$ ]], mod.VkPeerMemoryFeatureFlagBits)
mod.VkMemoryAllocateFlagsKHR = ffi.typeof([[$ ]], mod.VkMemoryAllocateFlags)
mod.VkMemoryAllocateFlagBitsKHR = ffi.typeof([[$ ]], mod.VkMemoryAllocateFlagBits)
mod.VkMemoryAllocateFlagsInfoKHR = ffi.typeof([[$ ]], mod.VkMemoryAllocateFlagsInfo)
mod.VkDeviceGroupRenderPassBeginInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceGroupRenderPassBeginInfo)
mod.VkDeviceGroupCommandBufferBeginInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceGroupCommandBufferBeginInfo)
mod.VkDeviceGroupSubmitInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceGroupSubmitInfo)
mod.VkDeviceGroupBindSparseInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceGroupBindSparseInfo)
mod.VkBindBufferMemoryDeviceGroupInfoKHR = ffi.typeof([[$ ]], mod.VkBindBufferMemoryDeviceGroupInfo)
mod.VkBindImageMemoryDeviceGroupInfoKHR = ffi.typeof([[$ ]], mod.VkBindImageMemoryDeviceGroupInfo)
mod.PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , uint32_t , $*)]],
	mod.VkDevice,
	mod.VkPeerMemoryFeatureFlags
)
mod.PFN_vkCmdSetDeviceMaskKHR = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDispatchBaseKHR = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t )]],
	mod.VkCommandBuffer
)
ffi.cdef(
	[[void  vkGetDeviceGroupPeerMemoryFeaturesKHR($ , uint32_t , uint32_t , uint32_t , $*);]],
	mod.VkDevice,
	mod.VkPeerMemoryFeatureFlags
)
ffi.cdef([[void  vkCmdSetDeviceMaskKHR($ , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdDispatchBaseKHR($ , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t );]],
	mod.VkCommandBuffer
)
mod.VkCommandPoolTrimFlagsKHR = ffi.typeof([[$ ]], mod.VkCommandPoolTrimFlags)
mod.PFN_vkTrimCommandPoolKHR = ffi.typeof(
	[[void (*)($ , $ , $ )]],
	mod.VkDevice,
	mod.VkCommandPool,
	mod.VkCommandPoolTrimFlags
)
ffi.cdef(
	[[void  vkTrimCommandPoolKHR($ , $ , $ );]],
	mod.VkDevice,
	mod.VkCommandPool,
	mod.VkCommandPoolTrimFlags
)
mod.VkPhysicalDeviceGroupPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceGroupProperties)
mod.VkDeviceGroupDeviceCreateInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceGroupDeviceCreateInfo)
mod.PFN_vkEnumeratePhysicalDeviceGroupsKHR = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkPhysicalDeviceGroupProperties
)
ffi.cdef(
	[[$  vkEnumeratePhysicalDeviceGroupsKHR($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkPhysicalDeviceGroupProperties
)
mod.VkExternalMemoryHandleTypeFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryHandleTypeFlags)
mod.VkExternalMemoryHandleTypeFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryHandleTypeFlagBits)
mod.VkExternalMemoryFeatureFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryFeatureFlags)
mod.VkExternalMemoryFeatureFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryFeatureFlagBits)
mod.VkExternalMemoryPropertiesKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryProperties)
mod.VkPhysicalDeviceExternalImageFormatInfoKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceExternalImageFormatInfo)
mod.VkExternalImageFormatPropertiesKHR = ffi.typeof([[$ ]], mod.VkExternalImageFormatProperties)
mod.VkPhysicalDeviceExternalBufferInfoKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceExternalBufferInfo)
mod.VkExternalBufferPropertiesKHR = ffi.typeof([[$ ]], mod.VkExternalBufferProperties)
mod.VkPhysicalDeviceIDPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceIDProperties)
mod.PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalBufferInfo,
	mod.VkExternalBufferProperties
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceExternalBufferPropertiesKHR($ , const $*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalBufferInfo,
	mod.VkExternalBufferProperties
)
mod.VkExternalMemoryImageCreateInfoKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryImageCreateInfo)
mod.VkExternalMemoryBufferCreateInfoKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryBufferCreateInfo)
mod.VkExportMemoryAllocateInfoKHR = ffi.typeof([[$ ]], mod.VkExportMemoryAllocateInfo)
mod.VkImportMemoryFdInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleType;
	int fd;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryHandleTypeFlagBits
)
ffi.metatype(
	mod.VkImportMemoryFdInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkImportMemoryFdInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleType, t.fd)
		end,
	}
)
mod.VkMemoryFdPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t memoryTypeBits;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkMemoryFdPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkMemoryFdPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memoryTypeBits)
		end,
	}
)
mod.VkMemoryGetFdInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ memory;
	$ handleType;
}]],
	mod.VkStructureType,
	mod.VkDeviceMemory,
	mod.VkExternalMemoryHandleTypeFlagBits
)
ffi.metatype(
	mod.VkMemoryGetFdInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkMemoryGetFdInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memory, t.handleType)
		end,
	}
)
mod.PFN_vkGetMemoryFdKHR = ffi.typeof(
	[[$ (*)($ , const $*, int*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryGetFdInfoKHR
)
mod.PFN_vkGetMemoryFdPropertiesKHR = ffi.typeof(
	[[$ (*)($ , $ , int , $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkExternalMemoryHandleTypeFlagBits,
	mod.VkMemoryFdPropertiesKHR
)
ffi.cdef(
	[[$  vkGetMemoryFdKHR($ , const $*, int*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryGetFdInfoKHR
)
ffi.cdef(
	[[$  vkGetMemoryFdPropertiesKHR($ , $ , int , $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkExternalMemoryHandleTypeFlagBits,
	mod.VkMemoryFdPropertiesKHR
)
mod.VkExternalSemaphoreHandleTypeFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalSemaphoreHandleTypeFlags)
mod.VkExternalSemaphoreHandleTypeFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalSemaphoreHandleTypeFlagBits)
mod.VkExternalSemaphoreFeatureFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalSemaphoreFeatureFlags)
mod.VkExternalSemaphoreFeatureFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalSemaphoreFeatureFlagBits)
mod.VkPhysicalDeviceExternalSemaphoreInfoKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceExternalSemaphoreInfo)
mod.VkExternalSemaphorePropertiesKHR = ffi.typeof([[$ ]], mod.VkExternalSemaphoreProperties)
mod.PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalSemaphoreInfo,
	mod.VkExternalSemaphoreProperties
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceExternalSemaphorePropertiesKHR($ , const $*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalSemaphoreInfo,
	mod.VkExternalSemaphoreProperties
)
mod.VkSemaphoreImportFlagsKHR = ffi.typeof([[$ ]], mod.VkSemaphoreImportFlags)
mod.VkSemaphoreImportFlagBitsKHR = ffi.typeof([[$ ]], mod.VkSemaphoreImportFlagBits)
mod.VkExportSemaphoreCreateInfoKHR = ffi.typeof([[$ ]], mod.VkExportSemaphoreCreateInfo)
mod.VkImportSemaphoreFdInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ semaphore;
	$ flags;
	$ handleType;
	int fd;
}]],
	mod.VkStructureType,
	mod.VkSemaphore,
	mod.VkSemaphoreImportFlags,
	mod.VkExternalSemaphoreHandleTypeFlagBits
)
ffi.metatype(
	mod.VkImportSemaphoreFdInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkImportSemaphoreFdInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.semaphore, t.flags, t.handleType, t.fd)
		end,
	}
)
mod.VkSemaphoreGetFdInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ semaphore;
	$ handleType;
}]],
	mod.VkStructureType,
	mod.VkSemaphore,
	mod.VkExternalSemaphoreHandleTypeFlagBits
)
ffi.metatype(
	mod.VkSemaphoreGetFdInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkSemaphoreGetFdInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.semaphore, t.handleType)
		end,
	}
)
mod.PFN_vkImportSemaphoreFdKHR = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImportSemaphoreFdInfoKHR
)
mod.PFN_vkGetSemaphoreFdKHR = ffi.typeof(
	[[$ (*)($ , const $*, int*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphoreGetFdInfoKHR
)
ffi.cdef(
	[[$  vkImportSemaphoreFdKHR($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImportSemaphoreFdInfoKHR
)
ffi.cdef(
	[[$  vkGetSemaphoreFdKHR($ , const $*, int*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphoreGetFdInfoKHR
)
mod.VkPhysicalDevicePushDescriptorPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDevicePushDescriptorProperties)
mod.PFN_vkCmdPushDescriptorSetKHR = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipelineLayout,
	mod.VkWriteDescriptorSet
)
mod.PFN_vkCmdPushDescriptorSetWithTemplateKHR = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , const void*)]],
	mod.VkCommandBuffer,
	mod.VkDescriptorUpdateTemplate,
	mod.VkPipelineLayout
)
ffi.cdef(
	[[void  vkCmdPushDescriptorSetKHR($ , $ , $ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipelineLayout,
	mod.VkWriteDescriptorSet
)
ffi.cdef(
	[[void  vkCmdPushDescriptorSetWithTemplateKHR($ , $ , $ , uint32_t , const void*);]],
	mod.VkCommandBuffer,
	mod.VkDescriptorUpdateTemplate,
	mod.VkPipelineLayout
)
mod.VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderFloat16Int8Features)
mod.VkPhysicalDeviceFloat16Int8FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderFloat16Int8Features)
mod.VkPhysicalDevice16BitStorageFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDevice16BitStorageFeatures)
mod.VkRectLayerKHR = ffi.typeof(
	[[struct {
	$ offset;
	$ extent;
	uint32_t layer;
}]],
	mod.VkOffset2D,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkRectLayerKHR,
	{
		__tostring = function(s)
			return ("struct VkRectLayerKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.offset, t.extent, t.layer)
		end,
	}
)
mod.VkPresentRegionKHR = ffi.typeof(
	[[struct {
	uint32_t rectangleCount;
	const $* pRectangles;
}]],
	mod.VkRectLayerKHR
)
ffi.metatype(
	mod.VkPresentRegionKHR,
	{
		__tostring = function(s)
			return ("struct VkPresentRegionKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.rectangleCount, t.pRectangles)
		end,
	}
)
mod.VkPresentRegionsKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const $* pRegions;
}]],
	mod.VkStructureType,
	mod.VkPresentRegionKHR
)
ffi.metatype(
	mod.VkPresentRegionsKHR,
	{
		__tostring = function(s)
			return ("struct VkPresentRegionsKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.swapchainCount, t.pRegions)
		end,
	}
)
mod.VkDescriptorUpdateTemplateKHR = ffi.typeof([[$ ]], mod.VkDescriptorUpdateTemplate)
mod.VkDescriptorUpdateTemplateTypeKHR = ffi.typeof([[$ ]], mod.VkDescriptorUpdateTemplateType)
mod.VkDescriptorUpdateTemplateCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkDescriptorUpdateTemplateCreateFlags)
mod.VkDescriptorUpdateTemplateEntryKHR = ffi.typeof([[$ ]], mod.VkDescriptorUpdateTemplateEntry)
mod.VkDescriptorUpdateTemplateCreateInfoKHR = ffi.typeof([[$ ]], mod.VkDescriptorUpdateTemplateCreateInfo)
mod.PFN_vkCreateDescriptorUpdateTemplateKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorUpdateTemplateCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDescriptorUpdateTemplate
)
mod.PFN_vkDestroyDescriptorUpdateTemplateKHR = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkDescriptorUpdateTemplate,
	mod.VkAllocationCallbacks
)
mod.PFN_vkUpdateDescriptorSetWithTemplateKHR = ffi.typeof(
	[[void (*)($ , $ , $ , const void*)]],
	mod.VkDevice,
	mod.VkDescriptorSet,
	mod.VkDescriptorUpdateTemplate
)
ffi.cdef(
	[[$  vkCreateDescriptorUpdateTemplateKHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDescriptorUpdateTemplateCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkDescriptorUpdateTemplate
)
ffi.cdef(
	[[void  vkDestroyDescriptorUpdateTemplateKHR($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkDescriptorUpdateTemplate,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkUpdateDescriptorSetWithTemplateKHR($ , $ , $ , const void*);]],
	mod.VkDevice,
	mod.VkDescriptorSet,
	mod.VkDescriptorUpdateTemplate
)
mod.VkPhysicalDeviceImagelessFramebufferFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceImagelessFramebufferFeatures)
mod.VkFramebufferAttachmentsCreateInfoKHR = ffi.typeof([[$ ]], mod.VkFramebufferAttachmentsCreateInfo)
mod.VkFramebufferAttachmentImageInfoKHR = ffi.typeof([[$ ]], mod.VkFramebufferAttachmentImageInfo)
mod.VkRenderPassAttachmentBeginInfoKHR = ffi.typeof([[$ ]], mod.VkRenderPassAttachmentBeginInfo)
mod.VkRenderPassCreateInfo2KHR = ffi.typeof([[$ ]], mod.VkRenderPassCreateInfo2)
mod.VkAttachmentDescription2KHR = ffi.typeof([[$ ]], mod.VkAttachmentDescription2)
mod.VkAttachmentReference2KHR = ffi.typeof([[$ ]], mod.VkAttachmentReference2)
mod.VkSubpassDescription2KHR = ffi.typeof([[$ ]], mod.VkSubpassDescription2)
mod.VkSubpassDependency2KHR = ffi.typeof([[$ ]], mod.VkSubpassDependency2)
mod.VkSubpassBeginInfoKHR = ffi.typeof([[$ ]], mod.VkSubpassBeginInfo)
mod.VkSubpassEndInfoKHR = ffi.typeof([[$ ]], mod.VkSubpassEndInfo)
mod.PFN_vkCreateRenderPass2KHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkRenderPassCreateInfo2,
	mod.VkAllocationCallbacks,
	mod.VkRenderPass
)
mod.PFN_vkCmdBeginRenderPass2KHR = ffi.typeof(
	[[void (*)($ , const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkRenderPassBeginInfo,
	mod.VkSubpassBeginInfo
)
mod.PFN_vkCmdNextSubpass2KHR = ffi.typeof(
	[[void (*)($ , const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkSubpassBeginInfo,
	mod.VkSubpassEndInfo
)
mod.PFN_vkCmdEndRenderPass2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkSubpassEndInfo)
ffi.cdef(
	[[$  vkCreateRenderPass2KHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkRenderPassCreateInfo2,
	mod.VkAllocationCallbacks,
	mod.VkRenderPass
)
ffi.cdef(
	[[void  vkCmdBeginRenderPass2KHR($ , const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkRenderPassBeginInfo,
	mod.VkSubpassBeginInfo
)
ffi.cdef(
	[[void  vkCmdNextSubpass2KHR($ , const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkSubpassBeginInfo,
	mod.VkSubpassEndInfo
)
ffi.cdef(
	[[void  vkCmdEndRenderPass2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkSubpassEndInfo
)
mod.VkSharedPresentSurfaceCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ sharedPresentSupportedUsageFlags;
}]],
	mod.VkStructureType,
	mod.VkImageUsageFlags
)
ffi.metatype(
	mod.VkSharedPresentSurfaceCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkSharedPresentSurfaceCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.sharedPresentSupportedUsageFlags)
		end,
	}
)
mod.PFN_vkGetSwapchainStatusKHR = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR)
ffi.cdef(
	[[$  vkGetSwapchainStatusKHR($ , $ );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR
)
mod.VkExternalFenceHandleTypeFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalFenceHandleTypeFlags)
mod.VkExternalFenceHandleTypeFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalFenceHandleTypeFlagBits)
mod.VkExternalFenceFeatureFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalFenceFeatureFlags)
mod.VkExternalFenceFeatureFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalFenceFeatureFlagBits)
mod.VkPhysicalDeviceExternalFenceInfoKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceExternalFenceInfo)
mod.VkExternalFencePropertiesKHR = ffi.typeof([[$ ]], mod.VkExternalFenceProperties)
mod.PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalFenceInfo,
	mod.VkExternalFenceProperties
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceExternalFencePropertiesKHR($ , const $*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalFenceInfo,
	mod.VkExternalFenceProperties
)
mod.VkFenceImportFlagsKHR = ffi.typeof([[$ ]], mod.VkFenceImportFlags)
mod.VkFenceImportFlagBitsKHR = ffi.typeof([[$ ]], mod.VkFenceImportFlagBits)
mod.VkExportFenceCreateInfoKHR = ffi.typeof([[$ ]], mod.VkExportFenceCreateInfo)
mod.VkImportFenceFdInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ fence;
	$ flags;
	$ handleType;
	int fd;
}]],
	mod.VkStructureType,
	mod.VkFence,
	mod.VkFenceImportFlags,
	mod.VkExternalFenceHandleTypeFlagBits
)
ffi.metatype(
	mod.VkImportFenceFdInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkImportFenceFdInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.fence, t.flags, t.handleType, t.fd)
		end,
	}
)
mod.VkFenceGetFdInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ fence;
	$ handleType;
}]],
	mod.VkStructureType,
	mod.VkFence,
	mod.VkExternalFenceHandleTypeFlagBits
)
ffi.metatype(
	mod.VkFenceGetFdInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkFenceGetFdInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.fence, t.handleType)
		end,
	}
)
mod.PFN_vkImportFenceFdKHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkImportFenceFdInfoKHR)
mod.PFN_vkGetFenceFdKHR = ffi.typeof(
	[[$ (*)($ , const $*, int*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkFenceGetFdInfoKHR
)
ffi.cdef(
	[[$  vkImportFenceFdKHR($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImportFenceFdInfoKHR
)
ffi.cdef(
	[[$  vkGetFenceFdKHR($ , const $*, int*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkFenceGetFdInfoKHR
)
mod.VkPerformanceCounterUnitKHR = ffi.typeof([[enum {
	VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
	VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
	VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
	VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
	VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
	VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
	VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
	VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
	VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
	VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPerformanceCounterScopeKHR = ffi.typeof([[enum {
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
	VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
	VK_QUERY_SCOPE_COMMAND_BUFFER_KHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
	VK_QUERY_SCOPE_RENDER_PASS_KHR = VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
	VK_QUERY_SCOPE_COMMAND_KHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
	VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPerformanceCounterStorageKHR = ffi.typeof([[enum {
	VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
	VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
	VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPerformanceCounterDescriptionFlagBitsKHR = ffi.typeof([[enum {
	VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 0x00000001,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 0x00000002,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPerformanceCounterDescriptionFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkAcquireProfilingLockFlagBitsKHR = ffi.typeof([[enum {
	VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAcquireProfilingLockFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDevicePerformanceQueryFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ performanceCounterQueryPools;
	$ performanceCounterMultipleQueryPools;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePerformanceQueryFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePerformanceQueryFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.performanceCounterQueryPools,
				t.performanceCounterMultipleQueryPools
			)
		end,
	}
)
mod.VkPhysicalDevicePerformanceQueryPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ allowCommandBufferQueryCopies;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePerformanceQueryPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePerformanceQueryPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.allowCommandBufferQueryCopies)
		end,
	}
)
mod.VkPerformanceCounterKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ unit;
	$ scope;
	$ storage;
	uint8_t uuid[16U];
}]],
	mod.VkStructureType,
	mod.VkPerformanceCounterUnitKHR,
	mod.VkPerformanceCounterScopeKHR,
	mod.VkPerformanceCounterStorageKHR
)
ffi.metatype(
	mod.VkPerformanceCounterKHR,
	{
		__tostring = function(s)
			return ("struct VkPerformanceCounterKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.unit, t.scope, t.storage, t.uuid)
		end,
	}
)
mod.VkPerformanceCounterDescriptionKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
	char name[256U];
	char category[256U];
	char description[256U];
}]],
	mod.VkStructureType,
	mod.VkPerformanceCounterDescriptionFlagsKHR
)
ffi.metatype(
	mod.VkPerformanceCounterDescriptionKHR,
	{
		__tostring = function(s)
			return ("struct VkPerformanceCounterDescriptionKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.name, t.category, t.description)
		end,
	}
)
mod.VkQueryPoolPerformanceCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t queueFamilyIndex;
	uint32_t counterIndexCount;
	const uint32_t* pCounterIndices;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkQueryPoolPerformanceCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkQueryPoolPerformanceCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.queueFamilyIndex,
				t.counterIndexCount,
				t.pCounterIndices
			)
		end,
	}
)
mod.VkPerformanceCounterResultKHR = ffi.typeof([[union {
	int32_t int32;
	int64_t int64;
	uint32_t uint32;
	uint64_t uint64;
	float float32;
	double float64;
}]])
ffi.metatype(
	mod.VkPerformanceCounterResultKHR,
	{
		__tostring = function(s)
			return ("struct VkPerformanceCounterResultKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.int32 ~= nil then obj.int32 = t.int32 end

			if t.int64 ~= nil then obj.int64 = t.int64 end

			if t.uint32 ~= nil then obj.uint32 = t.uint32 end

			if t.uint64 ~= nil then obj.uint64 = t.uint64 end

			if t.float32 ~= nil then obj.float32 = t.float32 end

			if t.float64 ~= nil then obj.float64 = t.float64 end

			return obj
		end,
	}
)
mod.VkAcquireProfilingLockInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint64_t timeout;
}]],
	mod.VkStructureType,
	mod.VkAcquireProfilingLockFlagsKHR
)
ffi.metatype(
	mod.VkAcquireProfilingLockInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkAcquireProfilingLockInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.timeout)
		end,
	}
)
mod.VkPerformanceQuerySubmitInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t counterPassIndex;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPerformanceQuerySubmitInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPerformanceQuerySubmitInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.counterPassIndex)
		end,
	}
)
mod.PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = ffi.typeof(
	[[$ (*)($ , uint32_t , uint32_t*, $*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPerformanceCounterKHR,
	mod.VkPerformanceCounterDescriptionKHR
)
mod.PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = ffi.typeof(
	[[void (*)($ , const $*, uint32_t*)]],
	mod.VkPhysicalDevice,
	mod.VkQueryPoolPerformanceCreateInfoKHR
)
mod.PFN_vkAcquireProfilingLockKHR = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAcquireProfilingLockInfoKHR
)
mod.PFN_vkReleaseProfilingLockKHR = ffi.typeof([[void (*)($ )]], mod.VkDevice)
ffi.cdef(
	[[$  vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR($ , uint32_t , uint32_t*, $*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPerformanceCounterKHR,
	mod.VkPerformanceCounterDescriptionKHR
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR($ , const $*, uint32_t*);]],
	mod.VkPhysicalDevice,
	mod.VkQueryPoolPerformanceCreateInfoKHR
)
ffi.cdef(
	[[$  vkAcquireProfilingLockKHR($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAcquireProfilingLockInfoKHR
)
ffi.cdef([[void  vkReleaseProfilingLockKHR($ );]], mod.VkDevice)
mod.VkPointClippingBehaviorKHR = ffi.typeof([[$ ]], mod.VkPointClippingBehavior)
mod.VkTessellationDomainOriginKHR = ffi.typeof([[$ ]], mod.VkTessellationDomainOrigin)
mod.VkPhysicalDevicePointClippingPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDevicePointClippingProperties)
mod.VkRenderPassInputAttachmentAspectCreateInfoKHR = ffi.typeof([[$ ]], mod.VkRenderPassInputAttachmentAspectCreateInfo)
mod.VkInputAttachmentAspectReferenceKHR = ffi.typeof([[$ ]], mod.VkInputAttachmentAspectReference)
mod.VkImageViewUsageCreateInfoKHR = ffi.typeof([[$ ]], mod.VkImageViewUsageCreateInfo)
mod.VkPipelineTessellationDomainOriginStateCreateInfoKHR = ffi.typeof([[$ ]], mod.VkPipelineTessellationDomainOriginStateCreateInfo)
mod.VkPhysicalDeviceSurfaceInfo2KHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ surface;
}]],
	mod.VkStructureType,
	mod.VkSurfaceKHR
)
ffi.metatype(
	mod.VkPhysicalDeviceSurfaceInfo2KHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSurfaceInfo2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.surface)
		end,
	}
)
mod.VkSurfaceCapabilities2KHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ surfaceCapabilities;
}]],
	mod.VkStructureType,
	mod.VkSurfaceCapabilitiesKHR
)
ffi.metatype(
	mod.VkSurfaceCapabilities2KHR,
	{
		__tostring = function(s)
			return ("struct VkSurfaceCapabilities2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.surfaceCapabilities)
		end,
	}
)
mod.VkSurfaceFormat2KHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ surfaceFormat;
}]],
	mod.VkStructureType,
	mod.VkSurfaceFormatKHR
)
ffi.metatype(
	mod.VkSurfaceFormat2KHR,
	{
		__tostring = function(s)
			return ("struct VkSurfaceFormat2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.surfaceFormat)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceSurfaceInfo2KHR,
	mod.VkSurfaceCapabilities2KHR
)
mod.PFN_vkGetPhysicalDeviceSurfaceFormats2KHR = ffi.typeof(
	[[$ (*)($ , const $*, uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceSurfaceInfo2KHR,
	mod.VkSurfaceFormat2KHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceSurfaceCapabilities2KHR($ , const $*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceSurfaceInfo2KHR,
	mod.VkSurfaceCapabilities2KHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceSurfaceFormats2KHR($ , const $*, uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceSurfaceInfo2KHR,
	mod.VkSurfaceFormat2KHR
)
mod.VkPhysicalDeviceVariablePointerFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVariablePointersFeatures)
mod.VkPhysicalDeviceVariablePointersFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVariablePointersFeatures)
mod.VkDisplayProperties2KHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ displayProperties;
}]],
	mod.VkStructureType,
	mod.VkDisplayPropertiesKHR
)
ffi.metatype(
	mod.VkDisplayProperties2KHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayProperties2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.displayProperties)
		end,
	}
)
mod.VkDisplayPlaneProperties2KHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ displayPlaneProperties;
}]],
	mod.VkStructureType,
	mod.VkDisplayPlanePropertiesKHR
)
ffi.metatype(
	mod.VkDisplayPlaneProperties2KHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayPlaneProperties2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.displayPlaneProperties)
		end,
	}
)
mod.VkDisplayModeProperties2KHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ displayModeProperties;
}]],
	mod.VkStructureType,
	mod.VkDisplayModePropertiesKHR
)
ffi.metatype(
	mod.VkDisplayModeProperties2KHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayModeProperties2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.displayModeProperties)
		end,
	}
)
mod.VkDisplayPlaneInfo2KHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ mode;
	uint32_t planeIndex;
}]],
	mod.VkStructureType,
	mod.VkDisplayModeKHR
)
ffi.metatype(
	mod.VkDisplayPlaneInfo2KHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayPlaneInfo2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.mode, t.planeIndex)
		end,
	}
)
mod.VkDisplayPlaneCapabilities2KHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ capabilities;
}]],
	mod.VkStructureType,
	mod.VkDisplayPlaneCapabilitiesKHR
)
ffi.metatype(
	mod.VkDisplayPlaneCapabilities2KHR,
	{
		__tostring = function(s)
			return ("struct VkDisplayPlaneCapabilities2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.capabilities)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceDisplayProperties2KHR = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayProperties2KHR
)
mod.PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayPlaneProperties2KHR
)
mod.PFN_vkGetDisplayModeProperties2KHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR,
	mod.VkDisplayModeProperties2KHR
)
mod.PFN_vkGetDisplayPlaneCapabilities2KHR = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayPlaneInfo2KHR,
	mod.VkDisplayPlaneCapabilities2KHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceDisplayProperties2KHR($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayProperties2KHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceDisplayPlaneProperties2KHR($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayPlaneProperties2KHR
)
ffi.cdef(
	[[$  vkGetDisplayModeProperties2KHR($ , $ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR,
	mod.VkDisplayModeProperties2KHR
)
ffi.cdef(
	[[$  vkGetDisplayPlaneCapabilities2KHR($ , const $*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayPlaneInfo2KHR,
	mod.VkDisplayPlaneCapabilities2KHR
)
mod.VkMemoryDedicatedRequirementsKHR = ffi.typeof([[$ ]], mod.VkMemoryDedicatedRequirements)
mod.VkMemoryDedicatedAllocateInfoKHR = ffi.typeof([[$ ]], mod.VkMemoryDedicatedAllocateInfo)
mod.VkPhysicalDeviceShaderBfloat16FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderBFloat16Type;
	$ shaderBFloat16DotProduct;
	$ shaderBFloat16CooperativeMatrix;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderBfloat16FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderBfloat16FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderBFloat16Type,
				t.shaderBFloat16DotProduct,
				t.shaderBFloat16CooperativeMatrix
			)
		end,
	}
)
mod.VkBufferMemoryRequirementsInfo2KHR = ffi.typeof([[$ ]], mod.VkBufferMemoryRequirementsInfo2)
mod.VkImageMemoryRequirementsInfo2KHR = ffi.typeof([[$ ]], mod.VkImageMemoryRequirementsInfo2)
mod.VkImageSparseMemoryRequirementsInfo2KHR = ffi.typeof([[$ ]], mod.VkImageSparseMemoryRequirementsInfo2)
mod.VkMemoryRequirements2KHR = ffi.typeof([[$ ]], mod.VkMemoryRequirements2)
mod.VkSparseImageMemoryRequirements2KHR = ffi.typeof([[$ ]], mod.VkSparseImageMemoryRequirements2)
mod.PFN_vkGetImageMemoryRequirements2KHR = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkImageMemoryRequirementsInfo2,
	mod.VkMemoryRequirements2
)
mod.PFN_vkGetBufferMemoryRequirements2KHR = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkBufferMemoryRequirementsInfo2,
	mod.VkMemoryRequirements2
)
mod.PFN_vkGetImageSparseMemoryRequirements2KHR = ffi.typeof(
	[[void (*)($ , const $*, uint32_t*, $*)]],
	mod.VkDevice,
	mod.VkImageSparseMemoryRequirementsInfo2,
	mod.VkSparseImageMemoryRequirements2
)
ffi.cdef(
	[[void  vkGetImageMemoryRequirements2KHR($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkImageMemoryRequirementsInfo2,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkGetBufferMemoryRequirements2KHR($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkBufferMemoryRequirementsInfo2,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkGetImageSparseMemoryRequirements2KHR($ , const $*, uint32_t*, $*);]],
	mod.VkDevice,
	mod.VkImageSparseMemoryRequirementsInfo2,
	mod.VkSparseImageMemoryRequirements2
)
mod.VkImageFormatListCreateInfoKHR = ffi.typeof([[$ ]], mod.VkImageFormatListCreateInfo)
mod.VkSamplerYcbcrConversionKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrConversion)
mod.VkSamplerYcbcrModelConversionKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrModelConversion)
mod.VkSamplerYcbcrRangeKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrRange)
mod.VkChromaLocationKHR = ffi.typeof([[$ ]], mod.VkChromaLocation)
mod.VkSamplerYcbcrConversionCreateInfoKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrConversionCreateInfo)
mod.VkSamplerYcbcrConversionInfoKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrConversionInfo)
mod.VkBindImagePlaneMemoryInfoKHR = ffi.typeof([[$ ]], mod.VkBindImagePlaneMemoryInfo)
mod.VkImagePlaneMemoryRequirementsInfoKHR = ffi.typeof([[$ ]], mod.VkImagePlaneMemoryRequirementsInfo)
mod.VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSamplerYcbcrConversionFeatures)
mod.VkSamplerYcbcrConversionImageFormatPropertiesKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrConversionImageFormatProperties)
mod.PFN_vkCreateSamplerYcbcrConversionKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSamplerYcbcrConversionCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkSamplerYcbcrConversion
)
mod.PFN_vkDestroySamplerYcbcrConversionKHR = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkSamplerYcbcrConversion,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateSamplerYcbcrConversionKHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSamplerYcbcrConversionCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkSamplerYcbcrConversion
)
ffi.cdef(
	[[void  vkDestroySamplerYcbcrConversionKHR($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkSamplerYcbcrConversion,
	mod.VkAllocationCallbacks
)
mod.VkBindBufferMemoryInfoKHR = ffi.typeof([[$ ]], mod.VkBindBufferMemoryInfo)
mod.VkBindImageMemoryInfoKHR = ffi.typeof([[$ ]], mod.VkBindImageMemoryInfo)
mod.PFN_vkBindBufferMemory2KHR = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindBufferMemoryInfo
)
mod.PFN_vkBindImageMemory2KHR = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindImageMemoryInfo
)
ffi.cdef(
	[[$  vkBindBufferMemory2KHR($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindBufferMemoryInfo
)
ffi.cdef(
	[[$  vkBindImageMemory2KHR($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindImageMemoryInfo
)
mod.VkPhysicalDeviceMaintenance3PropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance3Properties)
mod.VkDescriptorSetLayoutSupportKHR = ffi.typeof([[$ ]], mod.VkDescriptorSetLayoutSupport)
mod.PFN_vkGetDescriptorSetLayoutSupportKHR = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkDescriptorSetLayoutCreateInfo,
	mod.VkDescriptorSetLayoutSupport
)
ffi.cdef(
	[[void  vkGetDescriptorSetLayoutSupportKHR($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDescriptorSetLayoutCreateInfo,
	mod.VkDescriptorSetLayoutSupport
)
mod.PFN_vkCmdDrawIndirectCountKHR = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdDrawIndexedIndirectCountKHR = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdDrawIndirectCountKHR($ , $ , $ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdDrawIndexedIndirectCountKHR($ , $ , $ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures)
mod.VkPhysicalDevice8BitStorageFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDevice8BitStorageFeatures)
mod.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderAtomicInt64Features)
mod.VkPhysicalDeviceShaderClockFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderSubgroupClock;
	$ shaderDeviceClock;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderClockFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderClockFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderSubgroupClock, t.shaderDeviceClock)
		end,
	}
)
mod.StdVideoDecodeH265PictureInfoFlags = ffi.typeof([[struct {
	uint32_t IrapPicFlag;
	uint32_t IdrPicFlag;
	uint32_t IsReference;
	uint32_t short_term_ref_pic_set_sps_flag;
}]])
ffi.metatype(
	mod.StdVideoDecodeH265PictureInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeH265PictureInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.IrapPicFlag,
				t.IdrPicFlag,
				t.IsReference,
				t.short_term_ref_pic_set_sps_flag
			)
		end,
	}
)
mod.StdVideoDecodeH265PictureInfo = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t sps_video_parameter_set_id;
	uint8_t pps_seq_parameter_set_id;
	uint8_t pps_pic_parameter_set_id;
	uint8_t NumDeltaPocsOfRefRpsIdx;
	int32_t PicOrderCntVal;
	uint16_t NumBitsForSTRefPicSetInSlice;
	uint16_t reserved;
	uint8_t RefPicSetStCurrBefore[8U];
	uint8_t RefPicSetStCurrAfter[8U];
	uint8_t RefPicSetLtCurr[8U];
}]],
	mod.StdVideoDecodeH265PictureInfoFlags
)
ffi.metatype(
	mod.StdVideoDecodeH265PictureInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeH265PictureInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.sps_video_parameter_set_id,
				t.pps_seq_parameter_set_id,
				t.pps_pic_parameter_set_id,
				t.NumDeltaPocsOfRefRpsIdx,
				t.PicOrderCntVal,
				t.NumBitsForSTRefPicSetInSlice,
				t.reserved,
				t.RefPicSetStCurrBefore,
				t.RefPicSetStCurrAfter,
				t.RefPicSetLtCurr
			)
		end,
	}
)
mod.StdVideoDecodeH265ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t used_for_long_term_reference;
	uint32_t unused_for_reference;
}]])
ffi.metatype(
	mod.StdVideoDecodeH265ReferenceInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeH265ReferenceInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.used_for_long_term_reference, t.unused_for_reference)
		end,
	}
)
mod.StdVideoDecodeH265ReferenceInfo = ffi.typeof(
	[[struct {
	$ flags;
	int32_t PicOrderCntVal;
}]],
	mod.StdVideoDecodeH265ReferenceInfoFlags
)
ffi.metatype(
	mod.StdVideoDecodeH265ReferenceInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeH265ReferenceInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.flags, t.PicOrderCntVal)
		end,
	}
)
mod.VkVideoDecodeH265ProfileInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stdProfileIdc;
}]],
	mod.VkStructureType,
	mod.StdVideoH265ProfileIdc
)
ffi.metatype(
	mod.VkVideoDecodeH265ProfileInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH265ProfileInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stdProfileIdc)
		end,
	}
)
mod.VkVideoDecodeH265CapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maxLevelIdc;
}]],
	mod.VkStructureType,
	mod.StdVideoH265LevelIdc
)
ffi.metatype(
	mod.VkVideoDecodeH265CapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH265CapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxLevelIdc)
		end,
	}
)
mod.VkVideoDecodeH265SessionParametersAddInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t stdVPSCount;
	const $* pStdVPSs;
	uint32_t stdSPSCount;
	const $* pStdSPSs;
	uint32_t stdPPSCount;
	const $* pStdPPSs;
}]],
	mod.VkStructureType,
	mod.StdVideoH265VideoParameterSet,
	mod.StdVideoH265SequenceParameterSet,
	mod.StdVideoH265PictureParameterSet
)
ffi.metatype(
	mod.VkVideoDecodeH265SessionParametersAddInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH265SessionParametersAddInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.stdVPSCount,
				t.pStdVPSs,
				t.stdSPSCount,
				t.pStdSPSs,
				t.stdPPSCount,
				t.pStdPPSs
			)
		end,
	}
)
mod.VkVideoDecodeH265SessionParametersCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t maxStdVPSCount;
	uint32_t maxStdSPSCount;
	uint32_t maxStdPPSCount;
	const $* pParametersAddInfo;
}]],
	mod.VkStructureType,
	mod.VkVideoDecodeH265SessionParametersAddInfoKHR
)
ffi.metatype(
	mod.VkVideoDecodeH265SessionParametersCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH265SessionParametersCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxStdVPSCount,
				t.maxStdSPSCount,
				t.maxStdPPSCount,
				t.pParametersAddInfo
			)
		end,
	}
)
mod.VkVideoDecodeH265PictureInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdPictureInfo;
	uint32_t sliceSegmentCount;
	const uint32_t* pSliceSegmentOffsets;
}]],
	mod.VkStructureType,
	mod.StdVideoDecodeH265PictureInfo
)
ffi.metatype(
	mod.VkVideoDecodeH265PictureInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH265PictureInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pStdPictureInfo,
				t.sliceSegmentCount,
				t.pSliceSegmentOffsets
			)
		end,
	}
)
mod.VkVideoDecodeH265DpbSlotInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]],
	mod.VkStructureType,
	mod.StdVideoDecodeH265ReferenceInfo
)
ffi.metatype(
	mod.VkVideoDecodeH265DpbSlotInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH265DpbSlotInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pStdReferenceInfo)
		end,
	}
)
mod.VkQueueGlobalPriorityKHR = ffi.typeof([[$ ]], mod.VkQueueGlobalPriority)
mod.VkDeviceQueueGlobalPriorityCreateInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceQueueGlobalPriorityCreateInfo)
mod.VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceGlobalPriorityQueryFeatures)
mod.VkQueueFamilyGlobalPriorityPropertiesKHR = ffi.typeof([[$ ]], mod.VkQueueFamilyGlobalPriorityProperties)
mod.VkDriverIdKHR = ffi.typeof([[$ ]], mod.VkDriverId)
mod.VkConformanceVersionKHR = ffi.typeof([[$ ]], mod.VkConformanceVersion)
mod.VkPhysicalDeviceDriverPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDriverProperties)
mod.VkShaderFloatControlsIndependenceKHR = ffi.typeof([[$ ]], mod.VkShaderFloatControlsIndependence)
mod.VkPhysicalDeviceFloatControlsPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceFloatControlsProperties)
mod.VkResolveModeFlagBitsKHR = ffi.typeof([[$ ]], mod.VkResolveModeFlagBits)
mod.VkResolveModeFlagsKHR = ffi.typeof([[$ ]], mod.VkResolveModeFlags)
mod.VkSubpassDescriptionDepthStencilResolveKHR = ffi.typeof([[$ ]], mod.VkSubpassDescriptionDepthStencilResolve)
mod.VkPhysicalDeviceDepthStencilResolvePropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDepthStencilResolveProperties)
mod.VkSemaphoreTypeKHR = ffi.typeof([[$ ]], mod.VkSemaphoreType)
mod.VkSemaphoreWaitFlagBitsKHR = ffi.typeof([[$ ]], mod.VkSemaphoreWaitFlagBits)
mod.VkSemaphoreWaitFlagsKHR = ffi.typeof([[$ ]], mod.VkSemaphoreWaitFlags)
mod.VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceTimelineSemaphoreFeatures)
mod.VkPhysicalDeviceTimelineSemaphorePropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceTimelineSemaphoreProperties)
mod.VkSemaphoreTypeCreateInfoKHR = ffi.typeof([[$ ]], mod.VkSemaphoreTypeCreateInfo)
mod.VkTimelineSemaphoreSubmitInfoKHR = ffi.typeof([[$ ]], mod.VkTimelineSemaphoreSubmitInfo)
mod.VkSemaphoreWaitInfoKHR = ffi.typeof([[$ ]], mod.VkSemaphoreWaitInfo)
mod.VkSemaphoreSignalInfoKHR = ffi.typeof([[$ ]], mod.VkSemaphoreSignalInfo)
mod.PFN_vkGetSemaphoreCounterValueKHR = ffi.typeof([[$ (*)($ , $ , uint64_t*)]], mod.VkResult, mod.VkDevice, mod.VkSemaphore)
mod.PFN_vkWaitSemaphoresKHR = ffi.typeof(
	[[$ (*)($ , const $*, uint64_t )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphoreWaitInfo
)
mod.PFN_vkSignalSemaphoreKHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreSignalInfo)
ffi.cdef(
	[[$  vkGetSemaphoreCounterValueKHR($ , $ , uint64_t*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphore
)
ffi.cdef(
	[[$  vkWaitSemaphoresKHR($ , const $*, uint64_t );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphoreWaitInfo
)
ffi.cdef(
	[[$  vkSignalSemaphoreKHR($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSemaphoreSignalInfo
)
mod.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVulkanMemoryModelFeatures)
mod.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderTerminateInvocationFeatures)
mod.VkFragmentShadingRateCombinerOpKHR = ffi.typeof([[enum {
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkFragmentShadingRateAttachmentInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pFragmentShadingRateAttachment;
	$ shadingRateAttachmentTexelSize;
}]],
	mod.VkStructureType,
	mod.VkAttachmentReference2,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkFragmentShadingRateAttachmentInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkFragmentShadingRateAttachmentInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pFragmentShadingRateAttachment,
				t.shadingRateAttachmentTexelSize
			)
		end,
	}
)
mod.VkPipelineFragmentShadingRateStateCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ fragmentSize;
	$ combinerOps[2];
}]],
	mod.VkStructureType,
	mod.VkExtent2D,
	mod.VkFragmentShadingRateCombinerOpKHR
)
ffi.metatype(
	mod.VkPipelineFragmentShadingRateStateCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineFragmentShadingRateStateCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.fragmentSize, t.combinerOps)
		end,
	}
)
mod.VkPhysicalDeviceFragmentShadingRateFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelineFragmentShadingRate;
	$ primitiveFragmentShadingRate;
	$ attachmentFragmentShadingRate;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentShadingRateFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentShadingRateFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pipelineFragmentShadingRate,
				t.primitiveFragmentShadingRate,
				t.attachmentFragmentShadingRate
			)
		end,
	}
)
mod.VkPhysicalDeviceFragmentShadingRatePropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ minFragmentShadingRateAttachmentTexelSize;
	$ maxFragmentShadingRateAttachmentTexelSize;
	uint32_t maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
	$ primitiveFragmentShadingRateWithMultipleViewports;
	$ layeredShadingRateAttachments;
	$ fragmentShadingRateNonTrivialCombinerOps;
	$ maxFragmentSize;
	uint32_t maxFragmentSizeAspectRatio;
	uint32_t maxFragmentShadingRateCoverageSamples;
	$ maxFragmentShadingRateRasterizationSamples;
	$ fragmentShadingRateWithShaderDepthStencilWrites;
	$ fragmentShadingRateWithSampleMask;
	$ fragmentShadingRateWithShaderSampleMask;
	$ fragmentShadingRateWithConservativeRasterization;
	$ fragmentShadingRateWithFragmentShaderInterlock;
	$ fragmentShadingRateWithCustomSampleLocations;
	$ fragmentShadingRateStrictMultiplyCombiner;
}]],
	mod.VkStructureType,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkExtent2D,
	mod.VkSampleCountFlagBits,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentShadingRatePropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.minFragmentShadingRateAttachmentTexelSize,
				t.maxFragmentShadingRateAttachmentTexelSize,
				t.maxFragmentShadingRateAttachmentTexelSizeAspectRatio,
				t.primitiveFragmentShadingRateWithMultipleViewports,
				t.layeredShadingRateAttachments,
				t.fragmentShadingRateNonTrivialCombinerOps,
				t.maxFragmentSize,
				t.maxFragmentSizeAspectRatio,
				t.maxFragmentShadingRateCoverageSamples,
				t.maxFragmentShadingRateRasterizationSamples,
				t.fragmentShadingRateWithShaderDepthStencilWrites,
				t.fragmentShadingRateWithSampleMask,
				t.fragmentShadingRateWithShaderSampleMask,
				t.fragmentShadingRateWithConservativeRasterization,
				t.fragmentShadingRateWithFragmentShaderInterlock,
				t.fragmentShadingRateWithCustomSampleLocations,
				t.fragmentShadingRateStrictMultiplyCombiner
			)
		end,
	}
)
mod.VkPhysicalDeviceFragmentShadingRateKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ sampleCounts;
	$ fragmentSize;
}]],
	mod.VkStructureType,
	mod.VkSampleCountFlags,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentShadingRateKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentShadingRateKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.sampleCounts, t.fragmentSize)
		end,
	}
)
mod.VkRenderingFragmentShadingRateAttachmentInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ imageView;
	$ imageLayout;
	$ shadingRateAttachmentTexelSize;
}]],
	mod.VkStructureType,
	mod.VkImageView,
	mod.VkImageLayout,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkRenderingFragmentShadingRateAttachmentInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkRenderingFragmentShadingRateAttachmentInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.imageView,
				t.imageLayout,
				t.shadingRateAttachmentTexelSize
			)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceFragmentShadingRateKHR
)
mod.PFN_vkCmdSetFragmentShadingRateKHR = ffi.typeof(
	[[void (*)($ , const $*, const $[2])]],
	mod.VkCommandBuffer,
	mod.VkExtent2D,
	mod.VkFragmentShadingRateCombinerOpKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceFragmentShadingRatesKHR($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceFragmentShadingRateKHR
)
ffi.cdef(
	[[void  vkCmdSetFragmentShadingRateKHR($ , const $*, const $[2]);]],
	mod.VkCommandBuffer,
	mod.VkExtent2D,
	mod.VkFragmentShadingRateCombinerOpKHR
)
mod.VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDynamicRenderingLocalReadFeatures)
mod.VkRenderingAttachmentLocationInfoKHR = ffi.typeof([[$ ]], mod.VkRenderingAttachmentLocationInfo)
mod.VkRenderingInputAttachmentIndexInfoKHR = ffi.typeof([[$ ]], mod.VkRenderingInputAttachmentIndexInfo)
mod.PFN_vkCmdSetRenderingAttachmentLocationsKHR = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkRenderingAttachmentLocationInfo
)
mod.PFN_vkCmdSetRenderingInputAttachmentIndicesKHR = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkRenderingInputAttachmentIndexInfo
)
ffi.cdef(
	[[void  vkCmdSetRenderingAttachmentLocationsKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRenderingAttachmentLocationInfo
)
ffi.cdef(
	[[void  vkCmdSetRenderingInputAttachmentIndicesKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRenderingInputAttachmentIndexInfo
)
mod.VkPhysicalDeviceShaderQuadControlFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderQuadControl;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderQuadControlFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderQuadControlFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderQuadControl)
		end,
	}
)
mod.VkSurfaceProtectedCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ supportsProtected;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSurfaceProtectedCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkSurfaceProtectedCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.supportsProtected)
		end,
	}
)
mod.VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures)
mod.VkAttachmentReferenceStencilLayoutKHR = ffi.typeof([[$ ]], mod.VkAttachmentReferenceStencilLayout)
mod.VkAttachmentDescriptionStencilLayoutKHR = ffi.typeof([[$ ]], mod.VkAttachmentDescriptionStencilLayout)
mod.VkPhysicalDevicePresentWaitFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentWait;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePresentWaitFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePresentWaitFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentWait)
		end,
	}
)
mod.PFN_vkWaitForPresentKHR = ffi.typeof(
	[[$ (*)($ , $ , uint64_t , uint64_t )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR
)
ffi.cdef(
	[[$  vkWaitForPresentKHR($ , $ , uint64_t , uint64_t );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR
)
mod.VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceUniformBufferStandardLayoutFeatures)
mod.VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceBufferDeviceAddressFeatures)
mod.VkBufferDeviceAddressInfoKHR = ffi.typeof([[$ ]], mod.VkBufferDeviceAddressInfo)
mod.VkBufferOpaqueCaptureAddressCreateInfoKHR = ffi.typeof([[$ ]], mod.VkBufferOpaqueCaptureAddressCreateInfo)
mod.VkMemoryOpaqueCaptureAddressAllocateInfoKHR = ffi.typeof([[$ ]], mod.VkMemoryOpaqueCaptureAddressAllocateInfo)
mod.VkDeviceMemoryOpaqueCaptureAddressInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceMemoryOpaqueCaptureAddressInfo)
mod.PFN_vkGetBufferDeviceAddressKHR = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkDeviceAddress,
	mod.VkDevice,
	mod.VkBufferDeviceAddressInfo
)
mod.PFN_vkGetBufferOpaqueCaptureAddressKHR = ffi.typeof([[uint64_t (*)($ , const $*)]], mod.VkDevice, mod.VkBufferDeviceAddressInfo)
mod.PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR = ffi.typeof(
	[[uint64_t (*)($ , const $*)]],
	mod.VkDevice,
	mod.VkDeviceMemoryOpaqueCaptureAddressInfo
)
ffi.cdef(
	[[$  vkGetBufferDeviceAddressKHR($ , const $*);]],
	mod.VkDeviceAddress,
	mod.VkDevice,
	mod.VkBufferDeviceAddressInfo
)
ffi.cdef(
	[[uint64_t  vkGetBufferOpaqueCaptureAddressKHR($ , const $*);]],
	mod.VkDevice,
	mod.VkBufferDeviceAddressInfo
)
ffi.cdef(
	[[uint64_t  vkGetDeviceMemoryOpaqueCaptureAddressKHR($ , const $*);]],
	mod.VkDevice,
	mod.VkDeviceMemoryOpaqueCaptureAddressInfo
)
mod.VkDeferredOperationKHR = ffi.typeof([[void*]])
mod.PFN_vkCreateDeferredOperationKHR = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAllocationCallbacks,
	mod.VkDeferredOperationKHR
)
mod.PFN_vkDestroyDeferredOperationKHR = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetDeferredOperationMaxConcurrencyKHR = ffi.typeof([[uint32_t (*)($ , $ )]], mod.VkDevice, mod.VkDeferredOperationKHR)
mod.PFN_vkGetDeferredOperationResultKHR = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR)
mod.PFN_vkDeferredOperationJoinKHR = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR)
ffi.cdef(
	[[$  vkCreateDeferredOperationKHR($ , const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAllocationCallbacks,
	mod.VkDeferredOperationKHR
)
ffi.cdef(
	[[void  vkDestroyDeferredOperationKHR($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[uint32_t  vkGetDeferredOperationMaxConcurrencyKHR($ , $ );]],
	mod.VkDevice,
	mod.VkDeferredOperationKHR
)
ffi.cdef(
	[[$  vkGetDeferredOperationResultKHR($ , $ );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR
)
ffi.cdef(
	[[$  vkDeferredOperationJoinKHR($ , $ );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR
)
mod.VkPipelineExecutableStatisticFormatKHR = ffi.typeof([[enum {
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelineExecutableInfo;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineExecutableInfo)
		end,
	}
)
mod.VkPipelineInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ pipeline;
}]],
	mod.VkStructureType,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkPipelineInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipeline)
		end,
	}
)
mod.VkPipelineExecutablePropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ stages;
	char name[256U];
	char description[256U];
	uint32_t subgroupSize;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags
)
ffi.metatype(
	mod.VkPipelineExecutablePropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineExecutablePropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stages, t.name, t.description, t.subgroupSize)
		end,
	}
)
mod.VkPipelineExecutableInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ pipeline;
	uint32_t executableIndex;
}]],
	mod.VkStructureType,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkPipelineExecutableInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineExecutableInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipeline, t.executableIndex)
		end,
	}
)
mod.VkPipelineExecutableStatisticValueKHR = ffi.typeof([[union {
	$ b32;
	int64_t i64;
	uint64_t u64;
	double f64;
}]], mod.VkBool32)
ffi.metatype(
	mod.VkPipelineExecutableStatisticValueKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineExecutableStatisticValueKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.b32 ~= nil then obj.b32 = t.b32 end

			if t.i64 ~= nil then obj.i64 = t.i64 end

			if t.u64 ~= nil then obj.u64 = t.u64 end

			if t.f64 ~= nil then obj.f64 = t.f64 end

			return obj
		end,
	}
)
mod.VkPipelineExecutableStatisticKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	char name[256U];
	char description[256U];
	$ format;
	$ value;
}]],
	mod.VkStructureType,
	mod.VkPipelineExecutableStatisticFormatKHR,
	mod.VkPipelineExecutableStatisticValueKHR
)
ffi.metatype(
	mod.VkPipelineExecutableStatisticKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineExecutableStatisticKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.name, t.description, t.format, t.value)
		end,
	}
)
mod.VkPipelineExecutableInternalRepresentationKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	char name[256U];
	char description[256U];
	$ isText;
	size_t dataSize;
	void* pData;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPipelineExecutableInternalRepresentationKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineExecutableInternalRepresentationKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.name, t.description, t.isText, t.dataSize, t.pData)
		end,
	}
)
mod.PFN_vkGetPipelineExecutablePropertiesKHR = ffi.typeof(
	[[$ (*)($ , const $*, uint32_t*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineInfoKHR,
	mod.VkPipelineExecutablePropertiesKHR
)
mod.PFN_vkGetPipelineExecutableStatisticsKHR = ffi.typeof(
	[[$ (*)($ , const $*, uint32_t*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineExecutableInfoKHR,
	mod.VkPipelineExecutableStatisticKHR
)
mod.PFN_vkGetPipelineExecutableInternalRepresentationsKHR = ffi.typeof(
	[[$ (*)($ , const $*, uint32_t*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineExecutableInfoKHR,
	mod.VkPipelineExecutableInternalRepresentationKHR
)
ffi.cdef(
	[[$  vkGetPipelineExecutablePropertiesKHR($ , const $*, uint32_t*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineInfoKHR,
	mod.VkPipelineExecutablePropertiesKHR
)
ffi.cdef(
	[[$  vkGetPipelineExecutableStatisticsKHR($ , const $*, uint32_t*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineExecutableInfoKHR,
	mod.VkPipelineExecutableStatisticKHR
)
ffi.cdef(
	[[$  vkGetPipelineExecutableInternalRepresentationsKHR($ , const $*, uint32_t*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineExecutableInfoKHR,
	mod.VkPipelineExecutableInternalRepresentationKHR
)
mod.VkMemoryUnmapFlagBitsKHR = ffi.typeof([[$ ]], mod.VkMemoryUnmapFlagBits)
mod.VkMemoryUnmapFlagsKHR = ffi.typeof([[$ ]], mod.VkMemoryUnmapFlags)
mod.VkMemoryMapInfoKHR = ffi.typeof([[$ ]], mod.VkMemoryMapInfo)
mod.VkMemoryUnmapInfoKHR = ffi.typeof([[$ ]], mod.VkMemoryUnmapInfo)
mod.PFN_vkMapMemory2KHR = ffi.typeof([[$ (*)($ , const $*, void**)]], mod.VkResult, mod.VkDevice, mod.VkMemoryMapInfo)
mod.PFN_vkUnmapMemory2KHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkMemoryUnmapInfo)
ffi.cdef(
	[[$  vkMapMemory2KHR($ , const $*, void**);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryMapInfo
)
ffi.cdef(
	[[$  vkUnmapMemory2KHR($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryUnmapInfo
)
mod.VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderIntegerDotProductFeatures)
mod.VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderIntegerDotProductProperties)
mod.VkPipelineLibraryCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t libraryCount;
	const $* pLibraries;
}]],
	mod.VkStructureType,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkPipelineLibraryCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineLibraryCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.libraryCount, t.pLibraries)
		end,
	}
)
mod.VkPresentIdKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const uint64_t* pPresentIds;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPresentIdKHR,
	{
		__tostring = function(s)
			return ("struct VkPresentIdKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.swapchainCount, t.pPresentIds)
		end,
	}
)
mod.VkPhysicalDevicePresentIdFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentId;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePresentIdFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePresentIdFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentId)
		end,
	}
)
mod.VkVideoEncodeTuningModeKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = 1,
	VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = 2,
	VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = 3,
	VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4,
	VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeCapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeCapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeRateControlModeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeRateControlModeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeFeedbackFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeFeedbackFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeUsageFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeUsageFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeContentFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeContentFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeRateControlFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ dstBuffer;
	$ dstBufferOffset;
	$ dstBufferRange;
	$ srcPictureResource;
	const $* pSetupReferenceSlot;
	uint32_t referenceSlotCount;
	const $* pReferenceSlots;
	uint32_t precedingExternallyEncodedBytes;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeFlagsKHR,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkVideoPictureResourceInfoKHR,
	mod.VkVideoReferenceSlotInfoKHR,
	mod.VkVideoReferenceSlotInfoKHR
)
ffi.metatype(
	mod.VkVideoEncodeInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.dstBuffer,
				t.dstBufferOffset,
				t.dstBufferRange,
				t.srcPictureResource,
				t.pSetupReferenceSlot,
				t.referenceSlotCount,
				t.pReferenceSlots,
				t.precedingExternallyEncodedBytes
			)
		end,
	}
)
mod.VkVideoEncodeCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ rateControlModes;
	uint32_t maxRateControlLayers;
	uint64_t maxBitrate;
	uint32_t maxQualityLevels;
	$ encodeInputPictureGranularity;
	$ supportedEncodeFeedbackFlags;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeCapabilityFlagsKHR,
	mod.VkVideoEncodeRateControlModeFlagsKHR,
	mod.VkExtent2D,
	mod.VkVideoEncodeFeedbackFlagsKHR
)
ffi.metatype(
	mod.VkVideoEncodeCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.rateControlModes,
				t.maxRateControlLayers,
				t.maxBitrate,
				t.maxQualityLevels,
				t.encodeInputPictureGranularity,
				t.supportedEncodeFeedbackFlags
			)
		end,
	}
)
mod.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ encodeFeedbackFlags;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeFeedbackFlagsKHR
)
ffi.metatype(
	mod.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkQueryPoolVideoEncodeFeedbackCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.encodeFeedbackFlags)
		end,
	}
)
mod.VkVideoEncodeUsageInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ videoUsageHints;
	$ videoContentHints;
	$ tuningMode;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeUsageFlagsKHR,
	mod.VkVideoEncodeContentFlagsKHR,
	mod.VkVideoEncodeTuningModeKHR
)
ffi.metatype(
	mod.VkVideoEncodeUsageInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeUsageInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.videoUsageHints, t.videoContentHints, t.tuningMode)
		end,
	}
)
mod.VkVideoEncodeRateControlLayerInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint64_t averageBitrate;
	uint64_t maxBitrate;
	uint32_t frameRateNumerator;
	uint32_t frameRateDenominator;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkVideoEncodeRateControlLayerInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeRateControlLayerInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.averageBitrate,
				t.maxBitrate,
				t.frameRateNumerator,
				t.frameRateDenominator
			)
		end,
	}
)
mod.VkVideoEncodeRateControlInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ rateControlMode;
	uint32_t layerCount;
	const $* pLayers;
	uint32_t virtualBufferSizeInMs;
	uint32_t initialVirtualBufferSizeInMs;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeRateControlFlagsKHR,
	mod.VkVideoEncodeRateControlModeFlagBitsKHR,
	mod.VkVideoEncodeRateControlLayerInfoKHR
)
ffi.metatype(
	mod.VkVideoEncodeRateControlInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeRateControlInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.rateControlMode,
				t.layerCount,
				t.pLayers,
				t.virtualBufferSizeInMs,
				t.initialVirtualBufferSizeInMs
			)
		end,
	}
)
mod.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pVideoProfile;
	uint32_t qualityLevel;
}]],
	mod.VkStructureType,
	mod.VkVideoProfileInfoKHR
)
ffi.metatype(
	mod.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pVideoProfile, t.qualityLevel)
		end,
	}
)
mod.VkVideoEncodeQualityLevelPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ preferredRateControlMode;
	uint32_t preferredRateControlLayerCount;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeRateControlModeFlagBitsKHR
)
ffi.metatype(
	mod.VkVideoEncodeQualityLevelPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeQualityLevelPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.preferredRateControlMode,
				t.preferredRateControlLayerCount
			)
		end,
	}
)
mod.VkVideoEncodeQualityLevelInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t qualityLevel;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkVideoEncodeQualityLevelInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeQualityLevelInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.qualityLevel)
		end,
	}
)
mod.VkVideoEncodeSessionParametersGetInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ videoSessionParameters;
}]],
	mod.VkStructureType,
	mod.VkVideoSessionParametersKHR
)
ffi.metatype(
	mod.VkVideoEncodeSessionParametersGetInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeSessionParametersGetInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.videoSessionParameters)
		end,
	}
)
mod.VkVideoEncodeSessionParametersFeedbackInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ hasOverrides;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeSessionParametersFeedbackInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeSessionParametersFeedbackInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.hasOverrides)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR,
	mod.VkVideoEncodeQualityLevelPropertiesKHR
)
mod.PFN_vkGetEncodedVideoSessionParametersKHR = ffi.typeof(
	[[$ (*)($ , const $*, $*, size_t*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoEncodeSessionParametersGetInfoKHR,
	mod.VkVideoEncodeSessionParametersFeedbackInfoKHR
)
mod.PFN_vkCmdEncodeVideoKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkVideoEncodeInfoKHR)
ffi.cdef(
	[[$  vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR($ , const $*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR,
	mod.VkVideoEncodeQualityLevelPropertiesKHR
)
ffi.cdef(
	[[$  vkGetEncodedVideoSessionParametersKHR($ , const $*, $*, size_t*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkVideoEncodeSessionParametersGetInfoKHR,
	mod.VkVideoEncodeSessionParametersFeedbackInfoKHR
)
ffi.cdef(
	[[void  vkCmdEncodeVideoKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkVideoEncodeInfoKHR
)
mod.VkPipelineStageFlags2KHR = ffi.typeof([[$ ]], mod.VkPipelineStageFlags2)
mod.VkPipelineStageFlagBits2KHR = ffi.typeof([[$ ]], mod.VkPipelineStageFlagBits2)
mod.VkAccessFlags2KHR = ffi.typeof([[$ ]], mod.VkAccessFlags2)
mod.VkAccessFlagBits2KHR = ffi.typeof([[$ ]], mod.VkAccessFlagBits2)
mod.VkSubmitFlagBitsKHR = ffi.typeof([[$ ]], mod.VkSubmitFlagBits)
mod.VkSubmitFlagsKHR = ffi.typeof([[$ ]], mod.VkSubmitFlags)
mod.VkMemoryBarrier2KHR = ffi.typeof([[$ ]], mod.VkMemoryBarrier2)
mod.VkBufferMemoryBarrier2KHR = ffi.typeof([[$ ]], mod.VkBufferMemoryBarrier2)
mod.VkImageMemoryBarrier2KHR = ffi.typeof([[$ ]], mod.VkImageMemoryBarrier2)
mod.VkDependencyInfoKHR = ffi.typeof([[$ ]], mod.VkDependencyInfo)
mod.VkSubmitInfo2KHR = ffi.typeof([[$ ]], mod.VkSubmitInfo2)
mod.VkSemaphoreSubmitInfoKHR = ffi.typeof([[$ ]], mod.VkSemaphoreSubmitInfo)
mod.VkCommandBufferSubmitInfoKHR = ffi.typeof([[$ ]], mod.VkCommandBufferSubmitInfo)
mod.VkPhysicalDeviceSynchronization2FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSynchronization2Features)
mod.PFN_vkCmdSetEvent2KHR = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkDependencyInfo
)
mod.PFN_vkCmdResetEvent2KHR = ffi.typeof(
	[[void (*)($ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkPipelineStageFlags2
)
mod.PFN_vkCmdWaitEvents2KHR = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkDependencyInfo
)
mod.PFN_vkCmdPipelineBarrier2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDependencyInfo)
mod.PFN_vkCmdWriteTimestamp2KHR = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlags2,
	mod.VkQueryPool
)
mod.PFN_vkQueueSubmit2KHR = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*, $ )]],
	mod.VkResult,
	mod.VkQueue,
	mod.VkSubmitInfo2,
	mod.VkFence
)
ffi.cdef(
	[[void  vkCmdSetEvent2KHR($ , $ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkDependencyInfo
)
ffi.cdef(
	[[void  vkCmdResetEvent2KHR($ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkPipelineStageFlags2
)
ffi.cdef(
	[[void  vkCmdWaitEvents2KHR($ , uint32_t , const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkEvent,
	mod.VkDependencyInfo
)
ffi.cdef(
	[[void  vkCmdPipelineBarrier2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDependencyInfo
)
ffi.cdef(
	[[void  vkCmdWriteTimestamp2KHR($ , $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlags2,
	mod.VkQueryPool
)
ffi.cdef(
	[[$  vkQueueSubmit2KHR($ , uint32_t , const $*, $ );]],
	mod.VkResult,
	mod.VkQueue,
	mod.VkSubmitInfo2,
	mod.VkFence
)
mod.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ fragmentShaderBarycentric;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.fragmentShaderBarycentric)
		end,
	}
)
mod.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ triStripVertexOrderIndependentOfProvokingVertex;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.triStripVertexOrderIndependentOfProvokingVertex)
		end,
	}
)
mod.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderSubgroupUniformControlFlow;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderSubgroupUniformControlFlow)
		end,
	}
)
mod.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)
mod.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ workgroupMemoryExplicitLayout;
	$ workgroupMemoryExplicitLayoutScalarBlockLayout;
	$ workgroupMemoryExplicitLayout8BitAccess;
	$ workgroupMemoryExplicitLayout16BitAccess;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.workgroupMemoryExplicitLayout,
				t.workgroupMemoryExplicitLayoutScalarBlockLayout,
				t.workgroupMemoryExplicitLayout8BitAccess,
				t.workgroupMemoryExplicitLayout16BitAccess
			)
		end,
	}
)
mod.VkCopyBufferInfo2KHR = ffi.typeof([[$ ]], mod.VkCopyBufferInfo2)
mod.VkCopyImageInfo2KHR = ffi.typeof([[$ ]], mod.VkCopyImageInfo2)
mod.VkCopyBufferToImageInfo2KHR = ffi.typeof([[$ ]], mod.VkCopyBufferToImageInfo2)
mod.VkCopyImageToBufferInfo2KHR = ffi.typeof([[$ ]], mod.VkCopyImageToBufferInfo2)
mod.VkBlitImageInfo2KHR = ffi.typeof([[$ ]], mod.VkBlitImageInfo2)
mod.VkResolveImageInfo2KHR = ffi.typeof([[$ ]], mod.VkResolveImageInfo2)
mod.VkBufferCopy2KHR = ffi.typeof([[$ ]], mod.VkBufferCopy2)
mod.VkImageCopy2KHR = ffi.typeof([[$ ]], mod.VkImageCopy2)
mod.VkImageBlit2KHR = ffi.typeof([[$ ]], mod.VkImageBlit2)
mod.VkBufferImageCopy2KHR = ffi.typeof([[$ ]], mod.VkBufferImageCopy2)
mod.VkImageResolve2KHR = ffi.typeof([[$ ]], mod.VkImageResolve2)
mod.PFN_vkCmdCopyBuffer2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyBufferInfo2)
mod.PFN_vkCmdCopyImage2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyImageInfo2)
mod.PFN_vkCmdCopyBufferToImage2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyBufferToImageInfo2)
mod.PFN_vkCmdCopyImageToBuffer2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyImageToBufferInfo2)
mod.PFN_vkCmdBlitImage2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkBlitImageInfo2)
mod.PFN_vkCmdResolveImage2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkResolveImageInfo2)
ffi.cdef(
	[[void  vkCmdCopyBuffer2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyBufferInfo2
)
ffi.cdef(
	[[void  vkCmdCopyImage2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyImageInfo2
)
ffi.cdef(
	[[void  vkCmdCopyBufferToImage2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyBufferToImageInfo2
)
ffi.cdef(
	[[void  vkCmdCopyImageToBuffer2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyImageToBufferInfo2
)
ffi.cdef(
	[[void  vkCmdBlitImage2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBlitImageInfo2
)
ffi.cdef(
	[[void  vkCmdResolveImage2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkResolveImageInfo2
)
mod.VkFormatFeatureFlags2KHR = ffi.typeof([[$ ]], mod.VkFormatFeatureFlags2)
mod.VkFormatFeatureFlagBits2KHR = ffi.typeof([[$ ]], mod.VkFormatFeatureFlagBits2)
mod.VkFormatProperties3KHR = ffi.typeof([[$ ]], mod.VkFormatProperties3)
mod.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ rayTracingMaintenance1;
	$ rayTracingPipelineTraceRaysIndirect2;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.rayTracingMaintenance1,
				t.rayTracingPipelineTraceRaysIndirect2
			)
		end,
	}
)
mod.VkTraceRaysIndirectCommand2KHR = ffi.typeof(
	[[struct {
	$ raygenShaderRecordAddress;
	$ raygenShaderRecordSize;
	$ missShaderBindingTableAddress;
	$ missShaderBindingTableSize;
	$ missShaderBindingTableStride;
	$ hitShaderBindingTableAddress;
	$ hitShaderBindingTableSize;
	$ hitShaderBindingTableStride;
	$ callableShaderBindingTableAddress;
	$ callableShaderBindingTableSize;
	$ callableShaderBindingTableStride;
	uint32_t width;
	uint32_t height;
	uint32_t depth;
}]],
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkTraceRaysIndirectCommand2KHR,
	{
		__tostring = function(s)
			return ("struct VkTraceRaysIndirectCommand2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.raygenShaderRecordAddress,
				t.raygenShaderRecordSize,
				t.missShaderBindingTableAddress,
				t.missShaderBindingTableSize,
				t.missShaderBindingTableStride,
				t.hitShaderBindingTableAddress,
				t.hitShaderBindingTableSize,
				t.hitShaderBindingTableStride,
				t.callableShaderBindingTableAddress,
				t.callableShaderBindingTableSize,
				t.callableShaderBindingTableStride,
				t.width,
				t.height,
				t.depth
			)
		end,
	}
)
mod.PFN_vkCmdTraceRaysIndirect2KHR = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkDeviceAddress)
ffi.cdef(
	[[void  vkCmdTraceRaysIndirect2KHR($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkDeviceAddress
)
mod.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderUntypedPointers;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderUntypedPointersFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderUntypedPointers)
		end,
	}
)
mod.VkPhysicalDeviceMaintenance4FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance4Features)
mod.VkPhysicalDeviceMaintenance4PropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance4Properties)
mod.VkDeviceBufferMemoryRequirementsKHR = ffi.typeof([[$ ]], mod.VkDeviceBufferMemoryRequirements)
mod.VkDeviceImageMemoryRequirementsKHR = ffi.typeof([[$ ]], mod.VkDeviceImageMemoryRequirements)
mod.PFN_vkGetDeviceBufferMemoryRequirementsKHR = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkDeviceBufferMemoryRequirements,
	mod.VkMemoryRequirements2
)
mod.PFN_vkGetDeviceImageMemoryRequirementsKHR = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkDeviceImageMemoryRequirements,
	mod.VkMemoryRequirements2
)
mod.PFN_vkGetDeviceImageSparseMemoryRequirementsKHR = ffi.typeof(
	[[void (*)($ , const $*, uint32_t*, $*)]],
	mod.VkDevice,
	mod.VkDeviceImageMemoryRequirements,
	mod.VkSparseImageMemoryRequirements2
)
ffi.cdef(
	[[void  vkGetDeviceBufferMemoryRequirementsKHR($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDeviceBufferMemoryRequirements,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkGetDeviceImageMemoryRequirementsKHR($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDeviceImageMemoryRequirements,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkGetDeviceImageSparseMemoryRequirementsKHR($ , const $*, uint32_t*, $*);]],
	mod.VkDevice,
	mod.VkDeviceImageMemoryRequirements,
	mod.VkSparseImageMemoryRequirements2
)
mod.VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderSubgroupRotateFeatures)
mod.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderMaximalReconvergence;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderMaximalReconvergence)
		end,
	}
)
mod.VkPipelineCreateFlags2KHR = ffi.typeof([[$ ]], mod.VkPipelineCreateFlags2)
mod.VkPipelineCreateFlagBits2KHR = ffi.typeof([[$ ]], mod.VkPipelineCreateFlagBits2)
mod.VkBufferUsageFlags2KHR = ffi.typeof([[$ ]], mod.VkBufferUsageFlags2)
mod.VkBufferUsageFlagBits2KHR = ffi.typeof([[$ ]], mod.VkBufferUsageFlagBits2)
mod.VkPhysicalDeviceMaintenance5FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance5Features)
mod.VkPhysicalDeviceMaintenance5PropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance5Properties)
mod.VkRenderingAreaInfoKHR = ffi.typeof([[$ ]], mod.VkRenderingAreaInfo)
mod.VkDeviceImageSubresourceInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceImageSubresourceInfo)
mod.VkImageSubresource2KHR = ffi.typeof([[$ ]], mod.VkImageSubresource2)
mod.VkSubresourceLayout2KHR = ffi.typeof([[$ ]], mod.VkSubresourceLayout2)
mod.VkPipelineCreateFlags2CreateInfoKHR = ffi.typeof([[$ ]], mod.VkPipelineCreateFlags2CreateInfo)
mod.VkBufferUsageFlags2CreateInfoKHR = ffi.typeof([[$ ]], mod.VkBufferUsageFlags2CreateInfo)
mod.PFN_vkCmdBindIndexBuffer2KHR = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkIndexType
)
mod.PFN_vkGetRenderingAreaGranularityKHR = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkRenderingAreaInfo,
	mod.VkExtent2D
)
mod.PFN_vkGetDeviceImageSubresourceLayoutKHR = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkDeviceImageSubresourceInfo,
	mod.VkSubresourceLayout2
)
mod.PFN_vkGetImageSubresourceLayout2KHR = ffi.typeof(
	[[void (*)($ , $ , const $*, $*)]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkImageSubresource2,
	mod.VkSubresourceLayout2
)
ffi.cdef(
	[[void  vkCmdBindIndexBuffer2KHR($ , $ , $ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkIndexType
)
ffi.cdef(
	[[void  vkGetRenderingAreaGranularityKHR($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkRenderingAreaInfo,
	mod.VkExtent2D
)
ffi.cdef(
	[[void  vkGetDeviceImageSubresourceLayoutKHR($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDeviceImageSubresourceInfo,
	mod.VkSubresourceLayout2
)
ffi.cdef(
	[[void  vkGetImageSubresourceLayout2KHR($ , $ , const $*, $*);]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkImageSubresource2,
	mod.VkSubresourceLayout2
)
mod.VkSurfaceCapabilitiesPresentId2KHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentId2Supported;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSurfaceCapabilitiesPresentId2KHR,
	{
		__tostring = function(s)
			return ("struct VkSurfaceCapabilitiesPresentId2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentId2Supported)
		end,
	}
)
mod.VkPresentId2KHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const uint64_t* pPresentIds;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPresentId2KHR,
	{
		__tostring = function(s)
			return ("struct VkPresentId2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.swapchainCount, t.pPresentIds)
		end,
	}
)
mod.VkPhysicalDevicePresentId2FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentId2;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePresentId2FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePresentId2FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentId2)
		end,
	}
)
mod.VkSurfaceCapabilitiesPresentWait2KHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentWait2Supported;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSurfaceCapabilitiesPresentWait2KHR,
	{
		__tostring = function(s)
			return ("struct VkSurfaceCapabilitiesPresentWait2KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentWait2Supported)
		end,
	}
)
mod.VkPhysicalDevicePresentWait2FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentWait2;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePresentWait2FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePresentWait2FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentWait2)
		end,
	}
)
mod.VkPresentWait2InfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint64_t presentId;
	uint64_t timeout;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPresentWait2InfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPresentWait2InfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentId, t.timeout)
		end,
	}
)
mod.PFN_vkWaitForPresent2KHR = ffi.typeof(
	[[$ (*)($ , $ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkPresentWait2InfoKHR
)
ffi.cdef(
	[[$  vkWaitForPresent2KHR($ , $ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkPresentWait2InfoKHR
)
mod.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ rayTracingPositionFetch;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.rayTracingPositionFetch)
		end,
	}
)
mod.VkPipelineBinaryKHR = ffi.typeof([[void*]])
mod.VkPhysicalDevicePipelineBinaryFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelineBinaries;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePipelineBinaryFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePipelineBinaryFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineBinaries)
		end,
	}
)
mod.VkPhysicalDevicePipelineBinaryPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelineBinaryInternalCache;
	$ pipelineBinaryInternalCacheControl;
	$ pipelineBinaryPrefersInternalCache;
	$ pipelineBinaryPrecompiledInternalCache;
	$ pipelineBinaryCompressedData;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePipelineBinaryPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePipelineBinaryPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pipelineBinaryInternalCache,
				t.pipelineBinaryInternalCacheControl,
				t.pipelineBinaryPrefersInternalCache,
				t.pipelineBinaryPrecompiledInternalCache,
				t.pipelineBinaryCompressedData
			)
		end,
	}
)
mod.VkDevicePipelineBinaryInternalCacheControlKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ disableInternalCache;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkDevicePipelineBinaryInternalCacheControlKHR,
	{
		__tostring = function(s)
			return ("struct VkDevicePipelineBinaryInternalCacheControlKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.disableInternalCache)
		end,
	}
)
mod.VkPipelineBinaryKeyKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t keySize;
	uint8_t key[32U];
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPipelineBinaryKeyKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineBinaryKeyKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.keySize, t.key)
		end,
	}
)
mod.VkPipelineBinaryDataKHR = ffi.typeof([[struct {
	size_t dataSize;
	void* pData;
}]])
ffi.metatype(
	mod.VkPipelineBinaryDataKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineBinaryDataKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.dataSize, t.pData)
		end,
	}
)
mod.VkPipelineBinaryKeysAndDataKHR = ffi.typeof(
	[[struct {
	uint32_t binaryCount;
	const $* pPipelineBinaryKeys;
	const $* pPipelineBinaryData;
}]],
	mod.VkPipelineBinaryKeyKHR,
	mod.VkPipelineBinaryDataKHR
)
ffi.metatype(
	mod.VkPipelineBinaryKeysAndDataKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineBinaryKeysAndDataKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.binaryCount, t.pPipelineBinaryKeys, t.pPipelineBinaryData)
		end,
	}
)
mod.VkPipelineCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
}]], mod.VkStructureType)
ffi.metatype(
	mod.VkPipelineCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext)
		end,
	}
)
mod.VkPipelineBinaryCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pKeysAndDataInfo;
	$ pipeline;
	const $* pPipelineCreateInfo;
}]],
	mod.VkStructureType,
	mod.VkPipelineBinaryKeysAndDataKHR,
	mod.VkPipeline,
	mod.VkPipelineCreateInfoKHR
)
ffi.metatype(
	mod.VkPipelineBinaryCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineBinaryCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pKeysAndDataInfo, t.pipeline, t.pPipelineCreateInfo)
		end,
	}
)
mod.VkPipelineBinaryInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t binaryCount;
	const $* pPipelineBinaries;
}]],
	mod.VkStructureType,
	mod.VkPipelineBinaryKHR
)
ffi.metatype(
	mod.VkPipelineBinaryInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineBinaryInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.binaryCount, t.pPipelineBinaries)
		end,
	}
)
mod.VkReleaseCapturedPipelineDataInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipeline;
}]],
	mod.VkStructureType,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkReleaseCapturedPipelineDataInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkReleaseCapturedPipelineDataInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipeline)
		end,
	}
)
mod.VkPipelineBinaryDataInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelineBinary;
}]],
	mod.VkStructureType,
	mod.VkPipelineBinaryKHR
)
ffi.metatype(
	mod.VkPipelineBinaryDataInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineBinaryDataInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineBinary)
		end,
	}
)
mod.VkPipelineBinaryHandlesInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t pipelineBinaryCount;
	$* pPipelineBinaries;
}]],
	mod.VkStructureType,
	mod.VkPipelineBinaryKHR
)
ffi.metatype(
	mod.VkPipelineBinaryHandlesInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkPipelineBinaryHandlesInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineBinaryCount, t.pPipelineBinaries)
		end,
	}
)
mod.PFN_vkCreatePipelineBinariesKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineBinaryCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkPipelineBinaryHandlesInfoKHR
)
mod.PFN_vkDestroyPipelineBinaryKHR = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkPipelineBinaryKHR,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetPipelineKeyKHR = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCreateInfoKHR,
	mod.VkPipelineBinaryKeyKHR
)
mod.PFN_vkGetPipelineBinaryDataKHR = ffi.typeof(
	[[$ (*)($ , const $*, $*, size_t*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineBinaryDataInfoKHR,
	mod.VkPipelineBinaryKeyKHR
)
mod.PFN_vkReleaseCapturedPipelineDataKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkReleaseCapturedPipelineDataInfoKHR,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreatePipelineBinariesKHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineBinaryCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkPipelineBinaryHandlesInfoKHR
)
ffi.cdef(
	[[void  vkDestroyPipelineBinaryKHR($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkPipelineBinaryKHR,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkGetPipelineKeyKHR($ , const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCreateInfoKHR,
	mod.VkPipelineBinaryKeyKHR
)
ffi.cdef(
	[[$  vkGetPipelineBinaryDataKHR($ , const $*, $*, size_t*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineBinaryDataInfoKHR,
	mod.VkPipelineBinaryKeyKHR
)
ffi.cdef(
	[[$  vkReleaseCapturedPipelineDataKHR($ , const $*, const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkReleaseCapturedPipelineDataInfoKHR,
	mod.VkAllocationCallbacks
)
mod.VkPresentScalingFlagBitsKHR = ffi.typeof([[enum {
	VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR = 0x00000001,
	VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR = 0x00000002,
	VK_PRESENT_SCALING_STRETCH_BIT_KHR = 0x00000004,
	VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT = VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR,
	VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT = VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR,
	VK_PRESENT_SCALING_STRETCH_BIT_EXT = VK_PRESENT_SCALING_STRETCH_BIT_KHR,
	VK_PRESENT_SCALING_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPresentScalingFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPresentGravityFlagBitsKHR = ffi.typeof([[enum {
	VK_PRESENT_GRAVITY_MIN_BIT_KHR = 0x00000001,
	VK_PRESENT_GRAVITY_MAX_BIT_KHR = 0x00000002,
	VK_PRESENT_GRAVITY_CENTERED_BIT_KHR = 0x00000004,
	VK_PRESENT_GRAVITY_MIN_BIT_EXT = VK_PRESENT_GRAVITY_MIN_BIT_KHR,
	VK_PRESENT_GRAVITY_MAX_BIT_EXT = VK_PRESENT_GRAVITY_MAX_BIT_KHR,
	VK_PRESENT_GRAVITY_CENTERED_BIT_EXT = VK_PRESENT_GRAVITY_CENTERED_BIT_KHR,
	VK_PRESENT_GRAVITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPresentGravityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSurfacePresentModeKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentMode;
}]],
	mod.VkStructureType,
	mod.VkPresentModeKHR
)
ffi.metatype(
	mod.VkSurfacePresentModeKHR,
	{
		__tostring = function(s)
			return ("struct VkSurfacePresentModeKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentMode)
		end,
	}
)
mod.VkSurfacePresentScalingCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ supportedPresentScaling;
	$ supportedPresentGravityX;
	$ supportedPresentGravityY;
	$ minScaledImageExtent;
	$ maxScaledImageExtent;
}]],
	mod.VkStructureType,
	mod.VkPresentScalingFlagsKHR,
	mod.VkPresentGravityFlagsKHR,
	mod.VkPresentGravityFlagsKHR,
	mod.VkExtent2D,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkSurfacePresentScalingCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkSurfacePresentScalingCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.supportedPresentScaling,
				t.supportedPresentGravityX,
				t.supportedPresentGravityY,
				t.minScaledImageExtent,
				t.maxScaledImageExtent
			)
		end,
	}
)
mod.VkSurfacePresentModeCompatibilityKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t presentModeCount;
	$* pPresentModes;
}]],
	mod.VkStructureType,
	mod.VkPresentModeKHR
)
ffi.metatype(
	mod.VkSurfacePresentModeCompatibilityKHR,
	{
		__tostring = function(s)
			return ("struct VkSurfacePresentModeCompatibilityKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentModeCount, t.pPresentModes)
		end,
	}
)
mod.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ swapchainMaintenance1;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.swapchainMaintenance1)
		end,
	}
)
mod.VkSwapchainPresentFenceInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const $* pFences;
}]],
	mod.VkStructureType,
	mod.VkFence
)
ffi.metatype(
	mod.VkSwapchainPresentFenceInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkSwapchainPresentFenceInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.swapchainCount, t.pFences)
		end,
	}
)
mod.VkSwapchainPresentModesCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t presentModeCount;
	const $* pPresentModes;
}]],
	mod.VkStructureType,
	mod.VkPresentModeKHR
)
ffi.metatype(
	mod.VkSwapchainPresentModesCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkSwapchainPresentModesCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentModeCount, t.pPresentModes)
		end,
	}
)
mod.VkSwapchainPresentModeInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const $* pPresentModes;
}]],
	mod.VkStructureType,
	mod.VkPresentModeKHR
)
ffi.metatype(
	mod.VkSwapchainPresentModeInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkSwapchainPresentModeInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.swapchainCount, t.pPresentModes)
		end,
	}
)
mod.VkSwapchainPresentScalingCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ scalingBehavior;
	$ presentGravityX;
	$ presentGravityY;
}]],
	mod.VkStructureType,
	mod.VkPresentScalingFlagsKHR,
	mod.VkPresentGravityFlagsKHR,
	mod.VkPresentGravityFlagsKHR
)
ffi.metatype(
	mod.VkSwapchainPresentScalingCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkSwapchainPresentScalingCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.scalingBehavior, t.presentGravityX, t.presentGravityY)
		end,
	}
)
mod.VkReleaseSwapchainImagesInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ swapchain;
	uint32_t imageIndexCount;
	const uint32_t* pImageIndices;
}]],
	mod.VkStructureType,
	mod.VkSwapchainKHR
)
ffi.metatype(
	mod.VkReleaseSwapchainImagesInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkReleaseSwapchainImagesInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.swapchain, t.imageIndexCount, t.pImageIndices)
		end,
	}
)
mod.PFN_vkReleaseSwapchainImagesKHR = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkReleaseSwapchainImagesInfoKHR
)
ffi.cdef(
	[[$  vkReleaseSwapchainImagesKHR($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkReleaseSwapchainImagesInfoKHR
)
mod.VkComponentTypeKHR = ffi.typeof([[enum {
	VK_COMPONENT_TYPE_FLOAT16_KHR = 0,
	VK_COMPONENT_TYPE_FLOAT32_KHR = 1,
	VK_COMPONENT_TYPE_FLOAT64_KHR = 2,
	VK_COMPONENT_TYPE_SINT8_KHR = 3,
	VK_COMPONENT_TYPE_SINT16_KHR = 4,
	VK_COMPONENT_TYPE_SINT32_KHR = 5,
	VK_COMPONENT_TYPE_SINT64_KHR = 6,
	VK_COMPONENT_TYPE_UINT8_KHR = 7,
	VK_COMPONENT_TYPE_UINT16_KHR = 8,
	VK_COMPONENT_TYPE_UINT32_KHR = 9,
	VK_COMPONENT_TYPE_UINT64_KHR = 10,
	VK_COMPONENT_TYPE_BFLOAT16_KHR = 1000141000,
	VK_COMPONENT_TYPE_SINT8_PACKED_NV = 1000491000,
	VK_COMPONENT_TYPE_UINT8_PACKED_NV = 1000491001,
	VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT = 1000491002,
	VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT = 1000491003,
	VK_COMPONENT_TYPE_FLOAT16_NV = VK_COMPONENT_TYPE_FLOAT16_KHR,
	VK_COMPONENT_TYPE_FLOAT32_NV = VK_COMPONENT_TYPE_FLOAT32_KHR,
	VK_COMPONENT_TYPE_FLOAT64_NV = VK_COMPONENT_TYPE_FLOAT64_KHR,
	VK_COMPONENT_TYPE_SINT8_NV = VK_COMPONENT_TYPE_SINT8_KHR,
	VK_COMPONENT_TYPE_SINT16_NV = VK_COMPONENT_TYPE_SINT16_KHR,
	VK_COMPONENT_TYPE_SINT32_NV = VK_COMPONENT_TYPE_SINT32_KHR,
	VK_COMPONENT_TYPE_SINT64_NV = VK_COMPONENT_TYPE_SINT64_KHR,
	VK_COMPONENT_TYPE_UINT8_NV = VK_COMPONENT_TYPE_UINT8_KHR,
	VK_COMPONENT_TYPE_UINT16_NV = VK_COMPONENT_TYPE_UINT16_KHR,
	VK_COMPONENT_TYPE_UINT32_NV = VK_COMPONENT_TYPE_UINT32_KHR,
	VK_COMPONENT_TYPE_UINT64_NV = VK_COMPONENT_TYPE_UINT64_KHR,
	VK_COMPONENT_TYPE_FLOAT_E4M3_NV = VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT,
	VK_COMPONENT_TYPE_FLOAT_E5M2_NV = VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT,
	VK_COMPONENT_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkScopeKHR = ffi.typeof([[enum {
	VK_SCOPE_DEVICE_KHR = 1,
	VK_SCOPE_WORKGROUP_KHR = 2,
	VK_SCOPE_SUBGROUP_KHR = 3,
	VK_SCOPE_QUEUE_FAMILY_KHR = 5,
	VK_SCOPE_DEVICE_NV = VK_SCOPE_DEVICE_KHR,
	VK_SCOPE_WORKGROUP_NV = VK_SCOPE_WORKGROUP_KHR,
	VK_SCOPE_SUBGROUP_NV = VK_SCOPE_SUBGROUP_KHR,
	VK_SCOPE_QUEUE_FAMILY_NV = VK_SCOPE_QUEUE_FAMILY_KHR,
	VK_SCOPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkCooperativeMatrixPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t MSize;
	uint32_t NSize;
	uint32_t KSize;
	$ AType;
	$ BType;
	$ CType;
	$ ResultType;
	$ saturatingAccumulation;
	$ scope;
}]],
	mod.VkStructureType,
	mod.VkComponentTypeKHR,
	mod.VkComponentTypeKHR,
	mod.VkComponentTypeKHR,
	mod.VkComponentTypeKHR,
	mod.VkBool32,
	mod.VkScopeKHR
)
ffi.metatype(
	mod.VkCooperativeMatrixPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkCooperativeMatrixPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.MSize,
				t.NSize,
				t.KSize,
				t.AType,
				t.BType,
				t.CType,
				t.ResultType,
				t.saturatingAccumulation,
				t.scope
			)
		end,
	}
)
mod.VkPhysicalDeviceCooperativeMatrixFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ cooperativeMatrix;
	$ cooperativeMatrixRobustBufferAccess;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCooperativeMatrixFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCooperativeMatrixFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.cooperativeMatrix,
				t.cooperativeMatrixRobustBufferAccess
			)
		end,
	}
)
mod.VkPhysicalDeviceCooperativeMatrixPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ cooperativeMatrixSupportedStages;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags
)
ffi.metatype(
	mod.VkPhysicalDeviceCooperativeMatrixPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCooperativeMatrixPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.cooperativeMatrixSupportedStages)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkCooperativeMatrixPropertiesKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkCooperativeMatrixPropertiesKHR
)
mod.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ computeDerivativeGroupQuads;
	$ computeDerivativeGroupLinear;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.computeDerivativeGroupQuads,
				t.computeDerivativeGroupLinear
			)
		end,
	}
)
mod.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ meshAndTaskShaderDerivatives;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.meshAndTaskShaderDerivatives)
		end,
	}
)
mod.StdVideoAV1Profile = ffi.typeof([[enum {
	STD_VIDEO_AV1_PROFILE_MAIN = 0,
	STD_VIDEO_AV1_PROFILE_HIGH = 1,
	STD_VIDEO_AV1_PROFILE_PROFESSIONAL = 2,
	STD_VIDEO_AV1_PROFILE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_PROFILE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1Level = ffi.typeof([[enum {
	STD_VIDEO_AV1_LEVEL_2_0 = 0,
	STD_VIDEO_AV1_LEVEL_2_1 = 1,
	STD_VIDEO_AV1_LEVEL_2_2 = 2,
	STD_VIDEO_AV1_LEVEL_2_3 = 3,
	STD_VIDEO_AV1_LEVEL_3_0 = 4,
	STD_VIDEO_AV1_LEVEL_3_1 = 5,
	STD_VIDEO_AV1_LEVEL_3_2 = 6,
	STD_VIDEO_AV1_LEVEL_3_3 = 7,
	STD_VIDEO_AV1_LEVEL_4_0 = 8,
	STD_VIDEO_AV1_LEVEL_4_1 = 9,
	STD_VIDEO_AV1_LEVEL_4_2 = 10,
	STD_VIDEO_AV1_LEVEL_4_3 = 11,
	STD_VIDEO_AV1_LEVEL_5_0 = 12,
	STD_VIDEO_AV1_LEVEL_5_1 = 13,
	STD_VIDEO_AV1_LEVEL_5_2 = 14,
	STD_VIDEO_AV1_LEVEL_5_3 = 15,
	STD_VIDEO_AV1_LEVEL_6_0 = 16,
	STD_VIDEO_AV1_LEVEL_6_1 = 17,
	STD_VIDEO_AV1_LEVEL_6_2 = 18,
	STD_VIDEO_AV1_LEVEL_6_3 = 19,
	STD_VIDEO_AV1_LEVEL_7_0 = 20,
	STD_VIDEO_AV1_LEVEL_7_1 = 21,
	STD_VIDEO_AV1_LEVEL_7_2 = 22,
	STD_VIDEO_AV1_LEVEL_7_3 = 23,
	STD_VIDEO_AV1_LEVEL_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_LEVEL_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1FrameType = ffi.typeof([[enum {
	STD_VIDEO_AV1_FRAME_TYPE_KEY = 0,
	STD_VIDEO_AV1_FRAME_TYPE_INTER = 1,
	STD_VIDEO_AV1_FRAME_TYPE_INTRA_ONLY = 2,
	STD_VIDEO_AV1_FRAME_TYPE_SWITCH = 3,
	STD_VIDEO_AV1_FRAME_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_FRAME_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1ReferenceName = ffi.typeof([[enum {
	STD_VIDEO_AV1_REFERENCE_NAME_INTRA_FRAME = 0,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST_FRAME = 1,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST2_FRAME = 2,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST3_FRAME = 3,
	STD_VIDEO_AV1_REFERENCE_NAME_GOLDEN_FRAME = 4,
	STD_VIDEO_AV1_REFERENCE_NAME_BWDREF_FRAME = 5,
	STD_VIDEO_AV1_REFERENCE_NAME_ALTREF2_FRAME = 6,
	STD_VIDEO_AV1_REFERENCE_NAME_ALTREF_FRAME = 7,
	STD_VIDEO_AV1_REFERENCE_NAME_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_REFERENCE_NAME_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1InterpolationFilter = ffi.typeof([[enum {
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP = 0,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH = 1,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP = 2,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_BILINEAR = 3,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_SWITCHABLE = 4,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1TxMode = ffi.typeof([[enum {
	STD_VIDEO_AV1_TX_MODE_ONLY_4X4 = 0,
	STD_VIDEO_AV1_TX_MODE_LARGEST = 1,
	STD_VIDEO_AV1_TX_MODE_SELECT = 2,
	STD_VIDEO_AV1_TX_MODE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_TX_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1FrameRestorationType = ffi.typeof([[enum {
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_NONE = 0,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_WIENER = 1,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SGRPROJ = 2,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SWITCHABLE = 3,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1ColorPrimaries = ffi.typeof([[enum {
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_709 = 1,
	STD_VIDEO_AV1_COLOR_PRIMARIES_UNSPECIFIED = 2,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_M = 4,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_B_G = 5,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_601 = 6,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_240 = 7,
	STD_VIDEO_AV1_COLOR_PRIMARIES_GENERIC_FILM = 8,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_2020 = 9,
	STD_VIDEO_AV1_COLOR_PRIMARIES_XYZ = 10,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_431 = 11,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_432 = 12,
	STD_VIDEO_AV1_COLOR_PRIMARIES_EBU_3213 = 22,
	STD_VIDEO_AV1_COLOR_PRIMARIES_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_UNSPECIFIED = STD_VIDEO_AV1_COLOR_PRIMARIES_UNSPECIFIED,
	STD_VIDEO_AV1_COLOR_PRIMARIES_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1TransferCharacteristics = ffi.typeof([[enum {
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_0 = 0,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_709 = 1,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_UNSPECIFIED = 2,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_3 = 3,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_M = 4,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_B_G = 5,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_601 = 6,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_240 = 7,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LINEAR = 8,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100 = 9,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100_SQRT10 = 10,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_IEC_61966 = 11,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_1361 = 12,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SRGB = 13,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_10_BIT = 14,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_12_BIT = 15,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_2084 = 16,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_428 = 17,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_HLG = 18,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1MatrixCoefficients = ffi.typeof([[enum {
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_IDENTITY = 0,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_709 = 1,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_UNSPECIFIED = 2,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_RESERVED_3 = 3,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_FCC = 4,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_470_B_G = 5,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_601 = 6,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_240 = 7,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_YCGCO = 8,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_NCL = 9,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_CL = 10,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_2085 = 11,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_NCL = 12,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_CL = 13,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_ICTCP = 14,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1ChromaSamplePosition = ffi.typeof([[enum {
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_UNKNOWN = 0,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_VERTICAL = 1,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_COLOCATED = 2,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_RESERVED = 3,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1ColorConfigFlags = ffi.typeof([[struct {
	uint32_t mono_chrome;
	uint32_t color_range;
	uint32_t separate_uv_delta_q;
	uint32_t color_description_present_flag;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoAV1ColorConfigFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1ColorConfigFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.mono_chrome,
				t.color_range,
				t.separate_uv_delta_q,
				t.color_description_present_flag,
				t.reserved
			)
		end,
	}
)
mod.StdVideoAV1ColorConfig = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t BitDepth;
	uint8_t subsampling_x;
	uint8_t subsampling_y;
	uint8_t reserved1;
	$ color_primaries;
	$ transfer_characteristics;
	$ matrix_coefficients;
	$ chroma_sample_position;
}]],
	mod.StdVideoAV1ColorConfigFlags,
	mod.StdVideoAV1ColorPrimaries,
	mod.StdVideoAV1TransferCharacteristics,
	mod.StdVideoAV1MatrixCoefficients,
	mod.StdVideoAV1ChromaSamplePosition
)
ffi.metatype(
	mod.StdVideoAV1ColorConfig,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1ColorConfig[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.BitDepth,
				t.subsampling_x,
				t.subsampling_y,
				t.reserved1,
				t.color_primaries,
				t.transfer_characteristics,
				t.matrix_coefficients,
				t.chroma_sample_position
			)
		end,
	}
)
mod.StdVideoAV1TimingInfoFlags = ffi.typeof([[struct {
	uint32_t equal_picture_interval;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoAV1TimingInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1TimingInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.equal_picture_interval, t.reserved)
		end,
	}
)
mod.StdVideoAV1TimingInfo = ffi.typeof(
	[[struct {
	$ flags;
	uint32_t num_units_in_display_tick;
	uint32_t time_scale;
	uint32_t num_ticks_per_picture_minus_1;
}]],
	mod.StdVideoAV1TimingInfoFlags
)
ffi.metatype(
	mod.StdVideoAV1TimingInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1TimingInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.num_units_in_display_tick,
				t.time_scale,
				t.num_ticks_per_picture_minus_1
			)
		end,
	}
)
mod.StdVideoAV1LoopFilterFlags = ffi.typeof([[struct {
	uint32_t loop_filter_delta_enabled;
	uint32_t loop_filter_delta_update;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoAV1LoopFilterFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1LoopFilterFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.loop_filter_delta_enabled, t.loop_filter_delta_update, t.reserved)
		end,
	}
)
mod.StdVideoAV1LoopFilter = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t loop_filter_level[4U];
	uint8_t loop_filter_sharpness;
	uint8_t update_ref_delta;
	int8_t loop_filter_ref_deltas[8U];
	uint8_t update_mode_delta;
	int8_t loop_filter_mode_deltas[2U];
}]],
	mod.StdVideoAV1LoopFilterFlags
)
ffi.metatype(
	mod.StdVideoAV1LoopFilter,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1LoopFilter[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.loop_filter_level,
				t.loop_filter_sharpness,
				t.update_ref_delta,
				t.loop_filter_ref_deltas,
				t.update_mode_delta,
				t.loop_filter_mode_deltas
			)
		end,
	}
)
mod.StdVideoAV1QuantizationFlags = ffi.typeof([[struct {
	uint32_t using_qmatrix;
	uint32_t diff_uv_delta;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoAV1QuantizationFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1QuantizationFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.using_qmatrix, t.diff_uv_delta, t.reserved)
		end,
	}
)
mod.StdVideoAV1Quantization = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t base_q_idx;
	int8_t DeltaQYDc;
	int8_t DeltaQUDc;
	int8_t DeltaQUAc;
	int8_t DeltaQVDc;
	int8_t DeltaQVAc;
	uint8_t qm_y;
	uint8_t qm_u;
	uint8_t qm_v;
}]],
	mod.StdVideoAV1QuantizationFlags
)
ffi.metatype(
	mod.StdVideoAV1Quantization,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1Quantization[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.base_q_idx,
				t.DeltaQYDc,
				t.DeltaQUDc,
				t.DeltaQUAc,
				t.DeltaQVDc,
				t.DeltaQVAc,
				t.qm_y,
				t.qm_u,
				t.qm_v
			)
		end,
	}
)
mod.StdVideoAV1Segmentation = ffi.typeof([[struct {
	uint8_t FeatureEnabled[8U];
	int16_t FeatureData[8U][8U];
}]])
ffi.metatype(
	mod.StdVideoAV1Segmentation,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1Segmentation[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.FeatureEnabled, t.FeatureData)
		end,
	}
)
mod.StdVideoAV1TileInfoFlags = ffi.typeof([[struct {
	uint32_t uniform_tile_spacing_flag;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoAV1TileInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1TileInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.uniform_tile_spacing_flag, t.reserved)
		end,
	}
)
mod.StdVideoAV1TileInfo = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t TileCols;
	uint8_t TileRows;
	uint16_t context_update_tile_id;
	uint8_t tile_size_bytes_minus_1;
	uint8_t reserved1[7];
	const uint16_t* pMiColStarts;
	const uint16_t* pMiRowStarts;
	const uint16_t* pWidthInSbsMinus1;
	const uint16_t* pHeightInSbsMinus1;
}]],
	mod.StdVideoAV1TileInfoFlags
)
ffi.metatype(
	mod.StdVideoAV1TileInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1TileInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.TileCols,
				t.TileRows,
				t.context_update_tile_id,
				t.tile_size_bytes_minus_1,
				t.reserved1,
				t.pMiColStarts,
				t.pMiRowStarts,
				t.pWidthInSbsMinus1,
				t.pHeightInSbsMinus1
			)
		end,
	}
)
mod.StdVideoAV1CDEF = ffi.typeof([[struct {
	uint8_t cdef_damping_minus_3;
	uint8_t cdef_bits;
	uint8_t cdef_y_pri_strength[8U];
	uint8_t cdef_y_sec_strength[8U];
	uint8_t cdef_uv_pri_strength[8U];
	uint8_t cdef_uv_sec_strength[8U];
}]])
ffi.metatype(
	mod.StdVideoAV1CDEF,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1CDEF[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.cdef_damping_minus_3,
				t.cdef_bits,
				t.cdef_y_pri_strength,
				t.cdef_y_sec_strength,
				t.cdef_uv_pri_strength,
				t.cdef_uv_sec_strength
			)
		end,
	}
)
mod.StdVideoAV1LoopRestoration = ffi.typeof(
	[[struct {
	$ FrameRestorationType[3U];
	uint16_t LoopRestorationSize[3U];
}]],
	mod.StdVideoAV1FrameRestorationType
)
ffi.metatype(
	mod.StdVideoAV1LoopRestoration,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1LoopRestoration[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.FrameRestorationType, t.LoopRestorationSize)
		end,
	}
)
mod.StdVideoAV1GlobalMotion = ffi.typeof([[struct {
	uint8_t GmType[8U];
	int32_t gm_params[6U][8U];
}]])
ffi.metatype(
	mod.StdVideoAV1GlobalMotion,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1GlobalMotion[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.GmType, t.gm_params)
		end,
	}
)
mod.StdVideoAV1FilmGrainFlags = ffi.typeof([[struct {
	uint32_t chroma_scaling_from_luma;
	uint32_t overlap_flag;
	uint32_t clip_to_restricted_range;
	uint32_t update_grain;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoAV1FilmGrainFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1FilmGrainFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.chroma_scaling_from_luma,
				t.overlap_flag,
				t.clip_to_restricted_range,
				t.update_grain,
				t.reserved
			)
		end,
	}
)
mod.StdVideoAV1FilmGrain = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t grain_scaling_minus_8;
	uint8_t ar_coeff_lag;
	uint8_t ar_coeff_shift_minus_6;
	uint8_t grain_scale_shift;
	uint16_t grain_seed;
	uint8_t film_grain_params_ref_idx;
	uint8_t num_y_points;
	uint8_t point_y_value[14U];
	uint8_t point_y_scaling[14U];
	uint8_t num_cb_points;
	uint8_t point_cb_value[10U];
	uint8_t point_cb_scaling[10U];
	uint8_t num_cr_points;
	uint8_t point_cr_value[10U];
	uint8_t point_cr_scaling[10U];
	int8_t ar_coeffs_y_plus_128[24U];
	int8_t ar_coeffs_cb_plus_128[25U];
	int8_t ar_coeffs_cr_plus_128[25U];
	uint8_t cb_mult;
	uint8_t cb_luma_mult;
	uint16_t cb_offset;
	uint8_t cr_mult;
	uint8_t cr_luma_mult;
	uint16_t cr_offset;
}]],
	mod.StdVideoAV1FilmGrainFlags
)
ffi.metatype(
	mod.StdVideoAV1FilmGrain,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1FilmGrain[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.grain_scaling_minus_8,
				t.ar_coeff_lag,
				t.ar_coeff_shift_minus_6,
				t.grain_scale_shift,
				t.grain_seed,
				t.film_grain_params_ref_idx,
				t.num_y_points,
				t.point_y_value,
				t.point_y_scaling,
				t.num_cb_points,
				t.point_cb_value,
				t.point_cb_scaling,
				t.num_cr_points,
				t.point_cr_value,
				t.point_cr_scaling,
				t.ar_coeffs_y_plus_128,
				t.ar_coeffs_cb_plus_128,
				t.ar_coeffs_cr_plus_128,
				t.cb_mult,
				t.cb_luma_mult,
				t.cb_offset,
				t.cr_mult,
				t.cr_luma_mult,
				t.cr_offset
			)
		end,
	}
)
mod.StdVideoAV1SequenceHeaderFlags = ffi.typeof([[struct {
	uint32_t still_picture;
	uint32_t reduced_still_picture_header;
	uint32_t use_128x128_superblock;
	uint32_t enable_filter_intra;
	uint32_t enable_intra_edge_filter;
	uint32_t enable_interintra_compound;
	uint32_t enable_masked_compound;
	uint32_t enable_warped_motion;
	uint32_t enable_dual_filter;
	uint32_t enable_order_hint;
	uint32_t enable_jnt_comp;
	uint32_t enable_ref_frame_mvs;
	uint32_t frame_id_numbers_present_flag;
	uint32_t enable_superres;
	uint32_t enable_cdef;
	uint32_t enable_restoration;
	uint32_t film_grain_params_present;
	uint32_t timing_info_present_flag;
	uint32_t initial_display_delay_present_flag;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoAV1SequenceHeaderFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1SequenceHeaderFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.still_picture,
				t.reduced_still_picture_header,
				t.use_128x128_superblock,
				t.enable_filter_intra,
				t.enable_intra_edge_filter,
				t.enable_interintra_compound,
				t.enable_masked_compound,
				t.enable_warped_motion,
				t.enable_dual_filter,
				t.enable_order_hint,
				t.enable_jnt_comp,
				t.enable_ref_frame_mvs,
				t.frame_id_numbers_present_flag,
				t.enable_superres,
				t.enable_cdef,
				t.enable_restoration,
				t.film_grain_params_present,
				t.timing_info_present_flag,
				t.initial_display_delay_present_flag,
				t.reserved
			)
		end,
	}
)
mod.StdVideoAV1SequenceHeader = ffi.typeof(
	[[struct {
	$ flags;
	$ seq_profile;
	uint8_t frame_width_bits_minus_1;
	uint8_t frame_height_bits_minus_1;
	uint16_t max_frame_width_minus_1;
	uint16_t max_frame_height_minus_1;
	uint8_t delta_frame_id_length_minus_2;
	uint8_t additional_frame_id_length_minus_1;
	uint8_t order_hint_bits_minus_1;
	uint8_t seq_force_integer_mv;
	uint8_t seq_force_screen_content_tools;
	uint8_t reserved1[5];
	const $* pColorConfig;
	const $* pTimingInfo;
}]],
	mod.StdVideoAV1SequenceHeaderFlags,
	mod.StdVideoAV1Profile,
	mod.StdVideoAV1ColorConfig,
	mod.StdVideoAV1TimingInfo
)
ffi.metatype(
	mod.StdVideoAV1SequenceHeader,
	{
		__tostring = function(s)
			return ("struct StdVideoAV1SequenceHeader[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.seq_profile,
				t.frame_width_bits_minus_1,
				t.frame_height_bits_minus_1,
				t.max_frame_width_minus_1,
				t.max_frame_height_minus_1,
				t.delta_frame_id_length_minus_2,
				t.additional_frame_id_length_minus_1,
				t.order_hint_bits_minus_1,
				t.seq_force_integer_mv,
				t.seq_force_screen_content_tools,
				t.reserved1,
				t.pColorConfig,
				t.pTimingInfo
			)
		end,
	}
)
mod.StdVideoDecodeAV1PictureInfoFlags = ffi.typeof([[struct {
	uint32_t error_resilient_mode;
	uint32_t disable_cdf_update;
	uint32_t use_superres;
	uint32_t render_and_frame_size_different;
	uint32_t allow_screen_content_tools;
	uint32_t is_filter_switchable;
	uint32_t force_integer_mv;
	uint32_t frame_size_override_flag;
	uint32_t buffer_removal_time_present_flag;
	uint32_t allow_intrabc;
	uint32_t frame_refs_short_signaling;
	uint32_t allow_high_precision_mv;
	uint32_t is_motion_mode_switchable;
	uint32_t use_ref_frame_mvs;
	uint32_t disable_frame_end_update_cdf;
	uint32_t allow_warped_motion;
	uint32_t reduced_tx_set;
	uint32_t reference_select;
	uint32_t skip_mode_present;
	uint32_t delta_q_present;
	uint32_t delta_lf_present;
	uint32_t delta_lf_multi;
	uint32_t segmentation_enabled;
	uint32_t segmentation_update_map;
	uint32_t segmentation_temporal_update;
	uint32_t segmentation_update_data;
	uint32_t UsesLr;
	uint32_t usesChromaLr;
	uint32_t apply_grain;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoDecodeAV1PictureInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeAV1PictureInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.error_resilient_mode,
				t.disable_cdf_update,
				t.use_superres,
				t.render_and_frame_size_different,
				t.allow_screen_content_tools,
				t.is_filter_switchable,
				t.force_integer_mv,
				t.frame_size_override_flag,
				t.buffer_removal_time_present_flag,
				t.allow_intrabc,
				t.frame_refs_short_signaling,
				t.allow_high_precision_mv,
				t.is_motion_mode_switchable,
				t.use_ref_frame_mvs,
				t.disable_frame_end_update_cdf,
				t.allow_warped_motion,
				t.reduced_tx_set,
				t.reference_select,
				t.skip_mode_present,
				t.delta_q_present,
				t.delta_lf_present,
				t.delta_lf_multi,
				t.segmentation_enabled,
				t.segmentation_update_map,
				t.segmentation_temporal_update,
				t.segmentation_update_data,
				t.UsesLr,
				t.usesChromaLr,
				t.apply_grain,
				t.reserved
			)
		end,
	}
)
mod.StdVideoDecodeAV1PictureInfo = ffi.typeof(
	[[struct {
	$ flags;
	$ frame_type;
	uint32_t current_frame_id;
	uint8_t OrderHint;
	uint8_t primary_ref_frame;
	uint8_t refresh_frame_flags;
	uint8_t reserved1;
	$ interpolation_filter;
	$ TxMode;
	uint8_t delta_q_res;
	uint8_t delta_lf_res;
	uint8_t SkipModeFrame[2U];
	uint8_t coded_denom;
	uint8_t reserved2[3];
	uint8_t OrderHints[8U];
	uint32_t expectedFrameId[8U];
	const $* pTileInfo;
	const $* pQuantization;
	const $* pSegmentation;
	const $* pLoopFilter;
	const $* pCDEF;
	const $* pLoopRestoration;
	const $* pGlobalMotion;
	const $* pFilmGrain;
}]],
	mod.StdVideoDecodeAV1PictureInfoFlags,
	mod.StdVideoAV1FrameType,
	mod.StdVideoAV1InterpolationFilter,
	mod.StdVideoAV1TxMode,
	mod.StdVideoAV1TileInfo,
	mod.StdVideoAV1Quantization,
	mod.StdVideoAV1Segmentation,
	mod.StdVideoAV1LoopFilter,
	mod.StdVideoAV1CDEF,
	mod.StdVideoAV1LoopRestoration,
	mod.StdVideoAV1GlobalMotion,
	mod.StdVideoAV1FilmGrain
)
ffi.metatype(
	mod.StdVideoDecodeAV1PictureInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeAV1PictureInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.frame_type,
				t.current_frame_id,
				t.OrderHint,
				t.primary_ref_frame,
				t.refresh_frame_flags,
				t.reserved1,
				t.interpolation_filter,
				t.TxMode,
				t.delta_q_res,
				t.delta_lf_res,
				t.SkipModeFrame,
				t.coded_denom,
				t.reserved2,
				t.OrderHints,
				t.expectedFrameId,
				t.pTileInfo,
				t.pQuantization,
				t.pSegmentation,
				t.pLoopFilter,
				t.pCDEF,
				t.pLoopRestoration,
				t.pGlobalMotion,
				t.pFilmGrain
			)
		end,
	}
)
mod.StdVideoDecodeAV1ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t disable_frame_end_update_cdf;
	uint32_t segmentation_enabled;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoDecodeAV1ReferenceInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeAV1ReferenceInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.disable_frame_end_update_cdf, t.segmentation_enabled, t.reserved)
		end,
	}
)
mod.StdVideoDecodeAV1ReferenceInfo = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t frame_type;
	uint8_t RefFrameSignBias;
	uint8_t OrderHint;
	uint8_t SavedOrderHints[8U];
}]],
	mod.StdVideoDecodeAV1ReferenceInfoFlags
)
ffi.metatype(
	mod.StdVideoDecodeAV1ReferenceInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeAV1ReferenceInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.flags, t.frame_type, t.RefFrameSignBias, t.OrderHint, t.SavedOrderHints)
		end,
	}
)
mod.VkVideoDecodeAV1ProfileInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stdProfile;
	$ filmGrainSupport;
}]],
	mod.VkStructureType,
	mod.StdVideoAV1Profile,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoDecodeAV1ProfileInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeAV1ProfileInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stdProfile, t.filmGrainSupport)
		end,
	}
)
mod.VkVideoDecodeAV1CapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maxLevel;
}]],
	mod.VkStructureType,
	mod.StdVideoAV1Level
)
ffi.metatype(
	mod.VkVideoDecodeAV1CapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeAV1CapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxLevel)
		end,
	}
)
mod.VkVideoDecodeAV1SessionParametersCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdSequenceHeader;
}]],
	mod.VkStructureType,
	mod.StdVideoAV1SequenceHeader
)
ffi.metatype(
	mod.VkVideoDecodeAV1SessionParametersCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeAV1SessionParametersCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pStdSequenceHeader)
		end,
	}
)
mod.VkVideoDecodeAV1PictureInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdPictureInfo;
	int32_t referenceNameSlotIndices[7U];
	uint32_t frameHeaderOffset;
	uint32_t tileCount;
	const uint32_t* pTileOffsets;
	const uint32_t* pTileSizes;
}]],
	mod.VkStructureType,
	mod.StdVideoDecodeAV1PictureInfo
)
ffi.metatype(
	mod.VkVideoDecodeAV1PictureInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeAV1PictureInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pStdPictureInfo,
				t.referenceNameSlotIndices,
				t.frameHeaderOffset,
				t.tileCount,
				t.pTileOffsets,
				t.pTileSizes
			)
		end,
	}
)
mod.VkVideoDecodeAV1DpbSlotInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]],
	mod.VkStructureType,
	mod.StdVideoDecodeAV1ReferenceInfo
)
ffi.metatype(
	mod.VkVideoDecodeAV1DpbSlotInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeAV1DpbSlotInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pStdReferenceInfo)
		end,
	}
)
mod.StdVideoEncodeAV1DecoderModelInfo = ffi.typeof([[struct {
	uint8_t buffer_delay_length_minus_1;
	uint8_t buffer_removal_time_length_minus_1;
	uint8_t frame_presentation_time_length_minus_1;
	uint8_t reserved1;
	uint32_t num_units_in_decoding_tick;
}]])
ffi.metatype(
	mod.StdVideoEncodeAV1DecoderModelInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeAV1DecoderModelInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.buffer_delay_length_minus_1,
				t.buffer_removal_time_length_minus_1,
				t.frame_presentation_time_length_minus_1,
				t.reserved1,
				t.num_units_in_decoding_tick
			)
		end,
	}
)
mod.StdVideoEncodeAV1ExtensionHeader = ffi.typeof([[struct {
	uint8_t temporal_id;
	uint8_t spatial_id;
}]])
ffi.metatype(
	mod.StdVideoEncodeAV1ExtensionHeader,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeAV1ExtensionHeader[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.temporal_id, t.spatial_id)
		end,
	}
)
mod.StdVideoEncodeAV1OperatingPointInfoFlags = ffi.typeof([[struct {
	uint32_t decoder_model_present_for_this_op;
	uint32_t low_delay_mode_flag;
	uint32_t initial_display_delay_present_for_this_op;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoEncodeAV1OperatingPointInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeAV1OperatingPointInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.decoder_model_present_for_this_op,
				t.low_delay_mode_flag,
				t.initial_display_delay_present_for_this_op,
				t.reserved
			)
		end,
	}
)
mod.StdVideoEncodeAV1OperatingPointInfo = ffi.typeof(
	[[struct {
	$ flags;
	uint16_t operating_point_idc;
	uint8_t seq_level_idx;
	uint8_t seq_tier;
	uint32_t decoder_buffer_delay;
	uint32_t encoder_buffer_delay;
	uint8_t initial_display_delay_minus_1;
}]],
	mod.StdVideoEncodeAV1OperatingPointInfoFlags
)
ffi.metatype(
	mod.StdVideoEncodeAV1OperatingPointInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeAV1OperatingPointInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.operating_point_idc,
				t.seq_level_idx,
				t.seq_tier,
				t.decoder_buffer_delay,
				t.encoder_buffer_delay,
				t.initial_display_delay_minus_1
			)
		end,
	}
)
mod.StdVideoEncodeAV1PictureInfoFlags = ffi.typeof([[struct {
	uint32_t error_resilient_mode;
	uint32_t disable_cdf_update;
	uint32_t use_superres;
	uint32_t render_and_frame_size_different;
	uint32_t allow_screen_content_tools;
	uint32_t is_filter_switchable;
	uint32_t force_integer_mv;
	uint32_t frame_size_override_flag;
	uint32_t buffer_removal_time_present_flag;
	uint32_t allow_intrabc;
	uint32_t frame_refs_short_signaling;
	uint32_t allow_high_precision_mv;
	uint32_t is_motion_mode_switchable;
	uint32_t use_ref_frame_mvs;
	uint32_t disable_frame_end_update_cdf;
	uint32_t allow_warped_motion;
	uint32_t reduced_tx_set;
	uint32_t skip_mode_present;
	uint32_t delta_q_present;
	uint32_t delta_lf_present;
	uint32_t delta_lf_multi;
	uint32_t segmentation_enabled;
	uint32_t segmentation_update_map;
	uint32_t segmentation_temporal_update;
	uint32_t segmentation_update_data;
	uint32_t UsesLr;
	uint32_t usesChromaLr;
	uint32_t show_frame;
	uint32_t showable_frame;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoEncodeAV1PictureInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeAV1PictureInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.error_resilient_mode,
				t.disable_cdf_update,
				t.use_superres,
				t.render_and_frame_size_different,
				t.allow_screen_content_tools,
				t.is_filter_switchable,
				t.force_integer_mv,
				t.frame_size_override_flag,
				t.buffer_removal_time_present_flag,
				t.allow_intrabc,
				t.frame_refs_short_signaling,
				t.allow_high_precision_mv,
				t.is_motion_mode_switchable,
				t.use_ref_frame_mvs,
				t.disable_frame_end_update_cdf,
				t.allow_warped_motion,
				t.reduced_tx_set,
				t.skip_mode_present,
				t.delta_q_present,
				t.delta_lf_present,
				t.delta_lf_multi,
				t.segmentation_enabled,
				t.segmentation_update_map,
				t.segmentation_temporal_update,
				t.segmentation_update_data,
				t.UsesLr,
				t.usesChromaLr,
				t.show_frame,
				t.showable_frame,
				t.reserved
			)
		end,
	}
)
mod.StdVideoEncodeAV1PictureInfo = ffi.typeof(
	[[struct {
	$ flags;
	$ frame_type;
	uint32_t frame_presentation_time;
	uint32_t current_frame_id;
	uint8_t order_hint;
	uint8_t primary_ref_frame;
	uint8_t refresh_frame_flags;
	uint8_t coded_denom;
	uint16_t render_width_minus_1;
	uint16_t render_height_minus_1;
	$ interpolation_filter;
	$ TxMode;
	uint8_t delta_q_res;
	uint8_t delta_lf_res;
	uint8_t ref_order_hint[8U];
	int8_t ref_frame_idx[7U];
	uint8_t reserved1[3];
	uint32_t delta_frame_id_minus_1[7U];
	const $* pTileInfo;
	const $* pQuantization;
	const $* pSegmentation;
	const $* pLoopFilter;
	const $* pCDEF;
	const $* pLoopRestoration;
	const $* pGlobalMotion;
	const $* pExtensionHeader;
	const uint32_t* pBufferRemovalTimes;
}]],
	mod.StdVideoEncodeAV1PictureInfoFlags,
	mod.StdVideoAV1FrameType,
	mod.StdVideoAV1InterpolationFilter,
	mod.StdVideoAV1TxMode,
	mod.StdVideoAV1TileInfo,
	mod.StdVideoAV1Quantization,
	mod.StdVideoAV1Segmentation,
	mod.StdVideoAV1LoopFilter,
	mod.StdVideoAV1CDEF,
	mod.StdVideoAV1LoopRestoration,
	mod.StdVideoAV1GlobalMotion,
	mod.StdVideoEncodeAV1ExtensionHeader
)
ffi.metatype(
	mod.StdVideoEncodeAV1PictureInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeAV1PictureInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.frame_type,
				t.frame_presentation_time,
				t.current_frame_id,
				t.order_hint,
				t.primary_ref_frame,
				t.refresh_frame_flags,
				t.coded_denom,
				t.render_width_minus_1,
				t.render_height_minus_1,
				t.interpolation_filter,
				t.TxMode,
				t.delta_q_res,
				t.delta_lf_res,
				t.ref_order_hint,
				t.ref_frame_idx,
				t.reserved1,
				t.delta_frame_id_minus_1,
				t.pTileInfo,
				t.pQuantization,
				t.pSegmentation,
				t.pLoopFilter,
				t.pCDEF,
				t.pLoopRestoration,
				t.pGlobalMotion,
				t.pExtensionHeader,
				t.pBufferRemovalTimes
			)
		end,
	}
)
mod.StdVideoEncodeAV1ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t disable_frame_end_update_cdf;
	uint32_t segmentation_enabled;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoEncodeAV1ReferenceInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeAV1ReferenceInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.disable_frame_end_update_cdf, t.segmentation_enabled, t.reserved)
		end,
	}
)
mod.StdVideoEncodeAV1ReferenceInfo = ffi.typeof(
	[[struct {
	$ flags;
	uint32_t RefFrameId;
	$ frame_type;
	uint8_t OrderHint;
	uint8_t reserved1[3];
	const $* pExtensionHeader;
}]],
	mod.StdVideoEncodeAV1ReferenceInfoFlags,
	mod.StdVideoAV1FrameType,
	mod.StdVideoEncodeAV1ExtensionHeader
)
ffi.metatype(
	mod.StdVideoEncodeAV1ReferenceInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoEncodeAV1ReferenceInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.RefFrameId,
				t.frame_type,
				t.OrderHint,
				t.reserved1,
				t.pExtensionHeader
			)
		end,
	}
)
mod.VkVideoEncodeAV1PredictionModeKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR = 0,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR = 1,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR = 2,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR = 3,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1RateControlGroupKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR = 0,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR = 1,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR = 2,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1CapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1CapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeAV1StdFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1StdFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeAV1SuperblockSizeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1SuperblockSizeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeAV1RateControlFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1RateControlFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceVideoEncodeAV1FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ videoEncodeAV1;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVideoEncodeAV1FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVideoEncodeAV1FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.videoEncodeAV1)
		end,
	}
)
mod.VkVideoEncodeAV1CapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ maxLevel;
	$ codedPictureAlignment;
	$ maxTiles;
	$ minTileSize;
	$ maxTileSize;
	$ superblockSizes;
	uint32_t maxSingleReferenceCount;
	uint32_t singleReferenceNameMask;
	uint32_t maxUnidirectionalCompoundReferenceCount;
	uint32_t maxUnidirectionalCompoundGroup1ReferenceCount;
	uint32_t unidirectionalCompoundReferenceNameMask;
	uint32_t maxBidirectionalCompoundReferenceCount;
	uint32_t maxBidirectionalCompoundGroup1ReferenceCount;
	uint32_t maxBidirectionalCompoundGroup2ReferenceCount;
	uint32_t bidirectionalCompoundReferenceNameMask;
	uint32_t maxTemporalLayerCount;
	uint32_t maxSpatialLayerCount;
	uint32_t maxOperatingPoints;
	uint32_t minQIndex;
	uint32_t maxQIndex;
	$ prefersGopRemainingFrames;
	$ requiresGopRemainingFrames;
	$ stdSyntaxFlags;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeAV1CapabilityFlagsKHR,
	mod.StdVideoAV1Level,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkVideoEncodeAV1SuperblockSizeFlagsKHR,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkVideoEncodeAV1StdFlagsKHR
)
ffi.metatype(
	mod.VkVideoEncodeAV1CapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1CapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.maxLevel,
				t.codedPictureAlignment,
				t.maxTiles,
				t.minTileSize,
				t.maxTileSize,
				t.superblockSizes,
				t.maxSingleReferenceCount,
				t.singleReferenceNameMask,
				t.maxUnidirectionalCompoundReferenceCount,
				t.maxUnidirectionalCompoundGroup1ReferenceCount,
				t.unidirectionalCompoundReferenceNameMask,
				t.maxBidirectionalCompoundReferenceCount,
				t.maxBidirectionalCompoundGroup1ReferenceCount,
				t.maxBidirectionalCompoundGroup2ReferenceCount,
				t.bidirectionalCompoundReferenceNameMask,
				t.maxTemporalLayerCount,
				t.maxSpatialLayerCount,
				t.maxOperatingPoints,
				t.minQIndex,
				t.maxQIndex,
				t.prefersGopRemainingFrames,
				t.requiresGopRemainingFrames,
				t.stdSyntaxFlags
			)
		end,
	}
)
mod.VkVideoEncodeAV1QIndexKHR = ffi.typeof([[struct {
	uint32_t intraQIndex;
	uint32_t predictiveQIndex;
	uint32_t bipredictiveQIndex;
}]])
ffi.metatype(
	mod.VkVideoEncodeAV1QIndexKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1QIndexKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.intraQIndex, t.predictiveQIndex, t.bipredictiveQIndex)
		end,
	}
)
mod.VkVideoEncodeAV1QualityLevelPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ preferredRateControlFlags;
	uint32_t preferredGopFrameCount;
	uint32_t preferredKeyFramePeriod;
	uint32_t preferredConsecutiveBipredictiveFrameCount;
	uint32_t preferredTemporalLayerCount;
	$ preferredConstantQIndex;
	uint32_t preferredMaxSingleReferenceCount;
	uint32_t preferredSingleReferenceNameMask;
	uint32_t preferredMaxUnidirectionalCompoundReferenceCount;
	uint32_t preferredMaxUnidirectionalCompoundGroup1ReferenceCount;
	uint32_t preferredUnidirectionalCompoundReferenceNameMask;
	uint32_t preferredMaxBidirectionalCompoundReferenceCount;
	uint32_t preferredMaxBidirectionalCompoundGroup1ReferenceCount;
	uint32_t preferredMaxBidirectionalCompoundGroup2ReferenceCount;
	uint32_t preferredBidirectionalCompoundReferenceNameMask;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeAV1RateControlFlagsKHR,
	mod.VkVideoEncodeAV1QIndexKHR
)
ffi.metatype(
	mod.VkVideoEncodeAV1QualityLevelPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1QualityLevelPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.preferredRateControlFlags,
				t.preferredGopFrameCount,
				t.preferredKeyFramePeriod,
				t.preferredConsecutiveBipredictiveFrameCount,
				t.preferredTemporalLayerCount,
				t.preferredConstantQIndex,
				t.preferredMaxSingleReferenceCount,
				t.preferredSingleReferenceNameMask,
				t.preferredMaxUnidirectionalCompoundReferenceCount,
				t.preferredMaxUnidirectionalCompoundGroup1ReferenceCount,
				t.preferredUnidirectionalCompoundReferenceNameMask,
				t.preferredMaxBidirectionalCompoundReferenceCount,
				t.preferredMaxBidirectionalCompoundGroup1ReferenceCount,
				t.preferredMaxBidirectionalCompoundGroup2ReferenceCount,
				t.preferredBidirectionalCompoundReferenceNameMask
			)
		end,
	}
)
mod.VkVideoEncodeAV1SessionCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ useMaxLevel;
	$ maxLevel;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.StdVideoAV1Level
)
ffi.metatype(
	mod.VkVideoEncodeAV1SessionCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1SessionCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.useMaxLevel, t.maxLevel)
		end,
	}
)
mod.VkVideoEncodeAV1SessionParametersCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdSequenceHeader;
	const $* pStdDecoderModelInfo;
	uint32_t stdOperatingPointCount;
	const $* pStdOperatingPoints;
}]],
	mod.VkStructureType,
	mod.StdVideoAV1SequenceHeader,
	mod.StdVideoEncodeAV1DecoderModelInfo,
	mod.StdVideoEncodeAV1OperatingPointInfo
)
ffi.metatype(
	mod.VkVideoEncodeAV1SessionParametersCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1SessionParametersCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pStdSequenceHeader,
				t.pStdDecoderModelInfo,
				t.stdOperatingPointCount,
				t.pStdOperatingPoints
			)
		end,
	}
)
mod.VkVideoEncodeAV1PictureInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ predictionMode;
	$ rateControlGroup;
	uint32_t constantQIndex;
	const $* pStdPictureInfo;
	int32_t referenceNameSlotIndices[7U];
	$ primaryReferenceCdfOnly;
	$ generateObuExtensionHeader;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeAV1PredictionModeKHR,
	mod.VkVideoEncodeAV1RateControlGroupKHR,
	mod.StdVideoEncodeAV1PictureInfo,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeAV1PictureInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1PictureInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.predictionMode,
				t.rateControlGroup,
				t.constantQIndex,
				t.pStdPictureInfo,
				t.referenceNameSlotIndices,
				t.primaryReferenceCdfOnly,
				t.generateObuExtensionHeader
			)
		end,
	}
)
mod.VkVideoEncodeAV1DpbSlotInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]],
	mod.VkStructureType,
	mod.StdVideoEncodeAV1ReferenceInfo
)
ffi.metatype(
	mod.VkVideoEncodeAV1DpbSlotInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1DpbSlotInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pStdReferenceInfo)
		end,
	}
)
mod.VkVideoEncodeAV1ProfileInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stdProfile;
}]],
	mod.VkStructureType,
	mod.StdVideoAV1Profile
)
ffi.metatype(
	mod.VkVideoEncodeAV1ProfileInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1ProfileInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stdProfile)
		end,
	}
)
mod.VkVideoEncodeAV1FrameSizeKHR = ffi.typeof([[struct {
	uint32_t intraFrameSize;
	uint32_t predictiveFrameSize;
	uint32_t bipredictiveFrameSize;
}]])
ffi.metatype(
	mod.VkVideoEncodeAV1FrameSizeKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1FrameSizeKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.intraFrameSize, t.predictiveFrameSize, t.bipredictiveFrameSize)
		end,
	}
)
mod.VkVideoEncodeAV1GopRemainingFrameInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ useGopRemainingFrames;
	uint32_t gopRemainingIntra;
	uint32_t gopRemainingPredictive;
	uint32_t gopRemainingBipredictive;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeAV1GopRemainingFrameInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1GopRemainingFrameInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.useGopRemainingFrames,
				t.gopRemainingIntra,
				t.gopRemainingPredictive,
				t.gopRemainingBipredictive
			)
		end,
	}
)
mod.VkVideoEncodeAV1RateControlInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t gopFrameCount;
	uint32_t keyFramePeriod;
	uint32_t consecutiveBipredictiveFrameCount;
	uint32_t temporalLayerCount;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeAV1RateControlFlagsKHR
)
ffi.metatype(
	mod.VkVideoEncodeAV1RateControlInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1RateControlInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.gopFrameCount,
				t.keyFramePeriod,
				t.consecutiveBipredictiveFrameCount,
				t.temporalLayerCount
			)
		end,
	}
)
mod.VkVideoEncodeAV1RateControlLayerInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ useMinQIndex;
	$ minQIndex;
	$ useMaxQIndex;
	$ maxQIndex;
	$ useMaxFrameSize;
	$ maxFrameSize;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkVideoEncodeAV1QIndexKHR,
	mod.VkBool32,
	mod.VkVideoEncodeAV1QIndexKHR,
	mod.VkBool32,
	mod.VkVideoEncodeAV1FrameSizeKHR
)
ffi.metatype(
	mod.VkVideoEncodeAV1RateControlLayerInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1RateControlLayerInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.useMinQIndex,
				t.minQIndex,
				t.useMaxQIndex,
				t.maxQIndex,
				t.useMaxFrameSize,
				t.maxFrameSize
			)
		end,
	}
)
mod.StdVideoVP9Profile = ffi.typeof([[enum {
	STD_VIDEO_VP9_PROFILE_0 = 0,
	STD_VIDEO_VP9_PROFILE_1 = 1,
	STD_VIDEO_VP9_PROFILE_2 = 2,
	STD_VIDEO_VP9_PROFILE_3 = 3,
	STD_VIDEO_VP9_PROFILE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_PROFILE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9Level = ffi.typeof([[enum {
	STD_VIDEO_VP9_LEVEL_1_0 = 0,
	STD_VIDEO_VP9_LEVEL_1_1 = 1,
	STD_VIDEO_VP9_LEVEL_2_0 = 2,
	STD_VIDEO_VP9_LEVEL_2_1 = 3,
	STD_VIDEO_VP9_LEVEL_3_0 = 4,
	STD_VIDEO_VP9_LEVEL_3_1 = 5,
	STD_VIDEO_VP9_LEVEL_4_0 = 6,
	STD_VIDEO_VP9_LEVEL_4_1 = 7,
	STD_VIDEO_VP9_LEVEL_5_0 = 8,
	STD_VIDEO_VP9_LEVEL_5_1 = 9,
	STD_VIDEO_VP9_LEVEL_5_2 = 10,
	STD_VIDEO_VP9_LEVEL_6_0 = 11,
	STD_VIDEO_VP9_LEVEL_6_1 = 12,
	STD_VIDEO_VP9_LEVEL_6_2 = 13,
	STD_VIDEO_VP9_LEVEL_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_LEVEL_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9FrameType = ffi.typeof([[enum {
	STD_VIDEO_VP9_FRAME_TYPE_KEY = 0,
	STD_VIDEO_VP9_FRAME_TYPE_NON_KEY = 1,
	STD_VIDEO_VP9_FRAME_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_FRAME_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9ReferenceName = ffi.typeof([[enum {
	STD_VIDEO_VP9_REFERENCE_NAME_INTRA_FRAME = 0,
	STD_VIDEO_VP9_REFERENCE_NAME_LAST_FRAME = 1,
	STD_VIDEO_VP9_REFERENCE_NAME_GOLDEN_FRAME = 2,
	STD_VIDEO_VP9_REFERENCE_NAME_ALTREF_FRAME = 3,
	STD_VIDEO_VP9_REFERENCE_NAME_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_REFERENCE_NAME_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9InterpolationFilter = ffi.typeof([[enum {
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP = 0,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH = 1,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP_SHARP = 2,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_BILINEAR = 3,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_SWITCHABLE = 4,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9ColorSpace = ffi.typeof([[enum {
	STD_VIDEO_VP9_COLOR_SPACE_UNKNOWN = 0,
	STD_VIDEO_VP9_COLOR_SPACE_BT_601 = 1,
	STD_VIDEO_VP9_COLOR_SPACE_BT_709 = 2,
	STD_VIDEO_VP9_COLOR_SPACE_SMPTE_170 = 3,
	STD_VIDEO_VP9_COLOR_SPACE_SMPTE_240 = 4,
	STD_VIDEO_VP9_COLOR_SPACE_BT_2020 = 5,
	STD_VIDEO_VP9_COLOR_SPACE_RESERVED = 6,
	STD_VIDEO_VP9_COLOR_SPACE_RGB = 7,
	STD_VIDEO_VP9_COLOR_SPACE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_COLOR_SPACE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9ColorConfigFlags = ffi.typeof([[struct {
	uint32_t color_range;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoVP9ColorConfigFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoVP9ColorConfigFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.color_range, t.reserved)
		end,
	}
)
mod.StdVideoVP9ColorConfig = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t BitDepth;
	uint8_t subsampling_x;
	uint8_t subsampling_y;
	uint8_t reserved1;
	$ color_space;
}]],
	mod.StdVideoVP9ColorConfigFlags,
	mod.StdVideoVP9ColorSpace
)
ffi.metatype(
	mod.StdVideoVP9ColorConfig,
	{
		__tostring = function(s)
			return ("struct StdVideoVP9ColorConfig[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.BitDepth,
				t.subsampling_x,
				t.subsampling_y,
				t.reserved1,
				t.color_space
			)
		end,
	}
)
mod.StdVideoVP9LoopFilterFlags = ffi.typeof([[struct {
	uint32_t loop_filter_delta_enabled;
	uint32_t loop_filter_delta_update;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoVP9LoopFilterFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoVP9LoopFilterFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.loop_filter_delta_enabled, t.loop_filter_delta_update, t.reserved)
		end,
	}
)
mod.StdVideoVP9LoopFilter = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t loop_filter_level;
	uint8_t loop_filter_sharpness;
	uint8_t update_ref_delta;
	int8_t loop_filter_ref_deltas[4U];
	uint8_t update_mode_delta;
	int8_t loop_filter_mode_deltas[2U];
}]],
	mod.StdVideoVP9LoopFilterFlags
)
ffi.metatype(
	mod.StdVideoVP9LoopFilter,
	{
		__tostring = function(s)
			return ("struct StdVideoVP9LoopFilter[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.loop_filter_level,
				t.loop_filter_sharpness,
				t.update_ref_delta,
				t.loop_filter_ref_deltas,
				t.update_mode_delta,
				t.loop_filter_mode_deltas
			)
		end,
	}
)
mod.StdVideoVP9SegmentationFlags = ffi.typeof([[struct {
	uint32_t segmentation_update_map;
	uint32_t segmentation_temporal_update;
	uint32_t segmentation_update_data;
	uint32_t segmentation_abs_or_delta_update;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoVP9SegmentationFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoVP9SegmentationFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.segmentation_update_map,
				t.segmentation_temporal_update,
				t.segmentation_update_data,
				t.segmentation_abs_or_delta_update,
				t.reserved
			)
		end,
	}
)
mod.StdVideoVP9Segmentation = ffi.typeof(
	[[struct {
	$ flags;
	uint8_t segmentation_tree_probs[7U];
	uint8_t segmentation_pred_prob[3U];
	uint8_t FeatureEnabled[8U];
	int16_t FeatureData[4U][8U];
}]],
	mod.StdVideoVP9SegmentationFlags
)
ffi.metatype(
	mod.StdVideoVP9Segmentation,
	{
		__tostring = function(s)
			return ("struct StdVideoVP9Segmentation[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.segmentation_tree_probs,
				t.segmentation_pred_prob,
				t.FeatureEnabled,
				t.FeatureData
			)
		end,
	}
)
mod.StdVideoDecodeVP9PictureInfoFlags = ffi.typeof([[struct {
	uint32_t error_resilient_mode;
	uint32_t intra_only;
	uint32_t allow_high_precision_mv;
	uint32_t refresh_frame_context;
	uint32_t frame_parallel_decoding_mode;
	uint32_t segmentation_enabled;
	uint32_t show_frame;
	uint32_t UsePrevFrameMvs;
	uint32_t reserved;
}]])
ffi.metatype(
	mod.StdVideoDecodeVP9PictureInfoFlags,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeVP9PictureInfoFlags[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.error_resilient_mode,
				t.intra_only,
				t.allow_high_precision_mv,
				t.refresh_frame_context,
				t.frame_parallel_decoding_mode,
				t.segmentation_enabled,
				t.show_frame,
				t.UsePrevFrameMvs,
				t.reserved
			)
		end,
	}
)
mod.StdVideoDecodeVP9PictureInfo = ffi.typeof(
	[[struct {
	$ flags;
	$ profile;
	$ frame_type;
	uint8_t frame_context_idx;
	uint8_t reset_frame_context;
	uint8_t refresh_frame_flags;
	uint8_t ref_frame_sign_bias_mask;
	$ interpolation_filter;
	uint8_t base_q_idx;
	int8_t delta_q_y_dc;
	int8_t delta_q_uv_dc;
	int8_t delta_q_uv_ac;
	uint8_t tile_cols_log2;
	uint8_t tile_rows_log2;
	uint16_t reserved1[3];
	const $* pColorConfig;
	const $* pLoopFilter;
	const $* pSegmentation;
}]],
	mod.StdVideoDecodeVP9PictureInfoFlags,
	mod.StdVideoVP9Profile,
	mod.StdVideoVP9FrameType,
	mod.StdVideoVP9InterpolationFilter,
	mod.StdVideoVP9ColorConfig,
	mod.StdVideoVP9LoopFilter,
	mod.StdVideoVP9Segmentation
)
ffi.metatype(
	mod.StdVideoDecodeVP9PictureInfo,
	{
		__tostring = function(s)
			return ("struct StdVideoDecodeVP9PictureInfo[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.flags,
				t.profile,
				t.frame_type,
				t.frame_context_idx,
				t.reset_frame_context,
				t.refresh_frame_flags,
				t.ref_frame_sign_bias_mask,
				t.interpolation_filter,
				t.base_q_idx,
				t.delta_q_y_dc,
				t.delta_q_uv_dc,
				t.delta_q_uv_ac,
				t.tile_cols_log2,
				t.tile_rows_log2,
				t.reserved1,
				t.pColorConfig,
				t.pLoopFilter,
				t.pSegmentation
			)
		end,
	}
)
mod.VkPhysicalDeviceVideoDecodeVP9FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ videoDecodeVP9;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVideoDecodeVP9FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVideoDecodeVP9FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.videoDecodeVP9)
		end,
	}
)
mod.VkVideoDecodeVP9ProfileInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stdProfile;
}]],
	mod.VkStructureType,
	mod.StdVideoVP9Profile
)
ffi.metatype(
	mod.VkVideoDecodeVP9ProfileInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeVP9ProfileInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stdProfile)
		end,
	}
)
mod.VkVideoDecodeVP9CapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maxLevel;
}]],
	mod.VkStructureType,
	mod.StdVideoVP9Level
)
ffi.metatype(
	mod.VkVideoDecodeVP9CapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeVP9CapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxLevel)
		end,
	}
)
mod.VkVideoDecodeVP9PictureInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdPictureInfo;
	int32_t referenceNameSlotIndices[3U];
	uint32_t uncompressedHeaderOffset;
	uint32_t compressedHeaderOffset;
	uint32_t tilesOffset;
}]],
	mod.VkStructureType,
	mod.StdVideoDecodeVP9PictureInfo
)
ffi.metatype(
	mod.VkVideoDecodeVP9PictureInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeVP9PictureInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pStdPictureInfo,
				t.referenceNameSlotIndices,
				t.uncompressedHeaderOffset,
				t.compressedHeaderOffset,
				t.tilesOffset
			)
		end,
	}
)
mod.VkPhysicalDeviceVideoMaintenance1FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ videoMaintenance1;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVideoMaintenance1FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVideoMaintenance1FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.videoMaintenance1)
		end,
	}
)
mod.VkVideoInlineQueryInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ queryPool;
	uint32_t firstQuery;
	uint32_t queryCount;
}]],
	mod.VkStructureType,
	mod.VkQueryPool
)
ffi.metatype(
	mod.VkVideoInlineQueryInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoInlineQueryInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.queryPool, t.firstQuery, t.queryCount)
		end,
	}
)
mod.VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVertexAttributeDivisorProperties)
mod.VkVertexInputBindingDivisorDescriptionKHR = ffi.typeof([[$ ]], mod.VkVertexInputBindingDivisorDescription)
mod.VkPipelineVertexInputDivisorStateCreateInfoKHR = ffi.typeof([[$ ]], mod.VkPipelineVertexInputDivisorStateCreateInfo)
mod.VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVertexAttributeDivisorFeatures)
mod.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ unifiedImageLayouts;
	$ unifiedImageLayoutsVideo;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.unifiedImageLayouts, t.unifiedImageLayoutsVideo)
		end,
	}
)
mod.VkAttachmentFeedbackLoopInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ feedbackLoopEnable;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkAttachmentFeedbackLoopInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkAttachmentFeedbackLoopInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.feedbackLoopEnable)
		end,
	}
)
mod.VkPhysicalDeviceShaderFloatControls2FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderFloatControls2Features)
mod.VkPhysicalDeviceIndexTypeUint8FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceIndexTypeUint8Features)
mod.VkLineRasterizationModeKHR = ffi.typeof([[$ ]], mod.VkLineRasterizationMode)
mod.VkPhysicalDeviceLineRasterizationFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceLineRasterizationFeatures)
mod.VkPhysicalDeviceLineRasterizationPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceLineRasterizationProperties)
mod.VkPipelineRasterizationLineStateCreateInfoKHR = ffi.typeof([[$ ]], mod.VkPipelineRasterizationLineStateCreateInfo)
mod.PFN_vkCmdSetLineStippleKHR = ffi.typeof([[void (*)($ , uint32_t , uint16_t )]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetLineStippleKHR($ , uint32_t , uint16_t );]], mod.VkCommandBuffer)
mod.VkTimeDomainKHR = ffi.typeof([[enum {
	VK_TIME_DOMAIN_DEVICE_KHR = 0,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR = 1,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR = 2,
	VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR = 3,
	VK_TIME_DOMAIN_DEVICE_EXT = VK_TIME_DOMAIN_DEVICE_KHR,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR,
	VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR,
	VK_TIME_DOMAIN_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkCalibratedTimestampInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ timeDomain;
}]],
	mod.VkStructureType,
	mod.VkTimeDomainKHR
)
ffi.metatype(
	mod.VkCalibratedTimestampInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkCalibratedTimestampInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.timeDomain)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkTimeDomainKHR
)
mod.PFN_vkGetCalibratedTimestampsKHR = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*, uint64_t*, uint64_t*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCalibratedTimestampInfoKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceCalibrateableTimeDomainsKHR($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkTimeDomainKHR
)
ffi.cdef(
	[[$  vkGetCalibratedTimestampsKHR($ , uint32_t , const $*, uint64_t*, uint64_t*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCalibratedTimestampInfoKHR
)
mod.VkPhysicalDeviceShaderExpectAssumeFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderExpectAssumeFeatures)
mod.VkPhysicalDeviceMaintenance6FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance6Features)
mod.VkPhysicalDeviceMaintenance6PropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance6Properties)
mod.VkBindMemoryStatusKHR = ffi.typeof([[$ ]], mod.VkBindMemoryStatus)
mod.VkBindDescriptorSetsInfoKHR = ffi.typeof([[$ ]], mod.VkBindDescriptorSetsInfo)
mod.VkPushConstantsInfoKHR = ffi.typeof([[$ ]], mod.VkPushConstantsInfo)
mod.VkPushDescriptorSetInfoKHR = ffi.typeof([[$ ]], mod.VkPushDescriptorSetInfo)
mod.VkPushDescriptorSetWithTemplateInfoKHR = ffi.typeof([[$ ]], mod.VkPushDescriptorSetWithTemplateInfo)
mod.VkSetDescriptorBufferOffsetsInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stageFlags;
	$ layout;
	uint32_t firstSet;
	uint32_t setCount;
	const uint32_t* pBufferIndices;
	const $* pOffsets;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags,
	mod.VkPipelineLayout,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkSetDescriptorBufferOffsetsInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkSetDescriptorBufferOffsetsInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.stageFlags,
				t.layout,
				t.firstSet,
				t.setCount,
				t.pBufferIndices,
				t.pOffsets
			)
		end,
	}
)
mod.VkBindDescriptorBufferEmbeddedSamplersInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stageFlags;
	$ layout;
	uint32_t set;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags,
	mod.VkPipelineLayout
)
ffi.metatype(
	mod.VkBindDescriptorBufferEmbeddedSamplersInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkBindDescriptorBufferEmbeddedSamplersInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stageFlags, t.layout, t.set)
		end,
	}
)
mod.PFN_vkCmdBindDescriptorSets2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkBindDescriptorSetsInfo)
mod.PFN_vkCmdPushConstants2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPushConstantsInfo)
mod.PFN_vkCmdPushDescriptorSet2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPushDescriptorSetInfo)
mod.PFN_vkCmdPushDescriptorSetWithTemplate2KHR = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkPushDescriptorSetWithTemplateInfo
)
mod.PFN_vkCmdSetDescriptorBufferOffsets2EXT = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkSetDescriptorBufferOffsetsInfoEXT
)
mod.PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkBindDescriptorBufferEmbeddedSamplersInfoEXT
)
ffi.cdef(
	[[void  vkCmdBindDescriptorSets2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBindDescriptorSetsInfo
)
ffi.cdef(
	[[void  vkCmdPushConstants2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkPushConstantsInfo
)
ffi.cdef(
	[[void  vkCmdPushDescriptorSet2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkPushDescriptorSetInfo
)
ffi.cdef(
	[[void  vkCmdPushDescriptorSetWithTemplate2KHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkPushDescriptorSetWithTemplateInfo
)
ffi.cdef(
	[[void  vkCmdSetDescriptorBufferOffsets2EXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkSetDescriptorBufferOffsetsInfoEXT
)
ffi.cdef(
	[[void  vkCmdBindDescriptorBufferEmbeddedSamplers2EXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBindDescriptorBufferEmbeddedSamplersInfoEXT
)
mod.VkAddressCopyFlagBitsKHR = ffi.typeof([[enum {
	VK_ADDRESS_COPY_DEVICE_LOCAL_BIT_KHR = 0x00000001,
	VK_ADDRESS_COPY_SPARSE_BIT_KHR = 0x00000002,
	VK_ADDRESS_COPY_PROTECTED_BIT_KHR = 0x00000004,
	VK_ADDRESS_COPY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAddressCopyFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkStridedDeviceAddressRangeKHR = ffi.typeof(
	[[struct {
	$ address;
	$ size;
	$ stride;
}]],
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkStridedDeviceAddressRangeKHR,
	{
		__tostring = function(s)
			return ("struct VkStridedDeviceAddressRangeKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.address, t.size, t.stride)
		end,
	}
)
mod.VkCopyMemoryIndirectCommandKHR = ffi.typeof(
	[[struct {
	$ srcAddress;
	$ dstAddress;
	$ size;
}]],
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkCopyMemoryIndirectCommandKHR,
	{
		__tostring = function(s)
			return ("struct VkCopyMemoryIndirectCommandKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.srcAddress, t.dstAddress, t.size)
		end,
	}
)
mod.VkCopyMemoryIndirectInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcCopyFlags;
	$ dstCopyFlags;
	uint32_t copyCount;
	$ copyAddressRange;
}]],
	mod.VkStructureType,
	mod.VkAddressCopyFlagsKHR,
	mod.VkAddressCopyFlagsKHR,
	mod.VkStridedDeviceAddressRangeKHR
)
ffi.metatype(
	mod.VkCopyMemoryIndirectInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkCopyMemoryIndirectInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcCopyFlags,
				t.dstCopyFlags,
				t.copyCount,
				t.copyAddressRange
			)
		end,
	}
)
mod.VkCopyMemoryToImageIndirectCommandKHR = ffi.typeof(
	[[struct {
	$ srcAddress;
	uint32_t bufferRowLength;
	uint32_t bufferImageHeight;
	$ imageSubresource;
	$ imageOffset;
	$ imageExtent;
}]],
	mod.VkDeviceAddress,
	mod.VkImageSubresourceLayers,
	mod.VkOffset3D,
	mod.VkExtent3D
)
ffi.metatype(
	mod.VkCopyMemoryToImageIndirectCommandKHR,
	{
		__tostring = function(s)
			return ("struct VkCopyMemoryToImageIndirectCommandKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.srcAddress,
				t.bufferRowLength,
				t.bufferImageHeight,
				t.imageSubresource,
				t.imageOffset,
				t.imageExtent
			)
		end,
	}
)
mod.VkCopyMemoryToImageIndirectInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcCopyFlags;
	uint32_t copyCount;
	$ copyAddressRange;
	$ dstImage;
	$ dstImageLayout;
	const $* pImageSubresources;
}]],
	mod.VkStructureType,
	mod.VkAddressCopyFlagsKHR,
	mod.VkStridedDeviceAddressRangeKHR,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageSubresourceLayers
)
ffi.metatype(
	mod.VkCopyMemoryToImageIndirectInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkCopyMemoryToImageIndirectInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcCopyFlags,
				t.copyCount,
				t.copyAddressRange,
				t.dstImage,
				t.dstImageLayout,
				t.pImageSubresources
			)
		end,
	}
)
mod.VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ indirectMemoryCopy;
	$ indirectMemoryToImageCopy;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.indirectMemoryCopy, t.indirectMemoryToImageCopy)
		end,
	}
)
mod.VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ supportedQueues;
}]],
	mod.VkStructureType,
	mod.VkQueueFlags
)
ffi.metatype(
	mod.VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.supportedQueues)
		end,
	}
)
mod.PFN_vkCmdCopyMemoryIndirectKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyMemoryIndirectInfoKHR)
mod.PFN_vkCmdCopyMemoryToImageIndirectKHR = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkCopyMemoryToImageIndirectInfoKHR
)
ffi.cdef(
	[[void  vkCmdCopyMemoryIndirectKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyMemoryIndirectInfoKHR
)
ffi.cdef(
	[[void  vkCmdCopyMemoryToImageIndirectKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyMemoryToImageIndirectInfoKHR
)
mod.VkVideoEncodeIntraRefreshModeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR = 0,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeIntraRefreshModeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeIntraRefreshCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ intraRefreshModes;
	uint32_t maxIntraRefreshCycleDuration;
	uint32_t maxIntraRefreshActiveReferencePictures;
	$ partitionIndependentIntraRefreshRegions;
	$ nonRectangularIntraRefreshRegions;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeIntraRefreshModeFlagsKHR,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeIntraRefreshCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeIntraRefreshCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.intraRefreshModes,
				t.maxIntraRefreshCycleDuration,
				t.maxIntraRefreshActiveReferencePictures,
				t.partitionIndependentIntraRefreshRegions,
				t.nonRectangularIntraRefreshRegions
			)
		end,
	}
)
mod.VkVideoEncodeSessionIntraRefreshCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ intraRefreshMode;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeIntraRefreshModeFlagBitsKHR
)
ffi.metatype(
	mod.VkVideoEncodeSessionIntraRefreshCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeSessionIntraRefreshCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.intraRefreshMode)
		end,
	}
)
mod.VkVideoEncodeIntraRefreshInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t intraRefreshCycleDuration;
	uint32_t intraRefreshIndex;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkVideoEncodeIntraRefreshInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeIntraRefreshInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.intraRefreshCycleDuration, t.intraRefreshIndex)
		end,
	}
)
mod.VkVideoReferenceIntraRefreshInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t dirtyIntraRefreshRegions;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkVideoReferenceIntraRefreshInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoReferenceIntraRefreshInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dirtyIntraRefreshRegions)
		end,
	}
)
mod.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ videoEncodeIntraRefresh;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.videoEncodeIntraRefresh)
		end,
	}
)
mod.VkVideoEncodeQuantizationMapCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maxQuantizationMapExtent;
}]],
	mod.VkStructureType,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkVideoEncodeQuantizationMapCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeQuantizationMapCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxQuantizationMapExtent)
		end,
	}
)
mod.VkVideoFormatQuantizationMapPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ quantizationMapTexelSize;
}]],
	mod.VkStructureType,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkVideoFormatQuantizationMapPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoFormatQuantizationMapPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.quantizationMapTexelSize)
		end,
	}
)
mod.VkVideoEncodeQuantizationMapInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ quantizationMap;
	$ quantizationMapExtent;
}]],
	mod.VkStructureType,
	mod.VkImageView,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkVideoEncodeQuantizationMapInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeQuantizationMapInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.quantizationMap, t.quantizationMapExtent)
		end,
	}
)
mod.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ quantizationMapTexelSize;
}]],
	mod.VkStructureType,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR,
	{
		__tostring = function(s)
			return (
				"struct VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.quantizationMapTexelSize)
		end,
	}
)
mod.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ videoEncodeQuantizationMap;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.videoEncodeQuantizationMap)
		end,
	}
)
mod.VkVideoEncodeH264QuantizationMapCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	int32_t minQpDelta;
	int32_t maxQpDelta;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkVideoEncodeH264QuantizationMapCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH264QuantizationMapCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.minQpDelta, t.maxQpDelta)
		end,
	}
)
mod.VkVideoEncodeH265QuantizationMapCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	int32_t minQpDelta;
	int32_t maxQpDelta;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkVideoEncodeH265QuantizationMapCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeH265QuantizationMapCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.minQpDelta, t.maxQpDelta)
		end,
	}
)
mod.VkVideoFormatH265QuantizationMapPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ compatibleCtbSizes;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeH265CtbSizeFlagsKHR
)
ffi.metatype(
	mod.VkVideoFormatH265QuantizationMapPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoFormatH265QuantizationMapPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.compatibleCtbSizes)
		end,
	}
)
mod.VkVideoEncodeAV1QuantizationMapCapabilitiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	int32_t minQIndexDelta;
	int32_t maxQIndexDelta;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkVideoEncodeAV1QuantizationMapCapabilitiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeAV1QuantizationMapCapabilitiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.minQIndexDelta, t.maxQIndexDelta)
		end,
	}
)
mod.VkVideoFormatAV1QuantizationMapPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ compatibleSuperblockSizes;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeAV1SuperblockSizeFlagsKHR
)
ffi.metatype(
	mod.VkVideoFormatAV1QuantizationMapPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoFormatAV1QuantizationMapPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.compatibleSuperblockSizes)
		end,
	}
)
mod.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderRelaxedExtendedInstruction;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderRelaxedExtendedInstruction)
		end,
	}
)
mod.VkPhysicalDeviceLayeredApiKHR = ffi.typeof([[enum {
	VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR = 0,
	VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR = 1,
	VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR = 2,
	VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR = 3,
	VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR = 4,
	VK_PHYSICAL_DEVICE_LAYERED_API_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceMaintenance7FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maintenance7;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance7FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance7FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maintenance7)
		end,
	}
)
mod.VkPhysicalDeviceMaintenance7PropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ robustFragmentShadingRateAttachmentAccess;
	$ separateDepthStencilAttachmentAccess;
	uint32_t maxDescriptorSetTotalUniformBuffersDynamic;
	uint32_t maxDescriptorSetTotalStorageBuffersDynamic;
	uint32_t maxDescriptorSetTotalBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindTotalBuffersDynamic;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance7PropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance7PropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.robustFragmentShadingRateAttachmentAccess,
				t.separateDepthStencilAttachmentAccess,
				t.maxDescriptorSetTotalUniformBuffersDynamic,
				t.maxDescriptorSetTotalStorageBuffersDynamic,
				t.maxDescriptorSetTotalBuffersDynamic,
				t.maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic,
				t.maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic,
				t.maxDescriptorSetUpdateAfterBindTotalBuffersDynamic
			)
		end,
	}
)
mod.VkPhysicalDeviceLayeredApiPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t vendorID;
	uint32_t deviceID;
	$ layeredAPI;
	char deviceName[256U];
}]],
	mod.VkStructureType,
	mod.VkPhysicalDeviceLayeredApiKHR
)
ffi.metatype(
	mod.VkPhysicalDeviceLayeredApiPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceLayeredApiPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.vendorID, t.deviceID, t.layeredAPI, t.deviceName)
		end,
	}
)
mod.VkPhysicalDeviceLayeredApiPropertiesListKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t layeredApiCount;
	$* pLayeredApis;
}]],
	mod.VkStructureType,
	mod.VkPhysicalDeviceLayeredApiPropertiesKHR
)
ffi.metatype(
	mod.VkPhysicalDeviceLayeredApiPropertiesListKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceLayeredApiPropertiesListKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.layeredApiCount, t.pLayeredApis)
		end,
	}
)
mod.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ properties;
}]],
	mod.VkStructureType,
	mod.VkPhysicalDeviceProperties2
)
ffi.metatype(
	mod.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceLayeredApiVulkanPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.properties)
		end,
	}
)
mod.VkAccessFlags3KHR = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkAccessFlagBits3KHR = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_ACCESS_3_NONE_KHR = 0ULL
mod.VkMemoryBarrierAccessFlags3KHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcAccessMask3;
	$ dstAccessMask3;
}]],
	mod.VkStructureType,
	mod.VkAccessFlags3KHR,
	mod.VkAccessFlags3KHR
)
ffi.metatype(
	mod.VkMemoryBarrierAccessFlags3KHR,
	{
		__tostring = function(s)
			return ("struct VkMemoryBarrierAccessFlags3KHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.srcAccessMask3, t.dstAccessMask3)
		end,
	}
)
mod.VkPhysicalDeviceMaintenance8FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maintenance8;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance8FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance8FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maintenance8)
		end,
	}
)
mod.VkDefaultVertexAttributeValueKHR = ffi.typeof([[enum {
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR = 0,
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR = 1,
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceMaintenance9FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maintenance9;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance9FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance9FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maintenance9)
		end,
	}
)
mod.VkPhysicalDeviceMaintenance9PropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ image2DViewOf3DSparse;
	$ defaultVertexAttributeValue;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkDefaultVertexAttributeValueKHR
)
ffi.metatype(
	mod.VkPhysicalDeviceMaintenance9PropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMaintenance9PropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.image2DViewOf3DSparse, t.defaultVertexAttributeValue)
		end,
	}
)
mod.VkQueueFamilyOwnershipTransferPropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t optimalImageTransferToQueueFamilies;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkQueueFamilyOwnershipTransferPropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkQueueFamilyOwnershipTransferPropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.optimalImageTransferToQueueFamilies)
		end,
	}
)
mod.VkPhysicalDeviceVideoMaintenance2FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ videoMaintenance2;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVideoMaintenance2FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVideoMaintenance2FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.videoMaintenance2)
		end,
	}
)
mod.VkVideoDecodeH264InlineSessionParametersInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdSPS;
	const $* pStdPPS;
}]],
	mod.VkStructureType,
	mod.StdVideoH264SequenceParameterSet,
	mod.StdVideoH264PictureParameterSet
)
ffi.metatype(
	mod.VkVideoDecodeH264InlineSessionParametersInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH264InlineSessionParametersInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pStdSPS, t.pStdPPS)
		end,
	}
)
mod.VkVideoDecodeH265InlineSessionParametersInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdVPS;
	const $* pStdSPS;
	const $* pStdPPS;
}]],
	mod.VkStructureType,
	mod.StdVideoH265VideoParameterSet,
	mod.StdVideoH265SequenceParameterSet,
	mod.StdVideoH265PictureParameterSet
)
ffi.metatype(
	mod.VkVideoDecodeH265InlineSessionParametersInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeH265InlineSessionParametersInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pStdVPS, t.pStdSPS, t.pStdPPS)
		end,
	}
)
mod.VkVideoDecodeAV1InlineSessionParametersInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pStdSequenceHeader;
}]],
	mod.VkStructureType,
	mod.StdVideoAV1SequenceHeader
)
ffi.metatype(
	mod.VkVideoDecodeAV1InlineSessionParametersInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkVideoDecodeAV1InlineSessionParametersInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pStdSequenceHeader)
		end,
	}
)
mod.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ depthClampZeroOne;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDepthClampZeroOneFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.depthClampZeroOne)
		end,
	}
)
mod.VkPhysicalDeviceRobustness2FeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ robustBufferAccess2;
	$ robustImageAccess2;
	$ nullDescriptor;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRobustness2FeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRobustness2FeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.robustBufferAccess2,
				t.robustImageAccess2,
				t.nullDescriptor
			)
		end,
	}
)
mod.VkPhysicalDeviceRobustness2PropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ robustStorageBufferAccessSizeAlignment;
	$ robustUniformBufferAccessSizeAlignment;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkPhysicalDeviceRobustness2PropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRobustness2PropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.robustStorageBufferAccessSizeAlignment,
				t.robustUniformBufferAccessSizeAlignment
			)
		end,
	}
)
mod.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentModeFifoLatestReady;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentModeFifoLatestReady)
		end,
	}
)
mod.VkDebugReportCallbackEXT = ffi.typeof([[void*]])
mod.VkDebugReportObjectTypeEXT = ffi.typeof([[enum {
	VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
	VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
	VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
	VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
	VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
	VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
	VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
	VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
	VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
	VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
	VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT = 1000307000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT = 1000307001,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
	VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDebugReportFlagBitsEXT = ffi.typeof([[enum {
	VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
	VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
	VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
	VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
	VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
	VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDebugReportFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.PFN_vkDebugReportCallbackEXT = ffi.typeof(
	[[$ (*)($ , $ , uint64_t , size_t , int32_t , const char*, const char*, void*)]],
	mod.VkBool32,
	mod.VkDebugReportFlagsEXT,
	mod.VkDebugReportObjectTypeEXT
)
mod.VkDebugReportCallbackCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ pfnCallback;
	void* pUserData;
}]],
	mod.VkStructureType,
	mod.VkDebugReportFlagsEXT,
	mod.PFN_vkDebugReportCallbackEXT
)
ffi.metatype(
	mod.VkDebugReportCallbackCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDebugReportCallbackCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.pfnCallback, t.pUserData)
		end,
	}
)
mod.PFN_vkCreateDebugReportCallbackEXT = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkDebugReportCallbackCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkDebugReportCallbackEXT
)
mod.PFN_vkDestroyDebugReportCallbackEXT = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkInstance,
	mod.VkDebugReportCallbackEXT,
	mod.VkAllocationCallbacks
)
mod.PFN_vkDebugReportMessageEXT = ffi.typeof(
	[[void (*)($ , $ , $ , uint64_t , size_t , int32_t , const char*, const char*)]],
	mod.VkInstance,
	mod.VkDebugReportFlagsEXT,
	mod.VkDebugReportObjectTypeEXT
)
ffi.cdef(
	[[$  vkCreateDebugReportCallbackEXT($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkDebugReportCallbackCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkDebugReportCallbackEXT
)
ffi.cdef(
	[[void  vkDestroyDebugReportCallbackEXT($ , $ , const $*);]],
	mod.VkInstance,
	mod.VkDebugReportCallbackEXT,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkDebugReportMessageEXT($ , $ , $ , uint64_t , size_t , int32_t , const char*, const char*);]],
	mod.VkInstance,
	mod.VkDebugReportFlagsEXT,
	mod.VkDebugReportObjectTypeEXT
)
mod.VkRasterizationOrderAMD = ffi.typeof([[enum {
	VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
	VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
	VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkPipelineRasterizationStateRasterizationOrderAMD = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ rasterizationOrder;
}]],
	mod.VkStructureType,
	mod.VkRasterizationOrderAMD
)
ffi.metatype(
	mod.VkPipelineRasterizationStateRasterizationOrderAMD,
	{
		__tostring = function(s)
			return ("struct VkPipelineRasterizationStateRasterizationOrderAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.rasterizationOrder)
		end,
	}
)
mod.VkDebugMarkerObjectNameInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ objectType;
	uint64_t object;
	const char* pObjectName;
}]],
	mod.VkStructureType,
	mod.VkDebugReportObjectTypeEXT
)
ffi.metatype(
	mod.VkDebugMarkerObjectNameInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDebugMarkerObjectNameInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.objectType, t.object, t.pObjectName)
		end,
	}
)
mod.VkDebugMarkerObjectTagInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ objectType;
	uint64_t object;
	uint64_t tagName;
	size_t tagSize;
	const void* pTag;
}]],
	mod.VkStructureType,
	mod.VkDebugReportObjectTypeEXT
)
ffi.metatype(
	mod.VkDebugMarkerObjectTagInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDebugMarkerObjectTagInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.objectType, t.object, t.tagName, t.tagSize, t.pTag)
		end,
	}
)
mod.VkDebugMarkerMarkerInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const char* pMarkerName;
	float color[4];
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDebugMarkerMarkerInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDebugMarkerMarkerInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pMarkerName, t.color)
		end,
	}
)
mod.PFN_vkDebugMarkerSetObjectTagEXT = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDebugMarkerObjectTagInfoEXT
)
mod.PFN_vkDebugMarkerSetObjectNameEXT = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDebugMarkerObjectNameInfoEXT
)
mod.PFN_vkCmdDebugMarkerBeginEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDebugMarkerMarkerInfoEXT)
mod.PFN_vkCmdDebugMarkerEndEXT = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDebugMarkerInsertEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDebugMarkerMarkerInfoEXT)
ffi.cdef(
	[[$  vkDebugMarkerSetObjectTagEXT($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDebugMarkerObjectTagInfoEXT
)
ffi.cdef(
	[[$  vkDebugMarkerSetObjectNameEXT($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDebugMarkerObjectNameInfoEXT
)
ffi.cdef(
	[[void  vkCmdDebugMarkerBeginEXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDebugMarkerMarkerInfoEXT
)
ffi.cdef([[void  vkCmdDebugMarkerEndEXT($ );]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdDebugMarkerInsertEXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDebugMarkerMarkerInfoEXT
)
mod.VkDedicatedAllocationImageCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ dedicatedAllocation;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkDedicatedAllocationImageCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkDedicatedAllocationImageCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dedicatedAllocation)
		end,
	}
)
mod.VkDedicatedAllocationBufferCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ dedicatedAllocation;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkDedicatedAllocationBufferCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkDedicatedAllocationBufferCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dedicatedAllocation)
		end,
	}
)
mod.VkDedicatedAllocationMemoryAllocateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ buffer;
}]],
	mod.VkStructureType,
	mod.VkImage,
	mod.VkBuffer
)
ffi.metatype(
	mod.VkDedicatedAllocationMemoryAllocateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkDedicatedAllocationMemoryAllocateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.image, t.buffer)
		end,
	}
)
mod.VkPipelineRasterizationStateStreamCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceTransformFeedbackFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ transformFeedback;
	$ geometryStreams;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceTransformFeedbackFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTransformFeedbackFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.transformFeedback, t.geometryStreams)
		end,
	}
)
mod.VkPhysicalDeviceTransformFeedbackPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxTransformFeedbackStreams;
	uint32_t maxTransformFeedbackBuffers;
	$ maxTransformFeedbackBufferSize;
	uint32_t maxTransformFeedbackStreamDataSize;
	uint32_t maxTransformFeedbackBufferDataSize;
	uint32_t maxTransformFeedbackBufferDataStride;
	$ transformFeedbackQueries;
	$ transformFeedbackStreamsLinesTriangles;
	$ transformFeedbackRasterizationStreamSelect;
	$ transformFeedbackDraw;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceTransformFeedbackPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTransformFeedbackPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxTransformFeedbackStreams,
				t.maxTransformFeedbackBuffers,
				t.maxTransformFeedbackBufferSize,
				t.maxTransformFeedbackStreamDataSize,
				t.maxTransformFeedbackBufferDataSize,
				t.maxTransformFeedbackBufferDataStride,
				t.transformFeedbackQueries,
				t.transformFeedbackStreamsLinesTriangles,
				t.transformFeedbackRasterizationStreamSelect,
				t.transformFeedbackDraw
			)
		end,
	}
)
mod.VkPipelineRasterizationStateStreamCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t rasterizationStream;
}]],
	mod.VkStructureType,
	mod.VkPipelineRasterizationStateStreamCreateFlagsEXT
)
ffi.metatype(
	mod.VkPipelineRasterizationStateStreamCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelineRasterizationStateStreamCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.rasterizationStream)
		end,
	}
)
mod.PFN_vkCmdBindTransformFeedbackBuffersEXT = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*, const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
mod.PFN_vkCmdBeginTransformFeedbackEXT = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdEndTransformFeedbackEXT = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdBeginQueryIndexedEXT = ffi.typeof(
	[[void (*)($ , $ , uint32_t , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkQueryPool,
	mod.VkQueryControlFlags
)
mod.PFN_vkCmdEndQueryIndexedEXT = ffi.typeof([[void (*)($ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkQueryPool)
mod.PFN_vkCmdDrawIndirectByteCountEXT = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdBindTransformFeedbackBuffersEXT($ , uint32_t , uint32_t , const $*, const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdBeginTransformFeedbackEXT($ , uint32_t , uint32_t , const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdEndTransformFeedbackEXT($ , uint32_t , uint32_t , const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdBeginQueryIndexedEXT($ , $ , uint32_t , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkQueryPool,
	mod.VkQueryControlFlags
)
ffi.cdef(
	[[void  vkCmdEndQueryIndexedEXT($ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkQueryPool
)
ffi.cdef(
	[[void  vkCmdDrawIndirectByteCountEXT($ , uint32_t , uint32_t , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.VkCuModuleNVX = ffi.typeof([[void*]])
mod.VkCuFunctionNVX = ffi.typeof([[void*]])
mod.VkCuModuleCreateInfoNVX = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	size_t dataSize;
	const void* pData;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkCuModuleCreateInfoNVX,
	{
		__tostring = function(s)
			return ("struct VkCuModuleCreateInfoNVX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dataSize, t.pData)
		end,
	}
)
mod.VkCuModuleTexturingModeCreateInfoNVX = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ use64bitTexturing;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkCuModuleTexturingModeCreateInfoNVX,
	{
		__tostring = function(s)
			return ("struct VkCuModuleTexturingModeCreateInfoNVX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.use64bitTexturing)
		end,
	}
)
mod.VkCuFunctionCreateInfoNVX = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ module;
	const char* pName;
}]],
	mod.VkStructureType,
	mod.VkCuModuleNVX
)
ffi.metatype(
	mod.VkCuFunctionCreateInfoNVX,
	{
		__tostring = function(s)
			return ("struct VkCuFunctionCreateInfoNVX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.module, t.pName)
		end,
	}
)
mod.VkCuLaunchInfoNVX = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ function;
	uint32_t gridDimX;
	uint32_t gridDimY;
	uint32_t gridDimZ;
	uint32_t blockDimX;
	uint32_t blockDimY;
	uint32_t blockDimZ;
	uint32_t sharedMemBytes;
	size_t paramCount;
	const void** const pParams;
	size_t extraCount;
	const void** const pExtras;
}]],
	mod.VkStructureType,
	mod.VkCuFunctionNVX
)
ffi.metatype(
	mod.VkCuLaunchInfoNVX,
	{
		__tostring = function(s)
			return ("struct VkCuLaunchInfoNVX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t["function"],
				t.gridDimX,
				t.gridDimY,
				t.gridDimZ,
				t.blockDimX,
				t.blockDimY,
				t.blockDimZ,
				t.sharedMemBytes,
				t.paramCount,
				t.pParams,
				t.extraCount,
				t.pExtras
			)
		end,
	}
)
mod.PFN_vkCreateCuModuleNVX = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCuModuleCreateInfoNVX,
	mod.VkAllocationCallbacks,
	mod.VkCuModuleNVX
)
mod.PFN_vkCreateCuFunctionNVX = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCuFunctionCreateInfoNVX,
	mod.VkAllocationCallbacks,
	mod.VkCuFunctionNVX
)
mod.PFN_vkDestroyCuModuleNVX = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkCuModuleNVX,
	mod.VkAllocationCallbacks
)
mod.PFN_vkDestroyCuFunctionNVX = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkCuFunctionNVX,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCmdCuLaunchKernelNVX = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCuLaunchInfoNVX)
ffi.cdef(
	[[$  vkCreateCuModuleNVX($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCuModuleCreateInfoNVX,
	mod.VkAllocationCallbacks,
	mod.VkCuModuleNVX
)
ffi.cdef(
	[[$  vkCreateCuFunctionNVX($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCuFunctionCreateInfoNVX,
	mod.VkAllocationCallbacks,
	mod.VkCuFunctionNVX
)
ffi.cdef(
	[[void  vkDestroyCuModuleNVX($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkCuModuleNVX,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkDestroyCuFunctionNVX($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkCuFunctionNVX,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkCmdCuLaunchKernelNVX($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCuLaunchInfoNVX
)
mod.VkImageViewHandleInfoNVX = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ imageView;
	$ descriptorType;
	$ sampler;
}]],
	mod.VkStructureType,
	mod.VkImageView,
	mod.VkDescriptorType,
	mod.VkSampler
)
ffi.metatype(
	mod.VkImageViewHandleInfoNVX,
	{
		__tostring = function(s)
			return ("struct VkImageViewHandleInfoNVX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageView, t.descriptorType, t.sampler)
		end,
	}
)
mod.VkImageViewAddressPropertiesNVX = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ deviceAddress;
	$ size;
}]],
	mod.VkStructureType,
	mod.VkDeviceAddress,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkImageViewAddressPropertiesNVX,
	{
		__tostring = function(s)
			return ("struct VkImageViewAddressPropertiesNVX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.deviceAddress, t.size)
		end,
	}
)
mod.PFN_vkGetImageViewHandleNVX = ffi.typeof([[uint32_t (*)($ , const $*)]], mod.VkDevice, mod.VkImageViewHandleInfoNVX)
mod.PFN_vkGetImageViewHandle64NVX = ffi.typeof([[uint64_t (*)($ , const $*)]], mod.VkDevice, mod.VkImageViewHandleInfoNVX)
mod.PFN_vkGetImageViewAddressNVX = ffi.typeof(
	[[$ (*)($ , $ , $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImageView,
	mod.VkImageViewAddressPropertiesNVX
)
ffi.cdef(
	[[uint32_t  vkGetImageViewHandleNVX($ , const $*);]],
	mod.VkDevice,
	mod.VkImageViewHandleInfoNVX
)
ffi.cdef(
	[[uint64_t  vkGetImageViewHandle64NVX($ , const $*);]],
	mod.VkDevice,
	mod.VkImageViewHandleInfoNVX
)
ffi.cdef(
	[[$  vkGetImageViewAddressNVX($ , $ , $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImageView,
	mod.VkImageViewAddressPropertiesNVX
)
mod.PFN_vkCmdDrawIndirectCountAMD = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdDrawIndexedIndirectCountAMD = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdDrawIndirectCountAMD($ , $ , $ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdDrawIndexedIndirectCountAMD($ , $ , $ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.VkTextureLODGatherFormatPropertiesAMD = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ supportsTextureGatherLODBiasAMD;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkTextureLODGatherFormatPropertiesAMD,
	{
		__tostring = function(s)
			return ("struct VkTextureLODGatherFormatPropertiesAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.supportsTextureGatherLODBiasAMD)
		end,
	}
)
mod.VkShaderInfoTypeAMD = ffi.typeof([[enum {
	VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
	VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
	VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
	VK_SHADER_INFO_TYPE_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkShaderResourceUsageAMD = ffi.typeof([[struct {
	uint32_t numUsedVgprs;
	uint32_t numUsedSgprs;
	uint32_t ldsSizePerLocalWorkGroup;
	size_t ldsUsageSizeInBytes;
	size_t scratchMemUsageInBytes;
}]])
ffi.metatype(
	mod.VkShaderResourceUsageAMD,
	{
		__tostring = function(s)
			return ("struct VkShaderResourceUsageAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.numUsedVgprs,
				t.numUsedSgprs,
				t.ldsSizePerLocalWorkGroup,
				t.ldsUsageSizeInBytes,
				t.scratchMemUsageInBytes
			)
		end,
	}
)
mod.VkShaderStatisticsInfoAMD = ffi.typeof(
	[[struct {
	$ shaderStageMask;
	$ resourceUsage;
	uint32_t numPhysicalVgprs;
	uint32_t numPhysicalSgprs;
	uint32_t numAvailableVgprs;
	uint32_t numAvailableSgprs;
	uint32_t computeWorkGroupSize[3];
}]],
	mod.VkShaderStageFlags,
	mod.VkShaderResourceUsageAMD
)
ffi.metatype(
	mod.VkShaderStatisticsInfoAMD,
	{
		__tostring = function(s)
			return ("struct VkShaderStatisticsInfoAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.shaderStageMask,
				t.resourceUsage,
				t.numPhysicalVgprs,
				t.numPhysicalSgprs,
				t.numAvailableVgprs,
				t.numAvailableSgprs,
				t.computeWorkGroupSize
			)
		end,
	}
)
mod.PFN_vkGetShaderInfoAMD = ffi.typeof(
	[[$ (*)($ , $ , $ , $ , size_t*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipeline,
	mod.VkShaderStageFlagBits,
	mod.VkShaderInfoTypeAMD
)
ffi.cdef(
	[[$  vkGetShaderInfoAMD($ , $ , $ , $ , size_t*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipeline,
	mod.VkShaderStageFlagBits,
	mod.VkShaderInfoTypeAMD
)
mod.VkPhysicalDeviceCornerSampledImageFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ cornerSampledImage;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCornerSampledImageFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCornerSampledImageFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.cornerSampledImage)
		end,
	}
)
mod.VkExternalMemoryHandleTypeFlagBitsNV = ffi.typeof([[enum {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkExternalMemoryHandleTypeFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalMemoryFeatureFlagBitsNV = ffi.typeof([[enum {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
	VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkExternalMemoryFeatureFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalImageFormatPropertiesNV = ffi.typeof(
	[[struct {
	$ imageFormatProperties;
	$ externalMemoryFeatures;
	$ exportFromImportedHandleTypes;
	$ compatibleHandleTypes;
}]],
	mod.VkImageFormatProperties,
	mod.VkExternalMemoryFeatureFlagsNV,
	mod.VkExternalMemoryHandleTypeFlagsNV,
	mod.VkExternalMemoryHandleTypeFlagsNV
)
ffi.metatype(
	mod.VkExternalImageFormatPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkExternalImageFormatPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.imageFormatProperties,
				t.externalMemoryFeatures,
				t.exportFromImportedHandleTypes,
				t.compatibleHandleTypes
			)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = ffi.typeof(
	[[$ (*)($ , $ , $ , $ , $ , $ , $ , $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkImageType,
	mod.VkImageTiling,
	mod.VkImageUsageFlags,
	mod.VkImageCreateFlags,
	mod.VkExternalMemoryHandleTypeFlagsNV,
	mod.VkExternalImageFormatPropertiesNV
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceExternalImageFormatPropertiesNV($ , $ , $ , $ , $ , $ , $ , $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkFormat,
	mod.VkImageType,
	mod.VkImageTiling,
	mod.VkImageUsageFlags,
	mod.VkImageCreateFlags,
	mod.VkExternalMemoryHandleTypeFlagsNV,
	mod.VkExternalImageFormatPropertiesNV
)
mod.VkExternalMemoryImageCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryHandleTypeFlagsNV
)
ffi.metatype(
	mod.VkExternalMemoryImageCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkExternalMemoryImageCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleTypes)
		end,
	}
)
mod.VkExportMemoryAllocateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryHandleTypeFlagsNV
)
ffi.metatype(
	mod.VkExportMemoryAllocateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkExportMemoryAllocateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleTypes)
		end,
	}
)
mod.VkValidationCheckEXT = ffi.typeof([[enum {
	VK_VALIDATION_CHECK_ALL_EXT = 0,
	VK_VALIDATION_CHECK_SHADERS_EXT = 1,
	VK_VALIDATION_CHECK_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkValidationFlagsEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t disabledValidationCheckCount;
	const $* pDisabledValidationChecks;
}]],
	mod.VkStructureType,
	mod.VkValidationCheckEXT
)
ffi.metatype(
	mod.VkValidationFlagsEXT,
	{
		__tostring = function(s)
			return ("struct VkValidationFlagsEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.disabledValidationCheckCount,
				t.pDisabledValidationChecks
			)
		end,
	}
)
mod.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceTextureCompressionASTCHDRFeatures)
mod.VkImageViewASTCDecodeModeEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ decodeMode;
}]],
	mod.VkStructureType,
	mod.VkFormat
)
ffi.metatype(
	mod.VkImageViewASTCDecodeModeEXT,
	{
		__tostring = function(s)
			return ("struct VkImageViewASTCDecodeModeEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.decodeMode)
		end,
	}
)
mod.VkPhysicalDeviceASTCDecodeFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ decodeModeSharedExponent;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceASTCDecodeFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceASTCDecodeFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.decodeModeSharedExponent)
		end,
	}
)
mod.VkPipelineRobustnessBufferBehaviorEXT = ffi.typeof([[$ ]], mod.VkPipelineRobustnessBufferBehavior)
mod.VkPipelineRobustnessImageBehaviorEXT = ffi.typeof([[$ ]], mod.VkPipelineRobustnessImageBehavior)
mod.VkPhysicalDevicePipelineRobustnessFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePipelineRobustnessFeatures)
mod.VkPhysicalDevicePipelineRobustnessPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePipelineRobustnessProperties)
mod.VkPipelineRobustnessCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineRobustnessCreateInfo)
mod.VkConditionalRenderingFlagBitsEXT = ffi.typeof([[enum {
	VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 0x00000001,
	VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkConditionalRenderingFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkConditionalRenderingBeginInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ buffer;
	$ offset;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkConditionalRenderingFlagsEXT
)
ffi.metatype(
	mod.VkConditionalRenderingBeginInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkConditionalRenderingBeginInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.buffer, t.offset, t.flags)
		end,
	}
)
mod.VkPhysicalDeviceConditionalRenderingFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ conditionalRendering;
	$ inheritedConditionalRendering;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceConditionalRenderingFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceConditionalRenderingFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.conditionalRendering, t.inheritedConditionalRendering)
		end,
	}
)
mod.VkCommandBufferInheritanceConditionalRenderingInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ conditionalRenderingEnable;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkCommandBufferInheritanceConditionalRenderingInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkCommandBufferInheritanceConditionalRenderingInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.conditionalRenderingEnable)
		end,
	}
)
mod.PFN_vkCmdBeginConditionalRenderingEXT = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkConditionalRenderingBeginInfoEXT
)
mod.PFN_vkCmdEndConditionalRenderingEXT = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdBeginConditionalRenderingEXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkConditionalRenderingBeginInfoEXT
)
ffi.cdef([[void  vkCmdEndConditionalRenderingEXT($ );]], mod.VkCommandBuffer)
mod.VkViewportWScalingNV = ffi.typeof([[struct {
	float xcoeff;
	float ycoeff;
}]])
ffi.metatype(
	mod.VkViewportWScalingNV,
	{
		__tostring = function(s)
			return ("struct VkViewportWScalingNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.xcoeff, t.ycoeff)
		end,
	}
)
mod.VkPipelineViewportWScalingStateCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ viewportWScalingEnable;
	uint32_t viewportCount;
	const $* pViewportWScalings;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkViewportWScalingNV
)
ffi.metatype(
	mod.VkPipelineViewportWScalingStateCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkPipelineViewportWScalingStateCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.viewportWScalingEnable,
				t.viewportCount,
				t.pViewportWScalings
			)
		end,
	}
)
mod.PFN_vkCmdSetViewportWScalingNV = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkViewportWScalingNV
)
ffi.cdef(
	[[void  vkCmdSetViewportWScalingNV($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkViewportWScalingNV
)
mod.PFN_vkReleaseDisplayEXT = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR)
ffi.cdef(
	[[$  vkReleaseDisplayEXT($ , $ );]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR
)
mod.VkSurfaceCounterFlagBitsEXT = ffi.typeof([[enum {
	VK_SURFACE_COUNTER_VBLANK_BIT_EXT = 0x00000001,
	VK_SURFACE_COUNTER_VBLANK_EXT = VK_SURFACE_COUNTER_VBLANK_BIT_EXT,
	VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkSurfaceCounterFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSurfaceCapabilities2EXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t minImageCount;
	uint32_t maxImageCount;
	$ currentExtent;
	$ minImageExtent;
	$ maxImageExtent;
	uint32_t maxImageArrayLayers;
	$ supportedTransforms;
	$ currentTransform;
	$ supportedCompositeAlpha;
	$ supportedUsageFlags;
	$ supportedSurfaceCounters;
}]],
	mod.VkStructureType,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkSurfaceTransformFlagsKHR,
	mod.VkSurfaceTransformFlagBitsKHR,
	mod.VkCompositeAlphaFlagsKHR,
	mod.VkImageUsageFlags,
	mod.VkSurfaceCounterFlagsEXT
)
ffi.metatype(
	mod.VkSurfaceCapabilities2EXT,
	{
		__tostring = function(s)
			return ("struct VkSurfaceCapabilities2EXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.minImageCount,
				t.maxImageCount,
				t.currentExtent,
				t.minImageExtent,
				t.maxImageExtent,
				t.maxImageArrayLayers,
				t.supportedTransforms,
				t.currentTransform,
				t.supportedCompositeAlpha,
				t.supportedUsageFlags,
				t.supportedSurfaceCounters
			)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT = ffi.typeof(
	[[$ (*)($ , $ , $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkSurfaceCapabilities2EXT
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceSurfaceCapabilities2EXT($ , $ , $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkSurfaceKHR,
	mod.VkSurfaceCapabilities2EXT
)
mod.VkDisplayPowerStateEXT = ffi.typeof([[enum {
	VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
	VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
	VK_DISPLAY_POWER_STATE_ON_EXT = 2,
	VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDeviceEventTypeEXT = ffi.typeof([[enum {
	VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
	VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDisplayEventTypeEXT = ffi.typeof([[enum {
	VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
	VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDisplayPowerInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ powerState;
}]],
	mod.VkStructureType,
	mod.VkDisplayPowerStateEXT
)
ffi.metatype(
	mod.VkDisplayPowerInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDisplayPowerInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.powerState)
		end,
	}
)
mod.VkDeviceEventInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ deviceEvent;
}]],
	mod.VkStructureType,
	mod.VkDeviceEventTypeEXT
)
ffi.metatype(
	mod.VkDeviceEventInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDeviceEventInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.deviceEvent)
		end,
	}
)
mod.VkDisplayEventInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ displayEvent;
}]],
	mod.VkStructureType,
	mod.VkDisplayEventTypeEXT
)
ffi.metatype(
	mod.VkDisplayEventInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDisplayEventInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.displayEvent)
		end,
	}
)
mod.VkSwapchainCounterCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ surfaceCounters;
}]],
	mod.VkStructureType,
	mod.VkSurfaceCounterFlagsEXT
)
ffi.metatype(
	mod.VkSwapchainCounterCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkSwapchainCounterCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.surfaceCounters)
		end,
	}
)
mod.PFN_vkDisplayPowerControlEXT = ffi.typeof(
	[[$ (*)($ , $ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDisplayKHR,
	mod.VkDisplayPowerInfoEXT
)
mod.PFN_vkRegisterDeviceEventEXT = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeviceEventInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkFence
)
mod.PFN_vkRegisterDisplayEventEXT = ffi.typeof(
	[[$ (*)($ , $ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDisplayKHR,
	mod.VkDisplayEventInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkFence
)
mod.PFN_vkGetSwapchainCounterEXT = ffi.typeof(
	[[$ (*)($ , $ , $ , uint64_t*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkSurfaceCounterFlagBitsEXT
)
ffi.cdef(
	[[$  vkDisplayPowerControlEXT($ , $ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDisplayKHR,
	mod.VkDisplayPowerInfoEXT
)
ffi.cdef(
	[[$  vkRegisterDeviceEventEXT($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeviceEventInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkFence
)
ffi.cdef(
	[[$  vkRegisterDisplayEventEXT($ , $ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDisplayKHR,
	mod.VkDisplayEventInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkFence
)
ffi.cdef(
	[[$  vkGetSwapchainCounterEXT($ , $ , $ , uint64_t*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkSurfaceCounterFlagBitsEXT
)
mod.VkRefreshCycleDurationGOOGLE = ffi.typeof([[struct {
	uint64_t refreshDuration;
}]])
ffi.metatype(
	mod.VkRefreshCycleDurationGOOGLE,
	{
		__tostring = function(s)
			return ("struct VkRefreshCycleDurationGOOGLE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.refreshDuration)
		end,
	}
)
mod.VkPastPresentationTimingGOOGLE = ffi.typeof([[struct {
	uint32_t presentID;
	uint64_t desiredPresentTime;
	uint64_t actualPresentTime;
	uint64_t earliestPresentTime;
	uint64_t presentMargin;
}]])
ffi.metatype(
	mod.VkPastPresentationTimingGOOGLE,
	{
		__tostring = function(s)
			return ("struct VkPastPresentationTimingGOOGLE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.presentID,
				t.desiredPresentTime,
				t.actualPresentTime,
				t.earliestPresentTime,
				t.presentMargin
			)
		end,
	}
)
mod.VkPresentTimeGOOGLE = ffi.typeof([[struct {
	uint32_t presentID;
	uint64_t desiredPresentTime;
}]])
ffi.metatype(
	mod.VkPresentTimeGOOGLE,
	{
		__tostring = function(s)
			return ("struct VkPresentTimeGOOGLE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.presentID, t.desiredPresentTime)
		end,
	}
)
mod.VkPresentTimesInfoGOOGLE = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const $* pTimes;
}]],
	mod.VkStructureType,
	mod.VkPresentTimeGOOGLE
)
ffi.metatype(
	mod.VkPresentTimesInfoGOOGLE,
	{
		__tostring = function(s)
			return ("struct VkPresentTimesInfoGOOGLE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.swapchainCount, t.pTimes)
		end,
	}
)
mod.PFN_vkGetRefreshCycleDurationGOOGLE = ffi.typeof(
	[[$ (*)($ , $ , $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkRefreshCycleDurationGOOGLE
)
mod.PFN_vkGetPastPresentationTimingGOOGLE = ffi.typeof(
	[[$ (*)($ , $ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkPastPresentationTimingGOOGLE
)
ffi.cdef(
	[[$  vkGetRefreshCycleDurationGOOGLE($ , $ , $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkRefreshCycleDurationGOOGLE
)
ffi.cdef(
	[[$  vkGetPastPresentationTimingGOOGLE($ , $ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkPastPresentationTimingGOOGLE
)
mod.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ perViewPositionAllComponents;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.perViewPositionAllComponents)
		end,
	}
)
mod.VkMultiviewPerViewAttributesInfoNVX = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ perViewAttributes;
	$ perViewAttributesPositionXOnly;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkMultiviewPerViewAttributesInfoNVX,
	{
		__tostring = function(s)
			return ("struct VkMultiviewPerViewAttributesInfoNVX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.perViewAttributes, t.perViewAttributesPositionXOnly)
		end,
	}
)
mod.VkViewportCoordinateSwizzleNV = ffi.typeof([[enum {
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
	VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPipelineViewportSwizzleStateCreateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkViewportSwizzleNV = ffi.typeof(
	[[struct {
	$ x;
	$ y;
	$ z;
	$ w;
}]],
	mod.VkViewportCoordinateSwizzleNV,
	mod.VkViewportCoordinateSwizzleNV,
	mod.VkViewportCoordinateSwizzleNV,
	mod.VkViewportCoordinateSwizzleNV
)
ffi.metatype(
	mod.VkViewportSwizzleNV,
	{
		__tostring = function(s)
			return ("struct VkViewportSwizzleNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.x, t.y, t.z, t.w)
		end,
	}
)
mod.VkPipelineViewportSwizzleStateCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t viewportCount;
	const $* pViewportSwizzles;
}]],
	mod.VkStructureType,
	mod.VkPipelineViewportSwizzleStateCreateFlagsNV,
	mod.VkViewportSwizzleNV
)
ffi.metatype(
	mod.VkPipelineViewportSwizzleStateCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkPipelineViewportSwizzleStateCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.viewportCount, t.pViewportSwizzles)
		end,
	}
)
mod.VkDiscardRectangleModeEXT = ffi.typeof([[enum {
	VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
	VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
	VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPipelineDiscardRectangleStateCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDiscardRectanglePropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxDiscardRectangles;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceDiscardRectanglePropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDiscardRectanglePropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxDiscardRectangles)
		end,
	}
)
mod.VkPipelineDiscardRectangleStateCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ discardRectangleMode;
	uint32_t discardRectangleCount;
	const $* pDiscardRectangles;
}]],
	mod.VkStructureType,
	mod.VkPipelineDiscardRectangleStateCreateFlagsEXT,
	mod.VkDiscardRectangleModeEXT,
	mod.VkRect2D
)
ffi.metatype(
	mod.VkPipelineDiscardRectangleStateCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelineDiscardRectangleStateCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.discardRectangleMode,
				t.discardRectangleCount,
				t.pDiscardRectangles
			)
		end,
	}
)
mod.PFN_vkCmdSetDiscardRectangleEXT = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkRect2D
)
mod.PFN_vkCmdSetDiscardRectangleEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDiscardRectangleModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkDiscardRectangleModeEXT)
ffi.cdef(
	[[void  vkCmdSetDiscardRectangleEXT($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRect2D
)
ffi.cdef(
	[[void  vkCmdSetDiscardRectangleEnableEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetDiscardRectangleModeEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkDiscardRectangleModeEXT
)
mod.VkConservativeRasterizationModeEXT = ffi.typeof([[enum {
	VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
	VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
	VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
	VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPipelineRasterizationConservativeStateCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceConservativeRasterizationPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	float primitiveOverestimationSize;
	float maxExtraPrimitiveOverestimationSize;
	float extraPrimitiveOverestimationSizeGranularity;
	$ primitiveUnderestimation;
	$ conservativePointAndLineRasterization;
	$ degenerateTrianglesRasterized;
	$ degenerateLinesRasterized;
	$ fullyCoveredFragmentShaderInputVariable;
	$ conservativeRasterizationPostDepthCoverage;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.primitiveOverestimationSize,
				t.maxExtraPrimitiveOverestimationSize,
				t.extraPrimitiveOverestimationSizeGranularity,
				t.primitiveUnderestimation,
				t.conservativePointAndLineRasterization,
				t.degenerateTrianglesRasterized,
				t.degenerateLinesRasterized,
				t.fullyCoveredFragmentShaderInputVariable,
				t.conservativeRasterizationPostDepthCoverage
			)
		end,
	}
)
mod.VkPipelineRasterizationConservativeStateCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ conservativeRasterizationMode;
	float extraPrimitiveOverestimationSize;
}]],
	mod.VkStructureType,
	mod.VkPipelineRasterizationConservativeStateCreateFlagsEXT,
	mod.VkConservativeRasterizationModeEXT
)
ffi.metatype(
	mod.VkPipelineRasterizationConservativeStateCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelineRasterizationConservativeStateCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.conservativeRasterizationMode,
				t.extraPrimitiveOverestimationSize
			)
		end,
	}
)
mod.VkPipelineRasterizationDepthClipStateCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDepthClipEnableFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ depthClipEnable;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDepthClipEnableFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDepthClipEnableFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.depthClipEnable)
		end,
	}
)
mod.VkPipelineRasterizationDepthClipStateCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ depthClipEnable;
}]],
	mod.VkStructureType,
	mod.VkPipelineRasterizationDepthClipStateCreateFlagsEXT,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPipelineRasterizationDepthClipStateCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelineRasterizationDepthClipStateCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.depthClipEnable)
		end,
	}
)
mod.VkXYColorEXT = ffi.typeof([[struct {
	float x;
	float y;
}]])
ffi.metatype(
	mod.VkXYColorEXT,
	{
		__tostring = function(s)
			return ("struct VkXYColorEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.x, t.y)
		end,
	}
)
mod.VkHdrMetadataEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ displayPrimaryRed;
	$ displayPrimaryGreen;
	$ displayPrimaryBlue;
	$ whitePoint;
	float maxLuminance;
	float minLuminance;
	float maxContentLightLevel;
	float maxFrameAverageLightLevel;
}]],
	mod.VkStructureType,
	mod.VkXYColorEXT,
	mod.VkXYColorEXT,
	mod.VkXYColorEXT,
	mod.VkXYColorEXT
)
ffi.metatype(
	mod.VkHdrMetadataEXT,
	{
		__tostring = function(s)
			return ("struct VkHdrMetadataEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.displayPrimaryRed,
				t.displayPrimaryGreen,
				t.displayPrimaryBlue,
				t.whitePoint,
				t.maxLuminance,
				t.minLuminance,
				t.maxContentLightLevel,
				t.maxFrameAverageLightLevel
			)
		end,
	}
)
mod.PFN_vkSetHdrMetadataEXT = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, const $*)]],
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkHdrMetadataEXT
)
ffi.cdef(
	[[void  vkSetHdrMetadataEXT($ , uint32_t , const $*, const $*);]],
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkHdrMetadataEXT
)
mod.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ relaxedLineRasterization;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.relaxedLineRasterization)
		end,
	}
)
mod.VkDebugUtilsMessengerEXT = ffi.typeof([[void*]])
mod.VkDebugUtilsMessengerCallbackDataFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDebugUtilsMessageSeverityFlagBitsEXT = ffi.typeof([[enum {
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x00000001,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 0x00000010,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x00000100,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 0x00001000,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDebugUtilsMessageTypeFlagBitsEXT = ffi.typeof([[enum {
	VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 0x00000001,
	VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 0x00000002,
	VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x00000004,
	VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = 0x00000008,
	VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDebugUtilsMessageTypeFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDebugUtilsMessageSeverityFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDebugUtilsMessengerCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDebugUtilsLabelEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const char* pLabelName;
	float color[4];
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDebugUtilsLabelEXT,
	{
		__tostring = function(s)
			return ("struct VkDebugUtilsLabelEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pLabelName, t.color)
		end,
	}
)
mod.VkDebugUtilsObjectNameInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ objectType;
	uint64_t objectHandle;
	const char* pObjectName;
}]],
	mod.VkStructureType,
	mod.VkObjectType
)
ffi.metatype(
	mod.VkDebugUtilsObjectNameInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDebugUtilsObjectNameInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.objectType, t.objectHandle, t.pObjectName)
		end,
	}
)
mod.VkDebugUtilsMessengerCallbackDataEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const char* pMessageIdName;
	int32_t messageIdNumber;
	const char* pMessage;
	uint32_t queueLabelCount;
	const $* pQueueLabels;
	uint32_t cmdBufLabelCount;
	const $* pCmdBufLabels;
	uint32_t objectCount;
	const $* pObjects;
}]],
	mod.VkStructureType,
	mod.VkDebugUtilsMessengerCallbackDataFlagsEXT,
	mod.VkDebugUtilsLabelEXT,
	mod.VkDebugUtilsLabelEXT,
	mod.VkDebugUtilsObjectNameInfoEXT
)
ffi.metatype(
	mod.VkDebugUtilsMessengerCallbackDataEXT,
	{
		__tostring = function(s)
			return ("struct VkDebugUtilsMessengerCallbackDataEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.pMessageIdName,
				t.messageIdNumber,
				t.pMessage,
				t.queueLabelCount,
				t.pQueueLabels,
				t.cmdBufLabelCount,
				t.pCmdBufLabels,
				t.objectCount,
				t.pObjects
			)
		end,
	}
)
mod.PFN_vkDebugUtilsMessengerCallbackEXT = ffi.typeof(
	[[$ (*)($ , $ , const $*, void*)]],
	mod.VkBool32,
	mod.VkDebugUtilsMessageSeverityFlagBitsEXT,
	mod.VkDebugUtilsMessageTypeFlagsEXT,
	mod.VkDebugUtilsMessengerCallbackDataEXT
)
mod.VkDebugUtilsMessengerCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ messageSeverity;
	$ messageType;
	$ pfnUserCallback;
	void* pUserData;
}]],
	mod.VkStructureType,
	mod.VkDebugUtilsMessengerCreateFlagsEXT,
	mod.VkDebugUtilsMessageSeverityFlagsEXT,
	mod.VkDebugUtilsMessageTypeFlagsEXT,
	mod.PFN_vkDebugUtilsMessengerCallbackEXT
)
ffi.metatype(
	mod.VkDebugUtilsMessengerCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDebugUtilsMessengerCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.messageSeverity,
				t.messageType,
				t.pfnUserCallback,
				t.pUserData
			)
		end,
	}
)
mod.VkDebugUtilsObjectTagInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ objectType;
	uint64_t objectHandle;
	uint64_t tagName;
	size_t tagSize;
	const void* pTag;
}]],
	mod.VkStructureType,
	mod.VkObjectType
)
ffi.metatype(
	mod.VkDebugUtilsObjectTagInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDebugUtilsObjectTagInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.objectType,
				t.objectHandle,
				t.tagName,
				t.tagSize,
				t.pTag
			)
		end,
	}
)
mod.PFN_vkSetDebugUtilsObjectNameEXT = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDebugUtilsObjectNameInfoEXT
)
mod.PFN_vkSetDebugUtilsObjectTagEXT = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDebugUtilsObjectTagInfoEXT
)
mod.PFN_vkQueueBeginDebugUtilsLabelEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkQueue, mod.VkDebugUtilsLabelEXT)
mod.PFN_vkQueueEndDebugUtilsLabelEXT = ffi.typeof([[void (*)($ )]], mod.VkQueue)
mod.PFN_vkQueueInsertDebugUtilsLabelEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkQueue, mod.VkDebugUtilsLabelEXT)
mod.PFN_vkCmdBeginDebugUtilsLabelEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDebugUtilsLabelEXT)
mod.PFN_vkCmdEndDebugUtilsLabelEXT = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
mod.PFN_vkCmdInsertDebugUtilsLabelEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDebugUtilsLabelEXT)
mod.PFN_vkCreateDebugUtilsMessengerEXT = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkDebugUtilsMessengerCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkDebugUtilsMessengerEXT
)
mod.PFN_vkDestroyDebugUtilsMessengerEXT = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkInstance,
	mod.VkDebugUtilsMessengerEXT,
	mod.VkAllocationCallbacks
)
mod.PFN_vkSubmitDebugUtilsMessageEXT = ffi.typeof(
	[[void (*)($ , $ , $ , const $*)]],
	mod.VkInstance,
	mod.VkDebugUtilsMessageSeverityFlagBitsEXT,
	mod.VkDebugUtilsMessageTypeFlagsEXT,
	mod.VkDebugUtilsMessengerCallbackDataEXT
)
ffi.cdef(
	[[$  vkSetDebugUtilsObjectNameEXT($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDebugUtilsObjectNameInfoEXT
)
ffi.cdef(
	[[$  vkSetDebugUtilsObjectTagEXT($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDebugUtilsObjectTagInfoEXT
)
ffi.cdef(
	[[void  vkQueueBeginDebugUtilsLabelEXT($ , const $*);]],
	mod.VkQueue,
	mod.VkDebugUtilsLabelEXT
)
ffi.cdef([[void  vkQueueEndDebugUtilsLabelEXT($ );]], mod.VkQueue)
ffi.cdef(
	[[void  vkQueueInsertDebugUtilsLabelEXT($ , const $*);]],
	mod.VkQueue,
	mod.VkDebugUtilsLabelEXT
)
ffi.cdef(
	[[void  vkCmdBeginDebugUtilsLabelEXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDebugUtilsLabelEXT
)
ffi.cdef([[void  vkCmdEndDebugUtilsLabelEXT($ );]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdInsertDebugUtilsLabelEXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDebugUtilsLabelEXT
)
ffi.cdef(
	[[$  vkCreateDebugUtilsMessengerEXT($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkDebugUtilsMessengerCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkDebugUtilsMessengerEXT
)
ffi.cdef(
	[[void  vkDestroyDebugUtilsMessengerEXT($ , $ , const $*);]],
	mod.VkInstance,
	mod.VkDebugUtilsMessengerEXT,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkSubmitDebugUtilsMessageEXT($ , $ , $ , const $*);]],
	mod.VkInstance,
	mod.VkDebugUtilsMessageSeverityFlagBitsEXT,
	mod.VkDebugUtilsMessageTypeFlagsEXT,
	mod.VkDebugUtilsMessengerCallbackDataEXT
)
mod.VkSamplerReductionModeEXT = ffi.typeof([[$ ]], mod.VkSamplerReductionMode)
mod.VkSamplerReductionModeCreateInfoEXT = ffi.typeof([[$ ]], mod.VkSamplerReductionModeCreateInfo)
mod.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSamplerFilterMinmaxProperties)
mod.VkAttachmentSampleCountInfoAMD = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t colorAttachmentCount;
	const $* pColorAttachmentSamples;
	$ depthStencilAttachmentSamples;
}]],
	mod.VkStructureType,
	mod.VkSampleCountFlagBits,
	mod.VkSampleCountFlagBits
)
ffi.metatype(
	mod.VkAttachmentSampleCountInfoAMD,
	{
		__tostring = function(s)
			return ("struct VkAttachmentSampleCountInfoAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.colorAttachmentCount,
				t.pColorAttachmentSamples,
				t.depthStencilAttachmentSamples
			)
		end,
	}
)
mod.VkPhysicalDeviceInlineUniformBlockFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceInlineUniformBlockFeatures)
mod.VkPhysicalDeviceInlineUniformBlockPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceInlineUniformBlockProperties)
mod.VkWriteDescriptorSetInlineUniformBlockEXT = ffi.typeof([[$ ]], mod.VkWriteDescriptorSetInlineUniformBlock)
mod.VkDescriptorPoolInlineUniformBlockCreateInfoEXT = ffi.typeof([[$ ]], mod.VkDescriptorPoolInlineUniformBlockCreateInfo)
mod.VkSampleLocationEXT = ffi.typeof([[struct {
	float x;
	float y;
}]])
ffi.metatype(
	mod.VkSampleLocationEXT,
	{
		__tostring = function(s)
			return ("struct VkSampleLocationEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.x, t.y)
		end,
	}
)
mod.VkSampleLocationsInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ sampleLocationsPerPixel;
	$ sampleLocationGridSize;
	uint32_t sampleLocationsCount;
	const $* pSampleLocations;
}]],
	mod.VkStructureType,
	mod.VkSampleCountFlagBits,
	mod.VkExtent2D,
	mod.VkSampleLocationEXT
)
ffi.metatype(
	mod.VkSampleLocationsInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkSampleLocationsInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.sampleLocationsPerPixel,
				t.sampleLocationGridSize,
				t.sampleLocationsCount,
				t.pSampleLocations
			)
		end,
	}
)
mod.VkAttachmentSampleLocationsEXT = ffi.typeof(
	[[struct {
	uint32_t attachmentIndex;
	$ sampleLocationsInfo;
}]],
	mod.VkSampleLocationsInfoEXT
)
ffi.metatype(
	mod.VkAttachmentSampleLocationsEXT,
	{
		__tostring = function(s)
			return ("struct VkAttachmentSampleLocationsEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.attachmentIndex, t.sampleLocationsInfo)
		end,
	}
)
mod.VkSubpassSampleLocationsEXT = ffi.typeof(
	[[struct {
	uint32_t subpassIndex;
	$ sampleLocationsInfo;
}]],
	mod.VkSampleLocationsInfoEXT
)
ffi.metatype(
	mod.VkSubpassSampleLocationsEXT,
	{
		__tostring = function(s)
			return ("struct VkSubpassSampleLocationsEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.subpassIndex, t.sampleLocationsInfo)
		end,
	}
)
mod.VkRenderPassSampleLocationsBeginInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t attachmentInitialSampleLocationsCount;
	const $* pAttachmentInitialSampleLocations;
	uint32_t postSubpassSampleLocationsCount;
	const $* pPostSubpassSampleLocations;
}]],
	mod.VkStructureType,
	mod.VkAttachmentSampleLocationsEXT,
	mod.VkSubpassSampleLocationsEXT
)
ffi.metatype(
	mod.VkRenderPassSampleLocationsBeginInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkRenderPassSampleLocationsBeginInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.attachmentInitialSampleLocationsCount,
				t.pAttachmentInitialSampleLocations,
				t.postSubpassSampleLocationsCount,
				t.pPostSubpassSampleLocations
			)
		end,
	}
)
mod.VkPipelineSampleLocationsStateCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ sampleLocationsEnable;
	$ sampleLocationsInfo;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkSampleLocationsInfoEXT
)
ffi.metatype(
	mod.VkPipelineSampleLocationsStateCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelineSampleLocationsStateCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.sampleLocationsEnable, t.sampleLocationsInfo)
		end,
	}
)
mod.VkPhysicalDeviceSampleLocationsPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ sampleLocationSampleCounts;
	$ maxSampleLocationGridSize;
	float sampleLocationCoordinateRange[2];
	uint32_t sampleLocationSubPixelBits;
	$ variableSampleLocations;
}]],
	mod.VkStructureType,
	mod.VkSampleCountFlags,
	mod.VkExtent2D,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSampleLocationsPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSampleLocationsPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.sampleLocationSampleCounts,
				t.maxSampleLocationGridSize,
				t.sampleLocationCoordinateRange,
				t.sampleLocationSubPixelBits,
				t.variableSampleLocations
			)
		end,
	}
)
mod.VkMultisamplePropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maxSampleLocationGridSize;
}]],
	mod.VkStructureType,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkMultisamplePropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkMultisamplePropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxSampleLocationGridSize)
		end,
	}
)
mod.PFN_vkCmdSetSampleLocationsEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkSampleLocationsInfoEXT)
mod.PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT = ffi.typeof(
	[[void (*)($ , $ , $*)]],
	mod.VkPhysicalDevice,
	mod.VkSampleCountFlagBits,
	mod.VkMultisamplePropertiesEXT
)
ffi.cdef(
	[[void  vkCmdSetSampleLocationsEXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkSampleLocationsInfoEXT
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceMultisamplePropertiesEXT($ , $ , $*);]],
	mod.VkPhysicalDevice,
	mod.VkSampleCountFlagBits,
	mod.VkMultisamplePropertiesEXT
)
mod.VkBlendOverlapEXT = ffi.typeof([[enum {
	VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
	VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
	VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
	VK_BLEND_OVERLAP_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ advancedBlendCoherentOperations;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.advancedBlendCoherentOperations)
		end,
	}
)
mod.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t advancedBlendMaxColorAttachments;
	$ advancedBlendIndependentBlend;
	$ advancedBlendNonPremultipliedSrcColor;
	$ advancedBlendNonPremultipliedDstColor;
	$ advancedBlendCorrelatedOverlap;
	$ advancedBlendAllOperations;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.advancedBlendMaxColorAttachments,
				t.advancedBlendIndependentBlend,
				t.advancedBlendNonPremultipliedSrcColor,
				t.advancedBlendNonPremultipliedDstColor,
				t.advancedBlendCorrelatedOverlap,
				t.advancedBlendAllOperations
			)
		end,
	}
)
mod.VkPipelineColorBlendAdvancedStateCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcPremultiplied;
	$ dstPremultiplied;
	$ blendOverlap;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBlendOverlapEXT
)
ffi.metatype(
	mod.VkPipelineColorBlendAdvancedStateCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelineColorBlendAdvancedStateCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.srcPremultiplied, t.dstPremultiplied, t.blendOverlap)
		end,
	}
)
mod.VkPipelineCoverageToColorStateCreateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCoverageToColorStateCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ coverageToColorEnable;
	uint32_t coverageToColorLocation;
}]],
	mod.VkStructureType,
	mod.VkPipelineCoverageToColorStateCreateFlagsNV,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPipelineCoverageToColorStateCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkPipelineCoverageToColorStateCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.coverageToColorEnable,
				t.coverageToColorLocation
			)
		end,
	}
)
mod.VkCoverageModulationModeNV = ffi.typeof([[enum {
	VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
	VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
	VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
	VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
	VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPipelineCoverageModulationStateCreateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCoverageModulationStateCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ coverageModulationMode;
	$ coverageModulationTableEnable;
	uint32_t coverageModulationTableCount;
	const float* pCoverageModulationTable;
}]],
	mod.VkStructureType,
	mod.VkPipelineCoverageModulationStateCreateFlagsNV,
	mod.VkCoverageModulationModeNV,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPipelineCoverageModulationStateCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkPipelineCoverageModulationStateCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.coverageModulationMode,
				t.coverageModulationTableEnable,
				t.coverageModulationTableCount,
				t.pCoverageModulationTable
			)
		end,
	}
)
mod.VkAttachmentSampleCountInfoNV = ffi.typeof([[$ ]], mod.VkAttachmentSampleCountInfoAMD)
mod.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t shaderSMCount;
	uint32_t shaderWarpsPerSM;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderSMCount, t.shaderWarpsPerSM)
		end,
	}
)
mod.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderSMBuiltins;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderSMBuiltins)
		end,
	}
)
mod.VkDrmFormatModifierPropertiesEXT = ffi.typeof(
	[[struct {
	uint64_t drmFormatModifier;
	uint32_t drmFormatModifierPlaneCount;
	$ drmFormatModifierTilingFeatures;
}]],
	mod.VkFormatFeatureFlags
)
ffi.metatype(
	mod.VkDrmFormatModifierPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkDrmFormatModifierPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.drmFormatModifier,
				t.drmFormatModifierPlaneCount,
				t.drmFormatModifierTilingFeatures
			)
		end,
	}
)
mod.VkDrmFormatModifierPropertiesListEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t drmFormatModifierCount;
	$* pDrmFormatModifierProperties;
}]],
	mod.VkStructureType,
	mod.VkDrmFormatModifierPropertiesEXT
)
ffi.metatype(
	mod.VkDrmFormatModifierPropertiesListEXT,
	{
		__tostring = function(s)
			return ("struct VkDrmFormatModifierPropertiesListEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.drmFormatModifierCount, t.pDrmFormatModifierProperties)
		end,
	}
)
mod.VkPhysicalDeviceImageDrmFormatModifierInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint64_t drmFormatModifier;
	$ sharingMode;
	uint32_t queueFamilyIndexCount;
	const uint32_t* pQueueFamilyIndices;
}]],
	mod.VkStructureType,
	mod.VkSharingMode
)
ffi.metatype(
	mod.VkPhysicalDeviceImageDrmFormatModifierInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.drmFormatModifier,
				t.sharingMode,
				t.queueFamilyIndexCount,
				t.pQueueFamilyIndices
			)
		end,
	}
)
mod.VkImageDrmFormatModifierListCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t drmFormatModifierCount;
	const uint64_t* pDrmFormatModifiers;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkImageDrmFormatModifierListCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImageDrmFormatModifierListCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.drmFormatModifierCount, t.pDrmFormatModifiers)
		end,
	}
)
mod.VkImageDrmFormatModifierExplicitCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint64_t drmFormatModifier;
	uint32_t drmFormatModifierPlaneCount;
	const $* pPlaneLayouts;
}]],
	mod.VkStructureType,
	mod.VkSubresourceLayout
)
ffi.metatype(
	mod.VkImageDrmFormatModifierExplicitCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImageDrmFormatModifierExplicitCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.drmFormatModifier,
				t.drmFormatModifierPlaneCount,
				t.pPlaneLayouts
			)
		end,
	}
)
mod.VkImageDrmFormatModifierPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint64_t drmFormatModifier;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkImageDrmFormatModifierPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkImageDrmFormatModifierPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.drmFormatModifier)
		end,
	}
)
mod.VkDrmFormatModifierProperties2EXT = ffi.typeof(
	[[struct {
	uint64_t drmFormatModifier;
	uint32_t drmFormatModifierPlaneCount;
	$ drmFormatModifierTilingFeatures;
}]],
	mod.VkFormatFeatureFlags2
)
ffi.metatype(
	mod.VkDrmFormatModifierProperties2EXT,
	{
		__tostring = function(s)
			return ("struct VkDrmFormatModifierProperties2EXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.drmFormatModifier,
				t.drmFormatModifierPlaneCount,
				t.drmFormatModifierTilingFeatures
			)
		end,
	}
)
mod.VkDrmFormatModifierPropertiesList2EXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t drmFormatModifierCount;
	$* pDrmFormatModifierProperties;
}]],
	mod.VkStructureType,
	mod.VkDrmFormatModifierProperties2EXT
)
ffi.metatype(
	mod.VkDrmFormatModifierPropertiesList2EXT,
	{
		__tostring = function(s)
			return ("struct VkDrmFormatModifierPropertiesList2EXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.drmFormatModifierCount, t.pDrmFormatModifierProperties)
		end,
	}
)
mod.PFN_vkGetImageDrmFormatModifierPropertiesEXT = ffi.typeof(
	[[$ (*)($ , $ , $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImage,
	mod.VkImageDrmFormatModifierPropertiesEXT
)
ffi.cdef(
	[[$  vkGetImageDrmFormatModifierPropertiesEXT($ , $ , $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImage,
	mod.VkImageDrmFormatModifierPropertiesEXT
)
mod.VkValidationCacheEXT = ffi.typeof([[void*]])
mod.VkValidationCacheHeaderVersionEXT = ffi.typeof([[enum {
	VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
	VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkValidationCacheCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkValidationCacheCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	size_t initialDataSize;
	const void* pInitialData;
}]],
	mod.VkStructureType,
	mod.VkValidationCacheCreateFlagsEXT
)
ffi.metatype(
	mod.VkValidationCacheCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkValidationCacheCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.initialDataSize, t.pInitialData)
		end,
	}
)
mod.VkShaderModuleValidationCacheCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ validationCache;
}]],
	mod.VkStructureType,
	mod.VkValidationCacheEXT
)
ffi.metatype(
	mod.VkShaderModuleValidationCacheCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkShaderModuleValidationCacheCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.validationCache)
		end,
	}
)
mod.PFN_vkCreateValidationCacheEXT = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkValidationCacheCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkValidationCacheEXT
)
mod.PFN_vkDestroyValidationCacheEXT = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkValidationCacheEXT,
	mod.VkAllocationCallbacks
)
mod.PFN_vkMergeValidationCachesEXT = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkValidationCacheEXT,
	mod.VkValidationCacheEXT
)
mod.PFN_vkGetValidationCacheDataEXT = ffi.typeof(
	[[$ (*)($ , $ , size_t*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkValidationCacheEXT
)
ffi.cdef(
	[[$  vkCreateValidationCacheEXT($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkValidationCacheCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkValidationCacheEXT
)
ffi.cdef(
	[[void  vkDestroyValidationCacheEXT($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkValidationCacheEXT,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkMergeValidationCachesEXT($ , $ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkValidationCacheEXT,
	mod.VkValidationCacheEXT
)
ffi.cdef(
	[[$  vkGetValidationCacheDataEXT($ , $ , size_t*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkValidationCacheEXT
)
mod.VkDescriptorBindingFlagBitsEXT = ffi.typeof([[$ ]], mod.VkDescriptorBindingFlagBits)
mod.VkDescriptorBindingFlagsEXT = ffi.typeof([[$ ]], mod.VkDescriptorBindingFlags)
mod.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = ffi.typeof([[$ ]], mod.VkDescriptorSetLayoutBindingFlagsCreateInfo)
mod.VkPhysicalDeviceDescriptorIndexingFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDescriptorIndexingFeatures)
mod.VkPhysicalDeviceDescriptorIndexingPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDescriptorIndexingProperties)
mod.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = ffi.typeof([[$ ]], mod.VkDescriptorSetVariableDescriptorCountAllocateInfo)
mod.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = ffi.typeof([[$ ]], mod.VkDescriptorSetVariableDescriptorCountLayoutSupport)
mod.VkShadingRatePaletteEntryNV = ffi.typeof([[enum {
	VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
	VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
	VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
	VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
	VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
	VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkCoarseSampleOrderTypeNV = ffi.typeof([[enum {
	VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
	VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
	VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
	VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
	VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkShadingRatePaletteNV = ffi.typeof(
	[[struct {
	uint32_t shadingRatePaletteEntryCount;
	const $* pShadingRatePaletteEntries;
}]],
	mod.VkShadingRatePaletteEntryNV
)
ffi.metatype(
	mod.VkShadingRatePaletteNV,
	{
		__tostring = function(s)
			return ("struct VkShadingRatePaletteNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.shadingRatePaletteEntryCount, t.pShadingRatePaletteEntries)
		end,
	}
)
mod.VkPipelineViewportShadingRateImageStateCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ shadingRateImageEnable;
	uint32_t viewportCount;
	const $* pShadingRatePalettes;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkShadingRatePaletteNV
)
ffi.metatype(
	mod.VkPipelineViewportShadingRateImageStateCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkPipelineViewportShadingRateImageStateCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shadingRateImageEnable,
				t.viewportCount,
				t.pShadingRatePalettes
			)
		end,
	}
)
mod.VkPhysicalDeviceShadingRateImageFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shadingRateImage;
	$ shadingRateCoarseSampleOrder;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShadingRateImageFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShadingRateImageFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shadingRateImage, t.shadingRateCoarseSampleOrder)
		end,
	}
)
mod.VkPhysicalDeviceShadingRateImagePropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shadingRateTexelSize;
	uint32_t shadingRatePaletteSize;
	uint32_t shadingRateMaxCoarseSamples;
}]],
	mod.VkStructureType,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkPhysicalDeviceShadingRateImagePropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShadingRateImagePropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shadingRateTexelSize,
				t.shadingRatePaletteSize,
				t.shadingRateMaxCoarseSamples
			)
		end,
	}
)
mod.VkCoarseSampleLocationNV = ffi.typeof([[struct {
	uint32_t pixelX;
	uint32_t pixelY;
	uint32_t sample;
}]])
ffi.metatype(
	mod.VkCoarseSampleLocationNV,
	{
		__tostring = function(s)
			return ("struct VkCoarseSampleLocationNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.pixelX, t.pixelY, t.sample)
		end,
	}
)
mod.VkCoarseSampleOrderCustomNV = ffi.typeof(
	[[struct {
	$ shadingRate;
	uint32_t sampleCount;
	uint32_t sampleLocationCount;
	const $* pSampleLocations;
}]],
	mod.VkShadingRatePaletteEntryNV,
	mod.VkCoarseSampleLocationNV
)
ffi.metatype(
	mod.VkCoarseSampleOrderCustomNV,
	{
		__tostring = function(s)
			return ("struct VkCoarseSampleOrderCustomNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.shadingRate, t.sampleCount, t.sampleLocationCount, t.pSampleLocations)
		end,
	}
)
mod.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ sampleOrderType;
	uint32_t customSampleOrderCount;
	const $* pCustomSampleOrders;
}]],
	mod.VkStructureType,
	mod.VkCoarseSampleOrderTypeNV,
	mod.VkCoarseSampleOrderCustomNV
)
ffi.metatype(
	mod.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.sampleOrderType,
				t.customSampleOrderCount,
				t.pCustomSampleOrders
			)
		end,
	}
)
mod.PFN_vkCmdBindShadingRateImageNV = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkImageView, mod.VkImageLayout)
mod.PFN_vkCmdSetViewportShadingRatePaletteNV = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkShadingRatePaletteNV
)
mod.PFN_vkCmdSetCoarseSampleOrderNV = ffi.typeof(
	[[void (*)($ , $ , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkCoarseSampleOrderTypeNV,
	mod.VkCoarseSampleOrderCustomNV
)
ffi.cdef(
	[[void  vkCmdBindShadingRateImageNV($ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkImageView,
	mod.VkImageLayout
)
ffi.cdef(
	[[void  vkCmdSetViewportShadingRatePaletteNV($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkShadingRatePaletteNV
)
ffi.cdef(
	[[void  vkCmdSetCoarseSampleOrderNV($ , $ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCoarseSampleOrderTypeNV,
	mod.VkCoarseSampleOrderCustomNV
)
mod.VkAccelerationStructureNV = ffi.typeof([[void*]])
mod.VkRayTracingShaderGroupTypeKHR = ffi.typeof([[enum {
	VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkRayTracingShaderGroupTypeNV = ffi.typeof([[$ ]], mod.VkRayTracingShaderGroupTypeKHR)
mod.VkGeometryTypeKHR = ffi.typeof([[enum {
	VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
	VK_GEOMETRY_TYPE_AABBS_KHR = 1,
	VK_GEOMETRY_TYPE_INSTANCES_KHR = 2,
	VK_GEOMETRY_TYPE_SPHERES_NV = 1000429004,
	VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV = 1000429005,
	VK_GEOMETRY_TYPE_TRIANGLES_NV = VK_GEOMETRY_TYPE_TRIANGLES_KHR,
	VK_GEOMETRY_TYPE_AABBS_NV = VK_GEOMETRY_TYPE_AABBS_KHR,
	VK_GEOMETRY_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkGeometryTypeNV = ffi.typeof([[$ ]], mod.VkGeometryTypeKHR)
mod.VkAccelerationStructureTypeKHR = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
	VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
	VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
	VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
	VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
	VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureTypeNV = ffi.typeof([[$ ]], mod.VkAccelerationStructureTypeKHR)
mod.VkCopyAccelerationStructureModeKHR = ffi.typeof([[enum {
	VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV = VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV = VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkCopyAccelerationStructureModeNV = ffi.typeof([[$ ]], mod.VkCopyAccelerationStructureModeKHR)
mod.VkAccelerationStructureMemoryRequirementsTypeNV = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkGeometryFlagBitsKHR = ffi.typeof([[enum {
	VK_GEOMETRY_OPAQUE_BIT_KHR = 0x00000001,
	VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 0x00000002,
	VK_GEOMETRY_OPAQUE_BIT_NV = VK_GEOMETRY_OPAQUE_BIT_KHR,
	VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
	VK_GEOMETRY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkGeometryFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkGeometryFlagsNV = ffi.typeof([[$ ]], mod.VkGeometryFlagsKHR)
mod.VkGeometryFlagBitsNV = ffi.typeof([[$ ]], mod.VkGeometryFlagBitsKHR)
mod.VkGeometryInstanceFlagBitsKHR = ffi.typeof([[enum {
	VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 0x00000001,
	VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 0x00000002,
	VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 0x00000004,
	VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 0x00000008,
	VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT = 0x00000010,
	VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT = 0x00000020,
	VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR = VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR,
	VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR,
	VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR,
	VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV = VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR,
	VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV = VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR,
	VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT = VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT,
	VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT = VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT,
	VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkGeometryInstanceFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkGeometryInstanceFlagsNV = ffi.typeof([[$ ]], mod.VkGeometryInstanceFlagsKHR)
mod.VkGeometryInstanceFlagBitsNV = ffi.typeof([[$ ]], mod.VkGeometryInstanceFlagBitsKHR)
mod.VkBuildAccelerationStructureFlagBitsKHR = ffi.typeof([[enum {
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 0x00000001,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 0x00000002,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 0x00000004,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 0x00000008,
	VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 0x00000010,
	VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = 0x00000020,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT = 0x00000040,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT = 0x00000080,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT = 0x00000100,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR = 0x00000800,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV = 0x00001000,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkBuildAccelerationStructureFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkBuildAccelerationStructureFlagsNV = ffi.typeof([[$ ]], mod.VkBuildAccelerationStructureFlagsKHR)
mod.VkBuildAccelerationStructureFlagBitsNV = ffi.typeof([[$ ]], mod.VkBuildAccelerationStructureFlagBitsKHR)
mod.VkRayTracingShaderGroupCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ type;
	uint32_t generalShader;
	uint32_t closestHitShader;
	uint32_t anyHitShader;
	uint32_t intersectionShader;
}]],
	mod.VkStructureType,
	mod.VkRayTracingShaderGroupTypeKHR
)
ffi.metatype(
	mod.VkRayTracingShaderGroupCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkRayTracingShaderGroupCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.type,
				t.generalShader,
				t.closestHitShader,
				t.anyHitShader,
				t.intersectionShader
			)
		end,
	}
)
mod.VkRayTracingPipelineCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t stageCount;
	const $* pStages;
	uint32_t groupCount;
	const $* pGroups;
	uint32_t maxRecursionDepth;
	$ layout;
	$ basePipelineHandle;
	int32_t basePipelineIndex;
}]],
	mod.VkStructureType,
	mod.VkPipelineCreateFlags,
	mod.VkPipelineShaderStageCreateInfo,
	mod.VkRayTracingShaderGroupCreateInfoNV,
	mod.VkPipelineLayout,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkRayTracingPipelineCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkRayTracingPipelineCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.stageCount,
				t.pStages,
				t.groupCount,
				t.pGroups,
				t.maxRecursionDepth,
				t.layout,
				t.basePipelineHandle,
				t.basePipelineIndex
			)
		end,
	}
)
mod.VkGeometryTrianglesNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ vertexData;
	$ vertexOffset;
	uint32_t vertexCount;
	$ vertexStride;
	$ vertexFormat;
	$ indexData;
	$ indexOffset;
	uint32_t indexCount;
	$ indexType;
	$ transformData;
	$ transformOffset;
}]],
	mod.VkStructureType,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkFormat,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkIndexType,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkGeometryTrianglesNV,
	{
		__tostring = function(s)
			return ("struct VkGeometryTrianglesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.vertexData,
				t.vertexOffset,
				t.vertexCount,
				t.vertexStride,
				t.vertexFormat,
				t.indexData,
				t.indexOffset,
				t.indexCount,
				t.indexType,
				t.transformData,
				t.transformOffset
			)
		end,
	}
)
mod.VkGeometryAABBNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ aabbData;
	uint32_t numAABBs;
	uint32_t stride;
	$ offset;
}]],
	mod.VkStructureType,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkGeometryAABBNV,
	{
		__tostring = function(s)
			return ("struct VkGeometryAABBNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.aabbData, t.numAABBs, t.stride, t.offset)
		end,
	}
)
mod.VkGeometryDataNV = ffi.typeof(
	[[struct {
	$ triangles;
	$ aabbs;
}]],
	mod.VkGeometryTrianglesNV,
	mod.VkGeometryAABBNV
)
ffi.metatype(
	mod.VkGeometryDataNV,
	{
		__tostring = function(s)
			return ("struct VkGeometryDataNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.triangles, t.aabbs)
		end,
	}
)
mod.VkGeometryNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ geometryType;
	$ geometry;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkGeometryTypeKHR,
	mod.VkGeometryDataNV,
	mod.VkGeometryFlagsKHR
)
ffi.metatype(
	mod.VkGeometryNV,
	{
		__tostring = function(s)
			return ("struct VkGeometryNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.geometryType, t.geometry, t.flags)
		end,
	}
)
mod.VkAccelerationStructureInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ flags;
	uint32_t instanceCount;
	uint32_t geometryCount;
	const $* pGeometries;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureTypeNV,
	mod.VkBuildAccelerationStructureFlagsNV,
	mod.VkGeometryNV
)
ffi.metatype(
	mod.VkAccelerationStructureInfoNV,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.type,
				t.flags,
				t.instanceCount,
				t.geometryCount,
				t.pGeometries
			)
		end,
	}
)
mod.VkAccelerationStructureCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ compactedSize;
	$ info;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize,
	mod.VkAccelerationStructureInfoNV
)
ffi.metatype(
	mod.VkAccelerationStructureCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.compactedSize, t.info)
		end,
	}
)
mod.VkBindAccelerationStructureMemoryInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ accelerationStructure;
	$ memory;
	$ memoryOffset;
	uint32_t deviceIndexCount;
	const uint32_t* pDeviceIndices;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureNV,
	mod.VkDeviceMemory,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkBindAccelerationStructureMemoryInfoNV,
	{
		__tostring = function(s)
			return ("struct VkBindAccelerationStructureMemoryInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.accelerationStructure,
				t.memory,
				t.memoryOffset,
				t.deviceIndexCount,
				t.pDeviceIndices
			)
		end,
	}
)
mod.VkWriteDescriptorSetAccelerationStructureNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t accelerationStructureCount;
	const $* pAccelerationStructures;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureNV
)
ffi.metatype(
	mod.VkWriteDescriptorSetAccelerationStructureNV,
	{
		__tostring = function(s)
			return ("struct VkWriteDescriptorSetAccelerationStructureNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.accelerationStructureCount, t.pAccelerationStructures)
		end,
	}
)
mod.VkAccelerationStructureMemoryRequirementsInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ accelerationStructure;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureMemoryRequirementsTypeNV,
	mod.VkAccelerationStructureNV
)
ffi.metatype(
	mod.VkAccelerationStructureMemoryRequirementsInfoNV,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureMemoryRequirementsInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.type, t.accelerationStructure)
		end,
	}
)
mod.VkPhysicalDeviceRayTracingPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t shaderGroupHandleSize;
	uint32_t maxRecursionDepth;
	uint32_t maxShaderGroupStride;
	uint32_t shaderGroupBaseAlignment;
	uint64_t maxGeometryCount;
	uint64_t maxInstanceCount;
	uint64_t maxTriangleCount;
	uint32_t maxDescriptorSetAccelerationStructures;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceRayTracingPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRayTracingPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderGroupHandleSize,
				t.maxRecursionDepth,
				t.maxShaderGroupStride,
				t.shaderGroupBaseAlignment,
				t.maxGeometryCount,
				t.maxInstanceCount,
				t.maxTriangleCount,
				t.maxDescriptorSetAccelerationStructures
			)
		end,
	}
)
mod.VkTransformMatrixKHR = ffi.typeof([[struct {
	float matrix[4][3];
}]])
ffi.metatype(
	mod.VkTransformMatrixKHR,
	{
		__tostring = function(s)
			return ("struct VkTransformMatrixKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.matrix)
		end,
	}
)
mod.VkTransformMatrixNV = ffi.typeof([[$ ]], mod.VkTransformMatrixKHR)
mod.VkAabbPositionsKHR = ffi.typeof([[struct {
	float minX;
	float minY;
	float minZ;
	float maxX;
	float maxY;
	float maxZ;
}]])
ffi.metatype(
	mod.VkAabbPositionsKHR,
	{
		__tostring = function(s)
			return ("struct VkAabbPositionsKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.minX, t.minY, t.minZ, t.maxX, t.maxY, t.maxZ)
		end,
	}
)
mod.VkAabbPositionsNV = ffi.typeof([[$ ]], mod.VkAabbPositionsKHR)
mod.VkAccelerationStructureInstanceKHR = ffi.typeof(
	[[struct {
	$ transform;
	uint32_t instanceCustomIndex;
	uint32_t mask;
	uint32_t instanceShaderBindingTableRecordOffset;
	$ flags;
	uint64_t accelerationStructureReference;
}]],
	mod.VkTransformMatrixKHR,
	mod.VkGeometryInstanceFlagsKHR
)
ffi.metatype(
	mod.VkAccelerationStructureInstanceKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureInstanceKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.transform,
				t.instanceCustomIndex,
				t.mask,
				t.instanceShaderBindingTableRecordOffset,
				t.flags,
				t.accelerationStructureReference
			)
		end,
	}
)
mod.VkAccelerationStructureInstanceNV = ffi.typeof([[$ ]], mod.VkAccelerationStructureInstanceKHR)
mod.PFN_vkCreateAccelerationStructureNV = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAccelerationStructureCreateInfoNV,
	mod.VkAllocationCallbacks,
	mod.VkAccelerationStructureNV
)
mod.PFN_vkDestroyAccelerationStructureNV = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkAccelerationStructureNV,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetAccelerationStructureMemoryRequirementsNV = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkAccelerationStructureMemoryRequirementsInfoNV,
	mod.VkMemoryRequirements2KHR
)
mod.PFN_vkBindAccelerationStructureMemoryNV = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindAccelerationStructureMemoryInfoNV
)
mod.PFN_vkCmdBuildAccelerationStructureNV = ffi.typeof(
	[[void (*)($ , const $*, $ , $ , $ , $ , $ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureInfoNV,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBool32,
	mod.VkAccelerationStructureNV,
	mod.VkAccelerationStructureNV,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdCopyAccelerationStructureNV = ffi.typeof(
	[[void (*)($ , $ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureNV,
	mod.VkAccelerationStructureNV,
	mod.VkCopyAccelerationStructureModeKHR
)
mod.PFN_vkCmdTraceRaysNV = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , $ , $ , $ , $ , $ , $ , $ , uint32_t , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
mod.PFN_vkCreateRayTracingPipelinesNV = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCache,
	mod.VkRayTracingPipelineCreateInfoNV,
	mod.VkAllocationCallbacks,
	mod.VkPipeline
)
mod.PFN_vkGetRayTracingShaderGroupHandlesKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , uint32_t , size_t , void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipeline
)
mod.PFN_vkGetRayTracingShaderGroupHandlesNV = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , uint32_t , size_t , void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipeline
)
mod.PFN_vkGetAccelerationStructureHandleNV = ffi.typeof(
	[[$ (*)($ , $ , size_t , void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAccelerationStructureNV
)
mod.PFN_vkCmdWriteAccelerationStructuresPropertiesNV = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureNV,
	mod.VkQueryType,
	mod.VkQueryPool
)
mod.PFN_vkCompileDeferredNV = ffi.typeof([[$ (*)($ , $ , uint32_t )]], mod.VkResult, mod.VkDevice, mod.VkPipeline)
ffi.cdef(
	[[$  vkCreateAccelerationStructureNV($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAccelerationStructureCreateInfoNV,
	mod.VkAllocationCallbacks,
	mod.VkAccelerationStructureNV
)
ffi.cdef(
	[[void  vkDestroyAccelerationStructureNV($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkAccelerationStructureNV,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkGetAccelerationStructureMemoryRequirementsNV($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkAccelerationStructureMemoryRequirementsInfoNV,
	mod.VkMemoryRequirements2KHR
)
ffi.cdef(
	[[$  vkBindAccelerationStructureMemoryNV($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindAccelerationStructureMemoryInfoNV
)
ffi.cdef(
	[[void  vkCmdBuildAccelerationStructureNV($ , const $*, $ , $ , $ , $ , $ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureInfoNV,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBool32,
	mod.VkAccelerationStructureNV,
	mod.VkAccelerationStructureNV,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdCopyAccelerationStructureNV($ , $ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureNV,
	mod.VkAccelerationStructureNV,
	mod.VkCopyAccelerationStructureModeKHR
)
ffi.cdef(
	[[void  vkCmdTraceRaysNV($ , $ , $ , $ , $ , $ , $ , $ , $ , $ , $ , $ , uint32_t , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.cdef(
	[[$  vkCreateRayTracingPipelinesNV($ , $ , uint32_t , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineCache,
	mod.VkRayTracingPipelineCreateInfoNV,
	mod.VkAllocationCallbacks,
	mod.VkPipeline
)
ffi.cdef(
	[[$  vkGetRayTracingShaderGroupHandlesKHR($ , $ , uint32_t , uint32_t , size_t , void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipeline
)
ffi.cdef(
	[[$  vkGetRayTracingShaderGroupHandlesNV($ , $ , uint32_t , uint32_t , size_t , void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipeline
)
ffi.cdef(
	[[$  vkGetAccelerationStructureHandleNV($ , $ , size_t , void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAccelerationStructureNV
)
ffi.cdef(
	[[void  vkCmdWriteAccelerationStructuresPropertiesNV($ , uint32_t , const $*, $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureNV,
	mod.VkQueryType,
	mod.VkQueryPool
)
ffi.cdef(
	[[$  vkCompileDeferredNV($ , $ , uint32_t );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipeline
)
mod.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ representativeFragmentTest;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.representativeFragmentTest)
		end,
	}
)
mod.VkPipelineRepresentativeFragmentTestStateCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ representativeFragmentTestEnable;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPipelineRepresentativeFragmentTestStateCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.representativeFragmentTestEnable)
		end,
	}
)
mod.VkPhysicalDeviceImageViewImageFormatInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ imageViewType;
}]],
	mod.VkStructureType,
	mod.VkImageViewType
)
ffi.metatype(
	mod.VkPhysicalDeviceImageViewImageFormatInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageViewImageFormatInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageViewType)
		end,
	}
)
mod.VkFilterCubicImageViewImageFormatPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ filterCubic;
	$ filterCubicMinmax;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkFilterCubicImageViewImageFormatPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkFilterCubicImageViewImageFormatPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.filterCubic, t.filterCubicMinmax)
		end,
	}
)
mod.VkQueueGlobalPriorityEXT = ffi.typeof([[$ ]], mod.VkQueueGlobalPriority)
mod.VkDeviceQueueGlobalPriorityCreateInfoEXT = ffi.typeof([[$ ]], mod.VkDeviceQueueGlobalPriorityCreateInfo)
mod.VkImportMemoryHostPointerInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleType;
	void* pHostPointer;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryHandleTypeFlagBits
)
ffi.metatype(
	mod.VkImportMemoryHostPointerInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImportMemoryHostPointerInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleType, t.pHostPointer)
		end,
	}
)
mod.VkMemoryHostPointerPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t memoryTypeBits;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkMemoryHostPointerPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkMemoryHostPointerPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memoryTypeBits)
		end,
	}
)
mod.VkPhysicalDeviceExternalMemoryHostPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ minImportedHostPointerAlignment;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkPhysicalDeviceExternalMemoryHostPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.minImportedHostPointerAlignment)
		end,
	}
)
mod.PFN_vkGetMemoryHostPointerPropertiesEXT = ffi.typeof(
	[[$ (*)($ , $ , const void*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkExternalMemoryHandleTypeFlagBits,
	mod.VkMemoryHostPointerPropertiesEXT
)
ffi.cdef(
	[[$  vkGetMemoryHostPointerPropertiesEXT($ , $ , const void*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkExternalMemoryHandleTypeFlagBits,
	mod.VkMemoryHostPointerPropertiesEXT
)
mod.PFN_vkCmdWriteBufferMarkerAMD = ffi.typeof(
	[[void (*)($ , $ , $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlagBits,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdWriteBufferMarker2AMD = ffi.typeof(
	[[void (*)($ , $ , $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlags2,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdWriteBufferMarkerAMD($ , $ , $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlagBits,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdWriteBufferMarker2AMD($ , $ , $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkPipelineStageFlags2,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.VkPipelineCompilerControlFlagBitsAMD = ffi.typeof([[enum {
	VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkPipelineCompilerControlFlagsAMD = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCompilerControlCreateInfoAMD = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ compilerControlFlags;
}]],
	mod.VkStructureType,
	mod.VkPipelineCompilerControlFlagsAMD
)
ffi.metatype(
	mod.VkPipelineCompilerControlCreateInfoAMD,
	{
		__tostring = function(s)
			return ("struct VkPipelineCompilerControlCreateInfoAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.compilerControlFlags)
		end,
	}
)
mod.VkTimeDomainEXT = ffi.typeof([[$ ]], mod.VkTimeDomainKHR)
mod.VkCalibratedTimestampInfoEXT = ffi.typeof([[$ ]], mod.VkCalibratedTimestampInfoKHR)
mod.PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkTimeDomainKHR
)
mod.PFN_vkGetCalibratedTimestampsEXT = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*, uint64_t*, uint64_t*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCalibratedTimestampInfoKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceCalibrateableTimeDomainsEXT($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkTimeDomainKHR
)
ffi.cdef(
	[[$  vkGetCalibratedTimestampsEXT($ , uint32_t , const $*, uint64_t*, uint64_t*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCalibratedTimestampInfoKHR
)
mod.VkPhysicalDeviceShaderCorePropertiesAMD = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t shaderEngineCount;
	uint32_t shaderArraysPerEngineCount;
	uint32_t computeUnitsPerShaderArray;
	uint32_t simdPerComputeUnit;
	uint32_t wavefrontsPerSimd;
	uint32_t wavefrontSize;
	uint32_t sgprsPerSimd;
	uint32_t minSgprAllocation;
	uint32_t maxSgprAllocation;
	uint32_t sgprAllocationGranularity;
	uint32_t vgprsPerSimd;
	uint32_t minVgprAllocation;
	uint32_t maxVgprAllocation;
	uint32_t vgprAllocationGranularity;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderCorePropertiesAMD,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderCorePropertiesAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderEngineCount,
				t.shaderArraysPerEngineCount,
				t.computeUnitsPerShaderArray,
				t.simdPerComputeUnit,
				t.wavefrontsPerSimd,
				t.wavefrontSize,
				t.sgprsPerSimd,
				t.minSgprAllocation,
				t.maxSgprAllocation,
				t.sgprAllocationGranularity,
				t.vgprsPerSimd,
				t.minVgprAllocation,
				t.maxVgprAllocation,
				t.vgprAllocationGranularity
			)
		end,
	}
)
mod.VkMemoryOverallocationBehaviorAMD = ffi.typeof([[enum {
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkDeviceMemoryOverallocationCreateInfoAMD = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ overallocationBehavior;
}]],
	mod.VkStructureType,
	mod.VkMemoryOverallocationBehaviorAMD
)
ffi.metatype(
	mod.VkDeviceMemoryOverallocationCreateInfoAMD,
	{
		__tostring = function(s)
			return ("struct VkDeviceMemoryOverallocationCreateInfoAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.overallocationBehavior)
		end,
	}
)
mod.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxVertexAttribDivisor;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxVertexAttribDivisor)
		end,
	}
)
mod.VkVertexInputBindingDivisorDescriptionEXT = ffi.typeof([[$ ]], mod.VkVertexInputBindingDivisorDescription)
mod.VkPipelineVertexInputDivisorStateCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineVertexInputDivisorStateCreateInfo)
mod.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVertexAttributeDivisorFeatures)
mod.VkPipelineCreationFeedbackFlagBitsEXT = ffi.typeof([[$ ]], mod.VkPipelineCreationFeedbackFlagBits)
mod.VkPipelineCreationFeedbackFlagsEXT = ffi.typeof([[$ ]], mod.VkPipelineCreationFeedbackFlags)
mod.VkPipelineCreationFeedbackCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineCreationFeedbackCreateInfo)
mod.VkPipelineCreationFeedbackEXT = ffi.typeof([[$ ]], mod.VkPipelineCreationFeedback)
mod.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV = ffi.typeof([[$ ]], mod.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR)
mod.VkPhysicalDeviceMeshShaderFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ taskShader;
	$ meshShader;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMeshShaderFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMeshShaderFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.taskShader, t.meshShader)
		end,
	}
)
mod.VkPhysicalDeviceMeshShaderPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxDrawMeshTasksCount;
	uint32_t maxTaskWorkGroupInvocations;
	uint32_t maxTaskWorkGroupSize[3];
	uint32_t maxTaskTotalMemorySize;
	uint32_t maxTaskOutputCount;
	uint32_t maxMeshWorkGroupInvocations;
	uint32_t maxMeshWorkGroupSize[3];
	uint32_t maxMeshTotalMemorySize;
	uint32_t maxMeshOutputVertices;
	uint32_t maxMeshOutputPrimitives;
	uint32_t maxMeshMultiviewViewCount;
	uint32_t meshOutputPerVertexGranularity;
	uint32_t meshOutputPerPrimitiveGranularity;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceMeshShaderPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMeshShaderPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxDrawMeshTasksCount,
				t.maxTaskWorkGroupInvocations,
				t.maxTaskWorkGroupSize,
				t.maxTaskTotalMemorySize,
				t.maxTaskOutputCount,
				t.maxMeshWorkGroupInvocations,
				t.maxMeshWorkGroupSize,
				t.maxMeshTotalMemorySize,
				t.maxMeshOutputVertices,
				t.maxMeshOutputPrimitives,
				t.maxMeshMultiviewViewCount,
				t.meshOutputPerVertexGranularity,
				t.meshOutputPerPrimitiveGranularity
			)
		end,
	}
)
mod.VkDrawMeshTasksIndirectCommandNV = ffi.typeof([[struct {
	uint32_t taskCount;
	uint32_t firstTask;
}]])
ffi.metatype(
	mod.VkDrawMeshTasksIndirectCommandNV,
	{
		__tostring = function(s)
			return ("struct VkDrawMeshTasksIndirectCommandNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.taskCount, t.firstTask)
		end,
	}
)
mod.PFN_vkCmdDrawMeshTasksNV = ffi.typeof([[void (*)($ , uint32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDrawMeshTasksIndirectNV = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdDrawMeshTasksIndirectCountNV = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef([[void  vkCmdDrawMeshTasksNV($ , uint32_t , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdDrawMeshTasksIndirectNV($ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdDrawMeshTasksIndirectCountNV($ , $ , $ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = ffi.typeof([[$ ]], mod.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR)
mod.VkPhysicalDeviceShaderImageFootprintFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ imageFootprint;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderImageFootprintFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderImageFootprintFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageFootprint)
		end,
	}
)
mod.VkPipelineViewportExclusiveScissorStateCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t exclusiveScissorCount;
	const $* pExclusiveScissors;
}]],
	mod.VkStructureType,
	mod.VkRect2D
)
ffi.metatype(
	mod.VkPipelineViewportExclusiveScissorStateCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkPipelineViewportExclusiveScissorStateCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.exclusiveScissorCount, t.pExclusiveScissors)
		end,
	}
)
mod.VkPhysicalDeviceExclusiveScissorFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ exclusiveScissor;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceExclusiveScissorFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExclusiveScissorFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.exclusiveScissor)
		end,
	}
)
mod.PFN_vkCmdSetExclusiveScissorEnableNV = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
mod.PFN_vkCmdSetExclusiveScissorNV = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkRect2D
)
ffi.cdef(
	[[void  vkCmdSetExclusiveScissorEnableNV($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetExclusiveScissorNV($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRect2D
)
mod.VkQueueFamilyCheckpointPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ checkpointExecutionStageMask;
}]],
	mod.VkStructureType,
	mod.VkPipelineStageFlags
)
ffi.metatype(
	mod.VkQueueFamilyCheckpointPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkQueueFamilyCheckpointPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.checkpointExecutionStageMask)
		end,
	}
)
mod.VkCheckpointDataNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ stage;
	void* pCheckpointMarker;
}]],
	mod.VkStructureType,
	mod.VkPipelineStageFlagBits
)
ffi.metatype(
	mod.VkCheckpointDataNV,
	{
		__tostring = function(s)
			return ("struct VkCheckpointDataNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stage, t.pCheckpointMarker)
		end,
	}
)
mod.VkQueueFamilyCheckpointProperties2NV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ checkpointExecutionStageMask;
}]],
	mod.VkStructureType,
	mod.VkPipelineStageFlags2
)
ffi.metatype(
	mod.VkQueueFamilyCheckpointProperties2NV,
	{
		__tostring = function(s)
			return ("struct VkQueueFamilyCheckpointProperties2NV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.checkpointExecutionStageMask)
		end,
	}
)
mod.VkCheckpointData2NV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ stage;
	void* pCheckpointMarker;
}]],
	mod.VkStructureType,
	mod.VkPipelineStageFlags2
)
ffi.metatype(
	mod.VkCheckpointData2NV,
	{
		__tostring = function(s)
			return ("struct VkCheckpointData2NV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stage, t.pCheckpointMarker)
		end,
	}
)
mod.PFN_vkCmdSetCheckpointNV = ffi.typeof([[void (*)($ , const void*)]], mod.VkCommandBuffer)
mod.PFN_vkGetQueueCheckpointDataNV = ffi.typeof([[void (*)($ , uint32_t*, $*)]], mod.VkQueue, mod.VkCheckpointDataNV)
mod.PFN_vkGetQueueCheckpointData2NV = ffi.typeof([[void (*)($ , uint32_t*, $*)]], mod.VkQueue, mod.VkCheckpointData2NV)
ffi.cdef([[void  vkCmdSetCheckpointNV($ , const void*);]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkGetQueueCheckpointDataNV($ , uint32_t*, $*);]],
	mod.VkQueue,
	mod.VkCheckpointDataNV
)
ffi.cdef(
	[[void  vkGetQueueCheckpointData2NV($ , uint32_t*, $*);]],
	mod.VkQueue,
	mod.VkCheckpointData2NV
)
mod.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderIntegerFunctions2;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderIntegerFunctions2)
		end,
	}
)
mod.VkPerformanceConfigurationINTEL = ffi.typeof([[void*]])
mod.VkPerformanceConfigurationTypeINTEL = ffi.typeof([[enum {
	VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
	VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF,
}]])
mod.VkQueryPoolSamplingModeINTEL = ffi.typeof([[enum {
	VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
	VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL = 0x7FFFFFFF,
}]])
mod.VkPerformanceOverrideTypeINTEL = ffi.typeof([[enum {
	VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
	VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
	VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF,
}]])
mod.VkPerformanceParameterTypeINTEL = ffi.typeof([[enum {
	VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
	VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
	VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF,
}]])
mod.VkPerformanceValueTypeINTEL = ffi.typeof([[enum {
	VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
	VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
	VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
	VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
	VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
	VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF,
}]])
mod.VkPerformanceValueDataINTEL = ffi.typeof(
	[[union {
	uint32_t value32;
	uint64_t value64;
	float valueFloat;
	$ valueBool;
	const char* valueString;
}]],
	mod.VkBool32
)
ffi.metatype(
	mod.VkPerformanceValueDataINTEL,
	{
		__tostring = function(s)
			return ("struct VkPerformanceValueDataINTEL[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.value32 ~= nil then obj.value32 = t.value32 end

			if t.value64 ~= nil then obj.value64 = t.value64 end

			if t.valueFloat ~= nil then obj.valueFloat = t.valueFloat end

			if t.valueBool ~= nil then obj.valueBool = t.valueBool end

			if t.valueString ~= nil then obj.valueString = t.valueString end

			return obj
		end,
	}
)
mod.VkPerformanceValueINTEL = ffi.typeof(
	[[struct {
	$ type;
	$ data;
}]],
	mod.VkPerformanceValueTypeINTEL,
	mod.VkPerformanceValueDataINTEL
)
ffi.metatype(
	mod.VkPerformanceValueINTEL,
	{
		__tostring = function(s)
			return ("struct VkPerformanceValueINTEL[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.type, t.data)
		end,
	}
)
mod.VkInitializePerformanceApiInfoINTEL = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	void* pUserData;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkInitializePerformanceApiInfoINTEL,
	{
		__tostring = function(s)
			return ("struct VkInitializePerformanceApiInfoINTEL[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pUserData)
		end,
	}
)
mod.VkQueryPoolPerformanceQueryCreateInfoINTEL = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ performanceCountersSampling;
}]],
	mod.VkStructureType,
	mod.VkQueryPoolSamplingModeINTEL
)
ffi.metatype(
	mod.VkQueryPoolPerformanceQueryCreateInfoINTEL,
	{
		__tostring = function(s)
			return ("struct VkQueryPoolPerformanceQueryCreateInfoINTEL[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.performanceCountersSampling)
		end,
	}
)
mod.VkQueryPoolCreateInfoINTEL = ffi.typeof([[$ ]], mod.VkQueryPoolPerformanceQueryCreateInfoINTEL)
mod.VkPerformanceMarkerInfoINTEL = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint64_t marker;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPerformanceMarkerInfoINTEL,
	{
		__tostring = function(s)
			return ("struct VkPerformanceMarkerInfoINTEL[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.marker)
		end,
	}
)
mod.VkPerformanceStreamMarkerInfoINTEL = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t marker;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPerformanceStreamMarkerInfoINTEL,
	{
		__tostring = function(s)
			return ("struct VkPerformanceStreamMarkerInfoINTEL[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.marker)
		end,
	}
)
mod.VkPerformanceOverrideInfoINTEL = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ enable;
	uint64_t parameter;
}]],
	mod.VkStructureType,
	mod.VkPerformanceOverrideTypeINTEL,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPerformanceOverrideInfoINTEL,
	{
		__tostring = function(s)
			return ("struct VkPerformanceOverrideInfoINTEL[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.type, t.enable, t.parameter)
		end,
	}
)
mod.VkPerformanceConfigurationAcquireInfoINTEL = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ type;
}]],
	mod.VkStructureType,
	mod.VkPerformanceConfigurationTypeINTEL
)
ffi.metatype(
	mod.VkPerformanceConfigurationAcquireInfoINTEL,
	{
		__tostring = function(s)
			return ("struct VkPerformanceConfigurationAcquireInfoINTEL[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.type)
		end,
	}
)
mod.PFN_vkInitializePerformanceApiINTEL = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkInitializePerformanceApiInfoINTEL
)
mod.PFN_vkUninitializePerformanceApiINTEL = ffi.typeof([[void (*)($ )]], mod.VkDevice)
mod.PFN_vkCmdSetPerformanceMarkerINTEL = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkCommandBuffer,
	mod.VkPerformanceMarkerInfoINTEL
)
mod.PFN_vkCmdSetPerformanceStreamMarkerINTEL = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkCommandBuffer,
	mod.VkPerformanceStreamMarkerInfoINTEL
)
mod.PFN_vkCmdSetPerformanceOverrideINTEL = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkCommandBuffer,
	mod.VkPerformanceOverrideInfoINTEL
)
mod.PFN_vkAcquirePerformanceConfigurationINTEL = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPerformanceConfigurationAcquireInfoINTEL,
	mod.VkPerformanceConfigurationINTEL
)
mod.PFN_vkReleasePerformanceConfigurationINTEL = ffi.typeof(
	[[$ (*)($ , $ )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPerformanceConfigurationINTEL
)
mod.PFN_vkQueueSetPerformanceConfigurationINTEL = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkQueue, mod.VkPerformanceConfigurationINTEL)
mod.PFN_vkGetPerformanceParameterINTEL = ffi.typeof(
	[[$ (*)($ , $ , $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPerformanceParameterTypeINTEL,
	mod.VkPerformanceValueINTEL
)
ffi.cdef(
	[[$  vkInitializePerformanceApiINTEL($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkInitializePerformanceApiInfoINTEL
)
ffi.cdef([[void  vkUninitializePerformanceApiINTEL($ );]], mod.VkDevice)
ffi.cdef(
	[[$  vkCmdSetPerformanceMarkerINTEL($ , const $*);]],
	mod.VkResult,
	mod.VkCommandBuffer,
	mod.VkPerformanceMarkerInfoINTEL
)
ffi.cdef(
	[[$  vkCmdSetPerformanceStreamMarkerINTEL($ , const $*);]],
	mod.VkResult,
	mod.VkCommandBuffer,
	mod.VkPerformanceStreamMarkerInfoINTEL
)
ffi.cdef(
	[[$  vkCmdSetPerformanceOverrideINTEL($ , const $*);]],
	mod.VkResult,
	mod.VkCommandBuffer,
	mod.VkPerformanceOverrideInfoINTEL
)
ffi.cdef(
	[[$  vkAcquirePerformanceConfigurationINTEL($ , const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPerformanceConfigurationAcquireInfoINTEL,
	mod.VkPerformanceConfigurationINTEL
)
ffi.cdef(
	[[$  vkReleasePerformanceConfigurationINTEL($ , $ );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPerformanceConfigurationINTEL
)
ffi.cdef(
	[[$  vkQueueSetPerformanceConfigurationINTEL($ , $ );]],
	mod.VkResult,
	mod.VkQueue,
	mod.VkPerformanceConfigurationINTEL
)
ffi.cdef(
	[[$  vkGetPerformanceParameterINTEL($ , $ , $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPerformanceParameterTypeINTEL,
	mod.VkPerformanceValueINTEL
)
mod.VkPhysicalDevicePCIBusInfoPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t pciDomain;
	uint32_t pciBus;
	uint32_t pciDevice;
	uint32_t pciFunction;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDevicePCIBusInfoPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePCIBusInfoPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pciDomain, t.pciBus, t.pciDevice, t.pciFunction)
		end,
	}
)
mod.VkDisplayNativeHdrSurfaceCapabilitiesAMD = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ localDimmingSupport;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkDisplayNativeHdrSurfaceCapabilitiesAMD,
	{
		__tostring = function(s)
			return ("struct VkDisplayNativeHdrSurfaceCapabilitiesAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.localDimmingSupport)
		end,
	}
)
mod.VkSwapchainDisplayNativeHdrCreateInfoAMD = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ localDimmingEnable;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSwapchainDisplayNativeHdrCreateInfoAMD,
	{
		__tostring = function(s)
			return ("struct VkSwapchainDisplayNativeHdrCreateInfoAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.localDimmingEnable)
		end,
	}
)
mod.PFN_vkSetLocalDimmingAMD = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkDevice, mod.VkSwapchainKHR, mod.VkBool32)
ffi.cdef(
	[[void  vkSetLocalDimmingAMD($ , $ , $ );]],
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkBool32
)
mod.VkPhysicalDeviceFragmentDensityMapFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ fragmentDensityMap;
	$ fragmentDensityMapDynamic;
	$ fragmentDensityMapNonSubsampledImages;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentDensityMapFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.fragmentDensityMap,
				t.fragmentDensityMapDynamic,
				t.fragmentDensityMapNonSubsampledImages
			)
		end,
	}
)
mod.VkPhysicalDeviceFragmentDensityMapPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ minFragmentDensityTexelSize;
	$ maxFragmentDensityTexelSize;
	$ fragmentDensityInvocations;
}]],
	mod.VkStructureType,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentDensityMapPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.minFragmentDensityTexelSize,
				t.maxFragmentDensityTexelSize,
				t.fragmentDensityInvocations
			)
		end,
	}
)
mod.VkRenderPassFragmentDensityMapCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ fragmentDensityMapAttachment;
}]],
	mod.VkStructureType,
	mod.VkAttachmentReference
)
ffi.metatype(
	mod.VkRenderPassFragmentDensityMapCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkRenderPassFragmentDensityMapCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.fragmentDensityMapAttachment)
		end,
	}
)
mod.VkRenderingFragmentDensityMapAttachmentInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ imageView;
	$ imageLayout;
}]],
	mod.VkStructureType,
	mod.VkImageView,
	mod.VkImageLayout
)
ffi.metatype(
	mod.VkRenderingFragmentDensityMapAttachmentInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkRenderingFragmentDensityMapAttachmentInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageView, t.imageLayout)
		end,
	}
)
mod.VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceScalarBlockLayoutFeatures)
mod.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSubgroupSizeControlFeatures)
mod.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSubgroupSizeControlProperties)
mod.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo)
mod.VkShaderCorePropertiesFlagBitsAMD = ffi.typeof([[enum {
	VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkShaderCorePropertiesFlagsAMD = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceShaderCoreProperties2AMD = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderCoreFeatures;
	uint32_t activeComputeUnitCount;
}]],
	mod.VkStructureType,
	mod.VkShaderCorePropertiesFlagsAMD
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderCoreProperties2AMD,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderCoreProperties2AMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderCoreFeatures, t.activeComputeUnitCount)
		end,
	}
)
mod.VkPhysicalDeviceCoherentMemoryFeaturesAMD = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ deviceCoherentMemory;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCoherentMemoryFeaturesAMD,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCoherentMemoryFeaturesAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.deviceCoherentMemory)
		end,
	}
)
mod.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderImageInt64Atomics;
	$ sparseImageInt64Atomics;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderImageInt64Atomics, t.sparseImageInt64Atomics)
		end,
	}
)
mod.VkPhysicalDeviceMemoryBudgetPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ heapBudget[16U];
	$ heapUsage[16U];
}]],
	mod.VkStructureType,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkPhysicalDeviceMemoryBudgetPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMemoryBudgetPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.heapBudget, t.heapUsage)
		end,
	}
)
mod.VkPhysicalDeviceMemoryPriorityFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ memoryPriority;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMemoryPriorityFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMemoryPriorityFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memoryPriority)
		end,
	}
)
mod.VkMemoryPriorityAllocateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	float priority;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkMemoryPriorityAllocateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMemoryPriorityAllocateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.priority)
		end,
	}
)
mod.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ dedicatedAllocationImageAliasing;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dedicatedAllocationImageAliasing)
		end,
	}
)
mod.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ bufferDeviceAddress;
	$ bufferDeviceAddressCaptureReplay;
	$ bufferDeviceAddressMultiDevice;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.bufferDeviceAddress,
				t.bufferDeviceAddressCaptureReplay,
				t.bufferDeviceAddressMultiDevice
			)
		end,
	}
)
mod.VkPhysicalDeviceBufferAddressFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)
mod.VkBufferDeviceAddressInfoEXT = ffi.typeof([[$ ]], mod.VkBufferDeviceAddressInfo)
mod.VkBufferDeviceAddressCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ deviceAddress;
}]],
	mod.VkStructureType,
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkBufferDeviceAddressCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkBufferDeviceAddressCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.deviceAddress)
		end,
	}
)
mod.PFN_vkGetBufferDeviceAddressEXT = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkDeviceAddress,
	mod.VkDevice,
	mod.VkBufferDeviceAddressInfo
)
ffi.cdef(
	[[$  vkGetBufferDeviceAddressEXT($ , const $*);]],
	mod.VkDeviceAddress,
	mod.VkDevice,
	mod.VkBufferDeviceAddressInfo
)
mod.VkToolPurposeFlagBitsEXT = ffi.typeof([[$ ]], mod.VkToolPurposeFlagBits)
mod.VkToolPurposeFlagsEXT = ffi.typeof([[$ ]], mod.VkToolPurposeFlags)
mod.VkPhysicalDeviceToolPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceToolProperties)
mod.PFN_vkGetPhysicalDeviceToolPropertiesEXT = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceToolProperties
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceToolPropertiesEXT($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceToolProperties
)
mod.VkImageStencilUsageCreateInfoEXT = ffi.typeof([[$ ]], mod.VkImageStencilUsageCreateInfo)
mod.VkValidationFeatureEnableEXT = ffi.typeof([[enum {
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
	VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
	VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
	VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
	VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkValidationFeatureDisableEXT = ffi.typeof([[enum {
	VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
	VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
	VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
	VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
	VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
	VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
	VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
	VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
	VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkValidationFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t enabledValidationFeatureCount;
	const $* pEnabledValidationFeatures;
	uint32_t disabledValidationFeatureCount;
	const $* pDisabledValidationFeatures;
}]],
	mod.VkStructureType,
	mod.VkValidationFeatureEnableEXT,
	mod.VkValidationFeatureDisableEXT
)
ffi.metatype(
	mod.VkValidationFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkValidationFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.enabledValidationFeatureCount,
				t.pEnabledValidationFeatures,
				t.disabledValidationFeatureCount,
				t.pDisabledValidationFeatures
			)
		end,
	}
)
mod.VkComponentTypeNV = ffi.typeof([[$ ]], mod.VkComponentTypeKHR)
mod.VkScopeNV = ffi.typeof([[$ ]], mod.VkScopeKHR)
mod.VkCooperativeMatrixPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t MSize;
	uint32_t NSize;
	uint32_t KSize;
	$ AType;
	$ BType;
	$ CType;
	$ DType;
	$ scope;
}]],
	mod.VkStructureType,
	mod.VkComponentTypeNV,
	mod.VkComponentTypeNV,
	mod.VkComponentTypeNV,
	mod.VkComponentTypeNV,
	mod.VkScopeNV
)
ffi.metatype(
	mod.VkCooperativeMatrixPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkCooperativeMatrixPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.MSize,
				t.NSize,
				t.KSize,
				t.AType,
				t.BType,
				t.CType,
				t.DType,
				t.scope
			)
		end,
	}
)
mod.VkPhysicalDeviceCooperativeMatrixFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ cooperativeMatrix;
	$ cooperativeMatrixRobustBufferAccess;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCooperativeMatrixFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCooperativeMatrixFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.cooperativeMatrix,
				t.cooperativeMatrixRobustBufferAccess
			)
		end,
	}
)
mod.VkPhysicalDeviceCooperativeMatrixPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ cooperativeMatrixSupportedStages;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags
)
ffi.metatype(
	mod.VkPhysicalDeviceCooperativeMatrixPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCooperativeMatrixPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.cooperativeMatrixSupportedStages)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkCooperativeMatrixPropertiesNV
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceCooperativeMatrixPropertiesNV($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkCooperativeMatrixPropertiesNV
)
mod.VkCoverageReductionModeNV = ffi.typeof([[enum {
	VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
	VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
	VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPipelineCoverageReductionStateCreateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceCoverageReductionModeFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ coverageReductionMode;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCoverageReductionModeFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCoverageReductionModeFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.coverageReductionMode)
		end,
	}
)
mod.VkPipelineCoverageReductionStateCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ coverageReductionMode;
}]],
	mod.VkStructureType,
	mod.VkPipelineCoverageReductionStateCreateFlagsNV,
	mod.VkCoverageReductionModeNV
)
ffi.metatype(
	mod.VkPipelineCoverageReductionStateCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkPipelineCoverageReductionStateCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.coverageReductionMode)
		end,
	}
)
mod.VkFramebufferMixedSamplesCombinationNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ coverageReductionMode;
	$ rasterizationSamples;
	$ depthStencilSamples;
	$ colorSamples;
}]],
	mod.VkStructureType,
	mod.VkCoverageReductionModeNV,
	mod.VkSampleCountFlagBits,
	mod.VkSampleCountFlags,
	mod.VkSampleCountFlags
)
ffi.metatype(
	mod.VkFramebufferMixedSamplesCombinationNV,
	{
		__tostring = function(s)
			return ("struct VkFramebufferMixedSamplesCombinationNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.coverageReductionMode,
				t.rasterizationSamples,
				t.depthStencilSamples,
				t.colorSamples
			)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkFramebufferMixedSamplesCombinationNV
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkFramebufferMixedSamplesCombinationNV
)
mod.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ fragmentShaderSampleInterlock;
	$ fragmentShaderPixelInterlock;
	$ fragmentShaderShadingRateInterlock;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.fragmentShaderSampleInterlock,
				t.fragmentShaderPixelInterlock,
				t.fragmentShaderShadingRateInterlock
			)
		end,
	}
)
mod.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ ycbcrImageArrays;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.ycbcrImageArrays)
		end,
	}
)
mod.VkProvokingVertexModeEXT = ffi.typeof([[enum {
	VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
	VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
	VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceProvokingVertexFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ provokingVertexLast;
	$ transformFeedbackPreservesProvokingVertex;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceProvokingVertexFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceProvokingVertexFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.provokingVertexLast,
				t.transformFeedbackPreservesProvokingVertex
			)
		end,
	}
)
mod.VkPhysicalDeviceProvokingVertexPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ provokingVertexModePerPipeline;
	$ transformFeedbackPreservesTriangleFanProvokingVertex;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceProvokingVertexPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceProvokingVertexPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.provokingVertexModePerPipeline,
				t.transformFeedbackPreservesTriangleFanProvokingVertex
			)
		end,
	}
)
mod.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ provokingVertexMode;
}]],
	mod.VkStructureType,
	mod.VkProvokingVertexModeEXT
)
ffi.metatype(
	mod.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelineRasterizationProvokingVertexStateCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.provokingVertexMode)
		end,
	}
)
mod.VkHeadlessSurfaceCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkHeadlessSurfaceCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkHeadlessSurfaceCreateFlagsEXT
)
ffi.metatype(
	mod.VkHeadlessSurfaceCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkHeadlessSurfaceCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.PFN_vkCreateHeadlessSurfaceEXT = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkHeadlessSurfaceCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkCreateHeadlessSurfaceEXT($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkHeadlessSurfaceCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.VkLineRasterizationModeEXT = ffi.typeof([[$ ]], mod.VkLineRasterizationMode)
mod.VkPhysicalDeviceLineRasterizationFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceLineRasterizationFeatures)
mod.VkPhysicalDeviceLineRasterizationPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceLineRasterizationProperties)
mod.VkPipelineRasterizationLineStateCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineRasterizationLineStateCreateInfo)
mod.PFN_vkCmdSetLineStippleEXT = ffi.typeof([[void (*)($ , uint32_t , uint16_t )]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetLineStippleEXT($ , uint32_t , uint16_t );]], mod.VkCommandBuffer)
mod.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderBufferFloat32Atomics;
	$ shaderBufferFloat32AtomicAdd;
	$ shaderBufferFloat64Atomics;
	$ shaderBufferFloat64AtomicAdd;
	$ shaderSharedFloat32Atomics;
	$ shaderSharedFloat32AtomicAdd;
	$ shaderSharedFloat64Atomics;
	$ shaderSharedFloat64AtomicAdd;
	$ shaderImageFloat32Atomics;
	$ shaderImageFloat32AtomicAdd;
	$ sparseImageFloat32Atomics;
	$ sparseImageFloat32AtomicAdd;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderBufferFloat32Atomics,
				t.shaderBufferFloat32AtomicAdd,
				t.shaderBufferFloat64Atomics,
				t.shaderBufferFloat64AtomicAdd,
				t.shaderSharedFloat32Atomics,
				t.shaderSharedFloat32AtomicAdd,
				t.shaderSharedFloat64Atomics,
				t.shaderSharedFloat64AtomicAdd,
				t.shaderImageFloat32Atomics,
				t.shaderImageFloat32AtomicAdd,
				t.sparseImageFloat32Atomics,
				t.sparseImageFloat32AtomicAdd
			)
		end,
	}
)
mod.VkPhysicalDeviceHostQueryResetFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceHostQueryResetFeatures)
mod.PFN_vkResetQueryPoolEXT = ffi.typeof([[void (*)($ , $ , uint32_t , uint32_t )]], mod.VkDevice, mod.VkQueryPool)
ffi.cdef(
	[[void  vkResetQueryPoolEXT($ , $ , uint32_t , uint32_t );]],
	mod.VkDevice,
	mod.VkQueryPool
)
mod.VkPhysicalDeviceIndexTypeUint8FeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceIndexTypeUint8Features)
mod.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ extendedDynamicState;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.extendedDynamicState)
		end,
	}
)
mod.PFN_vkCmdSetCullModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCullModeFlags)
mod.PFN_vkCmdSetFrontFaceEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkFrontFace)
mod.PFN_vkCmdSetPrimitiveTopologyEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkPrimitiveTopology)
mod.PFN_vkCmdSetViewportWithCountEXT = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkViewport)
mod.PFN_vkCmdSetScissorWithCountEXT = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkRect2D)
mod.PFN_vkCmdBindVertexBuffers2EXT = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*, const $*, const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
mod.PFN_vkCmdSetDepthTestEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthWriteEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthCompareOpEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCompareOp)
mod.PFN_vkCmdSetDepthBoundsTestEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetStencilTestEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetStencilOpEXT = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkStencilFaceFlags,
	mod.VkStencilOp,
	mod.VkStencilOp,
	mod.VkStencilOp,
	mod.VkCompareOp
)
ffi.cdef([[void  vkCmdSetCullModeEXT($ , $ );]], mod.VkCommandBuffer, mod.VkCullModeFlags)
ffi.cdef([[void  vkCmdSetFrontFaceEXT($ , $ );]], mod.VkCommandBuffer, mod.VkFrontFace)
ffi.cdef(
	[[void  vkCmdSetPrimitiveTopologyEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkPrimitiveTopology
)
ffi.cdef(
	[[void  vkCmdSetViewportWithCountEXT($ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkViewport
)
ffi.cdef(
	[[void  vkCmdSetScissorWithCountEXT($ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRect2D
)
ffi.cdef(
	[[void  vkCmdBindVertexBuffers2EXT($ , uint32_t , uint32_t , const $*, const $*, const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.cdef([[void  vkCmdSetDepthTestEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetDepthWriteEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef(
	[[void  vkCmdSetDepthCompareOpEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkCompareOp
)
ffi.cdef(
	[[void  vkCmdSetDepthBoundsTestEnableEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetStencilTestEnableEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetStencilOpEXT($ , $ , $ , $ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkStencilFaceFlags,
	mod.VkStencilOp,
	mod.VkStencilOp,
	mod.VkStencilOp,
	mod.VkCompareOp
)
mod.VkHostImageCopyFlagBitsEXT = ffi.typeof([[$ ]], mod.VkHostImageCopyFlagBits)
mod.VkHostImageCopyFlagsEXT = ffi.typeof([[$ ]], mod.VkHostImageCopyFlags)
mod.VkPhysicalDeviceHostImageCopyFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceHostImageCopyFeatures)
mod.VkPhysicalDeviceHostImageCopyPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceHostImageCopyProperties)
mod.VkMemoryToImageCopyEXT = ffi.typeof([[$ ]], mod.VkMemoryToImageCopy)
mod.VkImageToMemoryCopyEXT = ffi.typeof([[$ ]], mod.VkImageToMemoryCopy)
mod.VkCopyMemoryToImageInfoEXT = ffi.typeof([[$ ]], mod.VkCopyMemoryToImageInfo)
mod.VkCopyImageToMemoryInfoEXT = ffi.typeof([[$ ]], mod.VkCopyImageToMemoryInfo)
mod.VkCopyImageToImageInfoEXT = ffi.typeof([[$ ]], mod.VkCopyImageToImageInfo)
mod.VkHostImageLayoutTransitionInfoEXT = ffi.typeof([[$ ]], mod.VkHostImageLayoutTransitionInfo)
mod.VkSubresourceHostMemcpySizeEXT = ffi.typeof([[$ ]], mod.VkSubresourceHostMemcpySize)
mod.VkHostImageCopyDevicePerformanceQueryEXT = ffi.typeof([[$ ]], mod.VkHostImageCopyDevicePerformanceQuery)
mod.VkSubresourceLayout2EXT = ffi.typeof([[$ ]], mod.VkSubresourceLayout2)
mod.VkImageSubresource2EXT = ffi.typeof([[$ ]], mod.VkImageSubresource2)
mod.PFN_vkCopyMemoryToImageEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyMemoryToImageInfo)
mod.PFN_vkCopyImageToMemoryEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToMemoryInfo)
mod.PFN_vkCopyImageToImageEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToImageInfo)
mod.PFN_vkTransitionImageLayoutEXT = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkHostImageLayoutTransitionInfo
)
mod.PFN_vkGetImageSubresourceLayout2EXT = ffi.typeof(
	[[void (*)($ , $ , const $*, $*)]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkImageSubresource2,
	mod.VkSubresourceLayout2
)
ffi.cdef(
	[[$  vkCopyMemoryToImageEXT($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCopyMemoryToImageInfo
)
ffi.cdef(
	[[$  vkCopyImageToMemoryEXT($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCopyImageToMemoryInfo
)
ffi.cdef(
	[[$  vkCopyImageToImageEXT($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkCopyImageToImageInfo
)
ffi.cdef(
	[[$  vkTransitionImageLayoutEXT($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkHostImageLayoutTransitionInfo
)
ffi.cdef(
	[[void  vkGetImageSubresourceLayout2EXT($ , $ , const $*, $*);]],
	mod.VkDevice,
	mod.VkImage,
	mod.VkImageSubresource2,
	mod.VkSubresourceLayout2
)
mod.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ memoryMapPlaced;
	$ memoryMapRangePlaced;
	$ memoryUnmapReserve;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMapMemoryPlacedFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.memoryMapPlaced,
				t.memoryMapRangePlaced,
				t.memoryUnmapReserve
			)
		end,
	}
)
mod.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ minPlacedMemoryMapAlignment;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMapMemoryPlacedPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.minPlacedMemoryMapAlignment)
		end,
	}
)
mod.VkMemoryMapPlacedInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	void* pPlacedAddress;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkMemoryMapPlacedInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMemoryMapPlacedInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pPlacedAddress)
		end,
	}
)
mod.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderBufferFloat16Atomics;
	$ shaderBufferFloat16AtomicAdd;
	$ shaderBufferFloat16AtomicMinMax;
	$ shaderBufferFloat32AtomicMinMax;
	$ shaderBufferFloat64AtomicMinMax;
	$ shaderSharedFloat16Atomics;
	$ shaderSharedFloat16AtomicAdd;
	$ shaderSharedFloat16AtomicMinMax;
	$ shaderSharedFloat32AtomicMinMax;
	$ shaderSharedFloat64AtomicMinMax;
	$ shaderImageFloat32AtomicMinMax;
	$ sparseImageFloat32AtomicMinMax;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderBufferFloat16Atomics,
				t.shaderBufferFloat16AtomicAdd,
				t.shaderBufferFloat16AtomicMinMax,
				t.shaderBufferFloat32AtomicMinMax,
				t.shaderBufferFloat64AtomicMinMax,
				t.shaderSharedFloat16Atomics,
				t.shaderSharedFloat16AtomicAdd,
				t.shaderSharedFloat16AtomicMinMax,
				t.shaderSharedFloat32AtomicMinMax,
				t.shaderSharedFloat64AtomicMinMax,
				t.shaderImageFloat32AtomicMinMax,
				t.sparseImageFloat32AtomicMinMax
			)
		end,
	}
)
mod.VkPresentScalingFlagBitsEXT = ffi.typeof([[$ ]], mod.VkPresentScalingFlagBitsKHR)
mod.VkPresentScalingFlagsEXT = ffi.typeof([[$ ]], mod.VkPresentScalingFlagsKHR)
mod.VkPresentGravityFlagBitsEXT = ffi.typeof([[$ ]], mod.VkPresentGravityFlagBitsKHR)
mod.VkPresentGravityFlagsEXT = ffi.typeof([[$ ]], mod.VkPresentGravityFlagsKHR)
mod.VkSurfacePresentModeEXT = ffi.typeof([[$ ]], mod.VkSurfacePresentModeKHR)
mod.VkSurfacePresentScalingCapabilitiesEXT = ffi.typeof([[$ ]], mod.VkSurfacePresentScalingCapabilitiesKHR)
mod.VkSurfacePresentModeCompatibilityEXT = ffi.typeof([[$ ]], mod.VkSurfacePresentModeCompatibilityKHR)
mod.VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR)
mod.VkSwapchainPresentFenceInfoEXT = ffi.typeof([[$ ]], mod.VkSwapchainPresentFenceInfoKHR)
mod.VkSwapchainPresentModesCreateInfoEXT = ffi.typeof([[$ ]], mod.VkSwapchainPresentModesCreateInfoKHR)
mod.VkSwapchainPresentModeInfoEXT = ffi.typeof([[$ ]], mod.VkSwapchainPresentModeInfoKHR)
mod.VkSwapchainPresentScalingCreateInfoEXT = ffi.typeof([[$ ]], mod.VkSwapchainPresentScalingCreateInfoKHR)
mod.VkReleaseSwapchainImagesInfoEXT = ffi.typeof([[$ ]], mod.VkReleaseSwapchainImagesInfoKHR)
mod.PFN_vkReleaseSwapchainImagesEXT = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkReleaseSwapchainImagesInfoKHR
)
ffi.cdef(
	[[$  vkReleaseSwapchainImagesEXT($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkReleaseSwapchainImagesInfoKHR
)
mod.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures)
mod.VkIndirectCommandsLayoutNV = ffi.typeof([[void*]])
mod.VkIndirectCommandsTokenTypeNV = ffi.typeof([[enum {
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = 1000428003,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = 1000428004,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkIndirectStateFlagBitsNV = ffi.typeof([[enum {
	VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 0x00000001,
	VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkIndirectStateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkIndirectCommandsLayoutUsageFlagBitsNV = ffi.typeof([[enum {
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 0x00000001,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 0x00000002,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 0x00000004,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkIndirectCommandsLayoutUsageFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxGraphicsShaderGroupCount;
	uint32_t maxIndirectSequenceCount;
	uint32_t maxIndirectCommandsTokenCount;
	uint32_t maxIndirectCommandsStreamCount;
	uint32_t maxIndirectCommandsTokenOffset;
	uint32_t maxIndirectCommandsStreamStride;
	uint32_t minSequencesCountBufferOffsetAlignment;
	uint32_t minSequencesIndexBufferOffsetAlignment;
	uint32_t minIndirectCommandsBufferOffsetAlignment;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxGraphicsShaderGroupCount,
				t.maxIndirectSequenceCount,
				t.maxIndirectCommandsTokenCount,
				t.maxIndirectCommandsStreamCount,
				t.maxIndirectCommandsTokenOffset,
				t.maxIndirectCommandsStreamStride,
				t.minSequencesCountBufferOffsetAlignment,
				t.minSequencesIndexBufferOffsetAlignment,
				t.minIndirectCommandsBufferOffsetAlignment
			)
		end,
	}
)
mod.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ deviceGeneratedCommands;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.deviceGeneratedCommands)
		end,
	}
)
mod.VkGraphicsShaderGroupCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t stageCount;
	const $* pStages;
	const $* pVertexInputState;
	const $* pTessellationState;
}]],
	mod.VkStructureType,
	mod.VkPipelineShaderStageCreateInfo,
	mod.VkPipelineVertexInputStateCreateInfo,
	mod.VkPipelineTessellationStateCreateInfo
)
ffi.metatype(
	mod.VkGraphicsShaderGroupCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkGraphicsShaderGroupCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.stageCount,
				t.pStages,
				t.pVertexInputState,
				t.pTessellationState
			)
		end,
	}
)
mod.VkGraphicsPipelineShaderGroupsCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t groupCount;
	const $* pGroups;
	uint32_t pipelineCount;
	const $* pPipelines;
}]],
	mod.VkStructureType,
	mod.VkGraphicsShaderGroupCreateInfoNV,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkGraphicsPipelineShaderGroupsCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkGraphicsPipelineShaderGroupsCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.groupCount, t.pGroups, t.pipelineCount, t.pPipelines)
		end,
	}
)
mod.VkBindShaderGroupIndirectCommandNV = ffi.typeof([[struct {
	uint32_t groupIndex;
}]])
ffi.metatype(
	mod.VkBindShaderGroupIndirectCommandNV,
	{
		__tostring = function(s)
			return ("struct VkBindShaderGroupIndirectCommandNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.groupIndex)
		end,
	}
)
mod.VkBindIndexBufferIndirectCommandNV = ffi.typeof(
	[[struct {
	$ bufferAddress;
	uint32_t size;
	$ indexType;
}]],
	mod.VkDeviceAddress,
	mod.VkIndexType
)
ffi.metatype(
	mod.VkBindIndexBufferIndirectCommandNV,
	{
		__tostring = function(s)
			return ("struct VkBindIndexBufferIndirectCommandNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.bufferAddress, t.size, t.indexType)
		end,
	}
)
mod.VkBindVertexBufferIndirectCommandNV = ffi.typeof(
	[[struct {
	$ bufferAddress;
	uint32_t size;
	uint32_t stride;
}]],
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkBindVertexBufferIndirectCommandNV,
	{
		__tostring = function(s)
			return ("struct VkBindVertexBufferIndirectCommandNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.bufferAddress, t.size, t.stride)
		end,
	}
)
mod.VkSetStateFlagsIndirectCommandNV = ffi.typeof([[struct {
	uint32_t data;
}]])
ffi.metatype(
	mod.VkSetStateFlagsIndirectCommandNV,
	{
		__tostring = function(s)
			return ("struct VkSetStateFlagsIndirectCommandNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.data)
		end,
	}
)
mod.VkIndirectCommandsStreamNV = ffi.typeof([[struct {
	$ buffer;
	$ offset;
}]], mod.VkBuffer, mod.VkDeviceSize)
ffi.metatype(
	mod.VkIndirectCommandsStreamNV,
	{
		__tostring = function(s)
			return ("struct VkIndirectCommandsStreamNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.buffer, t.offset)
		end,
	}
)
mod.VkIndirectCommandsLayoutTokenNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ tokenType;
	uint32_t stream;
	uint32_t offset;
	uint32_t vertexBindingUnit;
	$ vertexDynamicStride;
	$ pushconstantPipelineLayout;
	$ pushconstantShaderStageFlags;
	uint32_t pushconstantOffset;
	uint32_t pushconstantSize;
	$ indirectStateFlags;
	uint32_t indexTypeCount;
	const $* pIndexTypes;
	const uint32_t* pIndexTypeValues;
}]],
	mod.VkStructureType,
	mod.VkIndirectCommandsTokenTypeNV,
	mod.VkBool32,
	mod.VkPipelineLayout,
	mod.VkShaderStageFlags,
	mod.VkIndirectStateFlagsNV,
	mod.VkIndexType
)
ffi.metatype(
	mod.VkIndirectCommandsLayoutTokenNV,
	{
		__tostring = function(s)
			return ("struct VkIndirectCommandsLayoutTokenNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.tokenType,
				t.stream,
				t.offset,
				t.vertexBindingUnit,
				t.vertexDynamicStride,
				t.pushconstantPipelineLayout,
				t.pushconstantShaderStageFlags,
				t.pushconstantOffset,
				t.pushconstantSize,
				t.indirectStateFlags,
				t.indexTypeCount,
				t.pIndexTypes,
				t.pIndexTypeValues
			)
		end,
	}
)
mod.VkIndirectCommandsLayoutCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ pipelineBindPoint;
	uint32_t tokenCount;
	const $* pTokens;
	uint32_t streamCount;
	const uint32_t* pStreamStrides;
}]],
	mod.VkStructureType,
	mod.VkIndirectCommandsLayoutUsageFlagsNV,
	mod.VkPipelineBindPoint,
	mod.VkIndirectCommandsLayoutTokenNV
)
ffi.metatype(
	mod.VkIndirectCommandsLayoutCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkIndirectCommandsLayoutCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.pipelineBindPoint,
				t.tokenCount,
				t.pTokens,
				t.streamCount,
				t.pStreamStrides
			)
		end,
	}
)
mod.VkGeneratedCommandsInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ pipelineBindPoint;
	$ pipeline;
	$ indirectCommandsLayout;
	uint32_t streamCount;
	const $* pStreams;
	uint32_t sequencesCount;
	$ preprocessBuffer;
	$ preprocessOffset;
	$ preprocessSize;
	$ sequencesCountBuffer;
	$ sequencesCountOffset;
	$ sequencesIndexBuffer;
	$ sequencesIndexOffset;
}]],
	mod.VkStructureType,
	mod.VkPipelineBindPoint,
	mod.VkPipeline,
	mod.VkIndirectCommandsLayoutNV,
	mod.VkIndirectCommandsStreamNV,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkGeneratedCommandsInfoNV,
	{
		__tostring = function(s)
			return ("struct VkGeneratedCommandsInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pipelineBindPoint,
				t.pipeline,
				t.indirectCommandsLayout,
				t.streamCount,
				t.pStreams,
				t.sequencesCount,
				t.preprocessBuffer,
				t.preprocessOffset,
				t.preprocessSize,
				t.sequencesCountBuffer,
				t.sequencesCountOffset,
				t.sequencesIndexBuffer,
				t.sequencesIndexOffset
			)
		end,
	}
)
mod.VkGeneratedCommandsMemoryRequirementsInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ pipelineBindPoint;
	$ pipeline;
	$ indirectCommandsLayout;
	uint32_t maxSequencesCount;
}]],
	mod.VkStructureType,
	mod.VkPipelineBindPoint,
	mod.VkPipeline,
	mod.VkIndirectCommandsLayoutNV
)
ffi.metatype(
	mod.VkGeneratedCommandsMemoryRequirementsInfoNV,
	{
		__tostring = function(s)
			return ("struct VkGeneratedCommandsMemoryRequirementsInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.pipelineBindPoint,
				t.pipeline,
				t.indirectCommandsLayout,
				t.maxSequencesCount
			)
		end,
	}
)
mod.PFN_vkGetGeneratedCommandsMemoryRequirementsNV = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkGeneratedCommandsMemoryRequirementsInfoNV,
	mod.VkMemoryRequirements2
)
mod.PFN_vkCmdPreprocessGeneratedCommandsNV = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkGeneratedCommandsInfoNV)
mod.PFN_vkCmdExecuteGeneratedCommandsNV = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkBool32,
	mod.VkGeneratedCommandsInfoNV
)
mod.PFN_vkCmdBindPipelineShaderGroupNV = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipeline
)
mod.PFN_vkCreateIndirectCommandsLayoutNV = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkIndirectCommandsLayoutCreateInfoNV,
	mod.VkAllocationCallbacks,
	mod.VkIndirectCommandsLayoutNV
)
mod.PFN_vkDestroyIndirectCommandsLayoutNV = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkIndirectCommandsLayoutNV,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkGetGeneratedCommandsMemoryRequirementsNV($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkGeneratedCommandsMemoryRequirementsInfoNV,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkCmdPreprocessGeneratedCommandsNV($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkGeneratedCommandsInfoNV
)
ffi.cdef(
	[[void  vkCmdExecuteGeneratedCommandsNV($ , $ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBool32,
	mod.VkGeneratedCommandsInfoNV
)
ffi.cdef(
	[[void  vkCmdBindPipelineShaderGroupNV($ , $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipeline
)
ffi.cdef(
	[[$  vkCreateIndirectCommandsLayoutNV($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkIndirectCommandsLayoutCreateInfoNV,
	mod.VkAllocationCallbacks,
	mod.VkIndirectCommandsLayoutNV
)
ffi.cdef(
	[[void  vkDestroyIndirectCommandsLayoutNV($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkIndirectCommandsLayoutNV,
	mod.VkAllocationCallbacks
)
mod.VkPhysicalDeviceInheritedViewportScissorFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ inheritedViewportScissor2D;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceInheritedViewportScissorFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceInheritedViewportScissorFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.inheritedViewportScissor2D)
		end,
	}
)
mod.VkCommandBufferInheritanceViewportScissorInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ viewportScissor2D;
	uint32_t viewportDepthCount;
	const $* pViewportDepths;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkViewport
)
ffi.metatype(
	mod.VkCommandBufferInheritanceViewportScissorInfoNV,
	{
		__tostring = function(s)
			return ("struct VkCommandBufferInheritanceViewportScissorInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.viewportScissor2D,
				t.viewportDepthCount,
				t.pViewportDepths
			)
		end,
	}
)
mod.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ texelBufferAlignment;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.texelBufferAlignment)
		end,
	}
)
mod.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceTexelBufferAlignmentProperties)
mod.VkRenderPassTransformBeginInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ transform;
}]],
	mod.VkStructureType,
	mod.VkSurfaceTransformFlagBitsKHR
)
ffi.metatype(
	mod.VkRenderPassTransformBeginInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkRenderPassTransformBeginInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.transform)
		end,
	}
)
mod.VkCommandBufferInheritanceRenderPassTransformInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ transform;
	$ renderArea;
}]],
	mod.VkStructureType,
	mod.VkSurfaceTransformFlagBitsKHR,
	mod.VkRect2D
)
ffi.metatype(
	mod.VkCommandBufferInheritanceRenderPassTransformInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.transform, t.renderArea)
		end,
	}
)
mod.VkDepthBiasRepresentationEXT = ffi.typeof([[enum {
	VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT = 0,
	VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT = 1,
	VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT = 2,
	VK_DEPTH_BIAS_REPRESENTATION_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceDepthBiasControlFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ depthBiasControl;
	$ leastRepresentableValueForceUnormRepresentation;
	$ floatRepresentation;
	$ depthBiasExact;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDepthBiasControlFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDepthBiasControlFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.depthBiasControl,
				t.leastRepresentableValueForceUnormRepresentation,
				t.floatRepresentation,
				t.depthBiasExact
			)
		end,
	}
)
mod.VkDepthBiasInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	float depthBiasConstantFactor;
	float depthBiasClamp;
	float depthBiasSlopeFactor;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDepthBiasInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDepthBiasInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.depthBiasConstantFactor,
				t.depthBiasClamp,
				t.depthBiasSlopeFactor
			)
		end,
	}
)
mod.VkDepthBiasRepresentationInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ depthBiasRepresentation;
	$ depthBiasExact;
}]],
	mod.VkStructureType,
	mod.VkDepthBiasRepresentationEXT,
	mod.VkBool32
)
ffi.metatype(
	mod.VkDepthBiasRepresentationInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDepthBiasRepresentationInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.depthBiasRepresentation, t.depthBiasExact)
		end,
	}
)
mod.PFN_vkCmdSetDepthBias2EXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDepthBiasInfoEXT)
ffi.cdef(
	[[void  vkCmdSetDepthBias2EXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDepthBiasInfoEXT
)
mod.VkDeviceMemoryReportEventTypeEXT = ffi.typeof([[enum {
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDeviceMemoryReportFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ deviceMemoryReport;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.deviceMemoryReport)
		end,
	}
)
mod.VkDeviceMemoryReportCallbackDataEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ type;
	uint64_t memoryObjectId;
	$ size;
	$ objectType;
	uint64_t objectHandle;
	uint32_t heapIndex;
}]],
	mod.VkStructureType,
	mod.VkDeviceMemoryReportFlagsEXT,
	mod.VkDeviceMemoryReportEventTypeEXT,
	mod.VkDeviceSize,
	mod.VkObjectType
)
ffi.metatype(
	mod.VkDeviceMemoryReportCallbackDataEXT,
	{
		__tostring = function(s)
			return ("struct VkDeviceMemoryReportCallbackDataEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.type,
				t.memoryObjectId,
				t.size,
				t.objectType,
				t.objectHandle,
				t.heapIndex
			)
		end,
	}
)
mod.PFN_vkDeviceMemoryReportCallbackEXT = ffi.typeof([[void (*)(const $*, void*)]], mod.VkDeviceMemoryReportCallbackDataEXT)
mod.VkDeviceDeviceMemoryReportCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ pfnUserCallback;
	void* pUserData;
}]],
	mod.VkStructureType,
	mod.VkDeviceMemoryReportFlagsEXT,
	mod.PFN_vkDeviceMemoryReportCallbackEXT
)
ffi.metatype(
	mod.VkDeviceDeviceMemoryReportCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDeviceDeviceMemoryReportCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.pfnUserCallback, t.pUserData)
		end,
	}
)
mod.PFN_vkAcquireDrmDisplayEXT = ffi.typeof([[$ (*)($ , int32_t , $ )]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR)
mod.PFN_vkGetDrmDisplayEXT = ffi.typeof(
	[[$ (*)($ , int32_t , uint32_t , $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR
)
ffi.cdef(
	[[$  vkAcquireDrmDisplayEXT($ , int32_t , $ );]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR
)
ffi.cdef(
	[[$  vkGetDrmDisplayEXT($ , int32_t , uint32_t , $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkDisplayKHR
)
mod.VkPhysicalDeviceRobustness2FeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceRobustness2FeaturesKHR)
mod.VkPhysicalDeviceRobustness2PropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceRobustness2PropertiesKHR)
mod.VkSamplerCustomBorderColorCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ customBorderColor;
	$ format;
}]],
	mod.VkStructureType,
	mod.VkClearColorValue,
	mod.VkFormat
)
ffi.metatype(
	mod.VkSamplerCustomBorderColorCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkSamplerCustomBorderColorCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.customBorderColor, t.format)
		end,
	}
)
mod.VkPhysicalDeviceCustomBorderColorPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxCustomBorderColorSamplers;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceCustomBorderColorPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCustomBorderColorPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxCustomBorderColorSamplers)
		end,
	}
)
mod.VkPhysicalDeviceCustomBorderColorFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ customBorderColors;
	$ customBorderColorWithoutFormat;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCustomBorderColorFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCustomBorderColorFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.customBorderColors, t.customBorderColorWithoutFormat)
		end,
	}
)
mod.VkPhysicalDevicePresentBarrierFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentBarrier;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePresentBarrierFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePresentBarrierFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentBarrier)
		end,
	}
)
mod.VkSurfaceCapabilitiesPresentBarrierNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentBarrierSupported;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSurfaceCapabilitiesPresentBarrierNV,
	{
		__tostring = function(s)
			return ("struct VkSurfaceCapabilitiesPresentBarrierNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentBarrierSupported)
		end,
	}
)
mod.VkSwapchainPresentBarrierCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentBarrierEnable;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSwapchainPresentBarrierCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkSwapchainPresentBarrierCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentBarrierEnable)
		end,
	}
)
mod.VkPrivateDataSlotEXT = ffi.typeof([[$ ]], mod.VkPrivateDataSlot)
mod.VkPrivateDataSlotCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkPrivateDataSlotCreateFlags)
mod.VkPhysicalDevicePrivateDataFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePrivateDataFeatures)
mod.VkDevicePrivateDataCreateInfoEXT = ffi.typeof([[$ ]], mod.VkDevicePrivateDataCreateInfo)
mod.VkPrivateDataSlotCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPrivateDataSlotCreateInfo)
mod.PFN_vkCreatePrivateDataSlotEXT = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPrivateDataSlotCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPrivateDataSlot
)
mod.PFN_vkDestroyPrivateDataSlotEXT = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkPrivateDataSlot,
	mod.VkAllocationCallbacks
)
mod.PFN_vkSetPrivateDataEXT = ffi.typeof(
	[[$ (*)($ , $ , uint64_t , $ , uint64_t )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkObjectType,
	mod.VkPrivateDataSlot
)
mod.PFN_vkGetPrivateDataEXT = ffi.typeof(
	[[void (*)($ , $ , uint64_t , $ , uint64_t*)]],
	mod.VkDevice,
	mod.VkObjectType,
	mod.VkPrivateDataSlot
)
ffi.cdef(
	[[$  vkCreatePrivateDataSlotEXT($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPrivateDataSlotCreateInfo,
	mod.VkAllocationCallbacks,
	mod.VkPrivateDataSlot
)
ffi.cdef(
	[[void  vkDestroyPrivateDataSlotEXT($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkPrivateDataSlot,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkSetPrivateDataEXT($ , $ , uint64_t , $ , uint64_t );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkObjectType,
	mod.VkPrivateDataSlot
)
ffi.cdef(
	[[void  vkGetPrivateDataEXT($ , $ , uint64_t , $ , uint64_t*);]],
	mod.VkDevice,
	mod.VkObjectType,
	mod.VkPrivateDataSlot
)
mod.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePipelineCreationCacheControlFeatures)
mod.VkDeviceDiagnosticsConfigFlagBitsNV = ffi.typeof([[enum {
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 0x00000001,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 0x00000002,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 0x00000004,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 0x00000008,
	VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkDeviceDiagnosticsConfigFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDiagnosticsConfigFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ diagnosticsConfig;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDiagnosticsConfigFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDiagnosticsConfigFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.diagnosticsConfig)
		end,
	}
)
mod.VkDeviceDiagnosticsConfigCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkDeviceDiagnosticsConfigFlagsNV
)
ffi.metatype(
	mod.VkDeviceDiagnosticsConfigCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkDeviceDiagnosticsConfigCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.VkTileShadingRenderPassFlagBitsQCOM = ffi.typeof([[enum {
	VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM = 0x00000001,
	VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM = 0x00000002,
	VK_TILE_SHADING_RENDER_PASS_FLAG_BITS_MAX_ENUM_QCOM = 0x7FFFFFFF,
}]])
mod.VkTileShadingRenderPassFlagsQCOM = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceTileShadingFeaturesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ tileShading;
	$ tileShadingFragmentStage;
	$ tileShadingColorAttachments;
	$ tileShadingDepthAttachments;
	$ tileShadingStencilAttachments;
	$ tileShadingInputAttachments;
	$ tileShadingSampledAttachments;
	$ tileShadingPerTileDraw;
	$ tileShadingPerTileDispatch;
	$ tileShadingDispatchTile;
	$ tileShadingApron;
	$ tileShadingAnisotropicApron;
	$ tileShadingAtomicOps;
	$ tileShadingImageProcessing;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceTileShadingFeaturesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTileShadingFeaturesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.tileShading,
				t.tileShadingFragmentStage,
				t.tileShadingColorAttachments,
				t.tileShadingDepthAttachments,
				t.tileShadingStencilAttachments,
				t.tileShadingInputAttachments,
				t.tileShadingSampledAttachments,
				t.tileShadingPerTileDraw,
				t.tileShadingPerTileDispatch,
				t.tileShadingDispatchTile,
				t.tileShadingApron,
				t.tileShadingAnisotropicApron,
				t.tileShadingAtomicOps,
				t.tileShadingImageProcessing
			)
		end,
	}
)
mod.VkPhysicalDeviceTileShadingPropertiesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxApronSize;
	$ preferNonCoherent;
	$ tileGranularity;
	$ maxTileShadingRate;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkExtent2D,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkPhysicalDeviceTileShadingPropertiesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTileShadingPropertiesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxApronSize,
				t.preferNonCoherent,
				t.tileGranularity,
				t.maxTileShadingRate
			)
		end,
	}
)
mod.VkRenderPassTileShadingCreateInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ tileApronSize;
}]],
	mod.VkStructureType,
	mod.VkTileShadingRenderPassFlagsQCOM,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkRenderPassTileShadingCreateInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkRenderPassTileShadingCreateInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.tileApronSize)
		end,
	}
)
mod.VkPerTileBeginInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
ffi.metatype(
	mod.VkPerTileBeginInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkPerTileBeginInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext)
		end,
	}
)
mod.VkPerTileEndInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
ffi.metatype(
	mod.VkPerTileEndInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkPerTileEndInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext)
		end,
	}
)
mod.VkDispatchTileInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
ffi.metatype(
	mod.VkDispatchTileInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkDispatchTileInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext)
		end,
	}
)
mod.PFN_vkCmdDispatchTileQCOM = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDispatchTileInfoQCOM)
mod.PFN_vkCmdBeginPerTileExecutionQCOM = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPerTileBeginInfoQCOM)
mod.PFN_vkCmdEndPerTileExecutionQCOM = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPerTileEndInfoQCOM)
ffi.cdef(
	[[void  vkCmdDispatchTileQCOM($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDispatchTileInfoQCOM
)
ffi.cdef(
	[[void  vkCmdBeginPerTileExecutionQCOM($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkPerTileBeginInfoQCOM
)
ffi.cdef(
	[[void  vkCmdEndPerTileExecutionQCOM($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkPerTileEndInfoQCOM
)
mod.VkQueryLowLatencySupportNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	void* pQueriedLowLatencyData;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkQueryLowLatencySupportNV,
	{
		__tostring = function(s)
			return ("struct VkQueryLowLatencySupportNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pQueriedLowLatencyData)
		end,
	}
)
mod.VkAccelerationStructureKHR = ffi.typeof([[void*]])
mod.VkPhysicalDeviceDescriptorBufferPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ combinedImageSamplerDescriptorSingleArray;
	$ bufferlessPushDescriptors;
	$ allowSamplerImageViewPostSubmitCreation;
	$ descriptorBufferOffsetAlignment;
	uint32_t maxDescriptorBufferBindings;
	uint32_t maxResourceDescriptorBufferBindings;
	uint32_t maxSamplerDescriptorBufferBindings;
	uint32_t maxEmbeddedImmutableSamplerBindings;
	uint32_t maxEmbeddedImmutableSamplers;
	size_t bufferCaptureReplayDescriptorDataSize;
	size_t imageCaptureReplayDescriptorDataSize;
	size_t imageViewCaptureReplayDescriptorDataSize;
	size_t samplerCaptureReplayDescriptorDataSize;
	size_t accelerationStructureCaptureReplayDescriptorDataSize;
	size_t samplerDescriptorSize;
	size_t combinedImageSamplerDescriptorSize;
	size_t sampledImageDescriptorSize;
	size_t storageImageDescriptorSize;
	size_t uniformTexelBufferDescriptorSize;
	size_t robustUniformTexelBufferDescriptorSize;
	size_t storageTexelBufferDescriptorSize;
	size_t robustStorageTexelBufferDescriptorSize;
	size_t uniformBufferDescriptorSize;
	size_t robustUniformBufferDescriptorSize;
	size_t storageBufferDescriptorSize;
	size_t robustStorageBufferDescriptorSize;
	size_t inputAttachmentDescriptorSize;
	size_t accelerationStructureDescriptorSize;
	$ maxSamplerDescriptorBufferRange;
	$ maxResourceDescriptorBufferRange;
	$ samplerDescriptorBufferAddressSpaceSize;
	$ resourceDescriptorBufferAddressSpaceSize;
	$ descriptorBufferAddressSpaceSize;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkPhysicalDeviceDescriptorBufferPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDescriptorBufferPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.combinedImageSamplerDescriptorSingleArray,
				t.bufferlessPushDescriptors,
				t.allowSamplerImageViewPostSubmitCreation,
				t.descriptorBufferOffsetAlignment,
				t.maxDescriptorBufferBindings,
				t.maxResourceDescriptorBufferBindings,
				t.maxSamplerDescriptorBufferBindings,
				t.maxEmbeddedImmutableSamplerBindings,
				t.maxEmbeddedImmutableSamplers,
				t.bufferCaptureReplayDescriptorDataSize,
				t.imageCaptureReplayDescriptorDataSize,
				t.imageViewCaptureReplayDescriptorDataSize,
				t.samplerCaptureReplayDescriptorDataSize,
				t.accelerationStructureCaptureReplayDescriptorDataSize,
				t.samplerDescriptorSize,
				t.combinedImageSamplerDescriptorSize,
				t.sampledImageDescriptorSize,
				t.storageImageDescriptorSize,
				t.uniformTexelBufferDescriptorSize,
				t.robustUniformTexelBufferDescriptorSize,
				t.storageTexelBufferDescriptorSize,
				t.robustStorageTexelBufferDescriptorSize,
				t.uniformBufferDescriptorSize,
				t.robustUniformBufferDescriptorSize,
				t.storageBufferDescriptorSize,
				t.robustStorageBufferDescriptorSize,
				t.inputAttachmentDescriptorSize,
				t.accelerationStructureDescriptorSize,
				t.maxSamplerDescriptorBufferRange,
				t.maxResourceDescriptorBufferRange,
				t.samplerDescriptorBufferAddressSpaceSize,
				t.resourceDescriptorBufferAddressSpaceSize,
				t.descriptorBufferAddressSpaceSize
			)
		end,
	}
)
mod.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	size_t combinedImageSamplerDensityMapDescriptorSize;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.combinedImageSamplerDensityMapDescriptorSize)
		end,
	}
)
mod.VkPhysicalDeviceDescriptorBufferFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ descriptorBuffer;
	$ descriptorBufferCaptureReplay;
	$ descriptorBufferImageLayoutIgnored;
	$ descriptorBufferPushDescriptors;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDescriptorBufferFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDescriptorBufferFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.descriptorBuffer,
				t.descriptorBufferCaptureReplay,
				t.descriptorBufferImageLayoutIgnored,
				t.descriptorBufferPushDescriptors
			)
		end,
	}
)
mod.VkDescriptorAddressInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ address;
	$ range;
	$ format;
}]],
	mod.VkStructureType,
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkFormat
)
ffi.metatype(
	mod.VkDescriptorAddressInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDescriptorAddressInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.address, t.range, t.format)
		end,
	}
)
mod.VkDescriptorBufferBindingInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ address;
	$ usage;
}]],
	mod.VkStructureType,
	mod.VkDeviceAddress,
	mod.VkBufferUsageFlags
)
ffi.metatype(
	mod.VkDescriptorBufferBindingInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDescriptorBufferBindingInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.address, t.usage)
		end,
	}
)
mod.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ buffer;
}]],
	mod.VkStructureType,
	mod.VkBuffer
)
ffi.metatype(
	mod.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT,
	{
		__tostring = function(s)
			return ("struct VkDescriptorBufferBindingPushDescriptorBufferHandleEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.buffer)
		end,
	}
)
mod.VkDescriptorDataEXT = ffi.typeof(
	[[union {
	const $* pSampler;
	const $* pCombinedImageSampler;
	const $* pInputAttachmentImage;
	const $* pSampledImage;
	const $* pStorageImage;
	const $* pUniformTexelBuffer;
	const $* pStorageTexelBuffer;
	const $* pUniformBuffer;
	const $* pStorageBuffer;
	$ accelerationStructure;
}]],
	mod.VkSampler,
	mod.VkDescriptorImageInfo,
	mod.VkDescriptorImageInfo,
	mod.VkDescriptorImageInfo,
	mod.VkDescriptorImageInfo,
	mod.VkDescriptorAddressInfoEXT,
	mod.VkDescriptorAddressInfoEXT,
	mod.VkDescriptorAddressInfoEXT,
	mod.VkDescriptorAddressInfoEXT,
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkDescriptorDataEXT,
	{
		__tostring = function(s)
			return ("struct VkDescriptorDataEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.pSampler ~= nil then obj.pSampler = t.pSampler end

			if t.pCombinedImageSampler ~= nil then
				obj.pCombinedImageSampler = t.pCombinedImageSampler
			end

			if t.pInputAttachmentImage ~= nil then
				obj.pInputAttachmentImage = t.pInputAttachmentImage
			end

			if t.pSampledImage ~= nil then obj.pSampledImage = t.pSampledImage end

			if t.pStorageImage ~= nil then obj.pStorageImage = t.pStorageImage end

			if t.pUniformTexelBuffer ~= nil then
				obj.pUniformTexelBuffer = t.pUniformTexelBuffer
			end

			if t.pStorageTexelBuffer ~= nil then
				obj.pStorageTexelBuffer = t.pStorageTexelBuffer
			end

			if t.pUniformBuffer ~= nil then obj.pUniformBuffer = t.pUniformBuffer end

			if t.pStorageBuffer ~= nil then obj.pStorageBuffer = t.pStorageBuffer end

			if t.accelerationStructure ~= nil then
				obj.accelerationStructure = t.accelerationStructure
			end

			return obj
		end,
	}
)
mod.VkDescriptorGetInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ data;
}]],
	mod.VkStructureType,
	mod.VkDescriptorType,
	mod.VkDescriptorDataEXT
)
ffi.metatype(
	mod.VkDescriptorGetInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDescriptorGetInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.type, t.data)
		end,
	}
)
mod.VkBufferCaptureDescriptorDataInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ buffer;
}]],
	mod.VkStructureType,
	mod.VkBuffer
)
ffi.metatype(
	mod.VkBufferCaptureDescriptorDataInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkBufferCaptureDescriptorDataInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.buffer)
		end,
	}
)
mod.VkImageCaptureDescriptorDataInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ image;
}]],
	mod.VkStructureType,
	mod.VkImage
)
ffi.metatype(
	mod.VkImageCaptureDescriptorDataInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImageCaptureDescriptorDataInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.image)
		end,
	}
)
mod.VkImageViewCaptureDescriptorDataInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ imageView;
}]],
	mod.VkStructureType,
	mod.VkImageView
)
ffi.metatype(
	mod.VkImageViewCaptureDescriptorDataInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImageViewCaptureDescriptorDataInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageView)
		end,
	}
)
mod.VkSamplerCaptureDescriptorDataInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ sampler;
}]],
	mod.VkStructureType,
	mod.VkSampler
)
ffi.metatype(
	mod.VkSamplerCaptureDescriptorDataInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkSamplerCaptureDescriptorDataInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.sampler)
		end,
	}
)
mod.VkOpaqueCaptureDescriptorDataCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const void* opaqueCaptureDescriptorData;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkOpaqueCaptureDescriptorDataCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkOpaqueCaptureDescriptorDataCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.opaqueCaptureDescriptorData)
		end,
	}
)
mod.VkAccelerationStructureCaptureDescriptorDataInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ accelerationStructure;
	$ accelerationStructureNV;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureKHR,
	mod.VkAccelerationStructureNV
)
ffi.metatype(
	mod.VkAccelerationStructureCaptureDescriptorDataInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureCaptureDescriptorDataInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.accelerationStructure, t.accelerationStructureNV)
		end,
	}
)
mod.PFN_vkGetDescriptorSetLayoutSizeEXT = ffi.typeof(
	[[void (*)($ , $ , $*)]],
	mod.VkDevice,
	mod.VkDescriptorSetLayout,
	mod.VkDeviceSize
)
mod.PFN_vkGetDescriptorSetLayoutBindingOffsetEXT = ffi.typeof(
	[[void (*)($ , $ , uint32_t , $*)]],
	mod.VkDevice,
	mod.VkDescriptorSetLayout,
	mod.VkDeviceSize
)
mod.PFN_vkGetDescriptorEXT = ffi.typeof(
	[[void (*)($ , const $*, size_t , void*)]],
	mod.VkDevice,
	mod.VkDescriptorGetInfoEXT
)
mod.PFN_vkCmdBindDescriptorBuffersEXT = ffi.typeof(
	[[void (*)($ , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkDescriptorBufferBindingInfoEXT
)
mod.PFN_vkCmdSetDescriptorBufferOffsetsEXT = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , uint32_t , const uint32_t*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipelineLayout,
	mod.VkDeviceSize
)
mod.PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipelineLayout
)
mod.PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT = ffi.typeof(
	[[$ (*)($ , const $*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBufferCaptureDescriptorDataInfoEXT
)
mod.PFN_vkGetImageOpaqueCaptureDescriptorDataEXT = ffi.typeof(
	[[$ (*)($ , const $*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImageCaptureDescriptorDataInfoEXT
)
mod.PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT = ffi.typeof(
	[[$ (*)($ , const $*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImageViewCaptureDescriptorDataInfoEXT
)
mod.PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT = ffi.typeof(
	[[$ (*)($ , const $*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSamplerCaptureDescriptorDataInfoEXT
)
mod.PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = ffi.typeof(
	[[$ (*)($ , const $*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAccelerationStructureCaptureDescriptorDataInfoEXT
)
ffi.cdef(
	[[void  vkGetDescriptorSetLayoutSizeEXT($ , $ , $*);]],
	mod.VkDevice,
	mod.VkDescriptorSetLayout,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkGetDescriptorSetLayoutBindingOffsetEXT($ , $ , uint32_t , $*);]],
	mod.VkDevice,
	mod.VkDescriptorSetLayout,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkGetDescriptorEXT($ , const $*, size_t , void*);]],
	mod.VkDevice,
	mod.VkDescriptorGetInfoEXT
)
ffi.cdef(
	[[void  vkCmdBindDescriptorBuffersEXT($ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDescriptorBufferBindingInfoEXT
)
ffi.cdef(
	[[void  vkCmdSetDescriptorBufferOffsetsEXT($ , $ , $ , uint32_t , uint32_t , const uint32_t*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipelineLayout,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdBindDescriptorBufferEmbeddedSamplersEXT($ , $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipelineLayout
)
ffi.cdef(
	[[$  vkGetBufferOpaqueCaptureDescriptorDataEXT($ , const $*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBufferCaptureDescriptorDataInfoEXT
)
ffi.cdef(
	[[$  vkGetImageOpaqueCaptureDescriptorDataEXT($ , const $*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImageCaptureDescriptorDataInfoEXT
)
ffi.cdef(
	[[$  vkGetImageViewOpaqueCaptureDescriptorDataEXT($ , const $*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkImageViewCaptureDescriptorDataInfoEXT
)
ffi.cdef(
	[[$  vkGetSamplerOpaqueCaptureDescriptorDataEXT($ , const $*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSamplerCaptureDescriptorDataInfoEXT
)
ffi.cdef(
	[[$  vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT($ , const $*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAccelerationStructureCaptureDescriptorDataInfoEXT
)
mod.VkGraphicsPipelineLibraryFlagBitsEXT = ffi.typeof([[enum {
	VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 0x00000001,
	VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 0x00000002,
	VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 0x00000004,
	VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 0x00000008,
	VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkGraphicsPipelineLibraryFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ graphicsPipelineLibrary;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.graphicsPipelineLibrary)
		end,
	}
)
mod.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ graphicsPipelineLibraryFastLinking;
	$ graphicsPipelineLibraryIndependentInterpolationDecoration;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.graphicsPipelineLibraryFastLinking,
				t.graphicsPipelineLibraryIndependentInterpolationDecoration
			)
		end,
	}
)
mod.VkGraphicsPipelineLibraryCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkGraphicsPipelineLibraryFlagsEXT
)
ffi.metatype(
	mod.VkGraphicsPipelineLibraryCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkGraphicsPipelineLibraryCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderEarlyAndLateFragmentTests;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderEarlyAndLateFragmentTests)
		end,
	}
)
mod.VkFragmentShadingRateTypeNV = ffi.typeof([[enum {
	VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
	VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
	VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkFragmentShadingRateNV = ffi.typeof([[enum {
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
	VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
	VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
	VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
	VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
	VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
	VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ fragmentShadingRateEnums;
	$ supersampleFragmentShadingRates;
	$ noInvocationFragmentShadingRates;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.fragmentShadingRateEnums,
				t.supersampleFragmentShadingRates,
				t.noInvocationFragmentShadingRates
			)
		end,
	}
)
mod.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maxFragmentShadingRateInvocationCount;
}]],
	mod.VkStructureType,
	mod.VkSampleCountFlagBits
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxFragmentShadingRateInvocationCount)
		end,
	}
)
mod.VkPipelineFragmentShadingRateEnumStateCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ shadingRateType;
	$ shadingRate;
	$ combinerOps[2];
}]],
	mod.VkStructureType,
	mod.VkFragmentShadingRateTypeNV,
	mod.VkFragmentShadingRateNV,
	mod.VkFragmentShadingRateCombinerOpKHR
)
ffi.metatype(
	mod.VkPipelineFragmentShadingRateEnumStateCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkPipelineFragmentShadingRateEnumStateCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shadingRateType, t.shadingRate, t.combinerOps)
		end,
	}
)
mod.PFN_vkCmdSetFragmentShadingRateEnumNV = ffi.typeof(
	[[void (*)($ , $ , const $[2])]],
	mod.VkCommandBuffer,
	mod.VkFragmentShadingRateNV,
	mod.VkFragmentShadingRateCombinerOpKHR
)
ffi.cdef(
	[[void  vkCmdSetFragmentShadingRateEnumNV($ , $ , const $[2]);]],
	mod.VkCommandBuffer,
	mod.VkFragmentShadingRateNV,
	mod.VkFragmentShadingRateCombinerOpKHR
)
mod.VkAccelerationStructureMotionInstanceTypeNV = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureMotionInfoFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkAccelerationStructureMotionInstanceFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDeviceOrHostAddressConstKHR = ffi.typeof([[union {
	$ deviceAddress;
	const void* hostAddress;
}]], mod.VkDeviceAddress)
ffi.metatype(
	mod.VkDeviceOrHostAddressConstKHR,
	{
		__tostring = function(s)
			return ("struct VkDeviceOrHostAddressConstKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.deviceAddress ~= nil then obj.deviceAddress = t.deviceAddress end

			if t.hostAddress ~= nil then obj.hostAddress = t.hostAddress end

			return obj
		end,
	}
)
mod.VkAccelerationStructureGeometryMotionTrianglesDataNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ vertexData;
}]],
	mod.VkStructureType,
	mod.VkDeviceOrHostAddressConstKHR
)
ffi.metatype(
	mod.VkAccelerationStructureGeometryMotionTrianglesDataNV,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureGeometryMotionTrianglesDataNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.vertexData)
		end,
	}
)
mod.VkAccelerationStructureMotionInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t maxInstances;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureMotionInfoFlagsNV
)
ffi.metatype(
	mod.VkAccelerationStructureMotionInfoNV,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureMotionInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxInstances, t.flags)
		end,
	}
)
mod.VkAccelerationStructureMatrixMotionInstanceNV = ffi.typeof(
	[[struct {
	$ transformT0;
	$ transformT1;
	uint32_t instanceCustomIndex;
	uint32_t mask;
	uint32_t instanceShaderBindingTableRecordOffset;
	$ flags;
	uint64_t accelerationStructureReference;
}]],
	mod.VkTransformMatrixKHR,
	mod.VkTransformMatrixKHR,
	mod.VkGeometryInstanceFlagsKHR
)
ffi.metatype(
	mod.VkAccelerationStructureMatrixMotionInstanceNV,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureMatrixMotionInstanceNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.transformT0,
				t.transformT1,
				t.instanceCustomIndex,
				t.mask,
				t.instanceShaderBindingTableRecordOffset,
				t.flags,
				t.accelerationStructureReference
			)
		end,
	}
)
mod.VkSRTDataNV = ffi.typeof([[struct {
	float sx;
	float a;
	float b;
	float pvx;
	float sy;
	float c;
	float pvy;
	float sz;
	float pvz;
	float qx;
	float qy;
	float qz;
	float qw;
	float tx;
	float ty;
	float tz;
}]])
ffi.metatype(
	mod.VkSRTDataNV,
	{
		__tostring = function(s)
			return ("struct VkSRTDataNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sx,
				t.a,
				t.b,
				t.pvx,
				t.sy,
				t.c,
				t.pvy,
				t.sz,
				t.pvz,
				t.qx,
				t.qy,
				t.qz,
				t.qw,
				t.tx,
				t.ty,
				t.tz
			)
		end,
	}
)
mod.VkAccelerationStructureSRTMotionInstanceNV = ffi.typeof(
	[[struct {
	$ transformT0;
	$ transformT1;
	uint32_t instanceCustomIndex;
	uint32_t mask;
	uint32_t instanceShaderBindingTableRecordOffset;
	$ flags;
	uint64_t accelerationStructureReference;
}]],
	mod.VkSRTDataNV,
	mod.VkSRTDataNV,
	mod.VkGeometryInstanceFlagsKHR
)
ffi.metatype(
	mod.VkAccelerationStructureSRTMotionInstanceNV,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureSRTMotionInstanceNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.transformT0,
				t.transformT1,
				t.instanceCustomIndex,
				t.mask,
				t.instanceShaderBindingTableRecordOffset,
				t.flags,
				t.accelerationStructureReference
			)
		end,
	}
)
mod.VkAccelerationStructureMotionInstanceDataNV = ffi.typeof(
	[[union {
	$ staticInstance;
	$ matrixMotionInstance;
	$ srtMotionInstance;
}]],
	mod.VkAccelerationStructureInstanceKHR,
	mod.VkAccelerationStructureMatrixMotionInstanceNV,
	mod.VkAccelerationStructureSRTMotionInstanceNV
)
ffi.metatype(
	mod.VkAccelerationStructureMotionInstanceDataNV,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureMotionInstanceDataNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.staticInstance ~= nil then obj.staticInstance = t.staticInstance end

			if t.matrixMotionInstance ~= nil then
				obj.matrixMotionInstance = t.matrixMotionInstance
			end

			if t.srtMotionInstance ~= nil then
				obj.srtMotionInstance = t.srtMotionInstance
			end

			return obj
		end,
	}
)
mod.VkAccelerationStructureMotionInstanceNV = ffi.typeof(
	[[struct {
	$ type;
	$ flags;
	$ data;
}]],
	mod.VkAccelerationStructureMotionInstanceTypeNV,
	mod.VkAccelerationStructureMotionInstanceFlagsNV,
	mod.VkAccelerationStructureMotionInstanceDataNV
)
ffi.metatype(
	mod.VkAccelerationStructureMotionInstanceNV,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureMotionInstanceNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.type, t.flags, t.data)
		end,
	}
)
mod.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ rayTracingMotionBlur;
	$ rayTracingMotionBlurPipelineTraceRaysIndirect;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRayTracingMotionBlurFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.rayTracingMotionBlur,
				t.rayTracingMotionBlurPipelineTraceRaysIndirect
			)
		end,
	}
)
mod.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ ycbcr2plane444Formats;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.ycbcr2plane444Formats)
		end,
	}
)
mod.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ fragmentDensityMapDeferred;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.fragmentDensityMapDeferred)
		end,
	}
)
mod.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ subsampledLoads;
	$ subsampledCoarseReconstructionEarlyAccess;
	uint32_t maxSubsampledArrayLayers;
	uint32_t maxDescriptorSetSubsampledSamplers;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.subsampledLoads,
				t.subsampledCoarseReconstructionEarlyAccess,
				t.maxSubsampledArrayLayers,
				t.maxDescriptorSetSubsampledSamplers
			)
		end,
	}
)
mod.VkCopyCommandTransformInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ transform;
}]],
	mod.VkStructureType,
	mod.VkSurfaceTransformFlagBitsKHR
)
ffi.metatype(
	mod.VkCopyCommandTransformInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkCopyCommandTransformInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.transform)
		end,
	}
)
mod.VkPhysicalDeviceImageRobustnessFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceImageRobustnessFeatures)
mod.VkImageCompressionFlagBitsEXT = ffi.typeof([[enum {
	VK_IMAGE_COMPRESSION_DEFAULT_EXT = 0,
	VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = 0x00000001,
	VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = 0x00000002,
	VK_IMAGE_COMPRESSION_DISABLED_EXT = 0x00000004,
	VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkImageCompressionFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkImageCompressionFixedRateFlagBitsEXT = ffi.typeof([[enum {
	VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = 0,
	VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = 0x00000001,
	VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = 0x00000002,
	VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = 0x00000004,
	VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = 0x00000008,
	VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = 0x00000010,
	VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = 0x00000020,
	VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = 0x00000040,
	VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = 0x00000080,
	VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = 0x00000100,
	VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = 0x00000200,
	VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = 0x00000400,
	VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = 0x00000800,
	VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = 0x00001000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = 0x00002000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = 0x00004000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = 0x00008000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = 0x00010000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = 0x00020000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = 0x00040000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = 0x00080000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = 0x00100000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = 0x00200000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = 0x00400000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = 0x00800000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkImageCompressionFixedRateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceImageCompressionControlFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ imageCompressionControl;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceImageCompressionControlFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageCompressionControlFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageCompressionControl)
		end,
	}
)
mod.VkImageCompressionControlEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t compressionControlPlaneCount;
	$* pFixedRateFlags;
}]],
	mod.VkStructureType,
	mod.VkImageCompressionFlagsEXT,
	mod.VkImageCompressionFixedRateFlagsEXT
)
ffi.metatype(
	mod.VkImageCompressionControlEXT,
	{
		__tostring = function(s)
			return ("struct VkImageCompressionControlEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.compressionControlPlaneCount,
				t.pFixedRateFlags
			)
		end,
	}
)
mod.VkImageCompressionPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ imageCompressionFlags;
	$ imageCompressionFixedRateFlags;
}]],
	mod.VkStructureType,
	mod.VkImageCompressionFlagsEXT,
	mod.VkImageCompressionFixedRateFlagsEXT
)
ffi.metatype(
	mod.VkImageCompressionPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkImageCompressionPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.imageCompressionFlags,
				t.imageCompressionFixedRateFlags
			)
		end,
	}
)
mod.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ attachmentFeedbackLoopLayout;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.attachmentFeedbackLoopLayout)
		end,
	}
)
mod.VkPhysicalDevice4444FormatsFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ formatA4R4G4B4;
	$ formatA4B4G4R4;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevice4444FormatsFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevice4444FormatsFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.formatA4R4G4B4, t.formatA4B4G4R4)
		end,
	}
)
mod.VkDeviceFaultAddressTypeEXT = ffi.typeof([[enum {
	VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0,
	VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1,
	VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2,
	VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6,
	VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDeviceFaultVendorBinaryHeaderVersionEXT = ffi.typeof([[enum {
	VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1,
	VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceFaultFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ deviceFault;
	$ deviceFaultVendorBinary;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFaultFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFaultFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.deviceFault, t.deviceFaultVendorBinary)
		end,
	}
)
mod.VkDeviceFaultCountsEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t addressInfoCount;
	uint32_t vendorInfoCount;
	$ vendorBinarySize;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkDeviceFaultCountsEXT,
	{
		__tostring = function(s)
			return ("struct VkDeviceFaultCountsEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.addressInfoCount,
				t.vendorInfoCount,
				t.vendorBinarySize
			)
		end,
	}
)
mod.VkDeviceFaultAddressInfoEXT = ffi.typeof(
	[[struct {
	$ addressType;
	$ reportedAddress;
	$ addressPrecision;
}]],
	mod.VkDeviceFaultAddressTypeEXT,
	mod.VkDeviceAddress,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkDeviceFaultAddressInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDeviceFaultAddressInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.addressType, t.reportedAddress, t.addressPrecision)
		end,
	}
)
mod.VkDeviceFaultVendorInfoEXT = ffi.typeof([[struct {
	char description[256U];
	uint64_t vendorFaultCode;
	uint64_t vendorFaultData;
}]])
ffi.metatype(
	mod.VkDeviceFaultVendorInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDeviceFaultVendorInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.description, t.vendorFaultCode, t.vendorFaultData)
		end,
	}
)
mod.VkDeviceFaultInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	char description[256U];
	$* pAddressInfos;
	$* pVendorInfos;
	void* pVendorBinaryData;
}]],
	mod.VkStructureType,
	mod.VkDeviceFaultAddressInfoEXT,
	mod.VkDeviceFaultVendorInfoEXT
)
ffi.metatype(
	mod.VkDeviceFaultInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDeviceFaultInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.description,
				t.pAddressInfos,
				t.pVendorInfos,
				t.pVendorBinaryData
			)
		end,
	}
)
mod.VkDeviceFaultVendorBinaryHeaderVersionOneEXT = ffi.typeof(
	[[struct {
	uint32_t headerSize;
	$ headerVersion;
	uint32_t vendorID;
	uint32_t deviceID;
	uint32_t driverVersion;
	uint8_t pipelineCacheUUID[16U];
	uint32_t applicationNameOffset;
	uint32_t applicationVersion;
	uint32_t engineNameOffset;
	uint32_t engineVersion;
	uint32_t apiVersion;
}]],
	mod.VkDeviceFaultVendorBinaryHeaderVersionEXT
)
ffi.metatype(
	mod.VkDeviceFaultVendorBinaryHeaderVersionOneEXT,
	{
		__tostring = function(s)
			return ("struct VkDeviceFaultVendorBinaryHeaderVersionOneEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.headerSize,
				t.headerVersion,
				t.vendorID,
				t.deviceID,
				t.driverVersion,
				t.pipelineCacheUUID,
				t.applicationNameOffset,
				t.applicationVersion,
				t.engineNameOffset,
				t.engineVersion,
				t.apiVersion
			)
		end,
	}
)
mod.PFN_vkGetDeviceFaultInfoEXT = ffi.typeof(
	[[$ (*)($ , $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeviceFaultCountsEXT,
	mod.VkDeviceFaultInfoEXT
)
ffi.cdef(
	[[$  vkGetDeviceFaultInfoEXT($ , $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeviceFaultCountsEXT,
	mod.VkDeviceFaultInfoEXT
)
mod.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ rasterizationOrderColorAttachmentAccess;
	$ rasterizationOrderDepthAttachmentAccess;
	$ rasterizationOrderStencilAttachmentAccess;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.rasterizationOrderColorAttachmentAccess,
				t.rasterizationOrderDepthAttachmentAccess,
				t.rasterizationOrderStencilAttachmentAccess
			)
		end,
	}
)
mod.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = ffi.typeof([[$ ]], mod.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT)
mod.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ formatRgba10x6WithoutYCbCrSampler;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.formatRgba10x6WithoutYCbCrSampler)
		end,
	}
)
mod.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ mutableDescriptorType;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.mutableDescriptorType)
		end,
	}
)
mod.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT)
mod.VkMutableDescriptorTypeListEXT = ffi.typeof(
	[[struct {
	uint32_t descriptorTypeCount;
	const $* pDescriptorTypes;
}]],
	mod.VkDescriptorType
)
ffi.metatype(
	mod.VkMutableDescriptorTypeListEXT,
	{
		__tostring = function(s)
			return ("struct VkMutableDescriptorTypeListEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.descriptorTypeCount, t.pDescriptorTypes)
		end,
	}
)
mod.VkMutableDescriptorTypeListVALVE = ffi.typeof([[$ ]], mod.VkMutableDescriptorTypeListEXT)
mod.VkMutableDescriptorTypeCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t mutableDescriptorTypeListCount;
	const $* pMutableDescriptorTypeLists;
}]],
	mod.VkStructureType,
	mod.VkMutableDescriptorTypeListEXT
)
ffi.metatype(
	mod.VkMutableDescriptorTypeCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMutableDescriptorTypeCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.mutableDescriptorTypeListCount,
				t.pMutableDescriptorTypeLists
			)
		end,
	}
)
mod.VkMutableDescriptorTypeCreateInfoVALVE = ffi.typeof([[$ ]], mod.VkMutableDescriptorTypeCreateInfoEXT)
mod.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ vertexInputDynamicState;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.vertexInputDynamicState)
		end,
	}
)
mod.VkVertexInputBindingDescription2EXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t binding;
	uint32_t stride;
	$ inputRate;
	uint32_t divisor;
}]],
	mod.VkStructureType,
	mod.VkVertexInputRate
)
ffi.metatype(
	mod.VkVertexInputBindingDescription2EXT,
	{
		__tostring = function(s)
			return ("struct VkVertexInputBindingDescription2EXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.binding, t.stride, t.inputRate, t.divisor)
		end,
	}
)
mod.VkVertexInputAttributeDescription2EXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t location;
	uint32_t binding;
	$ format;
	uint32_t offset;
}]],
	mod.VkStructureType,
	mod.VkFormat
)
ffi.metatype(
	mod.VkVertexInputAttributeDescription2EXT,
	{
		__tostring = function(s)
			return ("struct VkVertexInputAttributeDescription2EXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.location, t.binding, t.format, t.offset)
		end,
	}
)
mod.PFN_vkCmdSetVertexInputEXT = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkVertexInputBindingDescription2EXT,
	mod.VkVertexInputAttributeDescription2EXT
)
ffi.cdef(
	[[void  vkCmdSetVertexInputEXT($ , uint32_t , const $*, uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkVertexInputBindingDescription2EXT,
	mod.VkVertexInputAttributeDescription2EXT
)
mod.VkPhysicalDeviceDrmPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ hasPrimary;
	$ hasRender;
	int64_t primaryMajor;
	int64_t primaryMinor;
	int64_t renderMajor;
	int64_t renderMinor;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDrmPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDrmPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.hasPrimary,
				t.hasRender,
				t.primaryMajor,
				t.primaryMinor,
				t.renderMajor,
				t.renderMinor
			)
		end,
	}
)
mod.VkDeviceAddressBindingTypeEXT = ffi.typeof([[enum {
	VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0,
	VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1,
	VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDeviceAddressBindingFlagBitsEXT = ffi.typeof([[enum {
	VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = 0x00000001,
	VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDeviceAddressBindingFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceAddressBindingReportFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ reportAddressBinding;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceAddressBindingReportFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceAddressBindingReportFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.reportAddressBinding)
		end,
	}
)
mod.VkDeviceAddressBindingCallbackDataEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ baseAddress;
	$ size;
	$ bindingType;
}]],
	mod.VkStructureType,
	mod.VkDeviceAddressBindingFlagsEXT,
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkDeviceAddressBindingTypeEXT
)
ffi.metatype(
	mod.VkDeviceAddressBindingCallbackDataEXT,
	{
		__tostring = function(s)
			return ("struct VkDeviceAddressBindingCallbackDataEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.baseAddress, t.size, t.bindingType)
		end,
	}
)
mod.VkPhysicalDeviceDepthClipControlFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ depthClipControl;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDepthClipControlFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDepthClipControlFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.depthClipControl)
		end,
	}
)
mod.VkPipelineViewportDepthClipControlCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ negativeOneToOne;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPipelineViewportDepthClipControlCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelineViewportDepthClipControlCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.negativeOneToOne)
		end,
	}
)
mod.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ primitiveTopologyListRestart;
	$ primitiveTopologyPatchListRestart;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.primitiveTopologyListRestart,
				t.primitiveTopologyPatchListRestart
			)
		end,
	}
)
mod.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR)
mod.VkSubpassShadingPipelineCreateInfoHUAWEI = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ renderPass;
	uint32_t subpass;
}]],
	mod.VkStructureType,
	mod.VkRenderPass
)
ffi.metatype(
	mod.VkSubpassShadingPipelineCreateInfoHUAWEI,
	{
		__tostring = function(s)
			return ("struct VkSubpassShadingPipelineCreateInfoHUAWEI[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.renderPass, t.subpass)
		end,
	}
)
mod.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ subpassShading;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSubpassShadingFeaturesHUAWEI[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.subpassShading)
		end,
	}
)
mod.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxSubpassShadingWorkgroupSizeAspectRatio;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSubpassShadingPropertiesHUAWEI[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxSubpassShadingWorkgroupSizeAspectRatio)
		end,
	}
)
mod.PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = ffi.typeof(
	[[$ (*)($ , $ , $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkRenderPass,
	mod.VkExtent2D
)
mod.PFN_vkCmdSubpassShadingHUAWEI = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
ffi.cdef(
	[[$  vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI($ , $ , $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkRenderPass,
	mod.VkExtent2D
)
ffi.cdef([[void  vkCmdSubpassShadingHUAWEI($ );]], mod.VkCommandBuffer)
mod.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ invocationMask;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceInvocationMaskFeaturesHUAWEI[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.invocationMask)
		end,
	}
)
mod.PFN_vkCmdBindInvocationMaskHUAWEI = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkImageView, mod.VkImageLayout)
ffi.cdef(
	[[void  vkCmdBindInvocationMaskHUAWEI($ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkImageView,
	mod.VkImageLayout
)
mod.VkRemoteAddressNV = ffi.typeof([[void*]])
mod.VkMemoryGetRemoteAddressInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ memory;
	$ handleType;
}]],
	mod.VkStructureType,
	mod.VkDeviceMemory,
	mod.VkExternalMemoryHandleTypeFlagBits
)
ffi.metatype(
	mod.VkMemoryGetRemoteAddressInfoNV,
	{
		__tostring = function(s)
			return ("struct VkMemoryGetRemoteAddressInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memory, t.handleType)
		end,
	}
)
mod.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ externalMemoryRDMA;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExternalMemoryRDMAFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.externalMemoryRDMA)
		end,
	}
)
mod.PFN_vkGetMemoryRemoteAddressNV = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryGetRemoteAddressInfoNV,
	mod.VkRemoteAddressNV
)
ffi.cdef(
	[[$  vkGetMemoryRemoteAddressNV($ , const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryGetRemoteAddressInfoNV,
	mod.VkRemoteAddressNV
)
mod.VkPipelineInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineInfoKHR)
mod.VkPipelinePropertiesIdentifierEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint8_t pipelineIdentifier[16U];
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPipelinePropertiesIdentifierEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelinePropertiesIdentifierEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineIdentifier)
		end,
	}
)
mod.VkPhysicalDevicePipelinePropertiesFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelinePropertiesIdentifier;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePipelinePropertiesFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePipelinePropertiesFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelinePropertiesIdentifier)
		end,
	}
)
mod.PFN_vkGetPipelinePropertiesEXT = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineInfoEXT,
	mod.VkBaseOutStructure
)
ffi.cdef(
	[[$  vkGetPipelinePropertiesEXT($ , const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipelineInfoEXT,
	mod.VkBaseOutStructure
)
mod.VkFrameBoundaryFlagBitsEXT = ffi.typeof([[enum {
	VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT = 0x00000001,
	VK_FRAME_BOUNDARY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkFrameBoundaryFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceFrameBoundaryFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ frameBoundary;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFrameBoundaryFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFrameBoundaryFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.frameBoundary)
		end,
	}
)
mod.VkFrameBoundaryEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint64_t frameID;
	uint32_t imageCount;
	const $* pImages;
	uint32_t bufferCount;
	const $* pBuffers;
	uint64_t tagName;
	size_t tagSize;
	const void* pTag;
}]],
	mod.VkStructureType,
	mod.VkFrameBoundaryFlagsEXT,
	mod.VkImage,
	mod.VkBuffer
)
ffi.metatype(
	mod.VkFrameBoundaryEXT,
	{
		__tostring = function(s)
			return ("struct VkFrameBoundaryEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.frameID,
				t.imageCount,
				t.pImages,
				t.bufferCount,
				t.pBuffers,
				t.tagName,
				t.tagSize,
				t.pTag
			)
		end,
	}
)
mod.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ multisampledRenderToSingleSampled;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.multisampledRenderToSingleSampled)
		end,
	}
)
mod.VkSubpassResolvePerformanceQueryEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ optimal;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSubpassResolvePerformanceQueryEXT,
	{
		__tostring = function(s)
			return ("struct VkSubpassResolvePerformanceQueryEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.optimal)
		end,
	}
)
mod.VkMultisampledRenderToSingleSampledInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ multisampledRenderToSingleSampledEnable;
	$ rasterizationSamples;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkSampleCountFlagBits
)
ffi.metatype(
	mod.VkMultisampledRenderToSingleSampledInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMultisampledRenderToSingleSampledInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.multisampledRenderToSingleSampledEnable,
				t.rasterizationSamples
			)
		end,
	}
)
mod.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ extendedDynamicState2;
	$ extendedDynamicState2LogicOp;
	$ extendedDynamicState2PatchControlPoints;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExtendedDynamicState2FeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.extendedDynamicState2,
				t.extendedDynamicState2LogicOp,
				t.extendedDynamicState2PatchControlPoints
			)
		end,
	}
)
mod.PFN_vkCmdSetPatchControlPointsEXT = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetRasterizerDiscardEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthBiasEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetLogicOpEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkLogicOp)
mod.PFN_vkCmdSetPrimitiveRestartEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetPatchControlPointsEXT($ , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdSetRasterizerDiscardEnableEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef([[void  vkCmdSetDepthBiasEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetLogicOpEXT($ , $ );]], mod.VkCommandBuffer, mod.VkLogicOp)
ffi.cdef(
	[[void  vkCmdSetPrimitiveRestartEnableEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
mod.VkPhysicalDeviceColorWriteEnableFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ colorWriteEnable;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceColorWriteEnableFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceColorWriteEnableFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.colorWriteEnable)
		end,
	}
)
mod.VkPipelineColorWriteCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t attachmentCount;
	const $* pColorWriteEnables;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPipelineColorWriteCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelineColorWriteCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.attachmentCount, t.pColorWriteEnables)
		end,
	}
)
mod.PFN_vkCmdSetColorWriteEnableEXT = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef(
	[[void  vkCmdSetColorWriteEnableEXT($ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
mod.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ primitivesGeneratedQuery;
	$ primitivesGeneratedQueryWithRasterizerDiscard;
	$ primitivesGeneratedQueryWithNonZeroStreams;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.primitivesGeneratedQuery,
				t.primitivesGeneratedQueryWithRasterizerDiscard,
				t.primitivesGeneratedQueryWithNonZeroStreams
			)
		end,
	}
)
mod.VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceGlobalPriorityQueryFeatures)
mod.VkQueueFamilyGlobalPriorityPropertiesEXT = ffi.typeof([[$ ]], mod.VkQueueFamilyGlobalPriorityProperties)
mod.VkVideoEncodeRgbModelConversionFlagBitsVALVE = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_RGB_IDENTITY_BIT_VALVE = 0x00000001,
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_IDENTITY_BIT_VALVE = 0x00000002,
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_709_BIT_VALVE = 0x00000004,
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_601_BIT_VALVE = 0x00000008,
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_2020_BIT_VALVE = 0x00000010,
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_FLAG_BITS_MAX_ENUM_VALVE = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeRgbModelConversionFlagsVALVE = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeRgbRangeCompressionFlagBitsVALVE = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_FULL_RANGE_BIT_VALVE = 0x00000001,
	VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_NARROW_RANGE_BIT_VALVE = 0x00000002,
	VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_FLAG_BITS_MAX_ENUM_VALVE = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeRgbRangeCompressionFlagsVALVE = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_COSITED_EVEN_BIT_VALVE = 0x00000001,
	VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_MIDPOINT_BIT_VALVE = 0x00000002,
	VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_FLAG_BITS_MAX_ENUM_VALVE = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeRgbChromaOffsetFlagsVALVE = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ videoEncodeRgbConversion;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.videoEncodeRgbConversion)
		end,
	}
)
mod.VkVideoEncodeRgbConversionCapabilitiesVALVE = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ rgbModels;
	$ rgbRanges;
	$ xChromaOffsets;
	$ yChromaOffsets;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeRgbModelConversionFlagsVALVE,
	mod.VkVideoEncodeRgbRangeCompressionFlagsVALVE,
	mod.VkVideoEncodeRgbChromaOffsetFlagsVALVE,
	mod.VkVideoEncodeRgbChromaOffsetFlagsVALVE
)
ffi.metatype(
	mod.VkVideoEncodeRgbConversionCapabilitiesVALVE,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeRgbConversionCapabilitiesVALVE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.rgbModels,
				t.rgbRanges,
				t.xChromaOffsets,
				t.yChromaOffsets
			)
		end,
	}
)
mod.VkVideoEncodeProfileRgbConversionInfoVALVE = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ performEncodeRgbConversion;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkVideoEncodeProfileRgbConversionInfoVALVE,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeProfileRgbConversionInfoVALVE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.performEncodeRgbConversion)
		end,
	}
)
mod.VkVideoEncodeSessionRgbConversionCreateInfoVALVE = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ rgbModel;
	$ rgbRange;
	$ xChromaOffset;
	$ yChromaOffset;
}]],
	mod.VkStructureType,
	mod.VkVideoEncodeRgbModelConversionFlagBitsVALVE,
	mod.VkVideoEncodeRgbRangeCompressionFlagBitsVALVE,
	mod.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE,
	mod.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE
)
ffi.metatype(
	mod.VkVideoEncodeSessionRgbConversionCreateInfoVALVE,
	{
		__tostring = function(s)
			return ("struct VkVideoEncodeSessionRgbConversionCreateInfoVALVE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.rgbModel,
				t.rgbRange,
				t.xChromaOffset,
				t.yChromaOffset
			)
		end,
	}
)
mod.VkPhysicalDeviceImageViewMinLodFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ minLod;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceImageViewMinLodFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageViewMinLodFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.minLod)
		end,
	}
)
mod.VkImageViewMinLodCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	float minLod;
}]], mod.VkStructureType)
ffi.metatype(
	mod.VkImageViewMinLodCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImageViewMinLodCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.minLod)
		end,
	}
)
mod.VkPhysicalDeviceMultiDrawFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ multiDraw;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMultiDrawFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMultiDrawFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.multiDraw)
		end,
	}
)
mod.VkPhysicalDeviceMultiDrawPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxMultiDrawCount;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceMultiDrawPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMultiDrawPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxMultiDrawCount)
		end,
	}
)
mod.VkMultiDrawInfoEXT = ffi.typeof([[struct {
	uint32_t firstVertex;
	uint32_t vertexCount;
}]])
ffi.metatype(
	mod.VkMultiDrawInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMultiDrawInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.firstVertex, t.vertexCount)
		end,
	}
)
mod.VkMultiDrawIndexedInfoEXT = ffi.typeof([[struct {
	uint32_t firstIndex;
	uint32_t indexCount;
	int32_t vertexOffset;
}]])
ffi.metatype(
	mod.VkMultiDrawIndexedInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMultiDrawIndexedInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.firstIndex, t.indexCount, t.vertexOffset)
		end,
	}
)
mod.PFN_vkCmdDrawMultiEXT = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, uint32_t , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkMultiDrawInfoEXT
)
mod.PFN_vkCmdDrawMultiIndexedEXT = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, uint32_t , uint32_t , uint32_t , const int32_t*)]],
	mod.VkCommandBuffer,
	mod.VkMultiDrawIndexedInfoEXT
)
ffi.cdef(
	[[void  vkCmdDrawMultiEXT($ , uint32_t , const $*, uint32_t , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkMultiDrawInfoEXT
)
ffi.cdef(
	[[void  vkCmdDrawMultiIndexedEXT($ , uint32_t , const $*, uint32_t , uint32_t , uint32_t , const int32_t*);]],
	mod.VkCommandBuffer,
	mod.VkMultiDrawIndexedInfoEXT
)
mod.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ image2DViewOf3D;
	$ sampler2DViewOf3D;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImage2DViewOf3DFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.image2DViewOf3D, t.sampler2DViewOf3D)
		end,
	}
)
mod.VkPhysicalDeviceShaderTileImageFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderTileImageColorReadAccess;
	$ shaderTileImageDepthReadAccess;
	$ shaderTileImageStencilReadAccess;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderTileImageFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderTileImageFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderTileImageColorReadAccess,
				t.shaderTileImageDepthReadAccess,
				t.shaderTileImageStencilReadAccess
			)
		end,
	}
)
mod.VkPhysicalDeviceShaderTileImagePropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderTileImageCoherentReadAccelerated;
	$ shaderTileImageReadSampleFromPixelRateInvocation;
	$ shaderTileImageReadFromHelperInvocation;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderTileImagePropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderTileImagePropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderTileImageCoherentReadAccelerated,
				t.shaderTileImageReadSampleFromPixelRateInvocation,
				t.shaderTileImageReadFromHelperInvocation
			)
		end,
	}
)
mod.VkMicromapEXT = ffi.typeof([[void*]])
mod.VkMicromapTypeEXT = ffi.typeof([[enum {
	VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0,
	VK_MICROMAP_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkBuildMicromapModeEXT = ffi.typeof([[enum {
	VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0,
	VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkCopyMicromapModeEXT = ffi.typeof([[enum {
	VK_COPY_MICROMAP_MODE_CLONE_EXT = 0,
	VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 1,
	VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2,
	VK_COPY_MICROMAP_MODE_COMPACT_EXT = 3,
	VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkOpacityMicromapFormatEXT = ffi.typeof([[enum {
	VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1,
	VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2,
	VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkOpacityMicromapSpecialIndexEXT = ffi.typeof([[enum {
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV = -5,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureCompatibilityKHR = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureBuildTypeKHR = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkBuildMicromapFlagBitsEXT = ffi.typeof([[enum {
	VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = 0x00000001,
	VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = 0x00000002,
	VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = 0x00000004,
	VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkBuildMicromapFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMicromapCreateFlagBitsEXT = ffi.typeof([[enum {
	VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x00000001,
	VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkMicromapCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMicromapUsageEXT = ffi.typeof([[struct {
	uint32_t count;
	uint32_t subdivisionLevel;
	uint32_t format;
}]])
ffi.metatype(
	mod.VkMicromapUsageEXT,
	{
		__tostring = function(s)
			return ("struct VkMicromapUsageEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.count, t.subdivisionLevel, t.format)
		end,
	}
)
mod.VkDeviceOrHostAddressKHR = ffi.typeof([[union {
	$ deviceAddress;
	void* hostAddress;
}]], mod.VkDeviceAddress)
ffi.metatype(
	mod.VkDeviceOrHostAddressKHR,
	{
		__tostring = function(s)
			return ("struct VkDeviceOrHostAddressKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.deviceAddress ~= nil then obj.deviceAddress = t.deviceAddress end

			if t.hostAddress ~= nil then obj.hostAddress = t.hostAddress end

			return obj
		end,
	}
)
mod.VkMicromapBuildInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ flags;
	$ mode;
	$ dstMicromap;
	uint32_t usageCountsCount;
	const $* pUsageCounts;
	const $** const ppUsageCounts;
	$ data;
	$ scratchData;
	$ triangleArray;
	$ triangleArrayStride;
}]],
	mod.VkStructureType,
	mod.VkMicromapTypeEXT,
	mod.VkBuildMicromapFlagsEXT,
	mod.VkBuildMicromapModeEXT,
	mod.VkMicromapEXT,
	mod.VkMicromapUsageEXT,
	mod.VkMicromapUsageEXT,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceOrHostAddressKHR,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkMicromapBuildInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMicromapBuildInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.type,
				t.flags,
				t.mode,
				t.dstMicromap,
				t.usageCountsCount,
				t.pUsageCounts,
				t.ppUsageCounts,
				t.data,
				t.scratchData,
				t.triangleArray,
				t.triangleArrayStride
			)
		end,
	}
)
mod.VkMicromapCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ createFlags;
	$ buffer;
	$ offset;
	$ size;
	$ type;
	$ deviceAddress;
}]],
	mod.VkStructureType,
	mod.VkMicromapCreateFlagsEXT,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkMicromapTypeEXT,
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkMicromapCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMicromapCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.createFlags,
				t.buffer,
				t.offset,
				t.size,
				t.type,
				t.deviceAddress
			)
		end,
	}
)
mod.VkPhysicalDeviceOpacityMicromapFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ micromap;
	$ micromapCaptureReplay;
	$ micromapHostCommands;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceOpacityMicromapFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceOpacityMicromapFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.micromap,
				t.micromapCaptureReplay,
				t.micromapHostCommands
			)
		end,
	}
)
mod.VkPhysicalDeviceOpacityMicromapPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxOpacity2StateSubdivisionLevel;
	uint32_t maxOpacity4StateSubdivisionLevel;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceOpacityMicromapPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceOpacityMicromapPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxOpacity2StateSubdivisionLevel,
				t.maxOpacity4StateSubdivisionLevel
			)
		end,
	}
)
mod.VkMicromapVersionInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const uint8_t* pVersionData;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkMicromapVersionInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMicromapVersionInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pVersionData)
		end,
	}
)
mod.VkCopyMicromapToMemoryInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]],
	mod.VkStructureType,
	mod.VkMicromapEXT,
	mod.VkDeviceOrHostAddressKHR,
	mod.VkCopyMicromapModeEXT
)
ffi.metatype(
	mod.VkCopyMicromapToMemoryInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkCopyMicromapToMemoryInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.src, t.dst, t.mode)
		end,
	}
)
mod.VkCopyMemoryToMicromapInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]],
	mod.VkStructureType,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkMicromapEXT,
	mod.VkCopyMicromapModeEXT
)
ffi.metatype(
	mod.VkCopyMemoryToMicromapInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkCopyMemoryToMicromapInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.src, t.dst, t.mode)
		end,
	}
)
mod.VkCopyMicromapInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]],
	mod.VkStructureType,
	mod.VkMicromapEXT,
	mod.VkMicromapEXT,
	mod.VkCopyMicromapModeEXT
)
ffi.metatype(
	mod.VkCopyMicromapInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkCopyMicromapInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.src, t.dst, t.mode)
		end,
	}
)
mod.VkMicromapBuildSizesInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ micromapSize;
	$ buildScratchSize;
	$ discardable;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkBool32
)
ffi.metatype(
	mod.VkMicromapBuildSizesInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMicromapBuildSizesInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.micromapSize, t.buildScratchSize, t.discardable)
		end,
	}
)
mod.VkAccelerationStructureTrianglesOpacityMicromapEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ indexType;
	$ indexBuffer;
	$ indexStride;
	uint32_t baseTriangle;
	uint32_t usageCountsCount;
	const $* pUsageCounts;
	const $** const ppUsageCounts;
	$ micromap;
}]],
	mod.VkStructureType,
	mod.VkIndexType,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceSize,
	mod.VkMicromapUsageEXT,
	mod.VkMicromapUsageEXT,
	mod.VkMicromapEXT
)
ffi.metatype(
	mod.VkAccelerationStructureTrianglesOpacityMicromapEXT,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureTrianglesOpacityMicromapEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.indexType,
				t.indexBuffer,
				t.indexStride,
				t.baseTriangle,
				t.usageCountsCount,
				t.pUsageCounts,
				t.ppUsageCounts,
				t.micromap
			)
		end,
	}
)
mod.VkMicromapTriangleEXT = ffi.typeof([[struct {
	uint32_t dataOffset;
	uint16_t subdivisionLevel;
	uint16_t format;
}]])
ffi.metatype(
	mod.VkMicromapTriangleEXT,
	{
		__tostring = function(s)
			return ("struct VkMicromapTriangleEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.dataOffset, t.subdivisionLevel, t.format)
		end,
	}
)
mod.PFN_vkCreateMicromapEXT = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMicromapCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkMicromapEXT
)
mod.PFN_vkDestroyMicromapEXT = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkMicromapEXT,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCmdBuildMicromapsEXT = ffi.typeof(
	[[void (*)($ , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkMicromapBuildInfoEXT
)
mod.PFN_vkBuildMicromapsEXT = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkMicromapBuildInfoEXT
)
mod.PFN_vkCopyMicromapEXT = ffi.typeof(
	[[$ (*)($ , $ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyMicromapInfoEXT
)
mod.PFN_vkCopyMicromapToMemoryEXT = ffi.typeof(
	[[$ (*)($ , $ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyMicromapToMemoryInfoEXT
)
mod.PFN_vkCopyMemoryToMicromapEXT = ffi.typeof(
	[[$ (*)($ , $ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyMemoryToMicromapInfoEXT
)
mod.PFN_vkWriteMicromapsPropertiesEXT = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*, $ , size_t , void*, size_t )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMicromapEXT,
	mod.VkQueryType
)
mod.PFN_vkCmdCopyMicromapEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyMicromapInfoEXT)
mod.PFN_vkCmdCopyMicromapToMemoryEXT = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkCopyMicromapToMemoryInfoEXT
)
mod.PFN_vkCmdCopyMemoryToMicromapEXT = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkCopyMemoryToMicromapInfoEXT
)
mod.PFN_vkCmdWriteMicromapsPropertiesEXT = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkMicromapEXT,
	mod.VkQueryType,
	mod.VkQueryPool
)
mod.PFN_vkGetDeviceMicromapCompatibilityEXT = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkMicromapVersionInfoEXT,
	mod.VkAccelerationStructureCompatibilityKHR
)
mod.PFN_vkGetMicromapBuildSizesEXT = ffi.typeof(
	[[void (*)($ , $ , const $*, $*)]],
	mod.VkDevice,
	mod.VkAccelerationStructureBuildTypeKHR,
	mod.VkMicromapBuildInfoEXT,
	mod.VkMicromapBuildSizesInfoEXT
)
ffi.cdef(
	[[$  vkCreateMicromapEXT($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMicromapCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkMicromapEXT
)
ffi.cdef(
	[[void  vkDestroyMicromapEXT($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkMicromapEXT,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkCmdBuildMicromapsEXT($ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkMicromapBuildInfoEXT
)
ffi.cdef(
	[[$  vkBuildMicromapsEXT($ , $ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkMicromapBuildInfoEXT
)
ffi.cdef(
	[[$  vkCopyMicromapEXT($ , $ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyMicromapInfoEXT
)
ffi.cdef(
	[[$  vkCopyMicromapToMemoryEXT($ , $ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyMicromapToMemoryInfoEXT
)
ffi.cdef(
	[[$  vkCopyMemoryToMicromapEXT($ , $ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyMemoryToMicromapInfoEXT
)
ffi.cdef(
	[[$  vkWriteMicromapsPropertiesEXT($ , uint32_t , const $*, $ , size_t , void*, size_t );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMicromapEXT,
	mod.VkQueryType
)
ffi.cdef(
	[[void  vkCmdCopyMicromapEXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyMicromapInfoEXT
)
ffi.cdef(
	[[void  vkCmdCopyMicromapToMemoryEXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyMicromapToMemoryInfoEXT
)
ffi.cdef(
	[[void  vkCmdCopyMemoryToMicromapEXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyMemoryToMicromapInfoEXT
)
ffi.cdef(
	[[void  vkCmdWriteMicromapsPropertiesEXT($ , uint32_t , const $*, $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkMicromapEXT,
	mod.VkQueryType,
	mod.VkQueryPool
)
ffi.cdef(
	[[void  vkGetDeviceMicromapCompatibilityEXT($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkMicromapVersionInfoEXT,
	mod.VkAccelerationStructureCompatibilityKHR
)
ffi.cdef(
	[[void  vkGetMicromapBuildSizesEXT($ , $ , const $*, $*);]],
	mod.VkDevice,
	mod.VkAccelerationStructureBuildTypeKHR,
	mod.VkMicromapBuildInfoEXT,
	mod.VkMicromapBuildSizesInfoEXT
)
mod.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ clustercullingShader;
	$ multiviewClusterCullingShader;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.clustercullingShader, t.multiviewClusterCullingShader)
		end,
	}
)
mod.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxWorkGroupCount[3];
	uint32_t maxWorkGroupSize[3];
	uint32_t maxOutputClusterCount;
	$ indirectBufferOffsetAlignment;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxWorkGroupCount,
				t.maxWorkGroupSize,
				t.maxOutputClusterCount,
				t.indirectBufferOffsetAlignment
			)
		end,
	}
)
mod.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ clusterShadingRate;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.clusterShadingRate)
		end,
	}
)
mod.PFN_vkCmdDrawClusterHUAWEI = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDrawClusterIndirectHUAWEI = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef(
	[[void  vkCmdDrawClusterHUAWEI($ , uint32_t , uint32_t , uint32_t );]],
	mod.VkCommandBuffer
)
ffi.cdef(
	[[void  vkCmdDrawClusterIndirectHUAWEI($ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ borderColorSwizzle;
	$ borderColorSwizzleFromImage;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceBorderColorSwizzleFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.borderColorSwizzle, t.borderColorSwizzleFromImage)
		end,
	}
)
mod.VkSamplerBorderColorComponentMappingCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ components;
	$ srgb;
}]],
	mod.VkStructureType,
	mod.VkComponentMapping,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSamplerBorderColorComponentMappingCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkSamplerBorderColorComponentMappingCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.components, t.srgb)
		end,
	}
)
mod.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pageableDeviceLocalMemory;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pageableDeviceLocalMemory)
		end,
	}
)
mod.PFN_vkSetDeviceMemoryPriorityEXT = ffi.typeof([[void (*)($ , $ , float )]], mod.VkDevice, mod.VkDeviceMemory)
ffi.cdef(
	[[void  vkSetDeviceMemoryPriorityEXT($ , $ , float );]],
	mod.VkDevice,
	mod.VkDeviceMemory
)
mod.VkPhysicalDeviceShaderCorePropertiesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t pixelRate;
	uint32_t texelRate;
	uint32_t fmaRate;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderCorePropertiesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderCorePropertiesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pixelRate, t.texelRate, t.fmaRate)
		end,
	}
)
mod.VkPhysicalDeviceSchedulingControlsFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkPhysicalDeviceSchedulingControlsFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM = 0x00000001ULL
mod.VkDeviceQueueShaderCoreControlCreateInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t shaderCoreCount;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDeviceQueueShaderCoreControlCreateInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDeviceQueueShaderCoreControlCreateInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderCoreCount)
		end,
	}
)
mod.VkPhysicalDeviceSchedulingControlsFeaturesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ schedulingControls;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSchedulingControlsFeaturesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSchedulingControlsFeaturesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.schedulingControls)
		end,
	}
)
mod.VkPhysicalDeviceSchedulingControlsPropertiesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ schedulingControlsFlags;
}]],
	mod.VkStructureType,
	mod.VkPhysicalDeviceSchedulingControlsFlagsARM
)
ffi.metatype(
	mod.VkPhysicalDeviceSchedulingControlsPropertiesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSchedulingControlsPropertiesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.schedulingControlsFlags)
		end,
	}
)
mod.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ imageSlicedViewOf3D;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageSlicedViewOf3D)
		end,
	}
)
mod.VkImageViewSlicedCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t sliceOffset;
	uint32_t sliceCount;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkImageViewSlicedCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImageViewSlicedCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.sliceOffset, t.sliceCount)
		end,
	}
)
mod.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ descriptorSetHostMapping;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.descriptorSetHostMapping)
		end,
	}
)
mod.VkDescriptorSetBindingReferenceVALVE = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ descriptorSetLayout;
	uint32_t binding;
}]],
	mod.VkStructureType,
	mod.VkDescriptorSetLayout
)
ffi.metatype(
	mod.VkDescriptorSetBindingReferenceVALVE,
	{
		__tostring = function(s)
			return ("struct VkDescriptorSetBindingReferenceVALVE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.descriptorSetLayout, t.binding)
		end,
	}
)
mod.VkDescriptorSetLayoutHostMappingInfoVALVE = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	size_t descriptorOffset;
	uint32_t descriptorSize;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDescriptorSetLayoutHostMappingInfoVALVE,
	{
		__tostring = function(s)
			return ("struct VkDescriptorSetLayoutHostMappingInfoVALVE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.descriptorOffset, t.descriptorSize)
		end,
	}
)
mod.PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkDescriptorSetBindingReferenceVALVE,
	mod.VkDescriptorSetLayoutHostMappingInfoVALVE
)
mod.PFN_vkGetDescriptorSetHostMappingVALVE = ffi.typeof([[void (*)($ , $ , void**)]], mod.VkDevice, mod.VkDescriptorSet)
ffi.cdef(
	[[void  vkGetDescriptorSetLayoutHostMappingInfoVALVE($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDescriptorSetBindingReferenceVALVE,
	mod.VkDescriptorSetLayoutHostMappingInfoVALVE
)
ffi.cdef(
	[[void  vkGetDescriptorSetHostMappingVALVE($ , $ , void**);]],
	mod.VkDevice,
	mod.VkDescriptorSet
)
mod.VkPhysicalDeviceDepthClampZeroOneFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR)
mod.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ nonSeamlessCubeMap;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.nonSeamlessCubeMap)
		end,
	}
)
mod.VkPhysicalDeviceRenderPassStripedFeaturesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ renderPassStriped;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRenderPassStripedFeaturesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRenderPassStripedFeaturesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.renderPassStriped)
		end,
	}
)
mod.VkPhysicalDeviceRenderPassStripedPropertiesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ renderPassStripeGranularity;
	uint32_t maxRenderPassStripes;
}]],
	mod.VkStructureType,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkPhysicalDeviceRenderPassStripedPropertiesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRenderPassStripedPropertiesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.renderPassStripeGranularity, t.maxRenderPassStripes)
		end,
	}
)
mod.VkRenderPassStripeInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stripeArea;
}]],
	mod.VkStructureType,
	mod.VkRect2D
)
ffi.metatype(
	mod.VkRenderPassStripeInfoARM,
	{
		__tostring = function(s)
			return ("struct VkRenderPassStripeInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stripeArea)
		end,
	}
)
mod.VkRenderPassStripeBeginInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t stripeInfoCount;
	const $* pStripeInfos;
}]],
	mod.VkStructureType,
	mod.VkRenderPassStripeInfoARM
)
ffi.metatype(
	mod.VkRenderPassStripeBeginInfoARM,
	{
		__tostring = function(s)
			return ("struct VkRenderPassStripeBeginInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stripeInfoCount, t.pStripeInfos)
		end,
	}
)
mod.VkRenderPassStripeSubmitInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t stripeSemaphoreInfoCount;
	const $* pStripeSemaphoreInfos;
}]],
	mod.VkStructureType,
	mod.VkSemaphoreSubmitInfo
)
ffi.metatype(
	mod.VkRenderPassStripeSubmitInfoARM,
	{
		__tostring = function(s)
			return ("struct VkRenderPassStripeSubmitInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stripeSemaphoreInfoCount, t.pStripeSemaphoreInfos)
		end,
	}
)
mod.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ fragmentDensityMapOffset;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.fragmentDensityMapOffset)
		end,
	}
)
mod.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = ffi.typeof([[$ ]], mod.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT)
mod.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ fragmentDensityOffsetGranularity;
}]],
	mod.VkStructureType,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.fragmentDensityOffsetGranularity)
		end,
	}
)
mod.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = ffi.typeof([[$ ]], mod.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT)
mod.VkRenderPassFragmentDensityMapOffsetEndInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t fragmentDensityOffsetCount;
	const $* pFragmentDensityOffsets;
}]],
	mod.VkStructureType,
	mod.VkOffset2D
)
ffi.metatype(
	mod.VkRenderPassFragmentDensityMapOffsetEndInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkRenderPassFragmentDensityMapOffsetEndInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.fragmentDensityOffsetCount, t.pFragmentDensityOffsets)
		end,
	}
)
mod.VkSubpassFragmentDensityMapOffsetEndInfoQCOM = ffi.typeof([[$ ]], mod.VkRenderPassFragmentDensityMapOffsetEndInfoEXT)
mod.VkCopyMemoryIndirectCommandNV = ffi.typeof([[$ ]], mod.VkCopyMemoryIndirectCommandKHR)
mod.VkCopyMemoryToImageIndirectCommandNV = ffi.typeof([[$ ]], mod.VkCopyMemoryToImageIndirectCommandKHR)
mod.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ indirectCopy;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCopyMemoryIndirectFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.indirectCopy)
		end,
	}
)
mod.VkPhysicalDeviceCopyMemoryIndirectPropertiesNV = ffi.typeof([[$ ]], mod.VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR)
mod.PFN_vkCmdCopyMemoryIndirectNV = ffi.typeof(
	[[void (*)($ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkDeviceAddress
)
mod.PFN_vkCmdCopyMemoryToImageIndirectNV = ffi.typeof(
	[[void (*)($ , $ , uint32_t , uint32_t , $ , $ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkDeviceAddress,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageSubresourceLayers
)
ffi.cdef(
	[[void  vkCmdCopyMemoryIndirectNV($ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkDeviceAddress
)
ffi.cdef(
	[[void  vkCmdCopyMemoryToImageIndirectNV($ , $ , uint32_t , uint32_t , $ , $ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDeviceAddress,
	mod.VkImage,
	mod.VkImageLayout,
	mod.VkImageSubresourceLayers
)
mod.VkMemoryDecompressionMethodFlagBitsNV = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV = 0x00000001ULL
mod.VkMemoryDecompressionMethodFlagsNV = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkDecompressMemoryRegionNV = ffi.typeof(
	[[struct {
	$ srcAddress;
	$ dstAddress;
	$ compressedSize;
	$ decompressedSize;
	$ decompressionMethod;
}]],
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkMemoryDecompressionMethodFlagsNV
)
ffi.metatype(
	mod.VkDecompressMemoryRegionNV,
	{
		__tostring = function(s)
			return ("struct VkDecompressMemoryRegionNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.srcAddress,
				t.dstAddress,
				t.compressedSize,
				t.decompressedSize,
				t.decompressionMethod
			)
		end,
	}
)
mod.VkPhysicalDeviceMemoryDecompressionFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ memoryDecompression;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMemoryDecompressionFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMemoryDecompressionFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memoryDecompression)
		end,
	}
)
mod.VkPhysicalDeviceMemoryDecompressionPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ decompressionMethods;
	uint64_t maxDecompressionIndirectCount;
}]],
	mod.VkStructureType,
	mod.VkMemoryDecompressionMethodFlagsNV
)
ffi.metatype(
	mod.VkPhysicalDeviceMemoryDecompressionPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMemoryDecompressionPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.decompressionMethods, t.maxDecompressionIndirectCount)
		end,
	}
)
mod.PFN_vkCmdDecompressMemoryNV = ffi.typeof(
	[[void (*)($ , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkDecompressMemoryRegionNV
)
mod.PFN_vkCmdDecompressMemoryIndirectCountNV = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress
)
ffi.cdef(
	[[void  vkCmdDecompressMemoryNV($ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDecompressMemoryRegionNV
)
ffi.cdef(
	[[void  vkCmdDecompressMemoryIndirectCountNV($ , $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress
)
mod.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ deviceGeneratedCompute;
	$ deviceGeneratedComputePipelines;
	$ deviceGeneratedComputeCaptureReplay;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.deviceGeneratedCompute,
				t.deviceGeneratedComputePipelines,
				t.deviceGeneratedComputeCaptureReplay
			)
		end,
	}
)
mod.VkComputePipelineIndirectBufferInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ deviceAddress;
	$ size;
	$ pipelineDeviceAddressCaptureReplay;
}]],
	mod.VkStructureType,
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkComputePipelineIndirectBufferInfoNV,
	{
		__tostring = function(s)
			return ("struct VkComputePipelineIndirectBufferInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.deviceAddress,
				t.size,
				t.pipelineDeviceAddressCaptureReplay
			)
		end,
	}
)
mod.VkPipelineIndirectDeviceAddressInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ pipelineBindPoint;
	$ pipeline;
}]],
	mod.VkStructureType,
	mod.VkPipelineBindPoint,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkPipelineIndirectDeviceAddressInfoNV,
	{
		__tostring = function(s)
			return ("struct VkPipelineIndirectDeviceAddressInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineBindPoint, t.pipeline)
		end,
	}
)
mod.VkBindPipelineIndirectCommandNV = ffi.typeof([[struct {
	$ pipelineAddress;
}]], mod.VkDeviceAddress)
ffi.metatype(
	mod.VkBindPipelineIndirectCommandNV,
	{
		__tostring = function(s)
			return ("struct VkBindPipelineIndirectCommandNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.pipelineAddress)
		end,
	}
)
mod.PFN_vkGetPipelineIndirectMemoryRequirementsNV = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkComputePipelineCreateInfo,
	mod.VkMemoryRequirements2
)
mod.PFN_vkCmdUpdatePipelineIndirectBufferNV = ffi.typeof(
	[[void (*)($ , $ , $ )]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipeline
)
mod.PFN_vkGetPipelineIndirectDeviceAddressNV = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkDeviceAddress,
	mod.VkDevice,
	mod.VkPipelineIndirectDeviceAddressInfoNV
)
ffi.cdef(
	[[void  vkGetPipelineIndirectMemoryRequirementsNV($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkComputePipelineCreateInfo,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkCmdUpdatePipelineIndirectBufferNV($ , $ , $ );]],
	mod.VkCommandBuffer,
	mod.VkPipelineBindPoint,
	mod.VkPipeline
)
ffi.cdef(
	[[$  vkGetPipelineIndirectDeviceAddressNV($ , const $*);]],
	mod.VkDeviceAddress,
	mod.VkDevice,
	mod.VkPipelineIndirectDeviceAddressInfoNV
)
mod.VkRayTracingLssIndexingModeNV = ffi.typeof([[enum {
	VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV = 0,
	VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV = 1,
	VK_RAY_TRACING_LSS_INDEXING_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkRayTracingLssPrimitiveEndCapsModeNV = ffi.typeof([[enum {
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV = 0,
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV = 1,
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ spheres;
	$ linearSweptSpheres;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.spheres, t.linearSweptSpheres)
		end,
	}
)
mod.VkAccelerationStructureGeometryLinearSweptSpheresDataNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ vertexFormat;
	$ vertexData;
	$ vertexStride;
	$ radiusFormat;
	$ radiusData;
	$ radiusStride;
	$ indexType;
	$ indexData;
	$ indexStride;
	$ indexingMode;
	$ endCapsMode;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceSize,
	mod.VkFormat,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceSize,
	mod.VkIndexType,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceSize,
	mod.VkRayTracingLssIndexingModeNV,
	mod.VkRayTracingLssPrimitiveEndCapsModeNV
)
ffi.metatype(
	mod.VkAccelerationStructureGeometryLinearSweptSpheresDataNV,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureGeometryLinearSweptSpheresDataNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.vertexFormat,
				t.vertexData,
				t.vertexStride,
				t.radiusFormat,
				t.radiusData,
				t.radiusStride,
				t.indexType,
				t.indexData,
				t.indexStride,
				t.indexingMode,
				t.endCapsMode
			)
		end,
	}
)
mod.VkAccelerationStructureGeometrySpheresDataNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ vertexFormat;
	$ vertexData;
	$ vertexStride;
	$ radiusFormat;
	$ radiusData;
	$ radiusStride;
	$ indexType;
	$ indexData;
	$ indexStride;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceSize,
	mod.VkFormat,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceSize,
	mod.VkIndexType,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkAccelerationStructureGeometrySpheresDataNV,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureGeometrySpheresDataNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.vertexFormat,
				t.vertexData,
				t.vertexStride,
				t.radiusFormat,
				t.radiusData,
				t.radiusStride,
				t.indexType,
				t.indexData,
				t.indexStride
			)
		end,
	}
)
mod.VkPhysicalDeviceLinearColorAttachmentFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ linearColorAttachment;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceLinearColorAttachmentFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceLinearColorAttachmentFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.linearColorAttachment)
		end,
	}
)
mod.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ imageCompressionControlSwapchain;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageCompressionControlSwapchain)
		end,
	}
)
mod.VkImageViewSampleWeightCreateInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ filterCenter;
	$ filterSize;
	uint32_t numPhases;
}]],
	mod.VkStructureType,
	mod.VkOffset2D,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkImageViewSampleWeightCreateInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkImageViewSampleWeightCreateInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.filterCenter, t.filterSize, t.numPhases)
		end,
	}
)
mod.VkPhysicalDeviceImageProcessingFeaturesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ textureSampleWeighted;
	$ textureBoxFilter;
	$ textureBlockMatch;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceImageProcessingFeaturesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageProcessingFeaturesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.textureSampleWeighted,
				t.textureBoxFilter,
				t.textureBlockMatch
			)
		end,
	}
)
mod.VkPhysicalDeviceImageProcessingPropertiesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxWeightFilterPhases;
	$ maxWeightFilterDimension;
	$ maxBlockMatchRegion;
	$ maxBoxFilterBlockSize;
}]],
	mod.VkStructureType,
	mod.VkExtent2D,
	mod.VkExtent2D,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkPhysicalDeviceImageProcessingPropertiesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageProcessingPropertiesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxWeightFilterPhases,
				t.maxWeightFilterDimension,
				t.maxBlockMatchRegion,
				t.maxBoxFilterBlockSize
			)
		end,
	}
)
mod.VkPhysicalDeviceNestedCommandBufferFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ nestedCommandBuffer;
	$ nestedCommandBufferRendering;
	$ nestedCommandBufferSimultaneousUse;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceNestedCommandBufferFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceNestedCommandBufferFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.nestedCommandBuffer,
				t.nestedCommandBufferRendering,
				t.nestedCommandBufferSimultaneousUse
			)
		end,
	}
)
mod.VkPhysicalDeviceNestedCommandBufferPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxCommandBufferNestingLevel;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceNestedCommandBufferPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceNestedCommandBufferPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxCommandBufferNestingLevel)
		end,
	}
)
mod.VkExternalMemoryAcquireUnmodifiedEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ acquireUnmodifiedMemory;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkExternalMemoryAcquireUnmodifiedEXT,
	{
		__tostring = function(s)
			return ("struct VkExternalMemoryAcquireUnmodifiedEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.acquireUnmodifiedMemory)
		end,
	}
)
mod.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ extendedDynamicState3TessellationDomainOrigin;
	$ extendedDynamicState3DepthClampEnable;
	$ extendedDynamicState3PolygonMode;
	$ extendedDynamicState3RasterizationSamples;
	$ extendedDynamicState3SampleMask;
	$ extendedDynamicState3AlphaToCoverageEnable;
	$ extendedDynamicState3AlphaToOneEnable;
	$ extendedDynamicState3LogicOpEnable;
	$ extendedDynamicState3ColorBlendEnable;
	$ extendedDynamicState3ColorBlendEquation;
	$ extendedDynamicState3ColorWriteMask;
	$ extendedDynamicState3RasterizationStream;
	$ extendedDynamicState3ConservativeRasterizationMode;
	$ extendedDynamicState3ExtraPrimitiveOverestimationSize;
	$ extendedDynamicState3DepthClipEnable;
	$ extendedDynamicState3SampleLocationsEnable;
	$ extendedDynamicState3ColorBlendAdvanced;
	$ extendedDynamicState3ProvokingVertexMode;
	$ extendedDynamicState3LineRasterizationMode;
	$ extendedDynamicState3LineStippleEnable;
	$ extendedDynamicState3DepthClipNegativeOneToOne;
	$ extendedDynamicState3ViewportWScalingEnable;
	$ extendedDynamicState3ViewportSwizzle;
	$ extendedDynamicState3CoverageToColorEnable;
	$ extendedDynamicState3CoverageToColorLocation;
	$ extendedDynamicState3CoverageModulationMode;
	$ extendedDynamicState3CoverageModulationTableEnable;
	$ extendedDynamicState3CoverageModulationTable;
	$ extendedDynamicState3CoverageReductionMode;
	$ extendedDynamicState3RepresentativeFragmentTestEnable;
	$ extendedDynamicState3ShadingRateImageEnable;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExtendedDynamicState3FeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.extendedDynamicState3TessellationDomainOrigin,
				t.extendedDynamicState3DepthClampEnable,
				t.extendedDynamicState3PolygonMode,
				t.extendedDynamicState3RasterizationSamples,
				t.extendedDynamicState3SampleMask,
				t.extendedDynamicState3AlphaToCoverageEnable,
				t.extendedDynamicState3AlphaToOneEnable,
				t.extendedDynamicState3LogicOpEnable,
				t.extendedDynamicState3ColorBlendEnable,
				t.extendedDynamicState3ColorBlendEquation,
				t.extendedDynamicState3ColorWriteMask,
				t.extendedDynamicState3RasterizationStream,
				t.extendedDynamicState3ConservativeRasterizationMode,
				t.extendedDynamicState3ExtraPrimitiveOverestimationSize,
				t.extendedDynamicState3DepthClipEnable,
				t.extendedDynamicState3SampleLocationsEnable,
				t.extendedDynamicState3ColorBlendAdvanced,
				t.extendedDynamicState3ProvokingVertexMode,
				t.extendedDynamicState3LineRasterizationMode,
				t.extendedDynamicState3LineStippleEnable,
				t.extendedDynamicState3DepthClipNegativeOneToOne,
				t.extendedDynamicState3ViewportWScalingEnable,
				t.extendedDynamicState3ViewportSwizzle,
				t.extendedDynamicState3CoverageToColorEnable,
				t.extendedDynamicState3CoverageToColorLocation,
				t.extendedDynamicState3CoverageModulationMode,
				t.extendedDynamicState3CoverageModulationTableEnable,
				t.extendedDynamicState3CoverageModulationTable,
				t.extendedDynamicState3CoverageReductionMode,
				t.extendedDynamicState3RepresentativeFragmentTestEnable,
				t.extendedDynamicState3ShadingRateImageEnable
			)
		end,
	}
)
mod.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ dynamicPrimitiveTopologyUnrestricted;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExtendedDynamicState3PropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dynamicPrimitiveTopologyUnrestricted)
		end,
	}
)
mod.VkColorBlendEquationEXT = ffi.typeof(
	[[struct {
	$ srcColorBlendFactor;
	$ dstColorBlendFactor;
	$ colorBlendOp;
	$ srcAlphaBlendFactor;
	$ dstAlphaBlendFactor;
	$ alphaBlendOp;
}]],
	mod.VkBlendFactor,
	mod.VkBlendFactor,
	mod.VkBlendOp,
	mod.VkBlendFactor,
	mod.VkBlendFactor,
	mod.VkBlendOp
)
ffi.metatype(
	mod.VkColorBlendEquationEXT,
	{
		__tostring = function(s)
			return ("struct VkColorBlendEquationEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.srcColorBlendFactor,
				t.dstColorBlendFactor,
				t.colorBlendOp,
				t.srcAlphaBlendFactor,
				t.dstAlphaBlendFactor,
				t.alphaBlendOp
			)
		end,
	}
)
mod.VkColorBlendAdvancedEXT = ffi.typeof(
	[[struct {
	$ advancedBlendOp;
	$ srcPremultiplied;
	$ dstPremultiplied;
	$ blendOverlap;
	$ clampResults;
}]],
	mod.VkBlendOp,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBlendOverlapEXT,
	mod.VkBool32
)
ffi.metatype(
	mod.VkColorBlendAdvancedEXT,
	{
		__tostring = function(s)
			return ("struct VkColorBlendAdvancedEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.advancedBlendOp,
				t.srcPremultiplied,
				t.dstPremultiplied,
				t.blendOverlap,
				t.clampResults
			)
		end,
	}
)
mod.PFN_vkCmdSetDepthClampEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetPolygonModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkPolygonMode)
mod.PFN_vkCmdSetRasterizationSamplesEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkSampleCountFlagBits)
mod.PFN_vkCmdSetSampleMaskEXT = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkSampleCountFlagBits,
	mod.VkSampleMask
)
mod.PFN_vkCmdSetAlphaToCoverageEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetAlphaToOneEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetLogicOpEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetColorBlendEnableEXT = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
mod.PFN_vkCmdSetColorBlendEquationEXT = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkColorBlendEquationEXT
)
mod.PFN_vkCmdSetColorWriteMaskEXT = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkColorComponentFlags
)
mod.PFN_vkCmdSetTessellationDomainOriginEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkTessellationDomainOrigin)
mod.PFN_vkCmdSetRasterizationStreamEXT = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetConservativeRasterizationModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkConservativeRasterizationModeEXT)
mod.PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT = ffi.typeof([[void (*)($ , float )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetDepthClipEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetSampleLocationsEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetColorBlendAdvancedEXT = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkColorBlendAdvancedEXT
)
mod.PFN_vkCmdSetProvokingVertexModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkProvokingVertexModeEXT)
mod.PFN_vkCmdSetLineRasterizationModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkLineRasterizationModeEXT)
mod.PFN_vkCmdSetLineStippleEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthClipNegativeOneToOneEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetViewportWScalingEnableNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetViewportSwizzleNV = ffi.typeof(
	[[void (*)($ , uint32_t , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkViewportSwizzleNV
)
mod.PFN_vkCmdSetCoverageToColorEnableNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetCoverageToColorLocationNV = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetCoverageModulationModeNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCoverageModulationModeNV)
mod.PFN_vkCmdSetCoverageModulationTableEnableNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetCoverageModulationTableNV = ffi.typeof([[void (*)($ , uint32_t , const float*)]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetShadingRateImageEnableNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetRepresentativeFragmentTestEnableNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetCoverageReductionModeNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCoverageReductionModeNV)
ffi.cdef([[void  vkCmdSetDepthClampEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetPolygonModeEXT($ , $ );]], mod.VkCommandBuffer, mod.VkPolygonMode)
ffi.cdef(
	[[void  vkCmdSetRasterizationSamplesEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkSampleCountFlagBits
)
ffi.cdef(
	[[void  vkCmdSetSampleMaskEXT($ , $ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkSampleCountFlagBits,
	mod.VkSampleMask
)
ffi.cdef(
	[[void  vkCmdSetAlphaToCoverageEnableEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef([[void  vkCmdSetAlphaToOneEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetLogicOpEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef(
	[[void  vkCmdSetColorBlendEnableEXT($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetColorBlendEquationEXT($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkColorBlendEquationEXT
)
ffi.cdef(
	[[void  vkCmdSetColorWriteMaskEXT($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkColorComponentFlags
)
ffi.cdef(
	[[void  vkCmdSetTessellationDomainOriginEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkTessellationDomainOrigin
)
ffi.cdef([[void  vkCmdSetRasterizationStreamEXT($ , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdSetConservativeRasterizationModeEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkConservativeRasterizationModeEXT
)
ffi.cdef(
	[[void  vkCmdSetExtraPrimitiveOverestimationSizeEXT($ , float );]],
	mod.VkCommandBuffer
)
ffi.cdef([[void  vkCmdSetDepthClipEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef(
	[[void  vkCmdSetSampleLocationsEnableEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetColorBlendAdvancedEXT($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkColorBlendAdvancedEXT
)
ffi.cdef(
	[[void  vkCmdSetProvokingVertexModeEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkProvokingVertexModeEXT
)
ffi.cdef(
	[[void  vkCmdSetLineRasterizationModeEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkLineRasterizationModeEXT
)
ffi.cdef(
	[[void  vkCmdSetLineStippleEnableEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetDepthClipNegativeOneToOneEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetViewportWScalingEnableNV($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetViewportSwizzleNV($ , uint32_t , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkViewportSwizzleNV
)
ffi.cdef(
	[[void  vkCmdSetCoverageToColorEnableNV($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef([[void  vkCmdSetCoverageToColorLocationNV($ , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdSetCoverageModulationModeNV($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkCoverageModulationModeNV
)
ffi.cdef(
	[[void  vkCmdSetCoverageModulationTableEnableNV($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetCoverageModulationTableNV($ , uint32_t , const float*);]],
	mod.VkCommandBuffer
)
ffi.cdef(
	[[void  vkCmdSetShadingRateImageEnableNV($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetRepresentativeFragmentTestEnableNV($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkBool32
)
ffi.cdef(
	[[void  vkCmdSetCoverageReductionModeNV($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkCoverageReductionModeNV
)
mod.VkSubpassMergeStatusEXT = ffi.typeof([[enum {
	VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0,
	VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13,
	VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ subpassMergeFeedback;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.subpassMergeFeedback)
		end,
	}
)
mod.VkRenderPassCreationControlEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ disallowMerging;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkRenderPassCreationControlEXT,
	{
		__tostring = function(s)
			return ("struct VkRenderPassCreationControlEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.disallowMerging)
		end,
	}
)
mod.VkRenderPassCreationFeedbackInfoEXT = ffi.typeof([[struct {
	uint32_t postMergeSubpassCount;
}]])
ffi.metatype(
	mod.VkRenderPassCreationFeedbackInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkRenderPassCreationFeedbackInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.postMergeSubpassCount)
		end,
	}
)
mod.VkRenderPassCreationFeedbackCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$* pRenderPassFeedback;
}]],
	mod.VkStructureType,
	mod.VkRenderPassCreationFeedbackInfoEXT
)
ffi.metatype(
	mod.VkRenderPassCreationFeedbackCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkRenderPassCreationFeedbackCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pRenderPassFeedback)
		end,
	}
)
mod.VkRenderPassSubpassFeedbackInfoEXT = ffi.typeof(
	[[struct {
	$ subpassMergeStatus;
	char description[256U];
	uint32_t postMergeIndex;
}]],
	mod.VkSubpassMergeStatusEXT
)
ffi.metatype(
	mod.VkRenderPassSubpassFeedbackInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkRenderPassSubpassFeedbackInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.subpassMergeStatus, t.description, t.postMergeIndex)
		end,
	}
)
mod.VkRenderPassSubpassFeedbackCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$* pSubpassFeedback;
}]],
	mod.VkStructureType,
	mod.VkRenderPassSubpassFeedbackInfoEXT
)
ffi.metatype(
	mod.VkRenderPassSubpassFeedbackCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkRenderPassSubpassFeedbackCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pSubpassFeedback)
		end,
	}
)
mod.VkDirectDriverLoadingModeLUNARG = ffi.typeof([[enum {
	VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG = 0,
	VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG = 1,
	VK_DIRECT_DRIVER_LOADING_MODE_MAX_ENUM_LUNARG = 0x7FFFFFFF,
}]])
mod.VkDirectDriverLoadingFlagsLUNARG = ffi.typeof([[$ ]], mod.VkFlags)
mod.PFN_vkGetInstanceProcAddrLUNARG = ffi.typeof([[$ (*)($ , const char*)]], mod.PFN_vkVoidFunction, mod.VkInstance)
mod.VkDirectDriverLoadingInfoLUNARG = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ pfnGetInstanceProcAddr;
}]],
	mod.VkStructureType,
	mod.VkDirectDriverLoadingFlagsLUNARG,
	mod.PFN_vkGetInstanceProcAddrLUNARG
)
ffi.metatype(
	mod.VkDirectDriverLoadingInfoLUNARG,
	{
		__tostring = function(s)
			return ("struct VkDirectDriverLoadingInfoLUNARG[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.pfnGetInstanceProcAddr)
		end,
	}
)
mod.VkDirectDriverLoadingListLUNARG = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ mode;
	uint32_t driverCount;
	const $* pDrivers;
}]],
	mod.VkStructureType,
	mod.VkDirectDriverLoadingModeLUNARG,
	mod.VkDirectDriverLoadingInfoLUNARG
)
ffi.metatype(
	mod.VkDirectDriverLoadingListLUNARG,
	{
		__tostring = function(s)
			return ("struct VkDirectDriverLoadingListLUNARG[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.mode, t.driverCount, t.pDrivers)
		end,
	}
)
mod.VkTensorARM = ffi.typeof([[void*]])
mod.VkTensorViewARM = ffi.typeof([[void*]])
mod.VkTensorTilingARM = ffi.typeof([[enum {
	VK_TENSOR_TILING_OPTIMAL_ARM = 0,
	VK_TENSOR_TILING_LINEAR_ARM = 1,
	VK_TENSOR_TILING_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkTensorCreateFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkTensorCreateFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_TENSOR_CREATE_MUTABLE_FORMAT_BIT_ARM = 0x00000001ULL
mod.VK_TENSOR_CREATE_PROTECTED_BIT_ARM = 0x00000002ULL
mod.VK_TENSOR_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM = 0x00000004ULL
mod.VkTensorViewCreateFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkTensorViewCreateFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_TENSOR_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM = 0x00000001ULL
mod.VkTensorUsageFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkTensorUsageFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_TENSOR_USAGE_SHADER_BIT_ARM = 0x00000002ULL
mod.VK_TENSOR_USAGE_TRANSFER_SRC_BIT_ARM = 0x00000004ULL
mod.VK_TENSOR_USAGE_TRANSFER_DST_BIT_ARM = 0x00000008ULL
mod.VK_TENSOR_USAGE_IMAGE_ALIASING_BIT_ARM = 0x00000010ULL
mod.VK_TENSOR_USAGE_DATA_GRAPH_BIT_ARM = 0x00000020ULL
mod.VkTensorDescriptionARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ tiling;
	$ format;
	uint32_t dimensionCount;
	const int64_t* pDimensions;
	const int64_t* pStrides;
	$ usage;
}]],
	mod.VkStructureType,
	mod.VkTensorTilingARM,
	mod.VkFormat,
	mod.VkTensorUsageFlagsARM
)
ffi.metatype(
	mod.VkTensorDescriptionARM,
	{
		__tostring = function(s)
			return ("struct VkTensorDescriptionARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.tiling,
				t.format,
				t.dimensionCount,
				t.pDimensions,
				t.pStrides,
				t.usage
			)
		end,
	}
)
mod.VkTensorCreateInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const $* pDescription;
	$ sharingMode;
	uint32_t queueFamilyIndexCount;
	const uint32_t* pQueueFamilyIndices;
}]],
	mod.VkStructureType,
	mod.VkTensorCreateFlagsARM,
	mod.VkTensorDescriptionARM,
	mod.VkSharingMode
)
ffi.metatype(
	mod.VkTensorCreateInfoARM,
	{
		__tostring = function(s)
			return ("struct VkTensorCreateInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.pDescription,
				t.sharingMode,
				t.queueFamilyIndexCount,
				t.pQueueFamilyIndices
			)
		end,
	}
)
mod.VkTensorViewCreateInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ tensor;
	$ format;
}]],
	mod.VkStructureType,
	mod.VkTensorViewCreateFlagsARM,
	mod.VkTensorARM,
	mod.VkFormat
)
ffi.metatype(
	mod.VkTensorViewCreateInfoARM,
	{
		__tostring = function(s)
			return ("struct VkTensorViewCreateInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.tensor, t.format)
		end,
	}
)
mod.VkTensorMemoryRequirementsInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ tensor;
}]],
	mod.VkStructureType,
	mod.VkTensorARM
)
ffi.metatype(
	mod.VkTensorMemoryRequirementsInfoARM,
	{
		__tostring = function(s)
			return ("struct VkTensorMemoryRequirementsInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tensor)
		end,
	}
)
mod.VkBindTensorMemoryInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ tensor;
	$ memory;
	$ memoryOffset;
}]],
	mod.VkStructureType,
	mod.VkTensorARM,
	mod.VkDeviceMemory,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkBindTensorMemoryInfoARM,
	{
		__tostring = function(s)
			return ("struct VkBindTensorMemoryInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tensor, t.memory, t.memoryOffset)
		end,
	}
)
mod.VkWriteDescriptorSetTensorARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t tensorViewCount;
	const $* pTensorViews;
}]],
	mod.VkStructureType,
	mod.VkTensorViewARM
)
ffi.metatype(
	mod.VkWriteDescriptorSetTensorARM,
	{
		__tostring = function(s)
			return ("struct VkWriteDescriptorSetTensorARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tensorViewCount, t.pTensorViews)
		end,
	}
)
mod.VkTensorFormatPropertiesARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ optimalTilingTensorFeatures;
	$ linearTilingTensorFeatures;
}]],
	mod.VkStructureType,
	mod.VkFormatFeatureFlags2,
	mod.VkFormatFeatureFlags2
)
ffi.metatype(
	mod.VkTensorFormatPropertiesARM,
	{
		__tostring = function(s)
			return ("struct VkTensorFormatPropertiesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.optimalTilingTensorFeatures,
				t.linearTilingTensorFeatures
			)
		end,
	}
)
mod.VkPhysicalDeviceTensorPropertiesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxTensorDimensionCount;
	uint64_t maxTensorElements;
	uint64_t maxPerDimensionTensorElements;
	int64_t maxTensorStride;
	uint64_t maxTensorSize;
	uint32_t maxTensorShaderAccessArrayLength;
	uint32_t maxTensorShaderAccessSize;
	uint32_t maxDescriptorSetStorageTensors;
	uint32_t maxPerStageDescriptorSetStorageTensors;
	uint32_t maxDescriptorSetUpdateAfterBindStorageTensors;
	uint32_t maxPerStageDescriptorUpdateAfterBindStorageTensors;
	$ shaderStorageTensorArrayNonUniformIndexingNative;
	$ shaderTensorSupportedStages;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkShaderStageFlags
)
ffi.metatype(
	mod.VkPhysicalDeviceTensorPropertiesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTensorPropertiesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxTensorDimensionCount,
				t.maxTensorElements,
				t.maxPerDimensionTensorElements,
				t.maxTensorStride,
				t.maxTensorSize,
				t.maxTensorShaderAccessArrayLength,
				t.maxTensorShaderAccessSize,
				t.maxDescriptorSetStorageTensors,
				t.maxPerStageDescriptorSetStorageTensors,
				t.maxDescriptorSetUpdateAfterBindStorageTensors,
				t.maxPerStageDescriptorUpdateAfterBindStorageTensors,
				t.shaderStorageTensorArrayNonUniformIndexingNative,
				t.shaderTensorSupportedStages
			)
		end,
	}
)
mod.VkTensorMemoryBarrierARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcStageMask;
	$ srcAccessMask;
	$ dstStageMask;
	$ dstAccessMask;
	uint32_t srcQueueFamilyIndex;
	uint32_t dstQueueFamilyIndex;
	$ tensor;
}]],
	mod.VkStructureType,
	mod.VkPipelineStageFlags2,
	mod.VkAccessFlags2,
	mod.VkPipelineStageFlags2,
	mod.VkAccessFlags2,
	mod.VkTensorARM
)
ffi.metatype(
	mod.VkTensorMemoryBarrierARM,
	{
		__tostring = function(s)
			return ("struct VkTensorMemoryBarrierARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcStageMask,
				t.srcAccessMask,
				t.dstStageMask,
				t.dstAccessMask,
				t.srcQueueFamilyIndex,
				t.dstQueueFamilyIndex,
				t.tensor
			)
		end,
	}
)
mod.VkTensorDependencyInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t tensorMemoryBarrierCount;
	const $* pTensorMemoryBarriers;
}]],
	mod.VkStructureType,
	mod.VkTensorMemoryBarrierARM
)
ffi.metatype(
	mod.VkTensorDependencyInfoARM,
	{
		__tostring = function(s)
			return ("struct VkTensorDependencyInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tensorMemoryBarrierCount, t.pTensorMemoryBarriers)
		end,
	}
)
mod.VkPhysicalDeviceTensorFeaturesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ tensorNonPacked;
	$ shaderTensorAccess;
	$ shaderStorageTensorArrayDynamicIndexing;
	$ shaderStorageTensorArrayNonUniformIndexing;
	$ descriptorBindingStorageTensorUpdateAfterBind;
	$ tensors;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceTensorFeaturesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTensorFeaturesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.tensorNonPacked,
				t.shaderTensorAccess,
				t.shaderStorageTensorArrayDynamicIndexing,
				t.shaderStorageTensorArrayNonUniformIndexing,
				t.descriptorBindingStorageTensorUpdateAfterBind,
				t.tensors
			)
		end,
	}
)
mod.VkDeviceTensorMemoryRequirementsARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const $* pCreateInfo;
}]],
	mod.VkStructureType,
	mod.VkTensorCreateInfoARM
)
ffi.metatype(
	mod.VkDeviceTensorMemoryRequirementsARM,
	{
		__tostring = function(s)
			return ("struct VkDeviceTensorMemoryRequirementsARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pCreateInfo)
		end,
	}
)
mod.VkTensorCopyARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t dimensionCount;
	const uint64_t* pSrcOffset;
	const uint64_t* pDstOffset;
	const uint64_t* pExtent;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkTensorCopyARM,
	{
		__tostring = function(s)
			return ("struct VkTensorCopyARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.dimensionCount,
				t.pSrcOffset,
				t.pDstOffset,
				t.pExtent
			)
		end,
	}
)
mod.VkCopyTensorInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ srcTensor;
	$ dstTensor;
	uint32_t regionCount;
	const $* pRegions;
}]],
	mod.VkStructureType,
	mod.VkTensorARM,
	mod.VkTensorARM,
	mod.VkTensorCopyARM
)
ffi.metatype(
	mod.VkCopyTensorInfoARM,
	{
		__tostring = function(s)
			return ("struct VkCopyTensorInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.srcTensor, t.dstTensor, t.regionCount, t.pRegions)
		end,
	}
)
mod.VkMemoryDedicatedAllocateInfoTensorARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ tensor;
}]],
	mod.VkStructureType,
	mod.VkTensorARM
)
ffi.metatype(
	mod.VkMemoryDedicatedAllocateInfoTensorARM,
	{
		__tostring = function(s)
			return ("struct VkMemoryDedicatedAllocateInfoTensorARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tensor)
		end,
	}
)
mod.VkPhysicalDeviceExternalTensorInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const $* pDescription;
	$ handleType;
}]],
	mod.VkStructureType,
	mod.VkTensorCreateFlagsARM,
	mod.VkTensorDescriptionARM,
	mod.VkExternalMemoryHandleTypeFlagBits
)
ffi.metatype(
	mod.VkPhysicalDeviceExternalTensorInfoARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExternalTensorInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.pDescription, t.handleType)
		end,
	}
)
mod.VkExternalTensorPropertiesARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ externalMemoryProperties;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryProperties
)
ffi.metatype(
	mod.VkExternalTensorPropertiesARM,
	{
		__tostring = function(s)
			return ("struct VkExternalTensorPropertiesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.externalMemoryProperties)
		end,
	}
)
mod.VkExternalMemoryTensorCreateInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryHandleTypeFlags
)
ffi.metatype(
	mod.VkExternalMemoryTensorCreateInfoARM,
	{
		__tostring = function(s)
			return ("struct VkExternalMemoryTensorCreateInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleTypes)
		end,
	}
)
mod.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ descriptorBufferTensorDescriptors;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDescriptorBufferTensorFeaturesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.descriptorBufferTensorDescriptors)
		end,
	}
)
mod.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	size_t tensorCaptureReplayDescriptorDataSize;
	size_t tensorViewCaptureReplayDescriptorDataSize;
	size_t tensorDescriptorSize;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDescriptorBufferTensorPropertiesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.tensorCaptureReplayDescriptorDataSize,
				t.tensorViewCaptureReplayDescriptorDataSize,
				t.tensorDescriptorSize
			)
		end,
	}
)
mod.VkDescriptorGetTensorInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ tensorView;
}]],
	mod.VkStructureType,
	mod.VkTensorViewARM
)
ffi.metatype(
	mod.VkDescriptorGetTensorInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDescriptorGetTensorInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tensorView)
		end,
	}
)
mod.VkTensorCaptureDescriptorDataInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ tensor;
}]],
	mod.VkStructureType,
	mod.VkTensorARM
)
ffi.metatype(
	mod.VkTensorCaptureDescriptorDataInfoARM,
	{
		__tostring = function(s)
			return ("struct VkTensorCaptureDescriptorDataInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tensor)
		end,
	}
)
mod.VkTensorViewCaptureDescriptorDataInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ tensorView;
}]],
	mod.VkStructureType,
	mod.VkTensorViewARM
)
ffi.metatype(
	mod.VkTensorViewCaptureDescriptorDataInfoARM,
	{
		__tostring = function(s)
			return ("struct VkTensorViewCaptureDescriptorDataInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tensorView)
		end,
	}
)
mod.VkFrameBoundaryTensorsARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t tensorCount;
	const $* pTensors;
}]],
	mod.VkStructureType,
	mod.VkTensorARM
)
ffi.metatype(
	mod.VkFrameBoundaryTensorsARM,
	{
		__tostring = function(s)
			return ("struct VkFrameBoundaryTensorsARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tensorCount, t.pTensors)
		end,
	}
)
mod.PFN_vkCreateTensorARM = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkTensorCreateInfoARM,
	mod.VkAllocationCallbacks,
	mod.VkTensorARM
)
mod.PFN_vkDestroyTensorARM = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkTensorARM,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreateTensorViewARM = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkTensorViewCreateInfoARM,
	mod.VkAllocationCallbacks,
	mod.VkTensorViewARM
)
mod.PFN_vkDestroyTensorViewARM = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkTensorViewARM,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetTensorMemoryRequirementsARM = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkTensorMemoryRequirementsInfoARM,
	mod.VkMemoryRequirements2
)
mod.PFN_vkBindTensorMemoryARM = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindTensorMemoryInfoARM
)
mod.PFN_vkGetDeviceTensorMemoryRequirementsARM = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkDeviceTensorMemoryRequirementsARM,
	mod.VkMemoryRequirements2
)
mod.PFN_vkCmdCopyTensorARM = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyTensorInfoARM)
mod.PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalTensorInfoARM,
	mod.VkExternalTensorPropertiesARM
)
mod.PFN_vkGetTensorOpaqueCaptureDescriptorDataARM = ffi.typeof(
	[[$ (*)($ , const $*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkTensorCaptureDescriptorDataInfoARM
)
mod.PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM = ffi.typeof(
	[[$ (*)($ , const $*, void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkTensorViewCaptureDescriptorDataInfoARM
)
ffi.cdef(
	[[$  vkCreateTensorARM($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkTensorCreateInfoARM,
	mod.VkAllocationCallbacks,
	mod.VkTensorARM
)
ffi.cdef(
	[[void  vkDestroyTensorARM($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkTensorARM,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateTensorViewARM($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkTensorViewCreateInfoARM,
	mod.VkAllocationCallbacks,
	mod.VkTensorViewARM
)
ffi.cdef(
	[[void  vkDestroyTensorViewARM($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkTensorViewARM,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkGetTensorMemoryRequirementsARM($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkTensorMemoryRequirementsInfoARM,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[$  vkBindTensorMemoryARM($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindTensorMemoryInfoARM
)
ffi.cdef(
	[[void  vkGetDeviceTensorMemoryRequirementsARM($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDeviceTensorMemoryRequirementsARM,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkCmdCopyTensorARM($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyTensorInfoARM
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceExternalTensorPropertiesARM($ , const $*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceExternalTensorInfoARM,
	mod.VkExternalTensorPropertiesARM
)
ffi.cdef(
	[[$  vkGetTensorOpaqueCaptureDescriptorDataARM($ , const $*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkTensorCaptureDescriptorDataInfoARM
)
ffi.cdef(
	[[$  vkGetTensorViewOpaqueCaptureDescriptorDataARM($ , const $*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkTensorViewCaptureDescriptorDataInfoARM
)
mod.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderModuleIdentifier;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderModuleIdentifier)
		end,
	}
)
mod.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint8_t shaderModuleIdentifierAlgorithmUUID[16U];
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderModuleIdentifierAlgorithmUUID)
		end,
	}
)
mod.VkPipelineShaderStageModuleIdentifierCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t identifierSize;
	const uint8_t* pIdentifier;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPipelineShaderStageModuleIdentifierCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelineShaderStageModuleIdentifierCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.identifierSize, t.pIdentifier)
		end,
	}
)
mod.VkShaderModuleIdentifierEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t identifierSize;
	uint8_t identifier[32U];
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkShaderModuleIdentifierEXT,
	{
		__tostring = function(s)
			return ("struct VkShaderModuleIdentifierEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.identifierSize, t.identifier)
		end,
	}
)
mod.PFN_vkGetShaderModuleIdentifierEXT = ffi.typeof(
	[[void (*)($ , $ , $*)]],
	mod.VkDevice,
	mod.VkShaderModule,
	mod.VkShaderModuleIdentifierEXT
)
mod.PFN_vkGetShaderModuleCreateInfoIdentifierEXT = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkShaderModuleCreateInfo,
	mod.VkShaderModuleIdentifierEXT
)
ffi.cdef(
	[[void  vkGetShaderModuleIdentifierEXT($ , $ , $*);]],
	mod.VkDevice,
	mod.VkShaderModule,
	mod.VkShaderModuleIdentifierEXT
)
ffi.cdef(
	[[void  vkGetShaderModuleCreateInfoIdentifierEXT($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkShaderModuleCreateInfo,
	mod.VkShaderModuleIdentifierEXT
)
mod.VkOpticalFlowSessionNV = ffi.typeof([[void*]])
mod.VkOpticalFlowPerformanceLevelNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowSessionBindingPointNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowGridSizeFlagBitsNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowGridSizeFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkOpticalFlowUsageFlagBitsNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = 0x00000010,
	VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowUsageFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkOpticalFlowSessionCreateFlagBitsNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = 0x00000010,
	VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowSessionCreateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkOpticalFlowExecuteFlagBitsNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowExecuteFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceOpticalFlowFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ opticalFlow;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceOpticalFlowFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceOpticalFlowFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.opticalFlow)
		end,
	}
)
mod.VkPhysicalDeviceOpticalFlowPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ supportedOutputGridSizes;
	$ supportedHintGridSizes;
	$ hintSupported;
	$ costSupported;
	$ bidirectionalFlowSupported;
	$ globalFlowSupported;
	uint32_t minWidth;
	uint32_t minHeight;
	uint32_t maxWidth;
	uint32_t maxHeight;
	uint32_t maxNumRegionsOfInterest;
}]],
	mod.VkStructureType,
	mod.VkOpticalFlowGridSizeFlagsNV,
	mod.VkOpticalFlowGridSizeFlagsNV,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceOpticalFlowPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceOpticalFlowPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.supportedOutputGridSizes,
				t.supportedHintGridSizes,
				t.hintSupported,
				t.costSupported,
				t.bidirectionalFlowSupported,
				t.globalFlowSupported,
				t.minWidth,
				t.minHeight,
				t.maxWidth,
				t.maxHeight,
				t.maxNumRegionsOfInterest
			)
		end,
	}
)
mod.VkOpticalFlowImageFormatInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ usage;
}]],
	mod.VkStructureType,
	mod.VkOpticalFlowUsageFlagsNV
)
ffi.metatype(
	mod.VkOpticalFlowImageFormatInfoNV,
	{
		__tostring = function(s)
			return ("struct VkOpticalFlowImageFormatInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.usage)
		end,
	}
)
mod.VkOpticalFlowImageFormatPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ format;
}]],
	mod.VkStructureType,
	mod.VkFormat
)
ffi.metatype(
	mod.VkOpticalFlowImageFormatPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkOpticalFlowImageFormatPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.format)
		end,
	}
)
mod.VkOpticalFlowSessionCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t width;
	uint32_t height;
	$ imageFormat;
	$ flowVectorFormat;
	$ costFormat;
	$ outputGridSize;
	$ hintGridSize;
	$ performanceLevel;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkFormat,
	mod.VkFormat,
	mod.VkOpticalFlowGridSizeFlagsNV,
	mod.VkOpticalFlowGridSizeFlagsNV,
	mod.VkOpticalFlowPerformanceLevelNV,
	mod.VkOpticalFlowSessionCreateFlagsNV
)
ffi.metatype(
	mod.VkOpticalFlowSessionCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkOpticalFlowSessionCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.width,
				t.height,
				t.imageFormat,
				t.flowVectorFormat,
				t.costFormat,
				t.outputGridSize,
				t.hintGridSize,
				t.performanceLevel,
				t.flags
			)
		end,
	}
)
mod.VkOpticalFlowSessionCreatePrivateDataInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t id;
	uint32_t size;
	const void* pPrivateData;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkOpticalFlowSessionCreatePrivateDataInfoNV,
	{
		__tostring = function(s)
			return ("struct VkOpticalFlowSessionCreatePrivateDataInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.id, t.size, t.pPrivateData)
		end,
	}
)
mod.VkOpticalFlowExecuteInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
	uint32_t regionCount;
	const $* pRegions;
}]],
	mod.VkStructureType,
	mod.VkOpticalFlowExecuteFlagsNV,
	mod.VkRect2D
)
ffi.metatype(
	mod.VkOpticalFlowExecuteInfoNV,
	{
		__tostring = function(s)
			return ("struct VkOpticalFlowExecuteInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.regionCount, t.pRegions)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV = ffi.typeof(
	[[$ (*)($ , const $*, uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkOpticalFlowImageFormatInfoNV,
	mod.VkOpticalFlowImageFormatPropertiesNV
)
mod.PFN_vkCreateOpticalFlowSessionNV = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkOpticalFlowSessionCreateInfoNV,
	mod.VkAllocationCallbacks,
	mod.VkOpticalFlowSessionNV
)
mod.PFN_vkDestroyOpticalFlowSessionNV = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkOpticalFlowSessionNV,
	mod.VkAllocationCallbacks
)
mod.PFN_vkBindOpticalFlowSessionImageNV = ffi.typeof(
	[[$ (*)($ , $ , $ , $ , $ )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkOpticalFlowSessionNV,
	mod.VkOpticalFlowSessionBindingPointNV,
	mod.VkImageView,
	mod.VkImageLayout
)
mod.PFN_vkCmdOpticalFlowExecuteNV = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkOpticalFlowSessionNV,
	mod.VkOpticalFlowExecuteInfoNV
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceOpticalFlowImageFormatsNV($ , const $*, uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkOpticalFlowImageFormatInfoNV,
	mod.VkOpticalFlowImageFormatPropertiesNV
)
ffi.cdef(
	[[$  vkCreateOpticalFlowSessionNV($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkOpticalFlowSessionCreateInfoNV,
	mod.VkAllocationCallbacks,
	mod.VkOpticalFlowSessionNV
)
ffi.cdef(
	[[void  vkDestroyOpticalFlowSessionNV($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkOpticalFlowSessionNV,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkBindOpticalFlowSessionImageNV($ , $ , $ , $ , $ );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkOpticalFlowSessionNV,
	mod.VkOpticalFlowSessionBindingPointNV,
	mod.VkImageView,
	mod.VkImageLayout
)
ffi.cdef(
	[[void  vkCmdOpticalFlowExecuteNV($ , $ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkOpticalFlowSessionNV,
	mod.VkOpticalFlowExecuteInfoNV
)
mod.VkPhysicalDeviceLegacyDitheringFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ legacyDithering;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceLegacyDitheringFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceLegacyDitheringFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.legacyDithering)
		end,
	}
)
mod.VkPhysicalDevicePipelineProtectedAccessFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePipelineProtectedAccessFeatures)
mod.VkAntiLagModeAMD = ffi.typeof([[enum {
	VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD = 0,
	VK_ANTI_LAG_MODE_ON_AMD = 1,
	VK_ANTI_LAG_MODE_OFF_AMD = 2,
	VK_ANTI_LAG_MODE_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkAntiLagStageAMD = ffi.typeof([[enum {
	VK_ANTI_LAG_STAGE_INPUT_AMD = 0,
	VK_ANTI_LAG_STAGE_PRESENT_AMD = 1,
	VK_ANTI_LAG_STAGE_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceAntiLagFeaturesAMD = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ antiLag;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceAntiLagFeaturesAMD,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceAntiLagFeaturesAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.antiLag)
		end,
	}
)
mod.VkAntiLagPresentationInfoAMD = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ stage;
	uint64_t frameIndex;
}]],
	mod.VkStructureType,
	mod.VkAntiLagStageAMD
)
ffi.metatype(
	mod.VkAntiLagPresentationInfoAMD,
	{
		__tostring = function(s)
			return ("struct VkAntiLagPresentationInfoAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stage, t.frameIndex)
		end,
	}
)
mod.VkAntiLagDataAMD = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ mode;
	uint32_t maxFPS;
	const $* pPresentationInfo;
}]],
	mod.VkStructureType,
	mod.VkAntiLagModeAMD,
	mod.VkAntiLagPresentationInfoAMD
)
ffi.metatype(
	mod.VkAntiLagDataAMD,
	{
		__tostring = function(s)
			return ("struct VkAntiLagDataAMD[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.mode, t.maxFPS, t.pPresentationInfo)
		end,
	}
)
mod.PFN_vkAntiLagUpdateAMD = ffi.typeof([[void (*)($ , const $*)]], mod.VkDevice, mod.VkAntiLagDataAMD)
ffi.cdef([[void  vkAntiLagUpdateAMD($ , const $*);]], mod.VkDevice, mod.VkAntiLagDataAMD)
mod.VkShaderEXT = ffi.typeof([[void*]])
mod.VkShaderCodeTypeEXT = ffi.typeof([[enum {
	VK_SHADER_CODE_TYPE_BINARY_EXT = 0,
	VK_SHADER_CODE_TYPE_SPIRV_EXT = 1,
	VK_SHADER_CODE_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDepthClampModeEXT = ffi.typeof([[enum {
	VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT = 0,
	VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT = 1,
	VK_DEPTH_CLAMP_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkShaderCreateFlagBitsEXT = ffi.typeof([[enum {
	VK_SHADER_CREATE_LINK_STAGE_BIT_EXT = 0x00000001,
	VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 0x00000002,
	VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 0x00000004,
	VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT = 0x00000008,
	VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT = 0x00000010,
	VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT = 0x00000020,
	VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00000040,
	VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT = 0x00000080,
	VK_SHADER_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkShaderCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceShaderObjectFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderObject;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderObjectFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderObjectFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderObject)
		end,
	}
)
mod.VkPhysicalDeviceShaderObjectPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint8_t shaderBinaryUUID[16U];
	uint32_t shaderBinaryVersion;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderObjectPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderObjectPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderBinaryUUID, t.shaderBinaryVersion)
		end,
	}
)
mod.VkShaderCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ stage;
	$ nextStage;
	$ codeType;
	size_t codeSize;
	const void* pCode;
	const char* pName;
	uint32_t setLayoutCount;
	const $* pSetLayouts;
	uint32_t pushConstantRangeCount;
	const $* pPushConstantRanges;
	const $* pSpecializationInfo;
}]],
	mod.VkStructureType,
	mod.VkShaderCreateFlagsEXT,
	mod.VkShaderStageFlagBits,
	mod.VkShaderStageFlags,
	mod.VkShaderCodeTypeEXT,
	mod.VkDescriptorSetLayout,
	mod.VkPushConstantRange,
	mod.VkSpecializationInfo
)
ffi.metatype(
	mod.VkShaderCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkShaderCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.stage,
				t.nextStage,
				t.codeType,
				t.codeSize,
				t.pCode,
				t.pName,
				t.setLayoutCount,
				t.pSetLayouts,
				t.pushConstantRangeCount,
				t.pPushConstantRanges,
				t.pSpecializationInfo
			)
		end,
	}
)
mod.VkShaderRequiredSubgroupSizeCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo)
mod.VkDepthClampRangeEXT = ffi.typeof([[struct {
	float minDepthClamp;
	float maxDepthClamp;
}]])
ffi.metatype(
	mod.VkDepthClampRangeEXT,
	{
		__tostring = function(s)
			return ("struct VkDepthClampRangeEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.minDepthClamp, t.maxDepthClamp)
		end,
	}
)
mod.PFN_vkCreateShadersEXT = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkShaderCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkShaderEXT
)
mod.PFN_vkDestroyShaderEXT = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkShaderEXT,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetShaderBinaryDataEXT = ffi.typeof([[$ (*)($ , $ , size_t*, void*)]], mod.VkResult, mod.VkDevice, mod.VkShaderEXT)
mod.PFN_vkCmdBindShadersEXT = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, const $*)]],
	mod.VkCommandBuffer,
	mod.VkShaderStageFlagBits,
	mod.VkShaderEXT
)
mod.PFN_vkCmdSetDepthClampRangeEXT = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkDepthClampModeEXT,
	mod.VkDepthClampRangeEXT
)
ffi.cdef(
	[[$  vkCreateShadersEXT($ , uint32_t , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkShaderCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkShaderEXT
)
ffi.cdef(
	[[void  vkDestroyShaderEXT($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkShaderEXT,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkGetShaderBinaryDataEXT($ , $ , size_t*, void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkShaderEXT
)
ffi.cdef(
	[[void  vkCmdBindShadersEXT($ , uint32_t , const $*, const $*);]],
	mod.VkCommandBuffer,
	mod.VkShaderStageFlagBits,
	mod.VkShaderEXT
)
ffi.cdef(
	[[void  vkCmdSetDepthClampRangeEXT($ , $ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDepthClampModeEXT,
	mod.VkDepthClampRangeEXT
)
mod.VkPhysicalDeviceTilePropertiesFeaturesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ tileProperties;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceTilePropertiesFeaturesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTilePropertiesFeaturesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tileProperties)
		end,
	}
)
mod.VkTilePropertiesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ tileSize;
	$ apronSize;
	$ origin;
}]],
	mod.VkStructureType,
	mod.VkExtent3D,
	mod.VkExtent2D,
	mod.VkOffset2D
)
ffi.metatype(
	mod.VkTilePropertiesQCOM,
	{
		__tostring = function(s)
			return ("struct VkTilePropertiesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tileSize, t.apronSize, t.origin)
		end,
	}
)
mod.PFN_vkGetFramebufferTilePropertiesQCOM = ffi.typeof(
	[[$ (*)($ , $ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkFramebuffer,
	mod.VkTilePropertiesQCOM
)
mod.PFN_vkGetDynamicRenderingTilePropertiesQCOM = ffi.typeof(
	[[$ (*)($ , const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkRenderingInfo,
	mod.VkTilePropertiesQCOM
)
ffi.cdef(
	[[$  vkGetFramebufferTilePropertiesQCOM($ , $ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkFramebuffer,
	mod.VkTilePropertiesQCOM
)
ffi.cdef(
	[[$  vkGetDynamicRenderingTilePropertiesQCOM($ , const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkRenderingInfo,
	mod.VkTilePropertiesQCOM
)
mod.VkPhysicalDeviceAmigoProfilingFeaturesSEC = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ amigoProfiling;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceAmigoProfilingFeaturesSEC,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceAmigoProfilingFeaturesSEC[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.amigoProfiling)
		end,
	}
)
mod.VkAmigoProfilingSubmitInfoSEC = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint64_t firstDrawTimestamp;
	uint64_t swapBufferTimestamp;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkAmigoProfilingSubmitInfoSEC,
	{
		__tostring = function(s)
			return ("struct VkAmigoProfilingSubmitInfoSEC[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.firstDrawTimestamp, t.swapBufferTimestamp)
		end,
	}
)
mod.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ multiviewPerViewViewports;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.multiviewPerViewViewports)
		end,
	}
)
mod.VkRayTracingInvocationReorderModeNV = ffi.typeof([[enum {
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = 0,
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = 1,
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ rayTracingInvocationReorderReorderingHint;
}]],
	mod.VkStructureType,
	mod.VkRayTracingInvocationReorderModeNV
)
ffi.metatype(
	mod.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.rayTracingInvocationReorderReorderingHint)
		end,
	}
)
mod.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ rayTracingInvocationReorder;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.rayTracingInvocationReorder)
		end,
	}
)
mod.VkCooperativeVectorMatrixLayoutNV = ffi.typeof([[enum {
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV = 0,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV = 1,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV = 2,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV = 3,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceCooperativeVectorPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ cooperativeVectorSupportedStages;
	$ cooperativeVectorTrainingFloat16Accumulation;
	$ cooperativeVectorTrainingFloat32Accumulation;
	uint32_t maxCooperativeVectorComponents;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCooperativeVectorPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCooperativeVectorPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.cooperativeVectorSupportedStages,
				t.cooperativeVectorTrainingFloat16Accumulation,
				t.cooperativeVectorTrainingFloat32Accumulation,
				t.maxCooperativeVectorComponents
			)
		end,
	}
)
mod.VkPhysicalDeviceCooperativeVectorFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ cooperativeVector;
	$ cooperativeVectorTraining;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCooperativeVectorFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCooperativeVectorFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.cooperativeVector, t.cooperativeVectorTraining)
		end,
	}
)
mod.VkCooperativeVectorPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ inputType;
	$ inputInterpretation;
	$ matrixInterpretation;
	$ biasInterpretation;
	$ resultType;
	$ transpose;
}]],
	mod.VkStructureType,
	mod.VkComponentTypeKHR,
	mod.VkComponentTypeKHR,
	mod.VkComponentTypeKHR,
	mod.VkComponentTypeKHR,
	mod.VkComponentTypeKHR,
	mod.VkBool32
)
ffi.metatype(
	mod.VkCooperativeVectorPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkCooperativeVectorPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.inputType,
				t.inputInterpretation,
				t.matrixInterpretation,
				t.biasInterpretation,
				t.resultType,
				t.transpose
			)
		end,
	}
)
mod.VkConvertCooperativeVectorMatrixInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	size_t srcSize;
	$ srcData;
	size_t* pDstSize;
	$ dstData;
	$ srcComponentType;
	$ dstComponentType;
	uint32_t numRows;
	uint32_t numColumns;
	$ srcLayout;
	size_t srcStride;
	$ dstLayout;
	size_t dstStride;
}]],
	mod.VkStructureType,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceOrHostAddressKHR,
	mod.VkComponentTypeKHR,
	mod.VkComponentTypeKHR,
	mod.VkCooperativeVectorMatrixLayoutNV,
	mod.VkCooperativeVectorMatrixLayoutNV
)
ffi.metatype(
	mod.VkConvertCooperativeVectorMatrixInfoNV,
	{
		__tostring = function(s)
			return ("struct VkConvertCooperativeVectorMatrixInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.srcSize,
				t.srcData,
				t.pDstSize,
				t.dstData,
				t.srcComponentType,
				t.dstComponentType,
				t.numRows,
				t.numColumns,
				t.srcLayout,
				t.srcStride,
				t.dstLayout,
				t.dstStride
			)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkCooperativeVectorPropertiesNV
)
mod.PFN_vkConvertCooperativeVectorMatrixNV = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkConvertCooperativeVectorMatrixInfoNV
)
mod.PFN_vkCmdConvertCooperativeVectorMatrixNV = ffi.typeof(
	[[void (*)($ , uint32_t , const $*)]],
	mod.VkCommandBuffer,
	mod.VkConvertCooperativeVectorMatrixInfoNV
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceCooperativeVectorPropertiesNV($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkCooperativeVectorPropertiesNV
)
ffi.cdef(
	[[$  vkConvertCooperativeVectorMatrixNV($ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkConvertCooperativeVectorMatrixInfoNV
)
ffi.cdef(
	[[void  vkCmdConvertCooperativeVectorMatrixNV($ , uint32_t , const $*);]],
	mod.VkCommandBuffer,
	mod.VkConvertCooperativeVectorMatrixInfoNV
)
mod.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ extendedSparseAddressSpace;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.extendedSparseAddressSpace)
		end,
	}
)
mod.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ extendedSparseAddressSpaceSize;
	$ extendedSparseImageUsageFlags;
	$ extendedSparseBufferUsageFlags;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize,
	mod.VkImageUsageFlags,
	mod.VkBufferUsageFlags
)
ffi.metatype(
	mod.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.extendedSparseAddressSpaceSize,
				t.extendedSparseImageUsageFlags,
				t.extendedSparseBufferUsageFlags
			)
		end,
	}
)
mod.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ legacyVertexAttributes;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.legacyVertexAttributes)
		end,
	}
)
mod.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ nativeUnalignedPerformance;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.nativeUnalignedPerformance)
		end,
	}
)
mod.VkLayerSettingTypeEXT = ffi.typeof([[enum {
	VK_LAYER_SETTING_TYPE_BOOL32_EXT = 0,
	VK_LAYER_SETTING_TYPE_INT32_EXT = 1,
	VK_LAYER_SETTING_TYPE_INT64_EXT = 2,
	VK_LAYER_SETTING_TYPE_UINT32_EXT = 3,
	VK_LAYER_SETTING_TYPE_UINT64_EXT = 4,
	VK_LAYER_SETTING_TYPE_FLOAT32_EXT = 5,
	VK_LAYER_SETTING_TYPE_FLOAT64_EXT = 6,
	VK_LAYER_SETTING_TYPE_STRING_EXT = 7,
	VK_LAYER_SETTING_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkLayerSettingEXT = ffi.typeof(
	[[struct {
	const char* pLayerName;
	const char* pSettingName;
	$ type;
	uint32_t valueCount;
	const void* pValues;
}]],
	mod.VkLayerSettingTypeEXT
)
ffi.metatype(
	mod.VkLayerSettingEXT,
	{
		__tostring = function(s)
			return ("struct VkLayerSettingEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.pLayerName, t.pSettingName, t.type, t.valueCount, t.pValues)
		end,
	}
)
mod.VkLayerSettingsCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t settingCount;
	const $* pSettings;
}]],
	mod.VkStructureType,
	mod.VkLayerSettingEXT
)
ffi.metatype(
	mod.VkLayerSettingsCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkLayerSettingsCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.settingCount, t.pSettings)
		end,
	}
)
mod.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderCoreBuiltins;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderCoreBuiltins)
		end,
	}
)
mod.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint64_t shaderCoreMask;
	uint32_t shaderCoreCount;
	uint32_t shaderWarpsPerCore;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderCoreMask,
				t.shaderCoreCount,
				t.shaderWarpsPerCore
			)
		end,
	}
)
mod.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelineLibraryGroupHandles;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineLibraryGroupHandles)
		end,
	}
)
mod.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ dynamicRenderingUnusedAttachments;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dynamicRenderingUnusedAttachments)
		end,
	}
)
mod.VkLatencyMarkerNV = ffi.typeof([[enum {
	VK_LATENCY_MARKER_SIMULATION_START_NV = 0,
	VK_LATENCY_MARKER_SIMULATION_END_NV = 1,
	VK_LATENCY_MARKER_RENDERSUBMIT_START_NV = 2,
	VK_LATENCY_MARKER_RENDERSUBMIT_END_NV = 3,
	VK_LATENCY_MARKER_PRESENT_START_NV = 4,
	VK_LATENCY_MARKER_PRESENT_END_NV = 5,
	VK_LATENCY_MARKER_INPUT_SAMPLE_NV = 6,
	VK_LATENCY_MARKER_TRIGGER_FLASH_NV = 7,
	VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV = 8,
	VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV = 9,
	VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV = 10,
	VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV = 11,
	VK_LATENCY_MARKER_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOutOfBandQueueTypeNV = ffi.typeof([[enum {
	VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV = 0,
	VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV = 1,
	VK_OUT_OF_BAND_QUEUE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkLatencySleepModeInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ lowLatencyMode;
	$ lowLatencyBoost;
	uint32_t minimumIntervalUs;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkLatencySleepModeInfoNV,
	{
		__tostring = function(s)
			return ("struct VkLatencySleepModeInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.lowLatencyMode,
				t.lowLatencyBoost,
				t.minimumIntervalUs
			)
		end,
	}
)
mod.VkLatencySleepInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ signalSemaphore;
	uint64_t value;
}]],
	mod.VkStructureType,
	mod.VkSemaphore
)
ffi.metatype(
	mod.VkLatencySleepInfoNV,
	{
		__tostring = function(s)
			return ("struct VkLatencySleepInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.signalSemaphore, t.value)
		end,
	}
)
mod.VkSetLatencyMarkerInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint64_t presentID;
	$ marker;
}]],
	mod.VkStructureType,
	mod.VkLatencyMarkerNV
)
ffi.metatype(
	mod.VkSetLatencyMarkerInfoNV,
	{
		__tostring = function(s)
			return ("struct VkSetLatencyMarkerInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentID, t.marker)
		end,
	}
)
mod.VkLatencyTimingsFrameReportNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint64_t presentID;
	uint64_t inputSampleTimeUs;
	uint64_t simStartTimeUs;
	uint64_t simEndTimeUs;
	uint64_t renderSubmitStartTimeUs;
	uint64_t renderSubmitEndTimeUs;
	uint64_t presentStartTimeUs;
	uint64_t presentEndTimeUs;
	uint64_t driverStartTimeUs;
	uint64_t driverEndTimeUs;
	uint64_t osRenderQueueStartTimeUs;
	uint64_t osRenderQueueEndTimeUs;
	uint64_t gpuRenderStartTimeUs;
	uint64_t gpuRenderEndTimeUs;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkLatencyTimingsFrameReportNV,
	{
		__tostring = function(s)
			return ("struct VkLatencyTimingsFrameReportNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.presentID,
				t.inputSampleTimeUs,
				t.simStartTimeUs,
				t.simEndTimeUs,
				t.renderSubmitStartTimeUs,
				t.renderSubmitEndTimeUs,
				t.presentStartTimeUs,
				t.presentEndTimeUs,
				t.driverStartTimeUs,
				t.driverEndTimeUs,
				t.osRenderQueueStartTimeUs,
				t.osRenderQueueEndTimeUs,
				t.gpuRenderStartTimeUs,
				t.gpuRenderEndTimeUs
			)
		end,
	}
)
mod.VkGetLatencyMarkerInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t timingCount;
	$* pTimings;
}]],
	mod.VkStructureType,
	mod.VkLatencyTimingsFrameReportNV
)
ffi.metatype(
	mod.VkGetLatencyMarkerInfoNV,
	{
		__tostring = function(s)
			return ("struct VkGetLatencyMarkerInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.timingCount, t.pTimings)
		end,
	}
)
mod.VkLatencySubmissionPresentIdNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint64_t presentID;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkLatencySubmissionPresentIdNV,
	{
		__tostring = function(s)
			return ("struct VkLatencySubmissionPresentIdNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentID)
		end,
	}
)
mod.VkSwapchainLatencyCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ latencyModeEnable;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSwapchainLatencyCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkSwapchainLatencyCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.latencyModeEnable)
		end,
	}
)
mod.VkOutOfBandQueueTypeInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ queueType;
}]],
	mod.VkStructureType,
	mod.VkOutOfBandQueueTypeNV
)
ffi.metatype(
	mod.VkOutOfBandQueueTypeInfoNV,
	{
		__tostring = function(s)
			return ("struct VkOutOfBandQueueTypeInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.queueType)
		end,
	}
)
mod.VkLatencySurfaceCapabilitiesNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t presentModeCount;
	$* pPresentModes;
}]],
	mod.VkStructureType,
	mod.VkPresentModeKHR
)
ffi.metatype(
	mod.VkLatencySurfaceCapabilitiesNV,
	{
		__tostring = function(s)
			return ("struct VkLatencySurfaceCapabilitiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentModeCount, t.pPresentModes)
		end,
	}
)
mod.PFN_vkSetLatencySleepModeNV = ffi.typeof(
	[[$ (*)($ , $ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkLatencySleepModeInfoNV
)
mod.PFN_vkLatencySleepNV = ffi.typeof(
	[[$ (*)($ , $ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkLatencySleepInfoNV
)
mod.PFN_vkSetLatencyMarkerNV = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkSetLatencyMarkerInfoNV
)
mod.PFN_vkGetLatencyTimingsNV = ffi.typeof(
	[[void (*)($ , $ , $*)]],
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkGetLatencyMarkerInfoNV
)
mod.PFN_vkQueueNotifyOutOfBandNV = ffi.typeof([[void (*)($ , const $*)]], mod.VkQueue, mod.VkOutOfBandQueueTypeInfoNV)
ffi.cdef(
	[[$  vkSetLatencySleepModeNV($ , $ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkLatencySleepModeInfoNV
)
ffi.cdef(
	[[$  vkLatencySleepNV($ , $ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkLatencySleepInfoNV
)
ffi.cdef(
	[[void  vkSetLatencyMarkerNV($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkSetLatencyMarkerInfoNV
)
ffi.cdef(
	[[void  vkGetLatencyTimingsNV($ , $ , $*);]],
	mod.VkDevice,
	mod.VkSwapchainKHR,
	mod.VkGetLatencyMarkerInfoNV
)
ffi.cdef(
	[[void  vkQueueNotifyOutOfBandNV($ , const $*);]],
	mod.VkQueue,
	mod.VkOutOfBandQueueTypeInfoNV
)
mod.VkDataGraphPipelineSessionARM = ffi.typeof([[void*]])
mod.VkDataGraphPipelineSessionBindPointARM = ffi.typeof([[enum {
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkDataGraphPipelineSessionBindPointTypeARM = ffi.typeof([[enum {
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkDataGraphPipelinePropertyARM = ffi.typeof([[enum {
	VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM = 1,
	VK_DATA_GRAPH_PIPELINE_PROPERTY_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceDataGraphProcessingEngineTypeARM = ffi.typeof([[enum {
	VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM = 0,
	VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceDataGraphOperationTypeARM = ffi.typeof([[enum {
	VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM = 0,
	VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkDataGraphPipelineSessionCreateFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkDataGraphPipelineSessionCreateFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_DATA_GRAPH_PIPELINE_SESSION_CREATE_PROTECTED_BIT_ARM = 0x00000001ULL
mod.VkDataGraphPipelineDispatchFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkDataGraphPipelineDispatchFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkPhysicalDeviceDataGraphFeaturesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ dataGraph;
	$ dataGraphUpdateAfterBind;
	$ dataGraphSpecializationConstants;
	$ dataGraphDescriptorBuffer;
	$ dataGraphShaderModule;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDataGraphFeaturesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDataGraphFeaturesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.dataGraph,
				t.dataGraphUpdateAfterBind,
				t.dataGraphSpecializationConstants,
				t.dataGraphDescriptorBuffer,
				t.dataGraphShaderModule
			)
		end,
	}
)
mod.VkDataGraphPipelineConstantARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t id;
	const void* pConstantData;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDataGraphPipelineConstantARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineConstantARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.id, t.pConstantData)
		end,
	}
)
mod.VkDataGraphPipelineResourceInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t descriptorSet;
	uint32_t binding;
	uint32_t arrayElement;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDataGraphPipelineResourceInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineResourceInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.descriptorSet, t.binding, t.arrayElement)
		end,
	}
)
mod.VkDataGraphPipelineCompilerControlCreateInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const char* pVendorOptions;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDataGraphPipelineCompilerControlCreateInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineCompilerControlCreateInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pVendorOptions)
		end,
	}
)
mod.VkDataGraphPipelineCreateInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ layout;
	uint32_t resourceInfoCount;
	const $* pResourceInfos;
}]],
	mod.VkStructureType,
	mod.VkPipelineCreateFlags2KHR,
	mod.VkPipelineLayout,
	mod.VkDataGraphPipelineResourceInfoARM
)
ffi.metatype(
	mod.VkDataGraphPipelineCreateInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineCreateInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.layout,
				t.resourceInfoCount,
				t.pResourceInfos
			)
		end,
	}
)
mod.VkDataGraphPipelineShaderModuleCreateInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ module;
	const char* pName;
	const $* pSpecializationInfo;
	uint32_t constantCount;
	const $* pConstants;
}]],
	mod.VkStructureType,
	mod.VkShaderModule,
	mod.VkSpecializationInfo,
	mod.VkDataGraphPipelineConstantARM
)
ffi.metatype(
	mod.VkDataGraphPipelineShaderModuleCreateInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineShaderModuleCreateInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.module,
				t.pName,
				t.pSpecializationInfo,
				t.constantCount,
				t.pConstants
			)
		end,
	}
)
mod.VkDataGraphPipelineSessionCreateInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ dataGraphPipeline;
}]],
	mod.VkStructureType,
	mod.VkDataGraphPipelineSessionCreateFlagsARM,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkDataGraphPipelineSessionCreateInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineSessionCreateInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.dataGraphPipeline)
		end,
	}
)
mod.VkDataGraphPipelineSessionBindPointRequirementsInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ session;
}]],
	mod.VkStructureType,
	mod.VkDataGraphPipelineSessionARM
)
ffi.metatype(
	mod.VkDataGraphPipelineSessionBindPointRequirementsInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineSessionBindPointRequirementsInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.session)
		end,
	}
)
mod.VkDataGraphPipelineSessionBindPointRequirementARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ bindPoint;
	$ bindPointType;
	uint32_t numObjects;
}]],
	mod.VkStructureType,
	mod.VkDataGraphPipelineSessionBindPointARM,
	mod.VkDataGraphPipelineSessionBindPointTypeARM
)
ffi.metatype(
	mod.VkDataGraphPipelineSessionBindPointRequirementARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineSessionBindPointRequirementARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.bindPoint, t.bindPointType, t.numObjects)
		end,
	}
)
mod.VkDataGraphPipelineSessionMemoryRequirementsInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ session;
	$ bindPoint;
	uint32_t objectIndex;
}]],
	mod.VkStructureType,
	mod.VkDataGraphPipelineSessionARM,
	mod.VkDataGraphPipelineSessionBindPointARM
)
ffi.metatype(
	mod.VkDataGraphPipelineSessionMemoryRequirementsInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineSessionMemoryRequirementsInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.session, t.bindPoint, t.objectIndex)
		end,
	}
)
mod.VkBindDataGraphPipelineSessionMemoryInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ session;
	$ bindPoint;
	uint32_t objectIndex;
	$ memory;
	$ memoryOffset;
}]],
	mod.VkStructureType,
	mod.VkDataGraphPipelineSessionARM,
	mod.VkDataGraphPipelineSessionBindPointARM,
	mod.VkDeviceMemory,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkBindDataGraphPipelineSessionMemoryInfoARM,
	{
		__tostring = function(s)
			return ("struct VkBindDataGraphPipelineSessionMemoryInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.session,
				t.bindPoint,
				t.objectIndex,
				t.memory,
				t.memoryOffset
			)
		end,
	}
)
mod.VkDataGraphPipelineInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ dataGraphPipeline;
}]],
	mod.VkStructureType,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkDataGraphPipelineInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dataGraphPipeline)
		end,
	}
)
mod.VkDataGraphPipelinePropertyQueryResultARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ property;
	$ isText;
	size_t dataSize;
	void* pData;
}]],
	mod.VkStructureType,
	mod.VkDataGraphPipelinePropertyARM,
	mod.VkBool32
)
ffi.metatype(
	mod.VkDataGraphPipelinePropertyQueryResultARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelinePropertyQueryResultARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.property, t.isText, t.dataSize, t.pData)
		end,
	}
)
mod.VkDataGraphPipelineIdentifierCreateInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t identifierSize;
	const uint8_t* pIdentifier;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDataGraphPipelineIdentifierCreateInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineIdentifierCreateInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.identifierSize, t.pIdentifier)
		end,
	}
)
mod.VkDataGraphPipelineDispatchInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkDataGraphPipelineDispatchFlagsARM
)
ffi.metatype(
	mod.VkDataGraphPipelineDispatchInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphPipelineDispatchInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags)
		end,
	}
)
mod.VkPhysicalDeviceDataGraphProcessingEngineARM = ffi.typeof(
	[[struct {
	$ type;
	$ isForeign;
}]],
	mod.VkPhysicalDeviceDataGraphProcessingEngineTypeARM,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDataGraphProcessingEngineARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDataGraphProcessingEngineARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.type, t.isForeign)
		end,
	}
)
mod.VkPhysicalDeviceDataGraphOperationSupportARM = ffi.typeof(
	[[struct {
	$ operationType;
	char name[128U];
	uint32_t version;
}]],
	mod.VkPhysicalDeviceDataGraphOperationTypeARM
)
ffi.metatype(
	mod.VkPhysicalDeviceDataGraphOperationSupportARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDataGraphOperationSupportARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.operationType, t.name, t.version)
		end,
	}
)
mod.VkQueueFamilyDataGraphPropertiesARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ engine;
	$ operation;
}]],
	mod.VkStructureType,
	mod.VkPhysicalDeviceDataGraphProcessingEngineARM,
	mod.VkPhysicalDeviceDataGraphOperationSupportARM
)
ffi.metatype(
	mod.VkQueueFamilyDataGraphPropertiesARM,
	{
		__tostring = function(s)
			return ("struct VkQueueFamilyDataGraphPropertiesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.engine, t.operation)
		end,
	}
)
mod.VkDataGraphProcessingEngineCreateInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t processingEngineCount;
	$* pProcessingEngines;
}]],
	mod.VkStructureType,
	mod.VkPhysicalDeviceDataGraphProcessingEngineARM
)
ffi.metatype(
	mod.VkDataGraphProcessingEngineCreateInfoARM,
	{
		__tostring = function(s)
			return ("struct VkDataGraphProcessingEngineCreateInfoARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.processingEngineCount, t.pProcessingEngines)
		end,
	}
)
mod.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t queueFamilyIndex;
	$ engineType;
}]],
	mod.VkStructureType,
	mod.VkPhysicalDeviceDataGraphProcessingEngineTypeARM
)
ffi.metatype(
	mod.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.queueFamilyIndex, t.engineType)
		end,
	}
)
mod.VkQueueFamilyDataGraphProcessingEnginePropertiesARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ foreignSemaphoreHandleTypes;
	$ foreignMemoryHandleTypes;
}]],
	mod.VkStructureType,
	mod.VkExternalSemaphoreHandleTypeFlags,
	mod.VkExternalMemoryHandleTypeFlags
)
ffi.metatype(
	mod.VkQueueFamilyDataGraphProcessingEnginePropertiesARM,
	{
		__tostring = function(s)
			return ("struct VkQueueFamilyDataGraphProcessingEnginePropertiesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.foreignSemaphoreHandleTypes,
				t.foreignMemoryHandleTypes
			)
		end,
	}
)
mod.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t dimension;
	uint32_t zeroCount;
	uint32_t groupSize;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM,
	{
		__tostring = function(s)
			return (
				"struct VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dimension, t.zeroCount, t.groupSize)
		end,
	}
)
mod.PFN_vkCreateDataGraphPipelinesARM = ffi.typeof(
	[[$ (*)($ , $ , $ , uint32_t , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkPipelineCache,
	mod.VkDataGraphPipelineCreateInfoARM,
	mod.VkAllocationCallbacks,
	mod.VkPipeline
)
mod.PFN_vkCreateDataGraphPipelineSessionARM = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDataGraphPipelineSessionCreateInfoARM,
	mod.VkAllocationCallbacks,
	mod.VkDataGraphPipelineSessionARM
)
mod.PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM = ffi.typeof(
	[[$ (*)($ , const $*, uint32_t*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDataGraphPipelineSessionBindPointRequirementsInfoARM,
	mod.VkDataGraphPipelineSessionBindPointRequirementARM
)
mod.PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkDataGraphPipelineSessionMemoryRequirementsInfoARM,
	mod.VkMemoryRequirements2
)
mod.PFN_vkBindDataGraphPipelineSessionMemoryARM = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindDataGraphPipelineSessionMemoryInfoARM
)
mod.PFN_vkDestroyDataGraphPipelineSessionARM = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkDataGraphPipelineSessionARM,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCmdDispatchDataGraphARM = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkDataGraphPipelineSessionARM,
	mod.VkDataGraphPipelineDispatchInfoARM
)
mod.PFN_vkGetDataGraphPipelineAvailablePropertiesARM = ffi.typeof(
	[[$ (*)($ , const $*, uint32_t*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDataGraphPipelineInfoARM,
	mod.VkDataGraphPipelinePropertyARM
)
mod.PFN_vkGetDataGraphPipelinePropertiesARM = ffi.typeof(
	[[$ (*)($ , const $*, uint32_t , $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDataGraphPipelineInfoARM,
	mod.VkDataGraphPipelinePropertyQueryResultARM
)
mod.PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = ffi.typeof(
	[[$ (*)($ , uint32_t , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkQueueFamilyDataGraphPropertiesARM
)
mod.PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM,
	mod.VkQueueFamilyDataGraphProcessingEnginePropertiesARM
)
ffi.cdef(
	[[$  vkCreateDataGraphPipelinesARM($ , $ , $ , uint32_t , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkPipelineCache,
	mod.VkDataGraphPipelineCreateInfoARM,
	mod.VkAllocationCallbacks,
	mod.VkPipeline
)
ffi.cdef(
	[[$  vkCreateDataGraphPipelineSessionARM($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDataGraphPipelineSessionCreateInfoARM,
	mod.VkAllocationCallbacks,
	mod.VkDataGraphPipelineSessionARM
)
ffi.cdef(
	[[$  vkGetDataGraphPipelineSessionBindPointRequirementsARM($ , const $*, uint32_t*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDataGraphPipelineSessionBindPointRequirementsInfoARM,
	mod.VkDataGraphPipelineSessionBindPointRequirementARM
)
ffi.cdef(
	[[void  vkGetDataGraphPipelineSessionMemoryRequirementsARM($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkDataGraphPipelineSessionMemoryRequirementsInfoARM,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[$  vkBindDataGraphPipelineSessionMemoryARM($ , uint32_t , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkBindDataGraphPipelineSessionMemoryInfoARM
)
ffi.cdef(
	[[void  vkDestroyDataGraphPipelineSessionARM($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkDataGraphPipelineSessionARM,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkCmdDispatchDataGraphARM($ , $ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkDataGraphPipelineSessionARM,
	mod.VkDataGraphPipelineDispatchInfoARM
)
ffi.cdef(
	[[$  vkGetDataGraphPipelineAvailablePropertiesARM($ , const $*, uint32_t*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDataGraphPipelineInfoARM,
	mod.VkDataGraphPipelinePropertyARM
)
ffi.cdef(
	[[$  vkGetDataGraphPipelinePropertiesARM($ , const $*, uint32_t , $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDataGraphPipelineInfoARM,
	mod.VkDataGraphPipelinePropertyQueryResultARM
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM($ , uint32_t , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkQueueFamilyDataGraphPropertiesARM
)
ffi.cdef(
	[[void  vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM($ , const $*, $*);]],
	mod.VkPhysicalDevice,
	mod.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM,
	mod.VkQueueFamilyDataGraphProcessingEnginePropertiesARM
)
mod.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ multiviewPerViewRenderAreas;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.multiviewPerViewRenderAreas)
		end,
	}
)
mod.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t perViewRenderAreaCount;
	const $* pPerViewRenderAreas;
}]],
	mod.VkStructureType,
	mod.VkRect2D
)
ffi.metatype(
	mod.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.perViewRenderAreaCount, t.pPerViewRenderAreas)
		end,
	}
)
mod.VkPhysicalDevicePerStageDescriptorSetFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ perStageDescriptorSet;
	$ dynamicPipelineLayout;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePerStageDescriptorSetFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePerStageDescriptorSetFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.perStageDescriptorSet, t.dynamicPipelineLayout)
		end,
	}
)
mod.VkBlockMatchWindowCompareModeQCOM = ffi.typeof([[enum {
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM = 0,
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM = 1,
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_ENUM_QCOM = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceImageProcessing2FeaturesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ textureBlockMatch2;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceImageProcessing2FeaturesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageProcessing2FeaturesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.textureBlockMatch2)
		end,
	}
)
mod.VkPhysicalDeviceImageProcessing2PropertiesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ maxBlockMatchWindow;
}]],
	mod.VkStructureType,
	mod.VkExtent2D
)
ffi.metatype(
	mod.VkPhysicalDeviceImageProcessing2PropertiesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageProcessing2PropertiesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxBlockMatchWindow)
		end,
	}
)
mod.VkSamplerBlockMatchWindowCreateInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ windowExtent;
	$ windowCompareMode;
}]],
	mod.VkStructureType,
	mod.VkExtent2D,
	mod.VkBlockMatchWindowCompareModeQCOM
)
ffi.metatype(
	mod.VkSamplerBlockMatchWindowCreateInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkSamplerBlockMatchWindowCreateInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.windowExtent, t.windowCompareMode)
		end,
	}
)
mod.VkCubicFilterWeightsQCOM = ffi.typeof([[enum {
	VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM = 0,
	VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM = 1,
	VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM = 2,
	VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM = 3,
	VK_CUBIC_FILTER_WEIGHTS_MAX_ENUM_QCOM = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceCubicWeightsFeaturesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ selectableCubicWeights;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCubicWeightsFeaturesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCubicWeightsFeaturesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.selectableCubicWeights)
		end,
	}
)
mod.VkSamplerCubicWeightsCreateInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ cubicWeights;
}]],
	mod.VkStructureType,
	mod.VkCubicFilterWeightsQCOM
)
ffi.metatype(
	mod.VkSamplerCubicWeightsCreateInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkSamplerCubicWeightsCreateInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.cubicWeights)
		end,
	}
)
mod.VkBlitImageCubicWeightsInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ cubicWeights;
}]],
	mod.VkStructureType,
	mod.VkCubicFilterWeightsQCOM
)
ffi.metatype(
	mod.VkBlitImageCubicWeightsInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkBlitImageCubicWeightsInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.cubicWeights)
		end,
	}
)
mod.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ ycbcrDegamma;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceYcbcrDegammaFeaturesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.ycbcrDegamma)
		end,
	}
)
mod.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ enableYDegamma;
	$ enableCbCrDegamma;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.enableYDegamma, t.enableCbCrDegamma)
		end,
	}
)
mod.VkPhysicalDeviceCubicClampFeaturesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ cubicRangeClamp;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCubicClampFeaturesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCubicClampFeaturesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.cubicRangeClamp)
		end,
	}
)
mod.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ attachmentFeedbackLoopDynamicState;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.attachmentFeedbackLoopDynamicState)
		end,
	}
)
mod.PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkImageAspectFlags)
ffi.cdef(
	[[void  vkCmdSetAttachmentFeedbackLoopEnableEXT($ , $ );]],
	mod.VkCommandBuffer,
	mod.VkImageAspectFlags
)
mod.VkLayeredDriverUnderlyingApiMSFT = ffi.typeof([[enum {
	VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT = 0,
	VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT = 1,
	VK_LAYERED_DRIVER_UNDERLYING_API_MAX_ENUM_MSFT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceLayeredDriverPropertiesMSFT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ underlyingAPI;
}]],
	mod.VkStructureType,
	mod.VkLayeredDriverUnderlyingApiMSFT
)
ffi.metatype(
	mod.VkPhysicalDeviceLayeredDriverPropertiesMSFT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceLayeredDriverPropertiesMSFT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.underlyingAPI)
		end,
	}
)
mod.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ descriptorPoolOverallocation;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.descriptorPoolOverallocation)
		end,
	}
)
mod.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ tileMemoryHeap;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTileMemoryHeapFeaturesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.tileMemoryHeap)
		end,
	}
)
mod.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ queueSubmitBoundary;
	$ tileBufferTransfers;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceTileMemoryHeapPropertiesQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.queueSubmitBoundary, t.tileBufferTransfers)
		end,
	}
)
mod.VkTileMemoryRequirementsQCOM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ size;
	$ alignment;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkTileMemoryRequirementsQCOM,
	{
		__tostring = function(s)
			return ("struct VkTileMemoryRequirementsQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.size, t.alignment)
		end,
	}
)
mod.VkTileMemoryBindInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ memory;
}]],
	mod.VkStructureType,
	mod.VkDeviceMemory
)
ffi.metatype(
	mod.VkTileMemoryBindInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkTileMemoryBindInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memory)
		end,
	}
)
mod.VkTileMemorySizeInfoQCOM = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ size;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkTileMemorySizeInfoQCOM,
	{
		__tostring = function(s)
			return ("struct VkTileMemorySizeInfoQCOM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.size)
		end,
	}
)
mod.PFN_vkCmdBindTileMemoryQCOM = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkTileMemoryBindInfoQCOM)
ffi.cdef(
	[[void  vkCmdBindTileMemoryQCOM($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkTileMemoryBindInfoQCOM
)
mod.VkDisplaySurfaceStereoTypeNV = ffi.typeof([[enum {
	VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV = 0,
	VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV = 1,
	VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV = 2,
	VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV = 3,
	VK_DISPLAY_SURFACE_STEREO_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkDisplaySurfaceStereoCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ stereoType;
}]],
	mod.VkStructureType,
	mod.VkDisplaySurfaceStereoTypeNV
)
ffi.metatype(
	mod.VkDisplaySurfaceStereoCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkDisplaySurfaceStereoCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.stereoType)
		end,
	}
)
mod.VkDisplayModeStereoPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ hdmi3DSupported;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkDisplayModeStereoPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkDisplayModeStereoPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.hdmi3DSupported)
		end,
	}
)
mod.VkPhysicalDeviceRawAccessChainsFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderRawAccessChains;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRawAccessChainsFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRawAccessChainsFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderRawAccessChains)
		end,
	}
)
mod.VkExternalComputeQueueNV = ffi.typeof([[void*]])
mod.VkExternalComputeQueueDeviceCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t reservedExternalQueues;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkExternalComputeQueueDeviceCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkExternalComputeQueueDeviceCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.reservedExternalQueues)
		end,
	}
)
mod.VkExternalComputeQueueCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ preferredQueue;
}]],
	mod.VkStructureType,
	mod.VkQueue
)
ffi.metatype(
	mod.VkExternalComputeQueueCreateInfoNV,
	{
		__tostring = function(s)
			return ("struct VkExternalComputeQueueCreateInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.preferredQueue)
		end,
	}
)
mod.VkExternalComputeQueueDataParamsNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t deviceIndex;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkExternalComputeQueueDataParamsNV,
	{
		__tostring = function(s)
			return ("struct VkExternalComputeQueueDataParamsNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.deviceIndex)
		end,
	}
)
mod.VkPhysicalDeviceExternalComputeQueuePropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t externalDataSize;
	uint32_t maxExternalQueues;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceExternalComputeQueuePropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExternalComputeQueuePropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.externalDataSize, t.maxExternalQueues)
		end,
	}
)
mod.PFN_vkCreateExternalComputeQueueNV = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkExternalComputeQueueCreateInfoNV,
	mod.VkAllocationCallbacks,
	mod.VkExternalComputeQueueNV
)
mod.PFN_vkDestroyExternalComputeQueueNV = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkExternalComputeQueueNV,
	mod.VkAllocationCallbacks
)
mod.PFN_vkGetExternalComputeQueueDataNV = ffi.typeof(
	[[void (*)($ , $*, void*)]],
	mod.VkExternalComputeQueueNV,
	mod.VkExternalComputeQueueDataParamsNV
)
ffi.cdef(
	[[$  vkCreateExternalComputeQueueNV($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkExternalComputeQueueCreateInfoNV,
	mod.VkAllocationCallbacks,
	mod.VkExternalComputeQueueNV
)
ffi.cdef(
	[[void  vkDestroyExternalComputeQueueNV($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkExternalComputeQueueNV,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkGetExternalComputeQueueDataNV($ , $*, void*);]],
	mod.VkExternalComputeQueueNV,
	mod.VkExternalComputeQueueDataParamsNV
)
mod.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ commandBufferInheritance;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCommandBufferInheritanceFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.commandBufferInheritance)
		end,
	}
)
mod.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderFloat16VectorAtomics;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderFloat16VectorAtomics)
		end,
	}
)
mod.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderReplicatedComposites;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderReplicatedComposites)
		end,
	}
)
mod.VkPhysicalDeviceShaderFloat8FeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ shaderFloat8;
	$ shaderFloat8CooperativeMatrix;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceShaderFloat8FeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceShaderFloat8FeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderFloat8, t.shaderFloat8CooperativeMatrix)
		end,
	}
)
mod.VkPhysicalDeviceRayTracingValidationFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ rayTracingValidation;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRayTracingValidationFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRayTracingValidationFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.rayTracingValidation)
		end,
	}
)
mod.VkClusterAccelerationStructureTypeNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureOpTypeNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV = 3,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV = 4,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV = 5,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureOpModeNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureAddressResolutionFlagBitsNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV = 0x00000008,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV = 0x00000010,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV = 0x00000020,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureAddressResolutionFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkClusterAccelerationStructureClusterFlagBitsNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureClusterFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkClusterAccelerationStructureGeometryFlagBitsNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureGeometryFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkClusterAccelerationStructureIndexFormatFlagBitsNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureIndexFormatFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ clusterAccelerationStructure;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceClusterAccelerationStructureFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.clusterAccelerationStructure)
		end,
	}
)
mod.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxVerticesPerCluster;
	uint32_t maxTrianglesPerCluster;
	uint32_t clusterScratchByteAlignment;
	uint32_t clusterByteAlignment;
	uint32_t clusterTemplateByteAlignment;
	uint32_t clusterBottomLevelByteAlignment;
	uint32_t clusterTemplateBoundsByteAlignment;
	uint32_t maxClusterGeometryIndex;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceClusterAccelerationStructurePropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxVerticesPerCluster,
				t.maxTrianglesPerCluster,
				t.clusterScratchByteAlignment,
				t.clusterByteAlignment,
				t.clusterTemplateByteAlignment,
				t.clusterBottomLevelByteAlignment,
				t.clusterTemplateBoundsByteAlignment,
				t.maxClusterGeometryIndex
			)
		end,
	}
)
mod.VkClusterAccelerationStructureClustersBottomLevelInputNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxTotalClusterCount;
	uint32_t maxClusterCountPerAccelerationStructure;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkClusterAccelerationStructureClustersBottomLevelInputNV,
	{
		__tostring = function(s)
			return ("struct VkClusterAccelerationStructureClustersBottomLevelInputNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxTotalClusterCount,
				t.maxClusterCountPerAccelerationStructure
			)
		end,
	}
)
mod.VkClusterAccelerationStructureTriangleClusterInputNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ vertexFormat;
	uint32_t maxGeometryIndexValue;
	uint32_t maxClusterUniqueGeometryCount;
	uint32_t maxClusterTriangleCount;
	uint32_t maxClusterVertexCount;
	uint32_t maxTotalTriangleCount;
	uint32_t maxTotalVertexCount;
	uint32_t minPositionTruncateBitCount;
}]],
	mod.VkStructureType,
	mod.VkFormat
)
ffi.metatype(
	mod.VkClusterAccelerationStructureTriangleClusterInputNV,
	{
		__tostring = function(s)
			return ("struct VkClusterAccelerationStructureTriangleClusterInputNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.vertexFormat,
				t.maxGeometryIndexValue,
				t.maxClusterUniqueGeometryCount,
				t.maxClusterTriangleCount,
				t.maxClusterVertexCount,
				t.maxTotalTriangleCount,
				t.maxTotalVertexCount,
				t.minPositionTruncateBitCount
			)
		end,
	}
)
mod.VkClusterAccelerationStructureMoveObjectsInputNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ type;
	$ noMoveOverlap;
	$ maxMovedBytes;
}]],
	mod.VkStructureType,
	mod.VkClusterAccelerationStructureTypeNV,
	mod.VkBool32,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkClusterAccelerationStructureMoveObjectsInputNV,
	{
		__tostring = function(s)
			return ("struct VkClusterAccelerationStructureMoveObjectsInputNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.type, t.noMoveOverlap, t.maxMovedBytes)
		end,
	}
)
mod.VkClusterAccelerationStructureOpInputNV = ffi.typeof(
	[[union {
	$* pClustersBottomLevel;
	$* pTriangleClusters;
	$* pMoveObjects;
}]],
	mod.VkClusterAccelerationStructureClustersBottomLevelInputNV,
	mod.VkClusterAccelerationStructureTriangleClusterInputNV,
	mod.VkClusterAccelerationStructureMoveObjectsInputNV
)
ffi.metatype(
	mod.VkClusterAccelerationStructureOpInputNV,
	{
		__tostring = function(s)
			return ("struct VkClusterAccelerationStructureOpInputNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.pClustersBottomLevel ~= nil then
				obj.pClustersBottomLevel = t.pClustersBottomLevel
			end

			if t.pTriangleClusters ~= nil then
				obj.pTriangleClusters = t.pTriangleClusters
			end

			if t.pMoveObjects ~= nil then obj.pMoveObjects = t.pMoveObjects end

			return obj
		end,
	}
)
mod.VkClusterAccelerationStructureInputInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxAccelerationStructureCount;
	$ flags;
	$ opType;
	$ opMode;
	$ opInput;
}]],
	mod.VkStructureType,
	mod.VkBuildAccelerationStructureFlagsKHR,
	mod.VkClusterAccelerationStructureOpTypeNV,
	mod.VkClusterAccelerationStructureOpModeNV,
	mod.VkClusterAccelerationStructureOpInputNV
)
ffi.metatype(
	mod.VkClusterAccelerationStructureInputInfoNV,
	{
		__tostring = function(s)
			return ("struct VkClusterAccelerationStructureInputInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxAccelerationStructureCount,
				t.flags,
				t.opType,
				t.opMode,
				t.opInput
			)
		end,
	}
)
mod.VkStridedDeviceAddressRegionKHR = ffi.typeof(
	[[struct {
	$ deviceAddress;
	$ stride;
	$ size;
}]],
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkStridedDeviceAddressRegionKHR,
	{
		__tostring = function(s)
			return ("struct VkStridedDeviceAddressRegionKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.deviceAddress, t.stride, t.size)
		end,
	}
)
mod.VkClusterAccelerationStructureCommandsInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ input;
	$ dstImplicitData;
	$ scratchData;
	$ dstAddressesArray;
	$ dstSizesArray;
	$ srcInfosArray;
	$ srcInfosCount;
	$ addressResolutionFlags;
}]],
	mod.VkStructureType,
	mod.VkClusterAccelerationStructureInputInfoNV,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkDeviceAddress,
	mod.VkClusterAccelerationStructureAddressResolutionFlagsNV
)
ffi.metatype(
	mod.VkClusterAccelerationStructureCommandsInfoNV,
	{
		__tostring = function(s)
			return ("struct VkClusterAccelerationStructureCommandsInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.input,
				t.dstImplicitData,
				t.scratchData,
				t.dstAddressesArray,
				t.dstSizesArray,
				t.srcInfosArray,
				t.srcInfosCount,
				t.addressResolutionFlags
			)
		end,
	}
)
mod.VkStridedDeviceAddressNV = ffi.typeof(
	[[struct {
	$ startAddress;
	$ strideInBytes;
}]],
	mod.VkDeviceAddress,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkStridedDeviceAddressNV,
	{
		__tostring = function(s)
			return ("struct VkStridedDeviceAddressNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.startAddress, t.strideInBytes)
		end,
	}
)
mod.VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV = ffi.typeof([[struct {
	uint32_t geometryIndex;
	uint32_t reserved;
	uint32_t geometryFlags;
}]])
ffi.metatype(
	mod.VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
	{
		__tostring = function(s)
			return (
				"struct VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.geometryIndex, t.reserved, t.geometryFlags)
		end,
	}
)
mod.VkClusterAccelerationStructureMoveObjectsInfoNV = ffi.typeof([[struct {
	$ srcAccelerationStructure;
}]], mod.VkDeviceAddress)
ffi.metatype(
	mod.VkClusterAccelerationStructureMoveObjectsInfoNV,
	{
		__tostring = function(s)
			return ("struct VkClusterAccelerationStructureMoveObjectsInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.srcAccelerationStructure)
		end,
	}
)
mod.VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV = ffi.typeof(
	[[struct {
	uint32_t clusterReferencesCount;
	uint32_t clusterReferencesStride;
	$ clusterReferences;
}]],
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV,
	{
		__tostring = function(s)
			return (
				"struct VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.clusterReferencesCount, t.clusterReferencesStride, t.clusterReferences)
		end,
	}
)
mod.VkClusterAccelerationStructureBuildTriangleClusterInfoNV = ffi.typeof(
	[[struct {
	uint32_t clusterID;
	$ clusterFlags;
	uint32_t triangleCount;
	uint32_t vertexCount;
	uint32_t positionTruncateBitCount;
	uint32_t indexType;
	uint32_t opacityMicromapIndexType;
	$ baseGeometryIndexAndGeometryFlags;
	uint16_t indexBufferStride;
	uint16_t vertexBufferStride;
	uint16_t geometryIndexAndFlagsBufferStride;
	uint16_t opacityMicromapIndexBufferStride;
	$ indexBuffer;
	$ vertexBuffer;
	$ geometryIndexAndFlagsBuffer;
	$ opacityMicromapArray;
	$ opacityMicromapIndexBuffer;
}]],
	mod.VkClusterAccelerationStructureClusterFlagsNV,
	mod.VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkClusterAccelerationStructureBuildTriangleClusterInfoNV,
	{
		__tostring = function(s)
			return ("struct VkClusterAccelerationStructureBuildTriangleClusterInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.clusterID,
				t.clusterFlags,
				t.triangleCount,
				t.vertexCount,
				t.positionTruncateBitCount,
				t.indexType,
				t.opacityMicromapIndexType,
				t.baseGeometryIndexAndGeometryFlags,
				t.indexBufferStride,
				t.vertexBufferStride,
				t.geometryIndexAndFlagsBufferStride,
				t.opacityMicromapIndexBufferStride,
				t.indexBuffer,
				t.vertexBuffer,
				t.geometryIndexAndFlagsBuffer,
				t.opacityMicromapArray,
				t.opacityMicromapIndexBuffer
			)
		end,
	}
)
mod.VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV = ffi.typeof(
	[[struct {
	uint32_t clusterID;
	$ clusterFlags;
	uint32_t triangleCount;
	uint32_t vertexCount;
	uint32_t positionTruncateBitCount;
	uint32_t indexType;
	uint32_t opacityMicromapIndexType;
	$ baseGeometryIndexAndGeometryFlags;
	uint16_t indexBufferStride;
	uint16_t vertexBufferStride;
	uint16_t geometryIndexAndFlagsBufferStride;
	uint16_t opacityMicromapIndexBufferStride;
	$ indexBuffer;
	$ vertexBuffer;
	$ geometryIndexAndFlagsBuffer;
	$ opacityMicromapArray;
	$ opacityMicromapIndexBuffer;
	$ instantiationBoundingBoxLimit;
}]],
	mod.VkClusterAccelerationStructureClusterFlagsNV,
	mod.VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV,
	{
		__tostring = function(s)
			return (
				"struct VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.clusterID,
				t.clusterFlags,
				t.triangleCount,
				t.vertexCount,
				t.positionTruncateBitCount,
				t.indexType,
				t.opacityMicromapIndexType,
				t.baseGeometryIndexAndGeometryFlags,
				t.indexBufferStride,
				t.vertexBufferStride,
				t.geometryIndexAndFlagsBufferStride,
				t.opacityMicromapIndexBufferStride,
				t.indexBuffer,
				t.vertexBuffer,
				t.geometryIndexAndFlagsBuffer,
				t.opacityMicromapArray,
				t.opacityMicromapIndexBuffer,
				t.instantiationBoundingBoxLimit
			)
		end,
	}
)
mod.VkClusterAccelerationStructureInstantiateClusterInfoNV = ffi.typeof(
	[[struct {
	uint32_t clusterIdOffset;
	uint32_t geometryIndexOffset;
	uint32_t reserved;
	$ clusterTemplateAddress;
	$ vertexBuffer;
}]],
	mod.VkDeviceAddress,
	mod.VkStridedDeviceAddressNV
)
ffi.metatype(
	mod.VkClusterAccelerationStructureInstantiateClusterInfoNV,
	{
		__tostring = function(s)
			return ("struct VkClusterAccelerationStructureInstantiateClusterInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.clusterIdOffset,
				t.geometryIndexOffset,
				t.reserved,
				t.clusterTemplateAddress,
				t.vertexBuffer
			)
		end,
	}
)
mod.VkClusterAccelerationStructureGetTemplateIndicesInfoNV = ffi.typeof([[struct {
	$ clusterTemplateAddress;
}]], mod.VkDeviceAddress)
ffi.metatype(
	mod.VkClusterAccelerationStructureGetTemplateIndicesInfoNV,
	{
		__tostring = function(s)
			return ("struct VkClusterAccelerationStructureGetTemplateIndicesInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.clusterTemplateAddress)
		end,
	}
)
mod.VkAccelerationStructureBuildSizesInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ accelerationStructureSize;
	$ updateScratchSize;
	$ buildScratchSize;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkAccelerationStructureBuildSizesInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureBuildSizesInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.accelerationStructureSize,
				t.updateScratchSize,
				t.buildScratchSize
			)
		end,
	}
)
mod.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ allowClusterAccelerationStructure;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV,
	{
		__tostring = function(s)
			return (
				"struct VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.allowClusterAccelerationStructure)
		end,
	}
)
mod.PFN_vkGetClusterAccelerationStructureBuildSizesNV = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkClusterAccelerationStructureInputInfoNV,
	mod.VkAccelerationStructureBuildSizesInfoKHR
)
mod.PFN_vkCmdBuildClusterAccelerationStructureIndirectNV = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkClusterAccelerationStructureCommandsInfoNV
)
ffi.cdef(
	[[void  vkGetClusterAccelerationStructureBuildSizesNV($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkClusterAccelerationStructureInputInfoNV,
	mod.VkAccelerationStructureBuildSizesInfoKHR
)
ffi.cdef(
	[[void  vkCmdBuildClusterAccelerationStructureIndirectNV($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkClusterAccelerationStructureCommandsInfoNV
)
mod.VkPartitionedAccelerationStructureOpTypeNV = ffi.typeof([[enum {
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV = 0,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV = 1,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV = 2,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPartitionedAccelerationStructureInstanceFlagBitsNV = ffi.typeof([[enum {
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV = 0x00000001,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV = 0x00000002,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV = 0x00000004,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV = 0x00000008,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV = 0x00000010,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPartitionedAccelerationStructureInstanceFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ partitionedAccelerationStructure;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.partitionedAccelerationStructure)
		end,
	}
)
mod.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxPartitionCount;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV,
	{
		__tostring = function(s)
			return (
				"struct VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxPartitionCount)
		end,
	}
)
mod.VkPartitionedAccelerationStructureFlagsNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ enablePartitionTranslation;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPartitionedAccelerationStructureFlagsNV,
	{
		__tostring = function(s)
			return ("struct VkPartitionedAccelerationStructureFlagsNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.enablePartitionTranslation)
		end,
	}
)
mod.VkBuildPartitionedAccelerationStructureIndirectCommandNV = ffi.typeof(
	[[struct {
	$ opType;
	uint32_t argCount;
	$ argData;
}]],
	mod.VkPartitionedAccelerationStructureOpTypeNV,
	mod.VkStridedDeviceAddressNV
)
ffi.metatype(
	mod.VkBuildPartitionedAccelerationStructureIndirectCommandNV,
	{
		__tostring = function(s)
			return ("struct VkBuildPartitionedAccelerationStructureIndirectCommandNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.opType, t.argCount, t.argData)
		end,
	}
)
mod.VkPartitionedAccelerationStructureWriteInstanceDataNV = ffi.typeof(
	[[struct {
	$ transform;
	float explicitAABB[6];
	uint32_t instanceID;
	uint32_t instanceMask;
	uint32_t instanceContributionToHitGroupIndex;
	$ instanceFlags;
	uint32_t instanceIndex;
	uint32_t partitionIndex;
	$ accelerationStructure;
}]],
	mod.VkTransformMatrixKHR,
	mod.VkPartitionedAccelerationStructureInstanceFlagsNV,
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkPartitionedAccelerationStructureWriteInstanceDataNV,
	{
		__tostring = function(s)
			return ("struct VkPartitionedAccelerationStructureWriteInstanceDataNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.transform,
				t.explicitAABB,
				t.instanceID,
				t.instanceMask,
				t.instanceContributionToHitGroupIndex,
				t.instanceFlags,
				t.instanceIndex,
				t.partitionIndex,
				t.accelerationStructure
			)
		end,
	}
)
mod.VkPartitionedAccelerationStructureUpdateInstanceDataNV = ffi.typeof(
	[[struct {
	uint32_t instanceIndex;
	uint32_t instanceContributionToHitGroupIndex;
	$ accelerationStructure;
}]],
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkPartitionedAccelerationStructureUpdateInstanceDataNV,
	{
		__tostring = function(s)
			return ("struct VkPartitionedAccelerationStructureUpdateInstanceDataNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.instanceIndex,
				t.instanceContributionToHitGroupIndex,
				t.accelerationStructure
			)
		end,
	}
)
mod.VkPartitionedAccelerationStructureWritePartitionTranslationDataNV = ffi.typeof([[struct {
	uint32_t partitionIndex;
	float partitionTranslation[3];
}]])
ffi.metatype(
	mod.VkPartitionedAccelerationStructureWritePartitionTranslationDataNV,
	{
		__tostring = function(s)
			return (
				"struct VkPartitionedAccelerationStructureWritePartitionTranslationDataNV[%p]"
			):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.partitionIndex, t.partitionTranslation)
		end,
	}
)
mod.VkWriteDescriptorSetPartitionedAccelerationStructureNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t accelerationStructureCount;
	const $* pAccelerationStructures;
}]],
	mod.VkStructureType,
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkWriteDescriptorSetPartitionedAccelerationStructureNV,
	{
		__tostring = function(s)
			return ("struct VkWriteDescriptorSetPartitionedAccelerationStructureNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.accelerationStructureCount, t.pAccelerationStructures)
		end,
	}
)
mod.VkPartitionedAccelerationStructureInstancesInputNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ flags;
	uint32_t instanceCount;
	uint32_t maxInstancePerPartitionCount;
	uint32_t partitionCount;
	uint32_t maxInstanceInGlobalPartitionCount;
}]],
	mod.VkStructureType,
	mod.VkBuildAccelerationStructureFlagsKHR
)
ffi.metatype(
	mod.VkPartitionedAccelerationStructureInstancesInputNV,
	{
		__tostring = function(s)
			return ("struct VkPartitionedAccelerationStructureInstancesInputNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.instanceCount,
				t.maxInstancePerPartitionCount,
				t.partitionCount,
				t.maxInstanceInGlobalPartitionCount
			)
		end,
	}
)
mod.VkBuildPartitionedAccelerationStructureInfoNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ input;
	$ srcAccelerationStructureData;
	$ dstAccelerationStructureData;
	$ scratchData;
	$ srcInfos;
	$ srcInfosCount;
}]],
	mod.VkStructureType,
	mod.VkPartitionedAccelerationStructureInstancesInputNV,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress,
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkBuildPartitionedAccelerationStructureInfoNV,
	{
		__tostring = function(s)
			return ("struct VkBuildPartitionedAccelerationStructureInfoNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.input,
				t.srcAccelerationStructureData,
				t.dstAccelerationStructureData,
				t.scratchData,
				t.srcInfos,
				t.srcInfosCount
			)
		end,
	}
)
mod.PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkPartitionedAccelerationStructureInstancesInputNV,
	mod.VkAccelerationStructureBuildSizesInfoKHR
)
mod.PFN_vkCmdBuildPartitionedAccelerationStructuresNV = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkBuildPartitionedAccelerationStructureInfoNV
)
ffi.cdef(
	[[void  vkGetPartitionedAccelerationStructuresBuildSizesNV($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkPartitionedAccelerationStructureInstancesInputNV,
	mod.VkAccelerationStructureBuildSizesInfoKHR
)
ffi.cdef(
	[[void  vkCmdBuildPartitionedAccelerationStructuresNV($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBuildPartitionedAccelerationStructureInfoNV
)
mod.VkIndirectExecutionSetEXT = ffi.typeof([[void*]])
mod.VkIndirectCommandsLayoutEXT = ffi.typeof([[void*]])
mod.VkIndirectExecutionSetInfoTypeEXT = ffi.typeof([[enum {
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT = 0,
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT = 1,
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkIndirectCommandsTokenTypeEXT = ffi.typeof([[enum {
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT = 0,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT = 1,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT = 2,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT = 3,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT = 4,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT = 5,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT = 6,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT = 7,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT = 8,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT = 9,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT = 1000202002,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT = 1000202003,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT = 1000328000,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT = 1000328001,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT = 1000386004,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkIndirectCommandsInputModeFlagBitsEXT = ffi.typeof([[enum {
	VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT = 0x00000001,
	VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT = 0x00000002,
	VK_INDIRECT_COMMANDS_INPUT_MODE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkIndirectCommandsInputModeFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkIndirectCommandsLayoutUsageFlagBitsEXT = ffi.typeof([[enum {
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT = 0x00000001,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT = 0x00000002,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkIndirectCommandsLayoutUsageFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ deviceGeneratedCommands;
	$ dynamicGeneratedPipelineLayout;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.deviceGeneratedCommands,
				t.dynamicGeneratedPipelineLayout
			)
		end,
	}
)
mod.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxIndirectPipelineCount;
	uint32_t maxIndirectShaderObjectCount;
	uint32_t maxIndirectSequenceCount;
	uint32_t maxIndirectCommandsTokenCount;
	uint32_t maxIndirectCommandsTokenOffset;
	uint32_t maxIndirectCommandsIndirectStride;
	$ supportedIndirectCommandsInputModes;
	$ supportedIndirectCommandsShaderStages;
	$ supportedIndirectCommandsShaderStagesPipelineBinding;
	$ supportedIndirectCommandsShaderStagesShaderBinding;
	$ deviceGeneratedCommandsTransformFeedback;
	$ deviceGeneratedCommandsMultiDrawIndirectCount;
}]],
	mod.VkStructureType,
	mod.VkIndirectCommandsInputModeFlagsEXT,
	mod.VkShaderStageFlags,
	mod.VkShaderStageFlags,
	mod.VkShaderStageFlags,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxIndirectPipelineCount,
				t.maxIndirectShaderObjectCount,
				t.maxIndirectSequenceCount,
				t.maxIndirectCommandsTokenCount,
				t.maxIndirectCommandsTokenOffset,
				t.maxIndirectCommandsIndirectStride,
				t.supportedIndirectCommandsInputModes,
				t.supportedIndirectCommandsShaderStages,
				t.supportedIndirectCommandsShaderStagesPipelineBinding,
				t.supportedIndirectCommandsShaderStagesShaderBinding,
				t.deviceGeneratedCommandsTransformFeedback,
				t.deviceGeneratedCommandsMultiDrawIndirectCount
			)
		end,
	}
)
mod.VkGeneratedCommandsMemoryRequirementsInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ indirectExecutionSet;
	$ indirectCommandsLayout;
	uint32_t maxSequenceCount;
	uint32_t maxDrawCount;
}]],
	mod.VkStructureType,
	mod.VkIndirectExecutionSetEXT,
	mod.VkIndirectCommandsLayoutEXT
)
ffi.metatype(
	mod.VkGeneratedCommandsMemoryRequirementsInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkGeneratedCommandsMemoryRequirementsInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.indirectExecutionSet,
				t.indirectCommandsLayout,
				t.maxSequenceCount,
				t.maxDrawCount
			)
		end,
	}
)
mod.VkIndirectExecutionSetPipelineInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ initialPipeline;
	uint32_t maxPipelineCount;
}]],
	mod.VkStructureType,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkIndirectExecutionSetPipelineInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectExecutionSetPipelineInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.initialPipeline, t.maxPipelineCount)
		end,
	}
)
mod.VkIndirectExecutionSetShaderLayoutInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t setLayoutCount;
	const $* pSetLayouts;
}]],
	mod.VkStructureType,
	mod.VkDescriptorSetLayout
)
ffi.metatype(
	mod.VkIndirectExecutionSetShaderLayoutInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectExecutionSetShaderLayoutInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.setLayoutCount, t.pSetLayouts)
		end,
	}
)
mod.VkIndirectExecutionSetShaderInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t shaderCount;
	const $* pInitialShaders;
	const $* pSetLayoutInfos;
	uint32_t maxShaderCount;
	uint32_t pushConstantRangeCount;
	const $* pPushConstantRanges;
}]],
	mod.VkStructureType,
	mod.VkShaderEXT,
	mod.VkIndirectExecutionSetShaderLayoutInfoEXT,
	mod.VkPushConstantRange
)
ffi.metatype(
	mod.VkIndirectExecutionSetShaderInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectExecutionSetShaderInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderCount,
				t.pInitialShaders,
				t.pSetLayoutInfos,
				t.maxShaderCount,
				t.pushConstantRangeCount,
				t.pPushConstantRanges
			)
		end,
	}
)
mod.VkIndirectExecutionSetInfoEXT = ffi.typeof(
	[[union {
	const $* pPipelineInfo;
	const $* pShaderInfo;
}]],
	mod.VkIndirectExecutionSetPipelineInfoEXT,
	mod.VkIndirectExecutionSetShaderInfoEXT
)
ffi.metatype(
	mod.VkIndirectExecutionSetInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectExecutionSetInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.pPipelineInfo ~= nil then obj.pPipelineInfo = t.pPipelineInfo end

			if t.pShaderInfo ~= nil then obj.pShaderInfo = t.pShaderInfo end

			return obj
		end,
	}
)
mod.VkIndirectExecutionSetCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ info;
}]],
	mod.VkStructureType,
	mod.VkIndirectExecutionSetInfoTypeEXT,
	mod.VkIndirectExecutionSetInfoEXT
)
ffi.metatype(
	mod.VkIndirectExecutionSetCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectExecutionSetCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.type, t.info)
		end,
	}
)
mod.VkGeneratedCommandsInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ shaderStages;
	$ indirectExecutionSet;
	$ indirectCommandsLayout;
	$ indirectAddress;
	$ indirectAddressSize;
	$ preprocessAddress;
	$ preprocessSize;
	uint32_t maxSequenceCount;
	$ sequenceCountAddress;
	uint32_t maxDrawCount;
}]],
	mod.VkStructureType,
	mod.VkShaderStageFlags,
	mod.VkIndirectExecutionSetEXT,
	mod.VkIndirectCommandsLayoutEXT,
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkDeviceAddress,
	mod.VkDeviceSize,
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkGeneratedCommandsInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkGeneratedCommandsInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderStages,
				t.indirectExecutionSet,
				t.indirectCommandsLayout,
				t.indirectAddress,
				t.indirectAddressSize,
				t.preprocessAddress,
				t.preprocessSize,
				t.maxSequenceCount,
				t.sequenceCountAddress,
				t.maxDrawCount
			)
		end,
	}
)
mod.VkWriteIndirectExecutionSetPipelineEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t index;
	$ pipeline;
}]],
	mod.VkStructureType,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkWriteIndirectExecutionSetPipelineEXT,
	{
		__tostring = function(s)
			return ("struct VkWriteIndirectExecutionSetPipelineEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.index, t.pipeline)
		end,
	}
)
mod.VkIndirectCommandsPushConstantTokenEXT = ffi.typeof([[struct {
	$ updateRange;
}]], mod.VkPushConstantRange)
ffi.metatype(
	mod.VkIndirectCommandsPushConstantTokenEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectCommandsPushConstantTokenEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.updateRange)
		end,
	}
)
mod.VkIndirectCommandsVertexBufferTokenEXT = ffi.typeof([[struct {
	uint32_t vertexBindingUnit;
}]])
ffi.metatype(
	mod.VkIndirectCommandsVertexBufferTokenEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectCommandsVertexBufferTokenEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.vertexBindingUnit)
		end,
	}
)
mod.VkIndirectCommandsIndexBufferTokenEXT = ffi.typeof([[struct {
	$ mode;
}]], mod.VkIndirectCommandsInputModeFlagBitsEXT)
ffi.metatype(
	mod.VkIndirectCommandsIndexBufferTokenEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectCommandsIndexBufferTokenEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.mode)
		end,
	}
)
mod.VkIndirectCommandsExecutionSetTokenEXT = ffi.typeof(
	[[struct {
	$ type;
	$ shaderStages;
}]],
	mod.VkIndirectExecutionSetInfoTypeEXT,
	mod.VkShaderStageFlags
)
ffi.metatype(
	mod.VkIndirectCommandsExecutionSetTokenEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectCommandsExecutionSetTokenEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.type, t.shaderStages)
		end,
	}
)
mod.VkIndirectCommandsTokenDataEXT = ffi.typeof(
	[[union {
	const $* pPushConstant;
	const $* pVertexBuffer;
	const $* pIndexBuffer;
	const $* pExecutionSet;
}]],
	mod.VkIndirectCommandsPushConstantTokenEXT,
	mod.VkIndirectCommandsVertexBufferTokenEXT,
	mod.VkIndirectCommandsIndexBufferTokenEXT,
	mod.VkIndirectCommandsExecutionSetTokenEXT
)
ffi.metatype(
	mod.VkIndirectCommandsTokenDataEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectCommandsTokenDataEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.pPushConstant ~= nil then obj.pPushConstant = t.pPushConstant end

			if t.pVertexBuffer ~= nil then obj.pVertexBuffer = t.pVertexBuffer end

			if t.pIndexBuffer ~= nil then obj.pIndexBuffer = t.pIndexBuffer end

			if t.pExecutionSet ~= nil then obj.pExecutionSet = t.pExecutionSet end

			return obj
		end,
	}
)
mod.VkIndirectCommandsLayoutTokenEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ data;
	uint32_t offset;
}]],
	mod.VkStructureType,
	mod.VkIndirectCommandsTokenTypeEXT,
	mod.VkIndirectCommandsTokenDataEXT
)
ffi.metatype(
	mod.VkIndirectCommandsLayoutTokenEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectCommandsLayoutTokenEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.type, t.data, t.offset)
		end,
	}
)
mod.VkIndirectCommandsLayoutCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ shaderStages;
	uint32_t indirectStride;
	$ pipelineLayout;
	uint32_t tokenCount;
	const $* pTokens;
}]],
	mod.VkStructureType,
	mod.VkIndirectCommandsLayoutUsageFlagsEXT,
	mod.VkShaderStageFlags,
	mod.VkPipelineLayout,
	mod.VkIndirectCommandsLayoutTokenEXT
)
ffi.metatype(
	mod.VkIndirectCommandsLayoutCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkIndirectCommandsLayoutCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.shaderStages,
				t.indirectStride,
				t.pipelineLayout,
				t.tokenCount,
				t.pTokens
			)
		end,
	}
)
mod.VkDrawIndirectCountIndirectCommandEXT = ffi.typeof(
	[[struct {
	$ bufferAddress;
	uint32_t stride;
	uint32_t commandCount;
}]],
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkDrawIndirectCountIndirectCommandEXT,
	{
		__tostring = function(s)
			return ("struct VkDrawIndirectCountIndirectCommandEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.bufferAddress, t.stride, t.commandCount)
		end,
	}
)
mod.VkBindVertexBufferIndirectCommandEXT = ffi.typeof(
	[[struct {
	$ bufferAddress;
	uint32_t size;
	uint32_t stride;
}]],
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkBindVertexBufferIndirectCommandEXT,
	{
		__tostring = function(s)
			return ("struct VkBindVertexBufferIndirectCommandEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.bufferAddress, t.size, t.stride)
		end,
	}
)
mod.VkBindIndexBufferIndirectCommandEXT = ffi.typeof(
	[[struct {
	$ bufferAddress;
	uint32_t size;
	$ indexType;
}]],
	mod.VkDeviceAddress,
	mod.VkIndexType
)
ffi.metatype(
	mod.VkBindIndexBufferIndirectCommandEXT,
	{
		__tostring = function(s)
			return ("struct VkBindIndexBufferIndirectCommandEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.bufferAddress, t.size, t.indexType)
		end,
	}
)
mod.VkGeneratedCommandsPipelineInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipeline;
}]],
	mod.VkStructureType,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkGeneratedCommandsPipelineInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkGeneratedCommandsPipelineInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipeline)
		end,
	}
)
mod.VkGeneratedCommandsShaderInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t shaderCount;
	const $* pShaders;
}]],
	mod.VkStructureType,
	mod.VkShaderEXT
)
ffi.metatype(
	mod.VkGeneratedCommandsShaderInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkGeneratedCommandsShaderInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.shaderCount, t.pShaders)
		end,
	}
)
mod.VkWriteIndirectExecutionSetShaderEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t index;
	$ shader;
}]],
	mod.VkStructureType,
	mod.VkShaderEXT
)
ffi.metatype(
	mod.VkWriteIndirectExecutionSetShaderEXT,
	{
		__tostring = function(s)
			return ("struct VkWriteIndirectExecutionSetShaderEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.index, t.shader)
		end,
	}
)
mod.PFN_vkGetGeneratedCommandsMemoryRequirementsEXT = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkGeneratedCommandsMemoryRequirementsInfoEXT,
	mod.VkMemoryRequirements2
)
mod.PFN_vkCmdPreprocessGeneratedCommandsEXT = ffi.typeof(
	[[void (*)($ , const $*, $ )]],
	mod.VkCommandBuffer,
	mod.VkGeneratedCommandsInfoEXT,
	mod.VkCommandBuffer
)
mod.PFN_vkCmdExecuteGeneratedCommandsEXT = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkBool32,
	mod.VkGeneratedCommandsInfoEXT
)
mod.PFN_vkCreateIndirectCommandsLayoutEXT = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkIndirectCommandsLayoutCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkIndirectCommandsLayoutEXT
)
mod.PFN_vkDestroyIndirectCommandsLayoutEXT = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkIndirectCommandsLayoutEXT,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCreateIndirectExecutionSetEXT = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkIndirectExecutionSetCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkIndirectExecutionSetEXT
)
mod.PFN_vkDestroyIndirectExecutionSetEXT = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkIndirectExecutionSetEXT,
	mod.VkAllocationCallbacks
)
mod.PFN_vkUpdateIndirectExecutionSetPipelineEXT = ffi.typeof(
	[[void (*)($ , $ , uint32_t , const $*)]],
	mod.VkDevice,
	mod.VkIndirectExecutionSetEXT,
	mod.VkWriteIndirectExecutionSetPipelineEXT
)
mod.PFN_vkUpdateIndirectExecutionSetShaderEXT = ffi.typeof(
	[[void (*)($ , $ , uint32_t , const $*)]],
	mod.VkDevice,
	mod.VkIndirectExecutionSetEXT,
	mod.VkWriteIndirectExecutionSetShaderEXT
)
ffi.cdef(
	[[void  vkGetGeneratedCommandsMemoryRequirementsEXT($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkGeneratedCommandsMemoryRequirementsInfoEXT,
	mod.VkMemoryRequirements2
)
ffi.cdef(
	[[void  vkCmdPreprocessGeneratedCommandsEXT($ , const $*, $ );]],
	mod.VkCommandBuffer,
	mod.VkGeneratedCommandsInfoEXT,
	mod.VkCommandBuffer
)
ffi.cdef(
	[[void  vkCmdExecuteGeneratedCommandsEXT($ , $ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkBool32,
	mod.VkGeneratedCommandsInfoEXT
)
ffi.cdef(
	[[$  vkCreateIndirectCommandsLayoutEXT($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkIndirectCommandsLayoutCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkIndirectCommandsLayoutEXT
)
ffi.cdef(
	[[void  vkDestroyIndirectCommandsLayoutEXT($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkIndirectCommandsLayoutEXT,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[$  vkCreateIndirectExecutionSetEXT($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkIndirectExecutionSetCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkIndirectExecutionSetEXT
)
ffi.cdef(
	[[void  vkDestroyIndirectExecutionSetEXT($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkIndirectExecutionSetEXT,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkUpdateIndirectExecutionSetPipelineEXT($ , $ , uint32_t , const $*);]],
	mod.VkDevice,
	mod.VkIndirectExecutionSetEXT,
	mod.VkWriteIndirectExecutionSetPipelineEXT
)
ffi.cdef(
	[[void  vkUpdateIndirectExecutionSetShaderEXT($ , $ , uint32_t , const $*);]],
	mod.VkDevice,
	mod.VkIndirectExecutionSetEXT,
	mod.VkWriteIndirectExecutionSetShaderEXT
)
mod.VkPhysicalDeviceImageAlignmentControlFeaturesMESA = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ imageAlignmentControl;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceImageAlignmentControlFeaturesMESA,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageAlignmentControlFeaturesMESA[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.imageAlignmentControl)
		end,
	}
)
mod.VkPhysicalDeviceImageAlignmentControlPropertiesMESA = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t supportedImageAlignmentMask;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceImageAlignmentControlPropertiesMESA,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceImageAlignmentControlPropertiesMESA[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.supportedImageAlignmentMask)
		end,
	}
)
mod.VkImageAlignmentControlCreateInfoMESA = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t maximumRequestedAlignment;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkImageAlignmentControlCreateInfoMESA,
	{
		__tostring = function(s)
			return ("struct VkImageAlignmentControlCreateInfoMESA[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maximumRequestedAlignment)
		end,
	}
)
mod.VkPhysicalDeviceDepthClampControlFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ depthClampControl;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceDepthClampControlFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceDepthClampControlFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.depthClampControl)
		end,
	}
)
mod.VkPipelineViewportDepthClampControlCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ depthClampMode;
	const $* pDepthClampRange;
}]],
	mod.VkStructureType,
	mod.VkDepthClampModeEXT,
	mod.VkDepthClampRangeEXT
)
ffi.metatype(
	mod.VkPipelineViewportDepthClampControlCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkPipelineViewportDepthClampControlCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.depthClampMode, t.pDepthClampRange)
		end,
	}
)
mod.VkPhysicalDeviceHdrVividFeaturesHUAWEI = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ hdrVivid;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceHdrVividFeaturesHUAWEI,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceHdrVividFeaturesHUAWEI[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.hdrVivid)
		end,
	}
)
mod.VkHdrVividDynamicMetadataHUAWEI = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	size_t dynamicMetadataSize;
	const void* pDynamicMetadata;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkHdrVividDynamicMetadataHUAWEI,
	{
		__tostring = function(s)
			return ("struct VkHdrVividDynamicMetadataHUAWEI[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.dynamicMetadataSize, t.pDynamicMetadata)
		end,
	}
)
mod.VkCooperativeMatrixFlexibleDimensionsPropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t MGranularity;
	uint32_t NGranularity;
	uint32_t KGranularity;
	$ AType;
	$ BType;
	$ CType;
	$ ResultType;
	$ saturatingAccumulation;
	$ scope;
	uint32_t workgroupInvocations;
}]],
	mod.VkStructureType,
	mod.VkComponentTypeKHR,
	mod.VkComponentTypeKHR,
	mod.VkComponentTypeKHR,
	mod.VkComponentTypeKHR,
	mod.VkBool32,
	mod.VkScopeKHR
)
ffi.metatype(
	mod.VkCooperativeMatrixFlexibleDimensionsPropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkCooperativeMatrixFlexibleDimensionsPropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.MGranularity,
				t.NGranularity,
				t.KGranularity,
				t.AType,
				t.BType,
				t.CType,
				t.ResultType,
				t.saturatingAccumulation,
				t.scope,
				t.workgroupInvocations
			)
		end,
	}
)
mod.VkPhysicalDeviceCooperativeMatrix2FeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ cooperativeMatrixWorkgroupScope;
	$ cooperativeMatrixFlexibleDimensions;
	$ cooperativeMatrixReductions;
	$ cooperativeMatrixConversions;
	$ cooperativeMatrixPerElementOperations;
	$ cooperativeMatrixTensorAddressing;
	$ cooperativeMatrixBlockLoads;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceCooperativeMatrix2FeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCooperativeMatrix2FeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.cooperativeMatrixWorkgroupScope,
				t.cooperativeMatrixFlexibleDimensions,
				t.cooperativeMatrixReductions,
				t.cooperativeMatrixConversions,
				t.cooperativeMatrixPerElementOperations,
				t.cooperativeMatrixTensorAddressing,
				t.cooperativeMatrixBlockLoads
			)
		end,
	}
)
mod.VkPhysicalDeviceCooperativeMatrix2PropertiesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t cooperativeMatrixWorkgroupScopeMaxWorkgroupSize;
	uint32_t cooperativeMatrixFlexibleDimensionsMaxDimension;
	uint32_t cooperativeMatrixWorkgroupScopeReservedSharedMemory;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceCooperativeMatrix2PropertiesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceCooperativeMatrix2PropertiesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.cooperativeMatrixWorkgroupScopeMaxWorkgroupSize,
				t.cooperativeMatrixFlexibleDimensionsMaxDimension,
				t.cooperativeMatrixWorkgroupScopeReservedSharedMemory
			)
		end,
	}
)
mod.PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = ffi.typeof(
	[[$ (*)($ , uint32_t*, $*)]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkCooperativeMatrixFlexibleDimensionsPropertiesNV
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV($ , uint32_t*, $*);]],
	mod.VkResult,
	mod.VkPhysicalDevice,
	mod.VkCooperativeMatrixFlexibleDimensionsPropertiesNV
)
mod.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelineOpacityMicromap;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePipelineOpacityMicromapFeaturesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineOpacityMicromap)
		end,
	}
)
mod.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ vertexAttributeRobustness;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.vertexAttributeRobustness)
		end,
	}
)
mod.VkPhysicalDeviceFormatPackFeaturesARM = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ formatPack;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFormatPackFeaturesARM,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFormatPackFeaturesARM[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.formatPack)
		end,
	}
)
mod.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ fragmentDensityMapLayered;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.fragmentDensityMapLayered)
		end,
	}
)
mod.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxFragmentDensityMapLayers;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxFragmentDensityMapLayers)
		end,
	}
)
mod.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t maxFragmentDensityMapLayers;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE,
	{
		__tostring = function(s)
			return ("struct VkPipelineFragmentDensityMapLayeredCreateInfoVALVE[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.maxFragmentDensityMapLayers)
		end,
	}
)
mod.VkSetPresentConfigNV = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t numFramesPerBatch;
	uint32_t presentConfigFeedback;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkSetPresentConfigNV,
	{
		__tostring = function(s)
			return ("struct VkSetPresentConfigNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.numFramesPerBatch, t.presentConfigFeedback)
		end,
	}
)
mod.VkPhysicalDevicePresentMeteringFeaturesNV = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ presentMetering;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePresentMeteringFeaturesNV,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePresentMeteringFeaturesNV[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.presentMetering)
		end,
	}
)
mod.VkRenderingEndInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
ffi.metatype(
	mod.VkRenderingEndInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkRenderingEndInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext)
		end,
	}
)
mod.PFN_vkCmdEndRendering2EXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkRenderingEndInfoEXT)
ffi.cdef(
	[[void  vkCmdEndRendering2EXT($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkRenderingEndInfoEXT
)
mod.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ zeroInitializeDeviceMemory;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.zeroInitializeDeviceMemory)
		end,
	}
)
mod.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ pipelineCacheIncrementalMode;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pipelineCacheIncrementalMode)
		end,
	}
)
mod.VkBuildAccelerationStructureModeKHR = ffi.typeof([[enum {
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureCreateFlagBitsKHR = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x00000001,
	VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000008,
	VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 0x00000004,
	VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkAccelerationStructureBuildRangeInfoKHR = ffi.typeof([[struct {
	uint32_t primitiveCount;
	uint32_t primitiveOffset;
	uint32_t firstVertex;
	uint32_t transformOffset;
}]])
ffi.metatype(
	mod.VkAccelerationStructureBuildRangeInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureBuildRangeInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.primitiveCount, t.primitiveOffset, t.firstVertex, t.transformOffset)
		end,
	}
)
mod.VkAccelerationStructureGeometryTrianglesDataKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ vertexFormat;
	$ vertexData;
	$ vertexStride;
	uint32_t maxVertex;
	$ indexType;
	$ indexData;
	$ transformData;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceSize,
	mod.VkIndexType,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceOrHostAddressConstKHR
)
ffi.metatype(
	mod.VkAccelerationStructureGeometryTrianglesDataKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureGeometryTrianglesDataKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.vertexFormat,
				t.vertexData,
				t.vertexStride,
				t.maxVertex,
				t.indexType,
				t.indexData,
				t.transformData
			)
		end,
	}
)
mod.VkAccelerationStructureGeometryAabbsDataKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ data;
	$ stride;
}]],
	mod.VkStructureType,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkAccelerationStructureGeometryAabbsDataKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureGeometryAabbsDataKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.data, t.stride)
		end,
	}
)
mod.VkAccelerationStructureGeometryInstancesDataKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ arrayOfPointers;
	$ data;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkDeviceOrHostAddressConstKHR
)
ffi.metatype(
	mod.VkAccelerationStructureGeometryInstancesDataKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureGeometryInstancesDataKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.arrayOfPointers, t.data)
		end,
	}
)
mod.VkAccelerationStructureGeometryDataKHR = ffi.typeof(
	[[union {
	$ triangles;
	$ aabbs;
	$ instances;
}]],
	mod.VkAccelerationStructureGeometryTrianglesDataKHR,
	mod.VkAccelerationStructureGeometryAabbsDataKHR,
	mod.VkAccelerationStructureGeometryInstancesDataKHR
)
ffi.metatype(
	mod.VkAccelerationStructureGeometryDataKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureGeometryDataKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			local obj = N(T)

			if t.triangles ~= nil then obj.triangles = t.triangles end

			if t.aabbs ~= nil then obj.aabbs = t.aabbs end

			if t.instances ~= nil then obj.instances = t.instances end

			return obj
		end,
	}
)
mod.VkAccelerationStructureGeometryKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ geometryType;
	$ geometry;
	$ flags;
}]],
	mod.VkStructureType,
	mod.VkGeometryTypeKHR,
	mod.VkAccelerationStructureGeometryDataKHR,
	mod.VkGeometryFlagsKHR
)
ffi.metatype(
	mod.VkAccelerationStructureGeometryKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureGeometryKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.geometryType, t.geometry, t.flags)
		end,
	}
)
mod.VkAccelerationStructureBuildGeometryInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ flags;
	$ mode;
	$ srcAccelerationStructure;
	$ dstAccelerationStructure;
	uint32_t geometryCount;
	const $* pGeometries;
	const $** const ppGeometries;
	$ scratchData;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureTypeKHR,
	mod.VkBuildAccelerationStructureFlagsKHR,
	mod.VkBuildAccelerationStructureModeKHR,
	mod.VkAccelerationStructureKHR,
	mod.VkAccelerationStructureKHR,
	mod.VkAccelerationStructureGeometryKHR,
	mod.VkAccelerationStructureGeometryKHR,
	mod.VkDeviceOrHostAddressKHR
)
ffi.metatype(
	mod.VkAccelerationStructureBuildGeometryInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureBuildGeometryInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.type,
				t.flags,
				t.mode,
				t.srcAccelerationStructure,
				t.dstAccelerationStructure,
				t.geometryCount,
				t.pGeometries,
				t.ppGeometries,
				t.scratchData
			)
		end,
	}
)
mod.VkAccelerationStructureCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ createFlags;
	$ buffer;
	$ offset;
	$ size;
	$ type;
	$ deviceAddress;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureCreateFlagsKHR,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkDeviceSize,
	mod.VkAccelerationStructureTypeKHR,
	mod.VkDeviceAddress
)
ffi.metatype(
	mod.VkAccelerationStructureCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.createFlags,
				t.buffer,
				t.offset,
				t.size,
				t.type,
				t.deviceAddress
			)
		end,
	}
)
mod.VkWriteDescriptorSetAccelerationStructureKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t accelerationStructureCount;
	const $* pAccelerationStructures;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureKHR
)
ffi.metatype(
	mod.VkWriteDescriptorSetAccelerationStructureKHR,
	{
		__tostring = function(s)
			return ("struct VkWriteDescriptorSetAccelerationStructureKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.accelerationStructureCount, t.pAccelerationStructures)
		end,
	}
)
mod.VkPhysicalDeviceAccelerationStructureFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ accelerationStructure;
	$ accelerationStructureCaptureReplay;
	$ accelerationStructureIndirectBuild;
	$ accelerationStructureHostCommands;
	$ descriptorBindingAccelerationStructureUpdateAfterBind;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceAccelerationStructureFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceAccelerationStructureFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.accelerationStructure,
				t.accelerationStructureCaptureReplay,
				t.accelerationStructureIndirectBuild,
				t.accelerationStructureHostCommands,
				t.descriptorBindingAccelerationStructureUpdateAfterBind
			)
		end,
	}
)
mod.VkPhysicalDeviceAccelerationStructurePropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint64_t maxGeometryCount;
	uint64_t maxInstanceCount;
	uint64_t maxPrimitiveCount;
	uint32_t maxPerStageDescriptorAccelerationStructures;
	uint32_t maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
	uint32_t maxDescriptorSetAccelerationStructures;
	uint32_t maxDescriptorSetUpdateAfterBindAccelerationStructures;
	uint32_t minAccelerationStructureScratchOffsetAlignment;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceAccelerationStructurePropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceAccelerationStructurePropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxGeometryCount,
				t.maxInstanceCount,
				t.maxPrimitiveCount,
				t.maxPerStageDescriptorAccelerationStructures,
				t.maxPerStageDescriptorUpdateAfterBindAccelerationStructures,
				t.maxDescriptorSetAccelerationStructures,
				t.maxDescriptorSetUpdateAfterBindAccelerationStructures,
				t.minAccelerationStructureScratchOffsetAlignment
			)
		end,
	}
)
mod.VkAccelerationStructureDeviceAddressInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ accelerationStructure;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureKHR
)
ffi.metatype(
	mod.VkAccelerationStructureDeviceAddressInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureDeviceAddressInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.accelerationStructure)
		end,
	}
)
mod.VkAccelerationStructureVersionInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	const uint8_t* pVersionData;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkAccelerationStructureVersionInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkAccelerationStructureVersionInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.pVersionData)
		end,
	}
)
mod.VkCopyAccelerationStructureToMemoryInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureKHR,
	mod.VkDeviceOrHostAddressKHR,
	mod.VkCopyAccelerationStructureModeKHR
)
ffi.metatype(
	mod.VkCopyAccelerationStructureToMemoryInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkCopyAccelerationStructureToMemoryInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.src, t.dst, t.mode)
		end,
	}
)
mod.VkCopyMemoryToAccelerationStructureInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]],
	mod.VkStructureType,
	mod.VkDeviceOrHostAddressConstKHR,
	mod.VkAccelerationStructureKHR,
	mod.VkCopyAccelerationStructureModeKHR
)
ffi.metatype(
	mod.VkCopyMemoryToAccelerationStructureInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkCopyMemoryToAccelerationStructureInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.src, t.dst, t.mode)
		end,
	}
)
mod.VkCopyAccelerationStructureInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]],
	mod.VkStructureType,
	mod.VkAccelerationStructureKHR,
	mod.VkAccelerationStructureKHR,
	mod.VkCopyAccelerationStructureModeKHR
)
ffi.metatype(
	mod.VkCopyAccelerationStructureInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkCopyAccelerationStructureInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.src, t.dst, t.mode)
		end,
	}
)
mod.PFN_vkCreateAccelerationStructureKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAccelerationStructureCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkAccelerationStructureKHR
)
mod.PFN_vkDestroyAccelerationStructureKHR = ffi.typeof(
	[[void (*)($ , $ , const $*)]],
	mod.VkDevice,
	mod.VkAccelerationStructureKHR,
	mod.VkAllocationCallbacks
)
mod.PFN_vkCmdBuildAccelerationStructuresKHR = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, const $** const)]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureBuildGeometryInfoKHR,
	mod.VkAccelerationStructureBuildRangeInfoKHR
)
mod.PFN_vkCmdBuildAccelerationStructuresIndirectKHR = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, const $*, const uint32_t*, const uint32_t** const)]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureBuildGeometryInfoKHR,
	mod.VkDeviceAddress
)
mod.PFN_vkBuildAccelerationStructuresKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , const $*, const $** const)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkAccelerationStructureBuildGeometryInfoKHR,
	mod.VkAccelerationStructureBuildRangeInfoKHR
)
mod.PFN_vkCopyAccelerationStructureKHR = ffi.typeof(
	[[$ (*)($ , $ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyAccelerationStructureInfoKHR
)
mod.PFN_vkCopyAccelerationStructureToMemoryKHR = ffi.typeof(
	[[$ (*)($ , $ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyAccelerationStructureToMemoryInfoKHR
)
mod.PFN_vkCopyMemoryToAccelerationStructureKHR = ffi.typeof(
	[[$ (*)($ , $ , const $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyMemoryToAccelerationStructureInfoKHR
)
mod.PFN_vkWriteAccelerationStructuresPropertiesKHR = ffi.typeof(
	[[$ (*)($ , uint32_t , const $*, $ , size_t , void*, size_t )]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAccelerationStructureKHR,
	mod.VkQueryType
)
mod.PFN_vkCmdCopyAccelerationStructureKHR = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkCopyAccelerationStructureInfoKHR
)
mod.PFN_vkCmdCopyAccelerationStructureToMemoryKHR = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkCopyAccelerationStructureToMemoryInfoKHR
)
mod.PFN_vkCmdCopyMemoryToAccelerationStructureKHR = ffi.typeof(
	[[void (*)($ , const $*)]],
	mod.VkCommandBuffer,
	mod.VkCopyMemoryToAccelerationStructureInfoKHR
)
mod.PFN_vkGetAccelerationStructureDeviceAddressKHR = ffi.typeof(
	[[$ (*)($ , const $*)]],
	mod.VkDeviceAddress,
	mod.VkDevice,
	mod.VkAccelerationStructureDeviceAddressInfoKHR
)
mod.PFN_vkCmdWriteAccelerationStructuresPropertiesKHR = ffi.typeof(
	[[void (*)($ , uint32_t , const $*, $ , $ , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureKHR,
	mod.VkQueryType,
	mod.VkQueryPool
)
mod.PFN_vkGetDeviceAccelerationStructureCompatibilityKHR = ffi.typeof(
	[[void (*)($ , const $*, $*)]],
	mod.VkDevice,
	mod.VkAccelerationStructureVersionInfoKHR,
	mod.VkAccelerationStructureCompatibilityKHR
)
mod.PFN_vkGetAccelerationStructureBuildSizesKHR = ffi.typeof(
	[[void (*)($ , $ , const $*, const uint32_t*, $*)]],
	mod.VkDevice,
	mod.VkAccelerationStructureBuildTypeKHR,
	mod.VkAccelerationStructureBuildGeometryInfoKHR,
	mod.VkAccelerationStructureBuildSizesInfoKHR
)
ffi.cdef(
	[[$  vkCreateAccelerationStructureKHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAccelerationStructureCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkAccelerationStructureKHR
)
ffi.cdef(
	[[void  vkDestroyAccelerationStructureKHR($ , $ , const $*);]],
	mod.VkDevice,
	mod.VkAccelerationStructureKHR,
	mod.VkAllocationCallbacks
)
ffi.cdef(
	[[void  vkCmdBuildAccelerationStructuresKHR($ , uint32_t , const $*, const $** const);]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureBuildGeometryInfoKHR,
	mod.VkAccelerationStructureBuildRangeInfoKHR
)
ffi.cdef(
	[[void  vkCmdBuildAccelerationStructuresIndirectKHR($ , uint32_t , const $*, const $*, const uint32_t*, const uint32_t** const);]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureBuildGeometryInfoKHR,
	mod.VkDeviceAddress
)
ffi.cdef(
	[[$  vkBuildAccelerationStructuresKHR($ , $ , uint32_t , const $*, const $** const);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkAccelerationStructureBuildGeometryInfoKHR,
	mod.VkAccelerationStructureBuildRangeInfoKHR
)
ffi.cdef(
	[[$  vkCopyAccelerationStructureKHR($ , $ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyAccelerationStructureInfoKHR
)
ffi.cdef(
	[[$  vkCopyAccelerationStructureToMemoryKHR($ , $ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyAccelerationStructureToMemoryInfoKHR
)
ffi.cdef(
	[[$  vkCopyMemoryToAccelerationStructureKHR($ , $ , const $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkCopyMemoryToAccelerationStructureInfoKHR
)
ffi.cdef(
	[[$  vkWriteAccelerationStructuresPropertiesKHR($ , uint32_t , const $*, $ , size_t , void*, size_t );]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAccelerationStructureKHR,
	mod.VkQueryType
)
ffi.cdef(
	[[void  vkCmdCopyAccelerationStructureKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyAccelerationStructureInfoKHR
)
ffi.cdef(
	[[void  vkCmdCopyAccelerationStructureToMemoryKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyAccelerationStructureToMemoryInfoKHR
)
ffi.cdef(
	[[void  vkCmdCopyMemoryToAccelerationStructureKHR($ , const $*);]],
	mod.VkCommandBuffer,
	mod.VkCopyMemoryToAccelerationStructureInfoKHR
)
ffi.cdef(
	[[$  vkGetAccelerationStructureDeviceAddressKHR($ , const $*);]],
	mod.VkDeviceAddress,
	mod.VkDevice,
	mod.VkAccelerationStructureDeviceAddressInfoKHR
)
ffi.cdef(
	[[void  vkCmdWriteAccelerationStructuresPropertiesKHR($ , uint32_t , const $*, $ , $ , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkAccelerationStructureKHR,
	mod.VkQueryType,
	mod.VkQueryPool
)
ffi.cdef(
	[[void  vkGetDeviceAccelerationStructureCompatibilityKHR($ , const $*, $*);]],
	mod.VkDevice,
	mod.VkAccelerationStructureVersionInfoKHR,
	mod.VkAccelerationStructureCompatibilityKHR
)
ffi.cdef(
	[[void  vkGetAccelerationStructureBuildSizesKHR($ , $ , const $*, const uint32_t*, $*);]],
	mod.VkDevice,
	mod.VkAccelerationStructureBuildTypeKHR,
	mod.VkAccelerationStructureBuildGeometryInfoKHR,
	mod.VkAccelerationStructureBuildSizesInfoKHR
)
mod.VkShaderGroupShaderKHR = ffi.typeof([[enum {
	VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0,
	VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
	VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
	VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
	VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkRayTracingShaderGroupCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ type;
	uint32_t generalShader;
	uint32_t closestHitShader;
	uint32_t anyHitShader;
	uint32_t intersectionShader;
	const void* pShaderGroupCaptureReplayHandle;
}]],
	mod.VkStructureType,
	mod.VkRayTracingShaderGroupTypeKHR
)
ffi.metatype(
	mod.VkRayTracingShaderGroupCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkRayTracingShaderGroupCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.type,
				t.generalShader,
				t.closestHitShader,
				t.anyHitShader,
				t.intersectionShader,
				t.pShaderGroupCaptureReplayHandle
			)
		end,
	}
)
mod.VkRayTracingPipelineInterfaceCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	uint32_t maxPipelineRayPayloadSize;
	uint32_t maxPipelineRayHitAttributeSize;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkRayTracingPipelineInterfaceCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkRayTracingPipelineInterfaceCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxPipelineRayPayloadSize,
				t.maxPipelineRayHitAttributeSize
			)
		end,
	}
)
mod.VkRayTracingPipelineCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t stageCount;
	const $* pStages;
	uint32_t groupCount;
	const $* pGroups;
	uint32_t maxPipelineRayRecursionDepth;
	const $* pLibraryInfo;
	const $* pLibraryInterface;
	const $* pDynamicState;
	$ layout;
	$ basePipelineHandle;
	int32_t basePipelineIndex;
}]],
	mod.VkStructureType,
	mod.VkPipelineCreateFlags,
	mod.VkPipelineShaderStageCreateInfo,
	mod.VkRayTracingShaderGroupCreateInfoKHR,
	mod.VkPipelineLibraryCreateInfoKHR,
	mod.VkRayTracingPipelineInterfaceCreateInfoKHR,
	mod.VkPipelineDynamicStateCreateInfo,
	mod.VkPipelineLayout,
	mod.VkPipeline
)
ffi.metatype(
	mod.VkRayTracingPipelineCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkRayTracingPipelineCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.flags,
				t.stageCount,
				t.pStages,
				t.groupCount,
				t.pGroups,
				t.maxPipelineRayRecursionDepth,
				t.pLibraryInfo,
				t.pLibraryInterface,
				t.pDynamicState,
				t.layout,
				t.basePipelineHandle,
				t.basePipelineIndex
			)
		end,
	}
)
mod.VkPhysicalDeviceRayTracingPipelineFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ rayTracingPipeline;
	$ rayTracingPipelineShaderGroupHandleCaptureReplay;
	$ rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
	$ rayTracingPipelineTraceRaysIndirect;
	$ rayTraversalPrimitiveCulling;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRayTracingPipelineFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRayTracingPipelineFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.rayTracingPipeline,
				t.rayTracingPipelineShaderGroupHandleCaptureReplay,
				t.rayTracingPipelineShaderGroupHandleCaptureReplayMixed,
				t.rayTracingPipelineTraceRaysIndirect,
				t.rayTraversalPrimitiveCulling
			)
		end,
	}
)
mod.VkPhysicalDeviceRayTracingPipelinePropertiesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t shaderGroupHandleSize;
	uint32_t maxRayRecursionDepth;
	uint32_t maxShaderGroupStride;
	uint32_t shaderGroupBaseAlignment;
	uint32_t shaderGroupHandleCaptureReplaySize;
	uint32_t maxRayDispatchInvocationCount;
	uint32_t shaderGroupHandleAlignment;
	uint32_t maxRayHitAttributeSize;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRayTracingPipelinePropertiesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.shaderGroupHandleSize,
				t.maxRayRecursionDepth,
				t.maxShaderGroupStride,
				t.shaderGroupBaseAlignment,
				t.shaderGroupHandleCaptureReplaySize,
				t.maxRayDispatchInvocationCount,
				t.shaderGroupHandleAlignment,
				t.maxRayHitAttributeSize
			)
		end,
	}
)
mod.VkTraceRaysIndirectCommandKHR = ffi.typeof([[struct {
	uint32_t width;
	uint32_t height;
	uint32_t depth;
}]])
ffi.metatype(
	mod.VkTraceRaysIndirectCommandKHR,
	{
		__tostring = function(s)
			return ("struct VkTraceRaysIndirectCommandKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.width, t.height, t.depth)
		end,
	}
)
mod.PFN_vkCmdTraceRaysKHR = ffi.typeof(
	[[void (*)($ , const $*, const $*, const $*, const $*, uint32_t , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR
)
mod.PFN_vkCreateRayTracingPipelinesKHR = ffi.typeof(
	[[$ (*)($ , $ , $ , uint32_t , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkPipelineCache,
	mod.VkRayTracingPipelineCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkPipeline
)
mod.PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , uint32_t , size_t , void*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipeline
)
mod.PFN_vkCmdTraceRaysIndirectKHR = ffi.typeof(
	[[void (*)($ , const $*, const $*, const $*, const $*, $ )]],
	mod.VkCommandBuffer,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkDeviceAddress
)
mod.PFN_vkGetRayTracingShaderGroupStackSizeKHR = ffi.typeof(
	[[$ (*)($ , $ , uint32_t , $ )]],
	mod.VkDeviceSize,
	mod.VkDevice,
	mod.VkPipeline,
	mod.VkShaderGroupShaderKHR
)
mod.PFN_vkCmdSetRayTracingPipelineStackSizeKHR = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
ffi.cdef(
	[[void  vkCmdTraceRaysKHR($ , const $*, const $*, const $*, const $*, uint32_t , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR
)
ffi.cdef(
	[[$  vkCreateRayTracingPipelinesKHR($ , $ , $ , uint32_t , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkDeferredOperationKHR,
	mod.VkPipelineCache,
	mod.VkRayTracingPipelineCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkPipeline
)
ffi.cdef(
	[[$  vkGetRayTracingCaptureReplayShaderGroupHandlesKHR($ , $ , uint32_t , uint32_t , size_t , void*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkPipeline
)
ffi.cdef(
	[[void  vkCmdTraceRaysIndirectKHR($ , const $*, const $*, const $*, const $*, $ );]],
	mod.VkCommandBuffer,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkStridedDeviceAddressRegionKHR,
	mod.VkDeviceAddress
)
ffi.cdef(
	[[$  vkGetRayTracingShaderGroupStackSizeKHR($ , $ , uint32_t , $ );]],
	mod.VkDeviceSize,
	mod.VkDevice,
	mod.VkPipeline,
	mod.VkShaderGroupShaderKHR
)
ffi.cdef(
	[[void  vkCmdSetRayTracingPipelineStackSizeKHR($ , uint32_t );]],
	mod.VkCommandBuffer
)
mod.VkPhysicalDeviceRayQueryFeaturesKHR = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ rayQuery;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceRayQueryFeaturesKHR,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceRayQueryFeaturesKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.rayQuery)
		end,
	}
)
mod.VkPhysicalDeviceMeshShaderFeaturesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ taskShader;
	$ meshShader;
	$ multiviewMeshShader;
	$ primitiveFragmentShadingRateMeshShader;
	$ meshShaderQueries;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMeshShaderFeaturesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMeshShaderFeaturesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.taskShader,
				t.meshShader,
				t.multiviewMeshShader,
				t.primitiveFragmentShadingRateMeshShader,
				t.meshShaderQueries
			)
		end,
	}
)
mod.VkPhysicalDeviceMeshShaderPropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t maxTaskWorkGroupTotalCount;
	uint32_t maxTaskWorkGroupCount[3];
	uint32_t maxTaskWorkGroupInvocations;
	uint32_t maxTaskWorkGroupSize[3];
	uint32_t maxTaskPayloadSize;
	uint32_t maxTaskSharedMemorySize;
	uint32_t maxTaskPayloadAndSharedMemorySize;
	uint32_t maxMeshWorkGroupTotalCount;
	uint32_t maxMeshWorkGroupCount[3];
	uint32_t maxMeshWorkGroupInvocations;
	uint32_t maxMeshWorkGroupSize[3];
	uint32_t maxMeshSharedMemorySize;
	uint32_t maxMeshPayloadAndSharedMemorySize;
	uint32_t maxMeshOutputMemorySize;
	uint32_t maxMeshPayloadAndOutputMemorySize;
	uint32_t maxMeshOutputComponents;
	uint32_t maxMeshOutputVertices;
	uint32_t maxMeshOutputPrimitives;
	uint32_t maxMeshOutputLayers;
	uint32_t maxMeshMultiviewViewCount;
	uint32_t meshOutputPerVertexGranularity;
	uint32_t meshOutputPerPrimitiveGranularity;
	uint32_t maxPreferredTaskWorkGroupInvocations;
	uint32_t maxPreferredMeshWorkGroupInvocations;
	$ prefersLocalInvocationVertexOutput;
	$ prefersLocalInvocationPrimitiveOutput;
	$ prefersCompactVertexOutput;
	$ prefersCompactPrimitiveOutput;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceMeshShaderPropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceMeshShaderPropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.maxTaskWorkGroupTotalCount,
				t.maxTaskWorkGroupCount,
				t.maxTaskWorkGroupInvocations,
				t.maxTaskWorkGroupSize,
				t.maxTaskPayloadSize,
				t.maxTaskSharedMemorySize,
				t.maxTaskPayloadAndSharedMemorySize,
				t.maxMeshWorkGroupTotalCount,
				t.maxMeshWorkGroupCount,
				t.maxMeshWorkGroupInvocations,
				t.maxMeshWorkGroupSize,
				t.maxMeshSharedMemorySize,
				t.maxMeshPayloadAndSharedMemorySize,
				t.maxMeshOutputMemorySize,
				t.maxMeshPayloadAndOutputMemorySize,
				t.maxMeshOutputComponents,
				t.maxMeshOutputVertices,
				t.maxMeshOutputPrimitives,
				t.maxMeshOutputLayers,
				t.maxMeshMultiviewViewCount,
				t.meshOutputPerVertexGranularity,
				t.meshOutputPerPrimitiveGranularity,
				t.maxPreferredTaskWorkGroupInvocations,
				t.maxPreferredMeshWorkGroupInvocations,
				t.prefersLocalInvocationVertexOutput,
				t.prefersLocalInvocationPrimitiveOutput,
				t.prefersCompactVertexOutput,
				t.prefersCompactPrimitiveOutput
			)
		end,
	}
)
mod.VkDrawMeshTasksIndirectCommandEXT = ffi.typeof([[struct {
	uint32_t groupCountX;
	uint32_t groupCountY;
	uint32_t groupCountZ;
}]])
ffi.metatype(
	mod.VkDrawMeshTasksIndirectCommandEXT,
	{
		__tostring = function(s)
			return ("struct VkDrawMeshTasksIndirectCommandEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.groupCountX, t.groupCountY, t.groupCountZ)
		end,
	}
)
mod.PFN_vkCmdDrawMeshTasksEXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDrawMeshTasksIndirectEXT = ffi.typeof(
	[[void (*)($ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.PFN_vkCmdDrawMeshTasksIndirectCountEXT = ffi.typeof(
	[[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdDrawMeshTasksEXT($ , uint32_t , uint32_t , uint32_t );]],
	mod.VkCommandBuffer
)
ffi.cdef(
	[[void  vkCmdDrawMeshTasksIndirectEXT($ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize
)
ffi.cdef(
	[[void  vkCmdDrawMeshTasksIndirectCountEXT($ , $ , $ , $ , $ , uint32_t , uint32_t );]],
	mod.VkCommandBuffer,
	mod.VkBuffer,
	mod.VkDeviceSize,
	mod.VkBuffer,
	mod.VkDeviceSize
)
mod.VkAndroidSurfaceCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkAndroidSurfaceCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	struct ANativeWindow* window;
}]],
	mod.VkStructureType,
	mod.VkAndroidSurfaceCreateFlagsKHR
)
ffi.metatype(
	mod.VkAndroidSurfaceCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkAndroidSurfaceCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.window)
		end,
	}
)
mod.PFN_vkCreateAndroidSurfaceKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkAndroidSurfaceCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkCreateAndroidSurfaceKHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkAndroidSurfaceCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.VkAndroidHardwareBufferUsageANDROID = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint64_t androidHardwareBufferUsage;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkAndroidHardwareBufferUsageANDROID,
	{
		__tostring = function(s)
			return ("struct VkAndroidHardwareBufferUsageANDROID[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.androidHardwareBufferUsage)
		end,
	}
)
mod.VkAndroidHardwareBufferPropertiesANDROID = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ allocationSize;
	uint32_t memoryTypeBits;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkAndroidHardwareBufferPropertiesANDROID,
	{
		__tostring = function(s)
			return ("struct VkAndroidHardwareBufferPropertiesANDROID[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.allocationSize, t.memoryTypeBits)
		end,
	}
)
mod.VkAndroidHardwareBufferFormatPropertiesANDROID = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ format;
	uint64_t externalFormat;
	$ formatFeatures;
	$ samplerYcbcrConversionComponents;
	$ suggestedYcbcrModel;
	$ suggestedYcbcrRange;
	$ suggestedXChromaOffset;
	$ suggestedYChromaOffset;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkFormatFeatureFlags,
	mod.VkComponentMapping,
	mod.VkSamplerYcbcrModelConversion,
	mod.VkSamplerYcbcrRange,
	mod.VkChromaLocation,
	mod.VkChromaLocation
)
ffi.metatype(
	mod.VkAndroidHardwareBufferFormatPropertiesANDROID,
	{
		__tostring = function(s)
			return ("struct VkAndroidHardwareBufferFormatPropertiesANDROID[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.format,
				t.externalFormat,
				t.formatFeatures,
				t.samplerYcbcrConversionComponents,
				t.suggestedYcbcrModel,
				t.suggestedYcbcrRange,
				t.suggestedXChromaOffset,
				t.suggestedYChromaOffset
			)
		end,
	}
)
mod.VkImportAndroidHardwareBufferInfoANDROID = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	struct AHardwareBuffer* buffer;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkImportAndroidHardwareBufferInfoANDROID,
	{
		__tostring = function(s)
			return ("struct VkImportAndroidHardwareBufferInfoANDROID[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.buffer)
		end,
	}
)
mod.VkMemoryGetAndroidHardwareBufferInfoANDROID = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ memory;
}]],
	mod.VkStructureType,
	mod.VkDeviceMemory
)
ffi.metatype(
	mod.VkMemoryGetAndroidHardwareBufferInfoANDROID,
	{
		__tostring = function(s)
			return ("struct VkMemoryGetAndroidHardwareBufferInfoANDROID[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memory)
		end,
	}
)
mod.VkExternalFormatANDROID = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint64_t externalFormat;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkExternalFormatANDROID,
	{
		__tostring = function(s)
			return ("struct VkExternalFormatANDROID[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.externalFormat)
		end,
	}
)
mod.VkAndroidHardwareBufferFormatProperties2ANDROID = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ format;
	uint64_t externalFormat;
	$ formatFeatures;
	$ samplerYcbcrConversionComponents;
	$ suggestedYcbcrModel;
	$ suggestedYcbcrRange;
	$ suggestedXChromaOffset;
	$ suggestedYChromaOffset;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkFormatFeatureFlags2,
	mod.VkComponentMapping,
	mod.VkSamplerYcbcrModelConversion,
	mod.VkSamplerYcbcrRange,
	mod.VkChromaLocation,
	mod.VkChromaLocation
)
ffi.metatype(
	mod.VkAndroidHardwareBufferFormatProperties2ANDROID,
	{
		__tostring = function(s)
			return ("struct VkAndroidHardwareBufferFormatProperties2ANDROID[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.format,
				t.externalFormat,
				t.formatFeatures,
				t.samplerYcbcrConversionComponents,
				t.suggestedYcbcrModel,
				t.suggestedYcbcrRange,
				t.suggestedXChromaOffset,
				t.suggestedYChromaOffset
			)
		end,
	}
)
mod.PFN_vkGetAndroidHardwareBufferPropertiesANDROID = ffi.typeof(
	[[$ (*)($ , const struct AHardwareBuffer*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAndroidHardwareBufferPropertiesANDROID
)
mod.PFN_vkGetMemoryAndroidHardwareBufferANDROID = ffi.typeof(
	[[$ (*)($ , const $*, struct AHardwareBuffer**)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryGetAndroidHardwareBufferInfoANDROID
)
ffi.cdef(
	[[$  vkGetAndroidHardwareBufferPropertiesANDROID($ , const struct AHardwareBuffer*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkAndroidHardwareBufferPropertiesANDROID
)
ffi.cdef(
	[[$  vkGetMemoryAndroidHardwareBufferANDROID($ , const $*, struct AHardwareBuffer**);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryGetAndroidHardwareBufferInfoANDROID
)
mod.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ externalFormatResolve;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExternalFormatResolveFeaturesANDROID[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.externalFormatResolve)
		end,
	}
)
mod.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ nullColorAttachmentWithExternalFormatResolve;
	$ externalFormatResolveChromaOffsetX;
	$ externalFormatResolveChromaOffsetY;
}]],
	mod.VkStructureType,
	mod.VkBool32,
	mod.VkChromaLocation,
	mod.VkChromaLocation
)
ffi.metatype(
	mod.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExternalFormatResolvePropertiesANDROID[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.nullColorAttachmentWithExternalFormatResolve,
				t.externalFormatResolveChromaOffsetX,
				t.externalFormatResolveChromaOffsetY
			)
		end,
	}
)
mod.VkAndroidHardwareBufferFormatResolvePropertiesANDROID = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ colorAttachmentFormat;
}]],
	mod.VkStructureType,
	mod.VkFormat
)
ffi.metatype(
	mod.VkAndroidHardwareBufferFormatResolvePropertiesANDROID,
	{
		__tostring = function(s)
			return ("struct VkAndroidHardwareBufferFormatResolvePropertiesANDROID[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.colorAttachmentFormat)
		end,
	}
)
mod.VkIOSSurfaceCreateFlagsMVK = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkIOSSurfaceCreateInfoMVK = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const void* pView;
}]],
	mod.VkStructureType,
	mod.VkIOSSurfaceCreateFlagsMVK
)
ffi.metatype(
	mod.VkIOSSurfaceCreateInfoMVK,
	{
		__tostring = function(s)
			return ("struct VkIOSSurfaceCreateInfoMVK[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.pView)
		end,
	}
)
mod.PFN_vkCreateIOSSurfaceMVK = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkIOSSurfaceCreateInfoMVK,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkCreateIOSSurfaceMVK($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkIOSSurfaceCreateInfoMVK,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.VkMacOSSurfaceCreateFlagsMVK = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMacOSSurfaceCreateInfoMVK = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const void* pView;
}]],
	mod.VkStructureType,
	mod.VkMacOSSurfaceCreateFlagsMVK
)
ffi.metatype(
	mod.VkMacOSSurfaceCreateInfoMVK,
	{
		__tostring = function(s)
			return ("struct VkMacOSSurfaceCreateInfoMVK[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.pView)
		end,
	}
)
mod.PFN_vkCreateMacOSSurfaceMVK = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkMacOSSurfaceCreateInfoMVK,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkCreateMacOSSurfaceMVK($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkMacOSSurfaceCreateInfoMVK,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.CAMetalLayer = ffi.typeof([[void ]])
mod.VkMetalSurfaceCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMetalSurfaceCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const $* pLayer;
}]],
	mod.VkStructureType,
	mod.VkMetalSurfaceCreateFlagsEXT,
	mod.CAMetalLayer
)
ffi.metatype(
	mod.VkMetalSurfaceCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMetalSurfaceCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.pLayer)
		end,
	}
)
mod.PFN_vkCreateMetalSurfaceEXT = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkMetalSurfaceCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkCreateMetalSurfaceEXT($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkMetalSurfaceCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.MTLDevice_id = ffi.typeof([[void*]])
mod.MTLCommandQueue_id = ffi.typeof([[void*]])
mod.MTLBuffer_id = ffi.typeof([[void*]])
mod.MTLTexture_id = ffi.typeof([[void*]])
mod.IOSurfaceRef = ffi.typeof([[void*]])
mod.MTLSharedEvent_id = ffi.typeof([[void*]])
mod.VkExportMetalObjectTypeFlagBitsEXT = ffi.typeof([[enum {
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = 0x00000001,
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = 0x00000002,
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = 0x00000004,
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = 0x00000008,
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = 0x00000010,
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = 0x00000020,
	VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkExportMetalObjectTypeFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExportMetalObjectCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ exportObjectType;
}]],
	mod.VkStructureType,
	mod.VkExportMetalObjectTypeFlagBitsEXT
)
ffi.metatype(
	mod.VkExportMetalObjectCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkExportMetalObjectCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.exportObjectType)
		end,
	}
)
mod.VkExportMetalObjectsInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
ffi.metatype(
	mod.VkExportMetalObjectsInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkExportMetalObjectsInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext)
		end,
	}
)
mod.VkExportMetalDeviceInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ mtlDevice;
}]],
	mod.VkStructureType,
	mod.MTLDevice_id
)
ffi.metatype(
	mod.VkExportMetalDeviceInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkExportMetalDeviceInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.mtlDevice)
		end,
	}
)
mod.VkExportMetalCommandQueueInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ queue;
	$ mtlCommandQueue;
}]],
	mod.VkStructureType,
	mod.VkQueue,
	mod.MTLCommandQueue_id
)
ffi.metatype(
	mod.VkExportMetalCommandQueueInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkExportMetalCommandQueueInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.queue, t.mtlCommandQueue)
		end,
	}
)
mod.VkExportMetalBufferInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ memory;
	$ mtlBuffer;
}]],
	mod.VkStructureType,
	mod.VkDeviceMemory,
	mod.MTLBuffer_id
)
ffi.metatype(
	mod.VkExportMetalBufferInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkExportMetalBufferInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memory, t.mtlBuffer)
		end,
	}
)
mod.VkImportMetalBufferInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ mtlBuffer;
}]],
	mod.VkStructureType,
	mod.MTLBuffer_id
)
ffi.metatype(
	mod.VkImportMetalBufferInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImportMetalBufferInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.mtlBuffer)
		end,
	}
)
mod.VkExportMetalTextureInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ imageView;
	$ bufferView;
	$ plane;
	$ mtlTexture;
}]],
	mod.VkStructureType,
	mod.VkImage,
	mod.VkImageView,
	mod.VkBufferView,
	mod.VkImageAspectFlagBits,
	mod.MTLTexture_id
)
ffi.metatype(
	mod.VkExportMetalTextureInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkExportMetalTextureInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.image,
				t.imageView,
				t.bufferView,
				t.plane,
				t.mtlTexture
			)
		end,
	}
)
mod.VkImportMetalTextureInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ plane;
	$ mtlTexture;
}]],
	mod.VkStructureType,
	mod.VkImageAspectFlagBits,
	mod.MTLTexture_id
)
ffi.metatype(
	mod.VkImportMetalTextureInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImportMetalTextureInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.plane, t.mtlTexture)
		end,
	}
)
mod.VkExportMetalIOSurfaceInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ ioSurface;
}]],
	mod.VkStructureType,
	mod.VkImage,
	mod.IOSurfaceRef
)
ffi.metatype(
	mod.VkExportMetalIOSurfaceInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkExportMetalIOSurfaceInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.image, t.ioSurface)
		end,
	}
)
mod.VkImportMetalIOSurfaceInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ ioSurface;
}]],
	mod.VkStructureType,
	mod.IOSurfaceRef
)
ffi.metatype(
	mod.VkImportMetalIOSurfaceInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImportMetalIOSurfaceInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.ioSurface)
		end,
	}
)
mod.VkExportMetalSharedEventInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ semaphore;
	$ event;
	$ mtlSharedEvent;
}]],
	mod.VkStructureType,
	mod.VkSemaphore,
	mod.VkEvent,
	mod.MTLSharedEvent_id
)
ffi.metatype(
	mod.VkExportMetalSharedEventInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkExportMetalSharedEventInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.semaphore, t.event, t.mtlSharedEvent)
		end,
	}
)
mod.VkImportMetalSharedEventInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ mtlSharedEvent;
}]],
	mod.VkStructureType,
	mod.MTLSharedEvent_id
)
ffi.metatype(
	mod.VkImportMetalSharedEventInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImportMetalSharedEventInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.mtlSharedEvent)
		end,
	}
)
mod.PFN_vkExportMetalObjectsEXT = ffi.typeof([[void (*)($ , $*)]], mod.VkDevice, mod.VkExportMetalObjectsInfoEXT)
ffi.cdef(
	[[void  vkExportMetalObjectsEXT($ , $*);]],
	mod.VkDevice,
	mod.VkExportMetalObjectsInfoEXT
)
mod.VkImportMemoryMetalHandleInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ handleType;
	void* handle;
}]],
	mod.VkStructureType,
	mod.VkExternalMemoryHandleTypeFlagBits
)
ffi.metatype(
	mod.VkImportMemoryMetalHandleInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkImportMemoryMetalHandleInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.handleType, t.handle)
		end,
	}
)
mod.VkMemoryMetalHandlePropertiesEXT = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint32_t memoryTypeBits;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkMemoryMetalHandlePropertiesEXT,
	{
		__tostring = function(s)
			return ("struct VkMemoryMetalHandlePropertiesEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memoryTypeBits)
		end,
	}
)
mod.VkMemoryGetMetalHandleInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ memory;
	$ handleType;
}]],
	mod.VkStructureType,
	mod.VkDeviceMemory,
	mod.VkExternalMemoryHandleTypeFlagBits
)
ffi.metatype(
	mod.VkMemoryGetMetalHandleInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkMemoryGetMetalHandleInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.memory, t.handleType)
		end,
	}
)
mod.PFN_vkGetMemoryMetalHandleEXT = ffi.typeof(
	[[$ (*)($ , const $*, void**)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryGetMetalHandleInfoEXT
)
mod.PFN_vkGetMemoryMetalHandlePropertiesEXT = ffi.typeof(
	[[$ (*)($ , $ , const void*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkExternalMemoryHandleTypeFlagBits,
	mod.VkMemoryMetalHandlePropertiesEXT
)
ffi.cdef(
	[[$  vkGetMemoryMetalHandleEXT($ , const $*, void**);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkMemoryGetMetalHandleInfoEXT
)
ffi.cdef(
	[[$  vkGetMemoryMetalHandlePropertiesEXT($ , $ , const void*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkExternalMemoryHandleTypeFlagBits,
	mod.VkMemoryMetalHandlePropertiesEXT
)
mod.VkViSurfaceCreateFlagsNN = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkViSurfaceCreateInfoNN = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	void* window;
}]],
	mod.VkStructureType,
	mod.VkViSurfaceCreateFlagsNN
)
ffi.metatype(
	mod.VkViSurfaceCreateInfoNN,
	{
		__tostring = function(s)
			return ("struct VkViSurfaceCreateInfoNN[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.window)
		end,
	}
)
mod.PFN_vkCreateViSurfaceNN = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkViSurfaceCreateInfoNN,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkCreateViSurfaceNN($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkViSurfaceCreateInfoNN,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.VkWaylandSurfaceCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkWaylandSurfaceCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	struct wl_display* display;
	struct wl_surface* surface;
}]],
	mod.VkStructureType,
	mod.VkWaylandSurfaceCreateFlagsKHR
)
ffi.metatype(
	mod.VkWaylandSurfaceCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkWaylandSurfaceCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.display, t.surface)
		end,
	}
)
mod.PFN_vkCreateWaylandSurfaceKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkWaylandSurfaceCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR = ffi.typeof([[$ (*)($ , uint32_t , struct wl_display*)]], mod.VkBool32, mod.VkPhysicalDevice)
ffi.cdef(
	[[$  vkCreateWaylandSurfaceKHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkWaylandSurfaceCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceWaylandPresentationSupportKHR($ , uint32_t , struct wl_display*);]],
	mod.VkBool32,
	mod.VkPhysicalDevice
)
mod.VkXlibSurfaceCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkXlibSurfaceCreateInfoKHR = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$* dpy;
	$ window;
}]],
	mod.VkStructureType,
	mod.VkXlibSurfaceCreateFlagsKHR,
	mod.Display,
	mod.Window
)
ffi.metatype(
	mod.VkXlibSurfaceCreateInfoKHR,
	{
		__tostring = function(s)
			return ("struct VkXlibSurfaceCreateInfoKHR[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.dpy, t.window)
		end,
	}
)
mod.PFN_vkCreateXlibSurfaceKHR = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkXlibSurfaceCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR = ffi.typeof(
	[[$ (*)($ , uint32_t , $*, $ )]],
	mod.VkBool32,
	mod.VkPhysicalDevice,
	mod.Display,
	mod.VisualID
)
ffi.cdef(
	[[$  vkCreateXlibSurfaceKHR($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkXlibSurfaceCreateInfoKHR,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceXlibPresentationSupportKHR($ , uint32_t , $*, $ );]],
	mod.VkBool32,
	mod.VkPhysicalDevice,
	mod.Display,
	mod.VisualID
)
mod.VkDirectFBSurfaceCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDirectFBSurfaceCreateInfoEXT = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$* dfb;
	$* surface;
}]],
	mod.VkStructureType,
	mod.VkDirectFBSurfaceCreateFlagsEXT,
	mod.IDirectFB,
	mod.IDirectFBSurface
)
ffi.metatype(
	mod.VkDirectFBSurfaceCreateInfoEXT,
	{
		__tostring = function(s)
			return ("struct VkDirectFBSurfaceCreateInfoEXT[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.dfb, t.surface)
		end,
	}
)
mod.PFN_vkCreateDirectFBSurfaceEXT = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkDirectFBSurfaceCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT = ffi.typeof([[$ (*)($ , uint32_t , $*)]], mod.VkBool32, mod.VkPhysicalDevice, mod.IDirectFB)
ffi.cdef(
	[[$  vkCreateDirectFBSurfaceEXT($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkDirectFBSurfaceCreateInfoEXT,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceDirectFBPresentationSupportEXT($ , uint32_t , $*);]],
	mod.VkBool32,
	mod.VkPhysicalDevice,
	mod.IDirectFB
)
mod.VkStreamDescriptorSurfaceCreateFlagsGGP = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkStreamDescriptorSurfaceCreateInfoGGP = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ streamDescriptor;
}]],
	mod.VkStructureType,
	mod.VkStreamDescriptorSurfaceCreateFlagsGGP,
	mod.GgpStreamDescriptor
)
ffi.metatype(
	mod.VkStreamDescriptorSurfaceCreateInfoGGP,
	{
		__tostring = function(s)
			return ("struct VkStreamDescriptorSurfaceCreateInfoGGP[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.streamDescriptor)
		end,
	}
)
mod.PFN_vkCreateStreamDescriptorSurfaceGGP = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkStreamDescriptorSurfaceCreateInfoGGP,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkCreateStreamDescriptorSurfaceGGP($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkStreamDescriptorSurfaceCreateInfoGGP,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.VkPresentFrameTokenGGP = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ frameToken;
}]],
	mod.VkStructureType,
	mod.GgpFrameToken
)
ffi.metatype(
	mod.VkPresentFrameTokenGGP,
	{
		__tostring = function(s)
			return ("struct VkPresentFrameTokenGGP[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.frameToken)
		end,
	}
)
mod.VkScreenSurfaceCreateFlagsQNX = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkScreenSurfaceCreateInfoQNX = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	$ flags;
	struct _screen_context* context;
	struct _screen_window* window;
}]],
	mod.VkStructureType,
	mod.VkScreenSurfaceCreateFlagsQNX
)
ffi.metatype(
	mod.VkScreenSurfaceCreateInfoQNX,
	{
		__tostring = function(s)
			return ("struct VkScreenSurfaceCreateInfoQNX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.flags, t.context, t.window)
		end,
	}
)
mod.PFN_vkCreateScreenSurfaceQNX = ffi.typeof(
	[[$ (*)($ , const $*, const $*, $*)]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkScreenSurfaceCreateInfoQNX,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
mod.PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX = ffi.typeof(
	[[$ (*)($ , uint32_t , struct _screen_window*)]],
	mod.VkBool32,
	mod.VkPhysicalDevice
)
ffi.cdef(
	[[$  vkCreateScreenSurfaceQNX($ , const $*, const $*, $*);]],
	mod.VkResult,
	mod.VkInstance,
	mod.VkScreenSurfaceCreateInfoQNX,
	mod.VkAllocationCallbacks,
	mod.VkSurfaceKHR
)
ffi.cdef(
	[[$  vkGetPhysicalDeviceScreenPresentationSupportQNX($ , uint32_t , struct _screen_window*);]],
	mod.VkBool32,
	mod.VkPhysicalDevice
)
mod.VkScreenBufferPropertiesQNX = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ allocationSize;
	uint32_t memoryTypeBits;
}]],
	mod.VkStructureType,
	mod.VkDeviceSize
)
ffi.metatype(
	mod.VkScreenBufferPropertiesQNX,
	{
		__tostring = function(s)
			return ("struct VkScreenBufferPropertiesQNX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.allocationSize, t.memoryTypeBits)
		end,
	}
)
mod.VkScreenBufferFormatPropertiesQNX = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ format;
	uint64_t externalFormat;
	uint64_t screenUsage;
	$ formatFeatures;
	$ samplerYcbcrConversionComponents;
	$ suggestedYcbcrModel;
	$ suggestedYcbcrRange;
	$ suggestedXChromaOffset;
	$ suggestedYChromaOffset;
}]],
	mod.VkStructureType,
	mod.VkFormat,
	mod.VkFormatFeatureFlags,
	mod.VkComponentMapping,
	mod.VkSamplerYcbcrModelConversion,
	mod.VkSamplerYcbcrRange,
	mod.VkChromaLocation,
	mod.VkChromaLocation
)
ffi.metatype(
	mod.VkScreenBufferFormatPropertiesQNX,
	{
		__tostring = function(s)
			return ("struct VkScreenBufferFormatPropertiesQNX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(
				T,
				t.sType,
				t.pNext,
				t.format,
				t.externalFormat,
				t.screenUsage,
				t.formatFeatures,
				t.samplerYcbcrConversionComponents,
				t.suggestedYcbcrModel,
				t.suggestedYcbcrRange,
				t.suggestedXChromaOffset,
				t.suggestedYChromaOffset
			)
		end,
	}
)
mod.VkImportScreenBufferInfoQNX = ffi.typeof(
	[[struct {
	$ sType;
	const void* pNext;
	struct _screen_buffer* buffer;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkImportScreenBufferInfoQNX,
	{
		__tostring = function(s)
			return ("struct VkImportScreenBufferInfoQNX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.buffer)
		end,
	}
)
mod.VkExternalFormatQNX = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	uint64_t externalFormat;
}]],
	mod.VkStructureType
)
ffi.metatype(
	mod.VkExternalFormatQNX,
	{
		__tostring = function(s)
			return ("struct VkExternalFormatQNX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.externalFormat)
		end,
	}
)
mod.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX = ffi.typeof(
	[[struct {
	$ sType;
	void* pNext;
	$ screenBufferImport;
}]],
	mod.VkStructureType,
	mod.VkBool32
)
ffi.metatype(
	mod.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX,
	{
		__tostring = function(s)
			return ("struct VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX[%p]"):format(s)
		end,
		__new = function(T, t)
			if not t then return N(T) end

			return N(T, t.sType, t.pNext, t.screenBufferImport)
		end,
	}
)
mod.PFN_vkGetScreenBufferPropertiesQNX = ffi.typeof(
	[[$ (*)($ , const struct _screen_buffer*, $*)]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkScreenBufferPropertiesQNX
)
ffi.cdef(
	[[$  vkGetScreenBufferPropertiesQNX($ , const struct _screen_buffer*, $*);]],
	mod.VkResult,
	mod.VkDevice,
	mod.VkScreenBufferPropertiesQNX
)
-- Enum lookup tables for string -> value translation
mod.e = {}

local function combine_flags(lookup, values, enum_name)
	local result = 0

	for _, v in ipairs(values) do
		if type(v) == "number" then
			result = bit.bor(result, v)
		else
			local val = lookup[v]

			if not val then
				error("unknown " .. enum_name .. " value: " .. tostring(v) .. " (must be lowercase)")
			end

			result = bit.bor(result, val)
		end
	end

	return result
end

mod.e.VkLayerSettingTypeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["string_ext"] = mod.VkLayerSettingTypeEXT("VK_LAYER_SETTING_TYPE_STRING_EXT"),
		["uint32_ext"] = mod.VkLayerSettingTypeEXT("VK_LAYER_SETTING_TYPE_UINT32_EXT"),
		["float64_ext"] = mod.VkLayerSettingTypeEXT("VK_LAYER_SETTING_TYPE_FLOAT64_EXT"),
		["bool32_ext"] = mod.VkLayerSettingTypeEXT("VK_LAYER_SETTING_TYPE_BOOL32_EXT"),
		["float32_ext"] = mod.VkLayerSettingTypeEXT("VK_LAYER_SETTING_TYPE_FLOAT32_EXT"),
		["int32_ext"] = mod.VkLayerSettingTypeEXT("VK_LAYER_SETTING_TYPE_INT32_EXT"),
		["uint64_ext"] = mod.VkLayerSettingTypeEXT("VK_LAYER_SETTING_TYPE_UINT64_EXT"),
		["int64_ext"] = mod.VkLayerSettingTypeEXT("VK_LAYER_SETTING_TYPE_INT64_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkLayerSettingTypeEXT")
	end

	return lookup[s] or
		error("unknown VkLayerSettingTypeEXT value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkStructureType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["device_buffer_memory_requirements_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR"),
		["subpass_begin_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO"),
		["device_image_memory_requirements_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR"),
		["subpass_end_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_END_INFO"),
		["physical_device_shader_subgroup_rotate_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR"),
		["physical_device_8bit_storage_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"),
		["physical_device_depth_clamp_zero_one_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT"),
		["physical_device_driver_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"),
		["physical_device_fragment_density_map_offset_features_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM"),
		["physical_device_shader_atomic_int64_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"),
		["physical_device_fragment_density_map_offset_properties_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM"),
		["physical_device_shader_float16_int8_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"),
		["subpass_fragment_density_map_offset_end_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM"),
		["physical_device_float_controls_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"),
		["physical_device_copy_memory_indirect_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV"),
		["descriptor_set_layout_binding_flags_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"),
		["physical_device_pipeline_protected_access_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT"),
		["physical_device_descriptor_indexing_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"),
		["physical_device_maintenance_5_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR"),
		["physical_device_descriptor_indexing_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"),
		["physical_device_maintenance_5_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR"),
		["descriptor_set_variable_descriptor_count_allocate_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"),
		["rendering_area_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR"),
		["descriptor_set_variable_descriptor_count_layout_support"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"),
		["memory_opaque_capture_address_allocate_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR"),
		["physical_device_depth_stencil_resolve_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"),
		["device_memory_opaque_capture_address_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR"),
		["subpass_description_depth_stencil_resolve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"),
		["physical_device_line_rasterization_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT"),
		["physical_device_scalar_block_layout_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"),
		["pipeline_rasterization_line_state_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT"),
		["image_stencil_usage_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO"),
		["physical_device_line_rasterization_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT"),
		["physical_device_sampler_filter_minmax_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"),
		["physical_device_host_query_reset_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT"),
		["sampler_reduction_mode_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO"),
		["physical_device_index_type_uint8_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT"),
		["physical_device_vulkan_memory_model_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"),
		["physical_device_host_image_copy_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT"),
		["physical_device_imageless_framebuffer_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"),
		["physical_device_host_image_copy_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT"),
		["framebuffer_attachments_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"),
		["memory_to_image_copy_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT"),
		["framebuffer_attachment_image_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"),
		["image_to_memory_copy_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT"),
		["render_pass_attachment_begin_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO"),
		["copy_image_to_memory_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT"),
		["physical_device_uniform_buffer_standard_layout_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"),
		["physical_device_optical_flow_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV"),
		["physical_device_shader_subgroup_extended_types_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"),
		["physical_device_optical_flow_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV"),
		["physical_device_separate_depth_stencil_layouts_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"),
		["optical_flow_image_format_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV"),
		["attachment_reference_stencil_layout"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT"),
		["optical_flow_image_format_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV"),
		["attachment_description_stencil_layout"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"),
		["optical_flow_session_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV"),
		["physical_device_host_query_reset_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"),
		["optical_flow_execute_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV"),
		["physical_device_timeline_semaphore_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"),
		["optical_flow_session_create_private_data_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV"),
		["physical_device_timeline_semaphore_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"),
		["physical_device_legacy_dithering_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT"),
		["semaphore_type_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO"),
		["physical_device_external_format_resolve_features_android"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID"),
		["timeline_semaphore_submit_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO"),
		["physical_device_external_format_resolve_properties_android"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID"),
		["semaphore_wait_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO"),
		["android_hardware_buffer_format_resolve_properties_android"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID"),
		["semaphore_signal_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO"),
		["physical_device_anti_lag_features_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD"),
		["physical_device_buffer_device_address_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"),
		["anti_lag_data_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD"),
		["buffer_device_address_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"),
		["anti_lag_presentation_info_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD"),
		["buffer_opaque_capture_address_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"),
		["surface_capabilities_present_id_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR"),
		["memory_opaque_capture_address_allocate_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"),
		["present_id_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR"),
		["device_memory_opaque_capture_address_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"),
		["physical_device_present_id_2_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR"),
		["physical_device_vulkan_1_3_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES"),
		["surface_capabilities_present_wait_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR"),
		["physical_device_vulkan_1_3_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES"),
		["physical_device_present_wait_2_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR"),
		["pipeline_creation_feedback_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO"),
		["present_wait_2_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR"),
		["physical_device_shader_terminate_invocation_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES"),
		["physical_device_ray_tracing_position_fetch_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR"),
		["physical_device_tool_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES"),
		["physical_device_shader_object_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT"),
		["physical_device_shader_demote_to_helper_invocation_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES"),
		["physical_device_shader_object_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT"),
		["physical_device_private_data_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES"),
		["shader_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT"),
		["device_private_data_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO"),
		["physical_device_pipeline_binary_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR"),
		["private_data_slot_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO"),
		["pipeline_binary_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR"),
		["physical_device_pipeline_creation_cache_control_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES"),
		["pipeline_binary_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR"),
		["memory_barrier_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_BARRIER_2"),
		["pipeline_binary_key_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR"),
		["buffer_memory_barrier_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2"),
		["physical_device_pipeline_binary_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR"),
		["image_memory_barrier_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2"),
		["release_captured_pipeline_data_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR"),
		["dependency_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEPENDENCY_INFO"),
		["pipeline_binary_data_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR"),
		["submit_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBMIT_INFO_2"),
		["pipeline_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR"),
		["semaphore_submit_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO"),
		["device_pipeline_binary_internal_cache_control_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR"),
		["command_buffer_submit_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO"),
		["pipeline_binary_handles_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR"),
		["physical_device_synchronization_2_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES"),
		["physical_device_tile_properties_features_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM"),
		["physical_device_zero_initialize_workgroup_memory_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES"),
		["tile_properties_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM"),
		["physical_device_image_robustness_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES"),
		["physical_device_amigo_profiling_features_sec"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC"),
		["copy_buffer_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2"),
		["amigo_profiling_submit_info_sec"] = mod.VkStructureType("VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC"),
		["copy_image_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2"),
		["surface_present_mode_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR"),
		["copy_buffer_to_image_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2"),
		["surface_present_scaling_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR"),
		["copy_image_to_buffer_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2"),
		["surface_present_mode_compatibility_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR"),
		["blit_image_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2"),
		["physical_device_swapchain_maintenance_1_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR"),
		["resolve_image_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2"),
		["swapchain_present_fence_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR"),
		["buffer_copy_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_COPY_2"),
		["swapchain_present_modes_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR"),
		["image_copy_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_COPY_2"),
		["swapchain_present_mode_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR"),
		["image_blit_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_BLIT_2"),
		["swapchain_present_scaling_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR"),
		["buffer_image_copy_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2"),
		["release_swapchain_images_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR"),
		["image_resolve_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2"),
		["physical_device_multiview_per_view_viewports_features_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM"),
		["physical_device_subgroup_size_control_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES"),
		["physical_device_ray_tracing_invocation_reorder_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV"),
		["pipeline_shader_stage_required_subgroup_size_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO"),
		["physical_device_ray_tracing_invocation_reorder_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV"),
		["physical_device_subgroup_size_control_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES"),
		["physical_device_cooperative_vector_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV"),
		["physical_device_inline_uniform_block_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES"),
		["physical_device_cooperative_vector_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV"),
		["physical_device_inline_uniform_block_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES"),
		["cooperative_vector_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV"),
		["write_descriptor_set_inline_uniform_block"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK"),
		["convert_cooperative_vector_matrix_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV"),
		["descriptor_pool_inline_uniform_block_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO"),
		["physical_device_extended_sparse_address_space_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV"),
		["physical_device_texture_compression_astc_hdr_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES"),
		["physical_device_extended_sparse_address_space_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV"),
		["rendering_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_INFO"),
		["physical_device_mutable_descriptor_type_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT"),
		["rendering_attachment_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO"),
		["mutable_descriptor_type_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT"),
		["pipeline_rendering_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO"),
		["physical_device_legacy_vertex_attributes_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT"),
		["physical_device_dynamic_rendering_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES"),
		["physical_device_legacy_vertex_attributes_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT"),
		["command_buffer_inheritance_rendering_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO"),
		["layer_settings_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT"),
		["physical_device_shader_integer_dot_product_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"),
		["physical_device_shader_core_builtins_features_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM"),
		["physical_device_shader_integer_dot_product_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES"),
		["physical_device_shader_core_builtins_properties_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM"),
		["physical_device_texel_buffer_alignment_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES"),
		["physical_device_pipeline_library_group_handles_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT"),
		["format_properties_3"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3"),
		["physical_device_dynamic_rendering_unused_attachments_features_ext"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT"
		),
		["display_native_hdr_surface_capabilities_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"),
		["latency_sleep_mode_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV"),
		["swapchain_display_native_hdr_create_info_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"),
		["latency_sleep_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV"),
		["imagepipe_surface_create_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"),
		["set_latency_marker_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV"),
		["metal_surface_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT"),
		["get_latency_marker_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV"),
		["physical_device_fragment_density_map_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"),
		["latency_timings_frame_report_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV"),
		["physical_device_fragment_density_map_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"),
		["latency_submission_present_id_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV"),
		["render_pass_fragment_density_map_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"),
		["out_of_band_queue_type_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV"),
		["rendering_fragment_density_map_attachment_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT"),
		["swapchain_latency_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV"),
		["fragment_shading_rate_attachment_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"),
		["latency_surface_capabilities_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV"),
		["pipeline_fragment_shading_rate_state_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR"),
		["physical_device_cooperative_matrix_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR"),
		["physical_device_fragment_shading_rate_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR"),
		["cooperative_matrix_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR"),
		["physical_device_fragment_shading_rate_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR"),
		["physical_device_cooperative_matrix_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR"),
		["data_graph_pipeline_create_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM"),
		["data_graph_pipeline_session_create_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM"),
		["data_graph_pipeline_resource_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM"),
		["import_fence_fd_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"),
		["data_graph_pipeline_constant_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM"),
		["fence_get_fd_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"),
		["data_graph_pipeline_session_memory_requirements_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM"),
		["physical_device_performance_query_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR"),
		["bind_data_graph_pipeline_session_memory_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM"),
		["physical_device_performance_query_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR"),
		["physical_device_data_graph_features_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM"),
		["query_pool_performance_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR"),
		["data_graph_pipeline_shader_module_create_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM"),
		["performance_query_submit_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR"),
		["data_graph_pipeline_property_query_result_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM"),
		["acquire_profiling_lock_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR"),
		["data_graph_pipeline_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM"),
		["performance_counter_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR"),
		["data_graph_pipeline_compiler_control_create_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM"),
		["performance_counter_description_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR"),
		["data_graph_pipeline_session_bind_point_requirements_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM"),
		["physical_device_surface_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"),
		["data_graph_pipeline_session_bind_point_requirement_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM"),
		["surface_capabilities_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"),
		["data_graph_pipeline_identifier_create_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM"),
		["surface_format_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"),
		["data_graph_pipeline_dispatch_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM"),
		["display_properties_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR"),
		["data_graph_processing_engine_create_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM"),
		["display_plane_properties_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR"),
		["queue_family_data_graph_processing_engine_properties_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM"),
		["display_mode_properties_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR"),
		["queue_family_data_graph_properties_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM"),
		["display_plane_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR"),
		["physical_device_queue_family_data_graph_processing_engine_info_arm"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM"
		),
		["display_plane_capabilities_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR"),
		["data_graph_pipeline_constant_tensor_semi_structured_sparsity_info_arm"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM"
		),
		["ios_surface_create_info_mvk"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"),
		["physical_device_multiview_per_view_render_areas_features_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM"),
		["macos_surface_create_info_mvk"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"),
		["multiview_per_view_render_areas_render_pass_begin_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM"),
		["debug_utils_object_name_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"),
		["physical_device_compute_shader_derivatives_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR"),
		["debug_utils_object_tag_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"),
		["physical_device_compute_shader_derivatives_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR"),
		["debug_utils_label_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"),
		["video_decode_av1_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR"),
		["debug_utils_messenger_callback_data_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"),
		["video_decode_av1_picture_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR"),
		["debug_utils_messenger_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"),
		["video_decode_av1_profile_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR"),
		["android_hardware_buffer_usage_android"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"),
		["video_decode_av1_session_parameters_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR"),
		["android_hardware_buffer_properties_android"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"),
		["video_decode_av1_dpb_slot_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR"),
		["android_hardware_buffer_format_properties_android"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"),
		["video_encode_av1_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR"),
		["import_android_hardware_buffer_info_android"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"),
		["video_encode_av1_session_parameters_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR"),
		["memory_get_android_hardware_buffer_info_android"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"),
		["video_encode_av1_picture_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR"),
		["external_format_android"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"),
		["video_encode_av1_dpb_slot_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR"),
		["android_hardware_buffer_format_properties_2_android"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID"),
		["physical_device_video_encode_av1_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR"),
		["attachment_sample_count_info_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD"),
		["video_encode_av1_profile_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR"),
		["physical_device_shader_bfloat16_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR"),
		["video_encode_av1_rate_control_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR"),
		["sample_locations_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"),
		["video_encode_av1_rate_control_layer_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR"),
		["render_pass_sample_locations_begin_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"),
		["video_encode_av1_quality_level_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR"),
		["pipeline_sample_locations_state_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"),
		["video_encode_av1_session_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR"),
		["physical_device_sample_locations_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"),
		["pipeline_vertex_input_divisor_state_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"),
		["multisample_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"),
		["physical_device_vertex_attribute_divisor_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT"),
		["physical_device_blend_operation_advanced_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"),
		["pipeline_creation_feedback_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT"),
		["physical_device_blend_operation_advanced_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"),
		["physical_device_driver_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR"),
		["pipeline_color_blend_advanced_state_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"),
		["physical_device_float_controls_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR"),
		["pipeline_coverage_to_color_state_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"),
		["physical_device_depth_stencil_resolve_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR"),
		["write_descriptor_set_acceleration_structure_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR"),
		["subpass_description_depth_stencil_resolve_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR"),
		["acceleration_structure_build_geometry_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR"),
		["physical_device_compute_shader_derivatives_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV"),
		["acceleration_structure_device_address_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR"),
		["physical_device_fragment_shader_barycentric_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV"),
		["acceleration_structure_geometry_aabbs_data_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR"),
		["physical_device_timeline_semaphore_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR"),
		["acceleration_structure_geometry_instances_data_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR"),
		["physical_device_timeline_semaphore_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR"),
		["acceleration_structure_geometry_triangles_data_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR"),
		["semaphore_type_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR"),
		["acceleration_structure_geometry_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR"),
		["timeline_semaphore_submit_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR"),
		["acceleration_structure_version_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR"),
		["semaphore_wait_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR"),
		["copy_acceleration_structure_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR"),
		["semaphore_signal_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR"),
		["copy_acceleration_structure_to_memory_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR"),
		["query_pool_create_info_intel"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL"),
		["copy_memory_to_acceleration_structure_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR"),
		["physical_device_acceleration_structure_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR"),
		["physical_device_acceleration_structure_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR"),
		["acceleration_structure_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR"),
		["acceleration_structure_build_sizes_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR"),
		["physical_device_ray_tracing_pipeline_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR"),
		["physical_device_ray_tracing_pipeline_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR"),
		["ray_tracing_pipeline_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR"),
		["ray_tracing_shader_group_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR"),
		["ray_tracing_pipeline_interface_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR"),
		["physical_device_ray_query_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR"),
		["pipeline_coverage_modulation_state_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"),
		["physical_device_shader_sm_builtins_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"),
		["physical_device_shader_sm_builtins_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"),
		["drm_format_modifier_properties_list_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"),
		["physical_device_image_drm_format_modifier_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"),
		["image_drm_format_modifier_list_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"),
		["image_drm_format_modifier_explicit_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"),
		["image_drm_format_modifier_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"),
		["drm_format_modifier_properties_list_2_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT"),
		["validation_cache_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"),
		["shader_module_validation_cache_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"),
		["pipeline_viewport_shading_rate_image_state_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"),
		["physical_device_shading_rate_image_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"),
		["physical_device_shading_rate_image_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"),
		["pipeline_viewport_coarse_sample_order_state_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"),
		["ray_tracing_pipeline_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV"),
		["acceleration_structure_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV"),
		["geometry_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GEOMETRY_NV"),
		["geometry_triangles_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV"),
		["geometry_aabb_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV"),
		["bind_acceleration_structure_memory_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"),
		["write_descriptor_set_acceleration_structure_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"),
		["acceleration_structure_memory_requirements_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"),
		["physical_device_ray_tracing_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"),
		["ray_tracing_shader_group_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"),
		["acceleration_structure_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV"),
		["physical_device_representative_fragment_test_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"),
		["pipeline_representative_fragment_test_state_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"),
		["physical_device_image_view_image_format_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"),
		["filter_cubic_image_view_image_format_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"),
		["import_memory_host_pointer_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"),
		["memory_host_pointer_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"),
		["physical_device_external_memory_host_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"),
		["physical_device_shader_clock_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR"),
		["pipeline_compiler_control_create_info_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD"),
		["physical_device_shader_core_properties_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"),
		["video_decode_h265_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR"),
		["video_decode_h265_session_parameters_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR"),
		["video_decode_h265_session_parameters_add_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR"),
		["video_decode_h265_profile_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR"),
		["video_decode_h265_picture_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR"),
		["video_decode_h265_dpb_slot_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR"),
		["device_memory_overallocation_create_info_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"),
		["physical_device_vertex_attribute_divisor_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"),
		["command_buffer_begin_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"),
		["render_pass_begin_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"),
		["buffer_memory_barrier"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"),
		["image_memory_barrier"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"),
		["memory_barrier"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_BARRIER"),
		["loader_instance_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"),
		["loader_device_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"),
		["physical_device_subgroup_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"),
		["bind_buffer_memory_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"),
		["bind_image_memory_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"),
		["physical_device_16bit_storage_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"),
		["memory_dedicated_requirements"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"),
		["memory_dedicated_allocate_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"),
		["memory_allocate_flags_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"),
		["device_group_render_pass_begin_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"),
		["device_group_command_buffer_begin_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"),
		["device_group_submit_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"),
		["device_group_bind_sparse_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"),
		["bind_buffer_memory_device_group_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"),
		["bind_image_memory_device_group_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"),
		["physical_device_group_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"),
		["device_group_device_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"),
		["buffer_memory_requirements_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"),
		["image_memory_requirements_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"),
		["image_sparse_memory_requirements_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"),
		["memory_requirements_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"),
		["sparse_image_memory_requirements_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"),
		["physical_device_features_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"),
		["physical_device_properties_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"),
		["format_properties_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"),
		["image_format_properties_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"),
		["physical_device_image_format_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"),
		["queue_family_properties_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"),
		["physical_device_memory_properties_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"),
		["sparse_image_format_properties_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"),
		["physical_device_sparse_image_format_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"),
		["physical_device_point_clipping_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"),
		["render_pass_input_attachment_aspect_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"),
		["image_view_usage_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"),
		["pipeline_tessellation_domain_origin_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"),
		["render_pass_multiview_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"),
		["physical_device_multiview_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"),
		["physical_device_multiview_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"),
		["physical_device_variable_pointers_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"),
		["protected_submit_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"),
		["physical_device_protected_memory_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"),
		["physical_device_protected_memory_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"),
		["device_queue_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"),
		["sampler_ycbcr_conversion_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"),
		["sampler_ycbcr_conversion_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"),
		["bind_image_plane_memory_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"),
		["physical_device_maintenance_4_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES"),
		["physical_device_maintenance_4_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES"),
		["device_buffer_memory_requirements"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS"),
		["device_image_memory_requirements"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS"),
		["physical_device_vulkan_1_4_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES"),
		["physical_device_fragment_shading_rate_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR"),
		["device_queue_global_priority_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO"),
		["physical_device_shader_core_properties_2_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD"),
		["queue_family_global_priority_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES"),
		["physical_device_shader_image_atomic_int64_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT"),
		["physical_device_shader_float_controls_2_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES"),
		["physical_device_memory_budget_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"),
		["physical_device_line_rasterization_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES"),
		["memory_priority_allocate_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT"),
		["physical_device_line_rasterization_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES"),
		["physical_device_dedicated_allocation_image_aliasing_features_nv"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"
		),
		["pipeline_vertex_input_divisor_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO"),
		["buffer_device_address_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"),
		["physical_device_index_type_uint8_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES"),
		["physical_device_present_wait_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR"),
		["physical_device_cooperative_matrix_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"),
		["cooperative_matrix_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV"),
		["physical_device_cooperative_matrix_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"),
		["physical_device_coverage_reduction_mode_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"),
		["pipeline_coverage_reduction_state_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"),
		["framebuffer_mixed_samples_combination_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"),
		["physical_device_fragment_shader_interlock_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"),
		["physical_device_ycbcr_image_arrays_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"),
		["physical_device_provoking_vertex_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"),
		["pipeline_rasterization_provoking_vertex_state_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT"),
		["physical_device_provoking_vertex_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT"),
		["surface_full_screen_exclusive_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"),
		["surface_capabilities_full_screen_exclusive_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"),
		["surface_full_screen_exclusive_win32_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"),
		["headless_surface_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT"),
		["physical_device_shader_atomic_float_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT"),
		["physical_device_extended_dynamic_state_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT"),
		["physical_device_pipeline_executable_properties_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR"),
		["pipeline_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR"),
		["pipeline_executable_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR"),
		["pipeline_executable_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR"),
		["pipeline_executable_statistic_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR"),
		["pipeline_executable_internal_representation_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR"),
		["physical_device_map_memory_placed_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT"),
		["physical_device_map_memory_placed_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT"),
		["memory_map_placed_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT"),
		["physical_device_shader_atomic_float_2_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT"),
		["physical_device_device_generated_commands_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV"),
		["graphics_shader_group_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV"),
		["graphics_pipeline_shader_groups_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV"),
		["indirect_commands_layout_token_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV"),
		["indirect_commands_layout_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV"),
		["generated_commands_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV"),
		["generated_commands_memory_requirements_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV"),
		["physical_device_device_generated_commands_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV"),
		["physical_device_inherited_viewport_scissor_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV"),
		["command_buffer_inheritance_viewport_scissor_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV"),
		["physical_device_texel_buffer_alignment_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT"),
		["command_buffer_inheritance_render_pass_transform_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM"),
		["render_pass_transform_begin_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM"),
		["physical_device_depth_bias_control_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT"),
		["depth_bias_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT"),
		["depth_bias_representation_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT"),
		["physical_device_device_memory_report_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT"),
		["device_device_memory_report_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT"),
		["device_memory_report_callback_data_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT"),
		["sampler_custom_border_color_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT"),
		["physical_device_custom_border_color_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"),
		["physical_device_custom_border_color_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT"),
		["pipeline_library_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR"),
		["physical_device_present_barrier_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV"),
		["surface_capabilities_present_barrier_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV"),
		["swapchain_present_barrier_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV"),
		["present_id_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_ID_KHR"),
		["physical_device_present_id_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR"),
		["video_encode_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR"),
		["descriptor_get_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT"),
		["video_encode_rate_control_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR"),
		["buffer_capture_descriptor_data_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"),
		["video_encode_rate_control_layer_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR"),
		["image_capture_descriptor_data_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"),
		["video_encode_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR"),
		["image_view_capture_descriptor_data_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"),
		["video_encode_usage_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR"),
		["sampler_capture_descriptor_data_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"),
		["query_pool_video_encode_feedback_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR"),
		["opaque_capture_descriptor_data_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT"),
		["physical_device_video_encode_quality_level_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR"),
		["descriptor_buffer_binding_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT"),
		["video_encode_quality_level_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR"),
		["descriptor_buffer_binding_push_descriptor_buffer_handle_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT"),
		["video_encode_quality_level_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR"),
		["acceleration_structure_capture_descriptor_data_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"),
		["video_encode_session_parameters_get_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR"),
		["physical_device_graphics_pipeline_library_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT"),
		["video_encode_session_parameters_feedback_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"),
		["physical_device_graphics_pipeline_library_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT"),
		["physical_device_diagnostics_config_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV"),
		["graphics_pipeline_library_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT"),
		["device_diagnostics_config_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV"),
		["physical_device_shader_early_and_late_fragment_tests_features_amd"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD"
		),
		["physical_device_tile_shading_features_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM"),
		["physical_device_fragment_shader_barycentric_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR"),
		["physical_device_tile_shading_properties_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM"),
		["physical_device_fragment_shader_barycentric_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR"),
		["render_pass_tile_shading_create_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM"),
		["physical_device_shader_subgroup_uniform_control_flow_features_khr"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"
		),
		["per_tile_begin_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM"),
		["physical_device_fragment_shading_rate_enums_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV"),
		["per_tile_end_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM"),
		["physical_device_fragment_shading_rate_enums_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV"),
		["dispatch_tile_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM"),
		["pipeline_fragment_shading_rate_enum_state_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV"),
		["query_low_latency_support_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV"),
		["acceleration_structure_geometry_motion_triangles_data_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV"),
		["export_metal_object_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT"),
		["physical_device_ray_tracing_motion_blur_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV"),
		["export_metal_objects_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT"),
		["acceleration_structure_motion_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV"),
		["export_metal_device_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT"),
		["physical_device_mesh_shader_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT"),
		["export_metal_command_queue_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT"),
		["physical_device_mesh_shader_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT"),
		["export_metal_buffer_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT"),
		["physical_device_ycbcr_2_plane_444_formats_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT"),
		["import_metal_buffer_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT"),
		["physical_device_fragment_density_map_2_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT"),
		["export_metal_texture_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT"),
		["physical_device_fragment_density_map_2_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT"),
		["import_metal_texture_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT"),
		["copy_command_transform_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM"),
		["export_metal_io_surface_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT"),
		["physical_device_workgroup_memory_explicit_layout_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR"),
		["import_metal_io_surface_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT"),
		["physical_device_image_compression_control_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT"),
		["export_metal_shared_event_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT"),
		["image_compression_control_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT"),
		["import_metal_shared_event_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT"),
		["image_compression_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT"),
		["physical_device_descriptor_buffer_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT"),
		["physical_device_attachment_feedback_loop_layout_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT"),
		["physical_device_descriptor_buffer_density_map_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT"),
		["physical_device_4444_formats_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT"),
		["physical_device_descriptor_buffer_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT"),
		["physical_device_fault_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT"),
		["descriptor_address_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT"),
		["device_fault_counts_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT"),
		["device_fault_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT"),
		["physical_device_rgba10x6_formats_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT"),
		["directfb_surface_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT"),
		["physical_device_vertex_input_dynamic_state_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT"),
		["vertex_input_binding_description_2_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"),
		["vertex_input_attribute_description_2_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"),
		["graphics_pipeline_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"),
		["physical_device_address_binding_report_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT"),
		["device_address_binding_callback_data_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT"),
		["physical_device_depth_clip_control_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT"),
		["pipeline_viewport_depth_clip_control_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT"),
		["physical_device_primitive_topology_list_restart_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"),
		["import_memory_zircon_handle_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA"),
		["memory_zircon_handle_properties_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA"),
		["memory_get_zircon_handle_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA"),
		["import_semaphore_zircon_handle_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA"),
		["semaphore_get_zircon_handle_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA"),
		["buffer_collection_create_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA"),
		["import_memory_buffer_collection_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA"),
		["buffer_collection_image_create_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA"),
		["buffer_collection_properties_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA"),
		["buffer_constraints_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA"),
		["buffer_collection_buffer_create_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA"),
		["device_group_present_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"),
		["image_swapchain_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"),
		["bind_image_memory_swapchain_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"),
		["acquire_next_image_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"),
		["device_group_present_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"),
		["device_group_swapchain_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"),
		["display_mode_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"),
		["display_surface_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"),
		["display_present_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"),
		["xlib_surface_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"),
		["xcb_surface_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"),
		["wayland_surface_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"),
		["android_surface_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"),
		["win32_surface_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"),
		["debug_report_callback_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"),
		["pipeline_rasterization_state_rasterization_order_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"),
		["debug_marker_object_name_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"),
		["debug_marker_object_tag_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"),
		["debug_marker_marker_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"),
		["video_profile_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR"),
		["video_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR"),
		["video_picture_resource_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR"),
		["video_session_memory_requirements_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR"),
		["bind_video_session_memory_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR"),
		["video_session_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR"),
		["video_session_parameters_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR"),
		["video_session_parameters_update_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR"),
		["video_begin_coding_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR"),
		["video_end_coding_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR"),
		["video_coding_control_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR"),
		["video_reference_slot_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR"),
		["queue_family_video_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR"),
		["video_profile_list_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR"),
		["physical_device_video_format_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR"),
		["video_format_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR"),
		["queue_family_query_result_status_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR"),
		["video_decode_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR"),
		["video_decode_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR"),
		["video_decode_usage_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR"),
		["dedicated_allocation_image_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"),
		["dedicated_allocation_buffer_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"),
		["dedicated_allocation_memory_allocate_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"),
		["physical_device_transform_feedback_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"),
		["physical_device_transform_feedback_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"),
		["pipeline_rasterization_state_stream_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"),
		["cu_module_create_info_nvx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX"),
		["cu_function_create_info_nvx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX"),
		["cu_launch_info_nvx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX"),
		["cu_module_texturing_mode_create_info_nvx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX"),
		["image_view_handle_info_nvx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX"),
		["image_view_address_properties_nvx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX"),
		["video_encode_h264_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR"),
		["video_encode_h264_session_parameters_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR"),
		["video_encode_h264_session_parameters_add_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR"),
		["video_encode_h264_picture_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR"),
		["video_encode_h264_dpb_slot_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR"),
		["physical_device_maintenance_7_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR"),
		["video_encode_h264_nalu_slice_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR"),
		["physical_device_layered_api_properties_list_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR"),
		["video_encode_h264_gop_remaining_frame_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR"),
		["physical_device_layered_api_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR"),
		["video_encode_h264_profile_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR"),
		["physical_device_layered_api_vulkan_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR"),
		["video_encode_h264_rate_control_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR"),
		["physical_device_shader_atomic_float16_vector_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV"),
		["video_encode_h264_rate_control_layer_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR"),
		["physical_device_shader_replicated_composites_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT"),
		["video_encode_h264_session_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR"),
		["physical_device_shader_float8_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT"),
		["video_encode_h264_quality_level_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR"),
		["physical_device_ray_tracing_validation_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV"),
		["video_encode_h264_session_parameters_get_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR"),
		["physical_device_cluster_acceleration_structure_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV"),
		["video_encode_h264_session_parameters_feedback_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"),
		["physical_device_cluster_acceleration_structure_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV"),
		["video_encode_h265_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR"),
		["cluster_acceleration_structure_clusters_bottom_level_input_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV"),
		["video_encode_h265_session_parameters_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR"),
		["cluster_acceleration_structure_triangle_cluster_input_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV"),
		["video_encode_h265_session_parameters_add_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR"),
		["cluster_acceleration_structure_move_objects_input_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV"),
		["video_encode_h265_picture_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR"),
		["cluster_acceleration_structure_input_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV"),
		["video_encode_h265_dpb_slot_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR"),
		["cluster_acceleration_structure_commands_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV"),
		["video_encode_h265_nalu_slice_segment_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR"),
		["ray_tracing_pipeline_cluster_acceleration_structure_create_info_nv"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV"
		),
		["video_encode_h265_gop_remaining_frame_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR"),
		["physical_device_partitioned_acceleration_structure_features_nv"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV"
		),
		["video_encode_h265_profile_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR"),
		["physical_device_partitioned_acceleration_structure_properties_nv"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV"
		),
		["video_encode_h265_rate_control_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR"),
		["write_descriptor_set_partitioned_acceleration_structure_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV"),
		["video_encode_h265_rate_control_layer_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR"),
		["partitioned_acceleration_structure_instances_input_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV"),
		["video_encode_h265_session_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR"),
		["build_partitioned_acceleration_structure_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV"),
		["video_encode_h265_quality_level_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR"),
		["partitioned_acceleration_structure_flags_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV"),
		["video_encode_h265_session_parameters_get_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR"),
		["physical_device_device_generated_commands_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT"),
		["video_encode_h265_session_parameters_feedback_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"),
		["physical_device_device_generated_commands_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT"),
		["video_decode_h264_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR"),
		["generated_commands_memory_requirements_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT"),
		["video_decode_h264_picture_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR"),
		["indirect_execution_set_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT"),
		["video_decode_h264_profile_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR"),
		["generated_commands_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT"),
		["video_decode_h264_session_parameters_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR"),
		["indirect_commands_layout_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT"),
		["indirect_commands_layout_token_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT"),
		["write_indirect_execution_set_pipeline_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT"),
		["write_indirect_execution_set_shader_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT"),
		["video_encode_av1_gop_remaining_frame_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR"),
		["physical_device_video_decode_vp9_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR"),
		["video_decode_vp9_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR"),
		["video_decode_vp9_picture_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR"),
		["video_decode_vp9_profile_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR"),
		["physical_device_video_maintenance_1_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR"),
		["physical_device_depth_clamp_zero_one_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR"),
		["video_inline_query_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR"),
		["physical_device_vertex_attribute_robustness_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT"),
		["physical_device_per_stage_descriptor_set_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV"),
		["physical_device_format_pack_features_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM"),
		["physical_device_image_processing_2_features_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM"),
		["physical_device_fragment_density_map_layered_features_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE"),
		["physical_device_image_processing_2_properties_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM"),
		["video_decode_h264_session_parameters_add_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR"),
		["sampler_block_match_window_create_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM"),
		["video_decode_h264_dpb_slot_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR"),
		["sampler_cubic_weights_create_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM"),
		["texture_lod_gather_format_properties_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"),
		["physical_device_cubic_weights_features_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM"),
		["stream_descriptor_surface_create_info_ggp"] = mod.VkStructureType("VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP"),
		["blit_image_cubic_weights_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM"),
		["physical_device_corner_sampled_image_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"),
		["physical_device_ycbcr_degamma_features_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM"),
		["external_memory_image_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"),
		["sampler_ycbcr_conversion_ycbcr_degamma_create_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM"),
		["export_memory_allocate_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"),
		["physical_device_cubic_clamp_features_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM"),
		["import_memory_win32_handle_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
		["physical_device_attachment_feedback_loop_dynamic_state_features_ext"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT"
		),
		["export_memory_win32_handle_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
		["physical_device_unified_image_layouts_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR"),
		["win32_keyed_mutex_acquire_release_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"),
		["attachment_feedback_loop_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT"),
		["validation_flags_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"),
		["screen_buffer_properties_qnx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX"),
		["vi_surface_create_info_nn"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"),
		["screen_buffer_format_properties_qnx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX"),
		["image_view_astc_decode_mode_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT"),
		["import_screen_buffer_info_qnx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX"),
		["physical_device_astc_decode_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"),
		["external_format_qnx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX"),
		["import_memory_win32_handle_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
		["physical_device_external_memory_screen_buffer_features_qnx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX"),
		["export_memory_win32_handle_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
		["physical_device_layered_driver_properties_msft"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT"),
		["memory_win32_handle_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"),
		["calibrated_timestamp_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR"),
		["memory_get_win32_handle_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"),
		["set_descriptor_buffer_offsets_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT"),
		["import_memory_fd_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"),
		["bind_descriptor_buffer_embedded_samplers_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT"),
		["memory_fd_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"),
		["physical_device_descriptor_pool_overallocation_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV"),
		["memory_get_fd_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"),
		["physical_device_tile_memory_heap_features_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM"),
		["win32_keyed_mutex_acquire_release_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"),
		["physical_device_tile_memory_heap_properties_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM"),
		["import_semaphore_win32_handle_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
		["tile_memory_requirements_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM"),
		["export_semaphore_win32_handle_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
		["tile_memory_bind_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM"),
		["d3d12_fence_submit_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"),
		["tile_memory_size_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM"),
		["semaphore_get_win32_handle_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"),
		["physical_device_copy_memory_indirect_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR"),
		["import_semaphore_fd_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"),
		["physical_device_copy_memory_indirect_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR"),
		["semaphore_get_fd_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"),
		["copy_memory_indirect_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR"),
		["command_buffer_inheritance_conditional_rendering_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"),
		["copy_memory_to_image_indirect_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR"),
		["physical_device_conditional_rendering_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"),
		["display_surface_stereo_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV"),
		["conditional_rendering_begin_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT"),
		["display_mode_stereo_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV"),
		["present_regions_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"),
		["video_encode_intra_refresh_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR"),
		["pipeline_viewport_w_scaling_state_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"),
		["video_encode_session_intra_refresh_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR"),
		["surface_capabilities_2_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT"),
		["video_encode_intra_refresh_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR"),
		["display_power_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"),
		["video_reference_intra_refresh_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR"),
		["device_event_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"),
		["physical_device_video_encode_intra_refresh_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR"),
		["display_event_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"),
		["video_encode_quantization_map_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR"),
		["swapchain_counter_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"),
		["video_format_quantization_map_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR"),
		["present_times_info_google"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"),
		["video_encode_quantization_map_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR"),
		["physical_device_multiview_per_view_attributes_properties_nvx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"),
		["video_encode_quantization_map_session_parameters_create_info_khr"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR"
		),
		["multiview_per_view_attributes_info_nvx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX"),
		["physical_device_video_encode_quantization_map_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR"),
		["pipeline_viewport_swizzle_state_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"),
		["video_encode_h264_quantization_map_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR"),
		["physical_device_discard_rectangle_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"),
		["video_encode_h265_quantization_map_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR"),
		["pipeline_discard_rectangle_state_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"),
		["video_format_h265_quantization_map_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR"),
		["physical_device_conservative_rasterization_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"),
		["video_encode_av1_quantization_map_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR"),
		["pipeline_rasterization_conservative_state_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"),
		["video_format_av1_quantization_map_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR"),
		["physical_device_depth_clip_enable_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"),
		["physical_device_raw_access_chains_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV"),
		["pipeline_rasterization_depth_clip_state_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"),
		["external_compute_queue_device_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV"),
		["hdr_metadata_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_HDR_METADATA_EXT"),
		["external_compute_queue_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV"),
		["physical_device_relaxed_line_rasterization_features_img"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG"),
		["external_compute_queue_data_params_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV"),
		["shared_present_surface_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"),
		["physical_device_external_compute_queue_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV"),
		["import_fence_win32_handle_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
		["physical_device_shader_relaxed_extended_instruction_features_khr"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR"
		),
		["export_fence_win32_handle_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
		["physical_device_command_buffer_inheritance_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV"),
		["fence_get_win32_handle_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"),
		["physical_device_maintenance_7_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR"),
		["application_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_APPLICATION_INFO"),
		["instance_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"),
		["device_queue_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"),
		["device_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"),
		["submit_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBMIT_INFO"),
		["memory_allocate_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"),
		["mapped_memory_range"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"),
		["bind_sparse_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"),
		["fence_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"),
		["semaphore_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"),
		["event_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"),
		["query_pool_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"),
		["buffer_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"),
		["buffer_view_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"),
		["image_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"),
		["image_view_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"),
		["shader_module_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"),
		["pipeline_cache_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"),
		["memory_barrier_access_flags_3_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR"),
		["physical_device_image_alignment_control_features_mesa"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA"),
		["physical_device_image_alignment_control_properties_mesa"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA"),
		["image_alignment_control_create_info_mesa"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA"),
		["physical_device_depth_clamp_control_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT"),
		["pipeline_viewport_depth_clamp_control_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT"),
		["physical_device_maintenance_9_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR"),
		["physical_device_maintenance_9_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR"),
		["queue_family_ownership_transfer_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR"),
		["physical_device_video_maintenance_2_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR"),
		["video_decode_h264_inline_session_parameters_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR"),
		["video_decode_h265_inline_session_parameters_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR"),
		["video_decode_av1_inline_session_parameters_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR"),
		["physical_device_vertex_attribute_divisor_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR"),
		["pipeline_vertex_input_divisor_state_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR"),
		["physical_device_vertex_attribute_divisor_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR"),
		["shader_required_subgroup_size_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT"),
		["buffer_usage_flags_2_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR"),
		["pipeline_create_flags_2_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR"),
		["image_subresource_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR"),
		["subresource_layout_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR"),
		["device_image_subresource_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR"),
		["performance_stream_marker_info_intel"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL"),
		["physical_device_shader_integer_functions_2_features_intel"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL"),
		["checkpoint_data_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV"),
		["physical_device_mesh_shader_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"),
		["present_frame_token_ggp"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP"),
		["physical_device_drm_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT"),
		["physical_device_vulkan_1_4_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES"),
		["physical_device_global_priority_query_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES"),
		["pipeline_layout_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"),
		["physical_device_shader_subgroup_rotate_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES"),
		["compute_pipeline_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"),
		["physical_device_mesh_shader_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"),
		["physical_device_shader_expect_assume_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES"),
		["physical_device_shader_image_footprint_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"),
		["physical_device_exclusive_scissor_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"),
		["pipeline_rasterization_line_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO"),
		["queue_family_checkpoint_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"),
		["checkpoint_data_2_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV"),
		["physical_device_vertex_attribute_divisor_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES"),
		["query_pool_performance_query_create_info_intel"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL"),
		["performance_marker_info_intel"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL"),
		["physical_device_vertex_attribute_divisor_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES"),
		["performance_override_info_intel"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL"),
		["physical_device_pci_bus_info_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"),
		["physical_device_zero_initialize_workgroup_memory_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR"),
		["physical_device_synchronization_2_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR"),
		["command_buffer_submit_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR"),
		["semaphore_submit_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR"),
		["submit_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR"),
		["dependency_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR"),
		["image_memory_barrier_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR"),
		["buffer_memory_barrier_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR"),
		["memory_barrier_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR"),
		["physical_device_pipeline_creation_cache_control_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT"),
		["private_data_slot_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT"),
		["device_private_data_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT"),
		["physical_device_private_data_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT"),
		["physical_device_robustness_2_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT"),
		["physical_device_robustness_2_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT"),
		["physical_device_texel_buffer_alignment_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT"),
		["physical_device_shader_integer_dot_product_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR"),
		["physical_device_shader_integer_dot_product_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR"),
		["physical_device_shader_demote_to_helper_invocation_features_ext"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT"
		),
		["release_swapchain_images_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT"),
		["swapchain_present_scaling_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT"),
		["swapchain_present_mode_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT"),
		["swapchain_present_modes_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT"),
		["swapchain_present_fence_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT"),
		["physical_device_swapchain_maintenance_1_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT"),
		["surface_present_mode_compatibility_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT"),
		["surface_present_scaling_capabilities_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT"),
		["surface_present_mode_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT"),
		["memory_unmap_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR"),
		["memory_map_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR"),
		["host_image_copy_device_performance_query_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT"),
		["subresource_host_memcpy_size_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT"),
		["copy_image_to_image_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT"),
		["host_image_layout_transition_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT"),
		["copy_memory_to_image_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT"),
		["buffer_opaque_capture_address_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR"),
		["buffer_device_address_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR"),
		["physical_device_buffer_device_address_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR"),
		["physical_device_uniform_buffer_standard_layout_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR"),
		["image_stencil_usage_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT"),
		["physical_device_tool_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT"),
		["buffer_device_address_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT"),
		["physical_device_buffer_address_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT"),
		["attachment_description_stencil_layout_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR"),
		["attachment_reference_stencil_layout_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR"),
		["physical_device_separate_depth_stencil_layouts_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR"),
		["rendering_input_attachment_index_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR"),
		["rendering_attachment_location_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR"),
		["physical_device_dynamic_rendering_local_read_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR"),
		["physical_device_subgroup_size_control_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT"),
		["pipeline_shader_stage_required_subgroup_size_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT"),
		["physical_device_subgroup_size_control_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT"),
		["physical_device_scalar_block_layout_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT"),
		["physical_device_shader_terminate_invocation_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR"),
		["physical_device_vulkan_memory_model_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR"),
		["queue_family_global_priority_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR"),
		["physical_device_global_priority_query_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR"),
		["device_queue_global_priority_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR"),
		["calibrated_timestamp_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT"),
		["physical_device_shader_atomic_int64_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR"),
		["physical_device_8bit_storage_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR"),
		["physical_device_shader_subgroup_extended_types_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR"),
		["device_queue_global_priority_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT"),
		["descriptor_set_layout_support_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR"),
		["physical_device_maintenance_3_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR"),
		["descriptor_set_variable_descriptor_count_layout_support_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT"),
		["descriptor_set_variable_descriptor_count_allocate_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT"),
		["physical_device_descriptor_indexing_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT"),
		["physical_device_descriptor_indexing_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT"),
		["descriptor_set_layout_binding_flags_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT"),
		["bind_image_memory_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR"),
		["bind_buffer_memory_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR"),
		["sampler_ycbcr_conversion_image_format_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR"),
		["physical_device_sampler_ycbcr_conversion_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR"),
		["image_plane_memory_requirements_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR"),
		["bind_image_plane_memory_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR"),
		["sampler_ycbcr_conversion_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR"),
		["sampler_ycbcr_conversion_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR"),
		["attachment_sample_count_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV"),
		["image_format_list_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR"),
		["sparse_image_memory_requirements_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR"),
		["memory_requirements_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR"),
		["image_sparse_memory_requirements_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR"),
		["image_memory_requirements_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR"),
		["buffer_memory_requirements_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR"),
		["descriptor_pool_inline_uniform_block_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT"),
		["write_descriptor_set_inline_uniform_block_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT"),
		["physical_device_inline_uniform_block_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT"),
		["physical_device_inline_uniform_block_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT"),
		["sampler_reduction_mode_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT"),
		["physical_device_sampler_filter_minmax_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT"),
		["memory_dedicated_allocate_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR"),
		["memory_dedicated_requirements_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR"),
		["physical_device_variable_pointer_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR"),
		["physical_device_variable_pointers_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR"),
		["pipeline_tessellation_domain_origin_state_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR"),
		["image_view_usage_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR"),
		["image_constraints_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA"),
		["render_pass_input_attachment_aspect_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR"),
		["image_format_constraints_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA"),
		["physical_device_point_clipping_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR"),
		["sysmem_color_space_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA"),
		["export_fence_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR"),
		["buffer_collection_constraints_info_fuchsia"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA"),
		["external_fence_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR"),
		["subpass_shading_pipeline_create_info_huawei"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI"),
		["physical_device_external_fence_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR"),
		["physical_device_subpass_shading_features_huawei"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI"),
		["subpass_end_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR"),
		["physical_device_subpass_shading_properties_huawei"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI"),
		["subpass_begin_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR"),
		["physical_device_invocation_mask_features_huawei"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI"),
		["render_pass_create_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR"),
		["memory_get_remote_address_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV"),
		["subpass_dependency_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR"),
		["physical_device_external_memory_rdma_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV"),
		["subpass_description_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR"),
		["pipeline_properties_identifier_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT"),
		["attachment_reference_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR"),
		["physical_device_pipeline_properties_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT"),
		["attachment_description_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR"),
		["physical_device_frame_boundary_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT"),
		["render_pass_attachment_begin_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR"),
		["frame_boundary_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT"),
		["framebuffer_attachment_image_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR"),
		["physical_device_multisampled_render_to_single_sampled_features_ext"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT"
		),
		["framebuffer_attachments_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR"),
		["subpass_resolve_performance_query_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT"),
		["physical_device_imageless_framebuffer_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR"),
		["multisampled_render_to_single_sampled_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT"),
		["surface_capabilities2_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT"),
		["physical_device_extended_dynamic_state_2_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT"),
		["descriptor_update_template_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR"),
		["screen_surface_create_info_qnx"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX"),
		["physical_device_16bit_storage_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR"),
		["physical_device_color_write_enable_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT"),
		["physical_device_float16_int8_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR"),
		["pipeline_color_write_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT"),
		["physical_device_shader_float16_int8_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR"),
		["physical_device_primitives_generated_query_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT"),
		["physical_device_push_descriptor_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"),
		["physical_device_ray_tracing_maintenance_1_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR"),
		["export_semaphore_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR"),
		["physical_device_shader_untyped_pointers_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR"),
		["external_semaphore_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR"),
		["physical_device_video_encode_rgb_conversion_features_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE"),
		["physical_device_external_semaphore_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR"),
		["video_encode_rgb_conversion_capabilities_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE"),
		["export_memory_allocate_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR"),
		["video_encode_profile_rgb_conversion_info_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE"),
		["external_memory_image_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR"),
		["video_encode_session_rgb_conversion_create_info_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE"),
		["external_memory_buffer_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR"),
		["physical_device_image_view_min_lod_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT"),
		["physical_device_id_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR"),
		["image_view_min_lod_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT"),
		["external_buffer_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR"),
		["physical_device_multi_draw_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT"),
		["physical_device_external_buffer_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR"),
		["physical_device_multi_draw_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT"),
		["external_image_format_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR"),
		["physical_device_image_2d_view_of_3d_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT"),
		["physical_device_external_image_format_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR"),
		["physical_device_shader_tile_image_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT"),
		["device_group_device_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR"),
		["physical_device_shader_tile_image_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT"),
		["physical_device_group_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR"),
		["micromap_build_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT"),
		["physical_device_pipeline_robustness_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT"),
		["micromap_version_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT"),
		["physical_device_pipeline_robustness_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT"),
		["copy_micromap_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT"),
		["pipeline_robustness_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT"),
		["copy_micromap_to_memory_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT"),
		["physical_device_texture_compression_astc_hdr_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT"),
		["copy_memory_to_micromap_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT"),
		["bind_image_memory_device_group_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR"),
		["physical_device_opacity_micromap_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT"),
		["bind_buffer_memory_device_group_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR"),
		["physical_device_opacity_micromap_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT"),
		["device_group_bind_sparse_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR"),
		["micromap_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT"),
		["device_group_submit_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR"),
		["micromap_build_sizes_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT"),
		["device_group_command_buffer_begin_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR"),
		["acceleration_structure_triangles_opacity_micromap_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT"),
		["device_group_render_pass_begin_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR"),
		["physical_device_cluster_culling_shader_features_huawei"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI"),
		["memory_allocate_flags_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR"),
		["physical_device_cluster_culling_shader_properties_huawei"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI"),
		["physical_device_sparse_image_format_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR"),
		["physical_device_cluster_culling_shader_vrs_features_huawei"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI"),
		["sparse_image_format_properties_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR"),
		["physical_device_border_color_swizzle_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT"),
		["physical_device_memory_properties_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR"),
		["sampler_border_color_component_mapping_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT"),
		["queue_family_properties_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR"),
		["physical_device_pageable_device_local_memory_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT"),
		["physical_device_image_format_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR"),
		["physical_device_shader_core_properties_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM"),
		["image_format_properties_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR"),
		["device_queue_shader_core_control_create_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM"),
		["format_properties_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR"),
		["physical_device_scheduling_controls_features_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM"),
		["physical_device_properties_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR"),
		["physical_device_scheduling_controls_properties_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM"),
		["physical_device_features_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR"),
		["physical_device_image_sliced_view_of_3d_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT"),
		["physical_device_multiview_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR"),
		["image_view_sliced_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT"),
		["physical_device_multiview_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR"),
		["physical_device_descriptor_set_host_mapping_features_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE"),
		["render_pass_multiview_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR"),
		["descriptor_set_binding_reference_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE"),
		["command_buffer_inheritance_rendering_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR"),
		["descriptor_set_layout_host_mapping_info_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE"),
		["physical_device_dynamic_rendering_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR"),
		["physical_device_non_seamless_cube_map_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT"),
		["pipeline_rendering_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR"),
		["physical_device_render_pass_striped_features_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM"),
		["rendering_attachment_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR"),
		["physical_device_render_pass_striped_properties_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM"),
		["rendering_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_INFO_KHR"),
		["render_pass_stripe_begin_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM"),
		["debug_report_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT"),
		["render_pass_stripe_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM"),
		["physical_device_shader_draw_parameter_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES"),
		["render_pass_stripe_submit_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM"),
		["physical_device_variable_pointer_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES"),
		["physical_device_copy_memory_indirect_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV"),
		["physical_device_pipeline_cache_incremental_mode_features_sec"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC"),
		["physical_device_memory_decompression_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV"),
		["physical_device_present_mode_fifo_latest_ready_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR"),
		["physical_device_memory_decompression_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV"),
		["physical_device_zero_initialize_device_memory_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT"),
		["physical_device_device_generated_commands_compute_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV"),
		["rendering_end_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT"),
		["compute_pipeline_indirect_buffer_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV"),
		["render_pass_fragment_density_map_offset_end_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT"),
		["pipeline_indirect_device_address_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV"),
		["physical_device_fragment_density_map_offset_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT"),
		["physical_device_ray_tracing_linear_swept_spheres_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV"),
		["physical_device_fragment_density_map_offset_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT"),
		["acceleration_structure_geometry_linear_swept_spheres_data_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV"),
		["physical_device_robustness_2_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR"),
		["acceleration_structure_geometry_spheres_data_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV"),
		["physical_device_robustness_2_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR"),
		["physical_device_linear_color_attachment_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV"),
		["pipeline_fragment_density_map_layered_create_info_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE"),
		["physical_device_shader_maximal_reconvergence_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR"),
		["physical_device_fragment_density_map_layered_properties_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE"),
		["physical_device_image_compression_control_swapchain_features_ext"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT"
		),
		["memory_get_metal_handle_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT"),
		["physical_device_image_processing_features_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM"),
		["memory_metal_handle_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT"),
		["physical_device_image_processing_properties_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM"),
		["import_memory_metal_handle_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT"),
		["image_view_sample_weight_create_info_qcom"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM"),
		["physical_device_pipeline_opacity_micromap_features_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM"),
		["physical_device_nested_command_buffer_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT"),
		["physical_device_cooperative_matrix_2_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV"),
		["physical_device_nested_command_buffer_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT"),
		["cooperative_matrix_flexible_dimensions_properties_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV"),
		["external_memory_acquire_unmodified_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT"),
		["physical_device_cooperative_matrix_2_features_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV"),
		["physical_device_extended_dynamic_state_3_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT"),
		["hdr_vivid_dynamic_metadata_huawei"] = mod.VkStructureType("VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI"),
		["physical_device_extended_dynamic_state_3_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT"),
		["physical_device_hdr_vivid_features_huawei"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI"),
		["physical_device_subpass_merge_feedback_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT"),
		["surface_create_info_ohos"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS"),
		["render_pass_creation_control_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT"),
		["physical_device_shader_float_controls_2_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR"),
		["render_pass_creation_feedback_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT"),
		["physical_device_index_type_uint8_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR"),
		["render_pass_subpass_feedback_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT"),
		["physical_device_line_rasterization_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR"),
		["direct_driver_loading_info_lunarg"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG"),
		["pipeline_rasterization_line_state_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR"),
		["direct_driver_loading_list_lunarg"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG"),
		["physical_device_line_rasterization_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR"),
		["tensor_create_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM"),
		["physical_device_shader_expect_assume_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR"),
		["tensor_view_create_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM"),
		["physical_device_maintenance_6_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR"),
		["bind_tensor_memory_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM"),
		["physical_device_maintenance_6_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR"),
		["write_descriptor_set_tensor_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM"),
		["bind_memory_status_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR"),
		["physical_device_tensor_properties_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM"),
		["bind_descriptor_sets_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR"),
		["tensor_format_properties_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM"),
		["push_constants_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR"),
		["tensor_description_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM"),
		["push_descriptor_set_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR"),
		["tensor_memory_requirements_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM"),
		["push_descriptor_set_with_template_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR"),
		["tensor_memory_barrier_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM"),
		["physical_device_maintenance_8_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR"),
		["physical_device_tensor_features_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM"),
		["generated_commands_shader_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT"),
		["device_tensor_memory_requirements_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM"),
		["generated_commands_pipeline_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT"),
		["copy_tensor_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM"),
		["indirect_execution_set_shader_layout_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT"),
		["tensor_copy_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_COPY_ARM"),
		["indirect_execution_set_shader_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT"),
		["tensor_dependency_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM"),
		["indirect_execution_set_pipeline_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT"),
		["memory_dedicated_allocate_info_tensor_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM"),
		["physical_device_sampler_ycbcr_conversion_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"),
		["physical_device_external_tensor_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM"),
		["descriptor_update_template_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"),
		["external_tensor_properties_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM"),
		["physical_device_external_image_format_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"),
		["external_memory_tensor_create_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM"),
		["sampler_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"),
		["physical_device_descriptor_buffer_tensor_features_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM"),
		["descriptor_set_layout_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"),
		["physical_device_descriptor_buffer_tensor_properties_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM"),
		["descriptor_pool_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"),
		["descriptor_get_tensor_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM"),
		["descriptor_set_allocate_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"),
		["tensor_capture_descriptor_data_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM"),
		["write_descriptor_set"] = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"),
		["tensor_view_capture_descriptor_data_info_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM"),
		["copy_descriptor_set"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"),
		["frame_boundary_tensors_arm"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM"),
		["framebuffer_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"),
		["physical_device_shader_module_identifier_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT"),
		["render_pass_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"),
		["physical_device_shader_module_identifier_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT"),
		["command_pool_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"),
		["pipeline_shader_stage_module_identifier_create_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT"),
		["external_image_format_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"),
		["shader_module_identifier_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT"),
		["present_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"),
		["physical_device_rasterization_order_attachment_access_features_ext"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT"
		),
		["command_buffer_allocate_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"),
		["swapchain_create_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"),
		["physical_device_external_buffer_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"),
		["host_image_copy_device_performance_query"] = mod.VkStructureType("VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY"),
		["command_buffer_inheritance_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"),
		["subresource_host_memcpy_size"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE"),
		["copy_image_to_image_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO"),
		["host_image_layout_transition_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO"),
		["copy_memory_to_image_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO"),
		["copy_image_to_memory_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO"),
		["image_to_memory_copy"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY"),
		["memory_to_image_copy"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY"),
		["physical_device_host_image_copy_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES"),
		["physical_device_host_image_copy_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES"),
		["physical_device_pipeline_robustness_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES"),
		["physical_device_pipeline_robustness_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES"),
		["pipeline_robustness_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO"),
		["physical_device_pipeline_protected_access_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES"),
		["image_plane_memory_requirements_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"),
		["push_descriptor_set_with_template_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO"),
		["sampler_ycbcr_conversion_image_format_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"),
		["pipeline_dynamic_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"),
		["performance_configuration_acquire_info_intel"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"),
		["pipeline_color_blend_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"),
		["pipeline_depth_stencil_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"),
		["initialize_performance_api_info_intel"] = mod.VkStructureType("VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL"),
		["pipeline_multisample_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"),
		["pipeline_rasterization_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"),
		["queue_family_checkpoint_properties_2_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV"),
		["pipeline_viewport_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"),
		["pipeline_viewport_exclusive_scissor_state_create_info_nv"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"),
		["pipeline_tessellation_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"),
		["pipeline_input_assembly_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"),
		["pipeline_vertex_input_state_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"),
		["pipeline_shader_stage_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"),
		["push_descriptor_set_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO"),
		["push_constants_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO"),
		["bind_descriptor_sets_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO"),
		["bind_memory_status"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS"),
		["physical_device_maintenance_6_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES"),
		["physical_device_maintenance_6_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES"),
		["rendering_input_attachment_index_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO"),
		["rendering_attachment_location_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO"),
		["physical_device_dynamic_rendering_local_read_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES"),
		["physical_device_push_descriptor_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES"),
		["buffer_usage_flags_2_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO"),
		["pipeline_create_flags_2_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO"),
		["image_subresource_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2"),
		["validation_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT"),
		["subresource_layout_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2"),
		["physical_device_buffer_device_address_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"),
		["device_image_subresource_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO"),
		["surface_protected_capabilities_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR"),
		["rendering_area_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_AREA_INFO"),
		["physical_device_memory_priority_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"),
		["physical_device_maintenance_5_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES"),
		["physical_device_shader_quad_control_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR"),
		["physical_device_maintenance_5_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES"),
		["physical_device_coherent_memory_features_amd"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD"),
		["memory_unmap_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO"),
		["rendering_fragment_shading_rate_attachment_info_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"),
		["memory_map_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_MAP_INFO"),
		["physical_device_image_robustness_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT"),
		["external_buffer_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"),
		["copy_buffer_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR"),
		["physical_device_id_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"),
		["copy_image_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR"),
		["external_memory_buffer_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"),
		["copy_buffer_to_image_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR"),
		["external_memory_image_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"),
		["copy_image_to_buffer_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR"),
		["export_memory_allocate_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"),
		["blit_image_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR"),
		["physical_device_external_fence_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"),
		["resolve_image_info_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR"),
		["external_fence_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"),
		["buffer_copy_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR"),
		["export_fence_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"),
		["image_copy_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR"),
		["export_semaphore_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"),
		["image_blit_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR"),
		["physical_device_external_semaphore_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"),
		["buffer_image_copy_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR"),
		["external_semaphore_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"),
		["image_resolve_2_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR"),
		["physical_device_maintenance_3_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"),
		["subresource_layout_2_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT"),
		["descriptor_set_layout_support"] = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"),
		["image_subresource_2_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT"),
		["physical_device_shader_draw_parameters_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"),
		["physical_device_rasterization_order_attachment_access_features_arm"] = mod.VkStructureType(
			"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM"
		),
		["physical_device_vulkan_1_1_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"),
		["physical_device_mutable_descriptor_type_features_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE"),
		["physical_device_vulkan_1_1_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"),
		["mutable_descriptor_type_create_info_valve"] = mod.VkStructureType("VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE"),
		["physical_device_vulkan_1_2_features"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"),
		["format_properties_3_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR"),
		["physical_device_vulkan_1_2_properties"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"),
		["physical_device_present_mode_fifo_latest_ready_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT"),
		["image_format_list_create_info"] = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO"),
		["pipeline_info_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT"),
		["attachment_description_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2"),
		["physical_device_global_priority_query_features_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT"),
		["attachment_reference_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2"),
		["queue_family_global_priority_properties_ext"] = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT"),
		["subpass_description_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2"),
		["physical_device_maintenance_4_features_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR"),
		["subpass_dependency_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2"),
		["physical_device_maintenance_4_properties_khr"] = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR"),
		["render_pass_create_info_2"] = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkStructureType") end

	return lookup[s] or
		error("unknown VkStructureType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.StdVideoAV1MatrixCoefficients = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["invalid"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_INVALID"),
		["reserved_3"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_RESERVED_3"),
		["ictcp"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_ICTCP"),
		["fcc"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_FCC"),
		["chromat_cl"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_CL"),
		["bt_470_b_g"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_470_B_G"),
		["chromat_ncl"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_NCL"),
		["bt_601"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_601"),
		["smpte_2085"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_2085"),
		["smpte_240"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_240"),
		["bt_2020_cl"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_CL"),
		["identity"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_IDENTITY"),
		["bt_2020_ncl"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_NCL"),
		["bt_709"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_709"),
		["smpte_ycgco"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_YCGCO"),
		["unspecified"] = mod.StdVideoAV1MatrixCoefficients("STD_VIDEO_AV1_MATRIX_COEFFICIENTS_UNSPECIFIED"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoAV1MatrixCoefficients")
	end

	return lookup[s] or
		error(
			"unknown StdVideoAV1MatrixCoefficients value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkBufferCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["sparse_residency"] = mod.VkBufferCreateFlagBits("VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"),
		["descriptor_buffer_capture_replay_ext"] = mod.VkBufferCreateFlagBits("VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"),
		["video_profile_independent_khr"] = mod.VkBufferCreateFlagBits("VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR"),
		["device_address_capture_replay_ext"] = mod.VkBufferCreateFlagBits("VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT"),
		["device_address_capture_replay"] = mod.VkBufferCreateFlagBits("VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"),
		["protected"] = mod.VkBufferCreateFlagBits("VK_BUFFER_CREATE_PROTECTED_BIT"),
		["device_address_capture_replay_khr"] = mod.VkBufferCreateFlagBits("VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR"),
		["sparse_binding"] = mod.VkBufferCreateFlagBits("VK_BUFFER_CREATE_SPARSE_BINDING_BIT"),
		["sparse_aliased"] = mod.VkBufferCreateFlagBits("VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkBufferCreateFlagBits")
	end

	return lookup[s] or
		error("unknown VkBufferCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeRgbModelConversionFlagBitsVALVE = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["ycbcr_709_valve"] = mod.VkVideoEncodeRgbModelConversionFlagBitsVALVE("VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_709_BIT_VALVE"),
		["rgb_identity_valve"] = mod.VkVideoEncodeRgbModelConversionFlagBitsVALVE("VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_RGB_IDENTITY_BIT_VALVE"),
		["ycbcr_601_valve"] = mod.VkVideoEncodeRgbModelConversionFlagBitsVALVE("VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_601_BIT_VALVE"),
		["ycbcr_identity_valve"] = mod.VkVideoEncodeRgbModelConversionFlagBitsVALVE("VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_IDENTITY_BIT_VALVE"),
		["ycbcr_2020_valve"] = mod.VkVideoEncodeRgbModelConversionFlagBitsVALVE("VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_2020_BIT_VALVE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeRgbModelConversionFlagBitsVALVE")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeRgbModelConversionFlagBitsVALVE value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeH264CapabilityFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["mb_qp_diff_wraparound_khr"] = mod.VkVideoEncodeH264CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR"),
		["b_frame_in_l1_list_khr"] = mod.VkVideoEncodeH264CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR"),
		["hrd_compliance_khr"] = mod.VkVideoEncodeH264CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR"),
		["per_picture_type_min_max_qp_khr"] = mod.VkVideoEncodeH264CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR"),
		["prediction_weight_table_generated_khr"] = mod.VkVideoEncodeH264CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR"),
		["per_slice_constant_qp_khr"] = mod.VkVideoEncodeH264CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR"),
		["row_unaligned_slice_khr"] = mod.VkVideoEncodeH264CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR"),
		["generate_prefix_nalu_khr"] = mod.VkVideoEncodeH264CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR"),
		["different_slice_type_khr"] = mod.VkVideoEncodeH264CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR"),
		["b_picture_intra_refresh_khr"] = mod.VkVideoEncodeH264CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR"),
		["b_frame_in_l0_list_khr"] = mod.VkVideoEncodeH264CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeH264CapabilityFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeH264CapabilityFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeRgbRangeCompressionFlagBitsVALVE = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["full_range_valve"] = mod.VkVideoEncodeRgbRangeCompressionFlagBitsVALVE("VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_FULL_RANGE_BIT_VALVE"),
		["narrow_range_valve"] = mod.VkVideoEncodeRgbRangeCompressionFlagBitsVALVE("VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_NARROW_RANGE_BIT_VALVE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeRgbRangeCompressionFlagBitsVALVE")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeRgbRangeCompressionFlagBitsVALVE value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoAV1ChromaSamplePosition = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["colocated"] = mod.StdVideoAV1ChromaSamplePosition("STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_COLOCATED"),
		["invalid"] = mod.StdVideoAV1ChromaSamplePosition("STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_INVALID"),
		["unknown"] = mod.StdVideoAV1ChromaSamplePosition("STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_UNKNOWN"),
		["reserved"] = mod.StdVideoAV1ChromaSamplePosition("STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_RESERVED"),
		["vertical"] = mod.StdVideoAV1ChromaSamplePosition("STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_VERTICAL"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoAV1ChromaSamplePosition")
	end

	return lookup[s] or
		error(
			"unknown StdVideoAV1ChromaSamplePosition value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkBufferUsageFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["index_buffer"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_INDEX_BUFFER_BIT"),
		["conditional_rendering_ext"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT"),
		["vertex_buffer"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"),
		["acceleration_structure_build_input_read_only_khr"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR"),
		["indirect_buffer"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"),
		["acceleration_structure_storage_khr"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR"),
		["shader_device_address_ext"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT"),
		["ray_tracing_nv"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_RAY_TRACING_BIT_NV"),
		["shader_binding_table_khr"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR"),
		["shader_device_address_khr"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR"),
		["tile_memory_qcom"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM"),
		["transfer_src"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_TRANSFER_SRC_BIT"),
		["micromap_storage_ext"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT"),
		["micromap_build_input_read_only_ext"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT"),
		["transfer_dst"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_TRANSFER_DST_BIT"),
		["push_descriptors_descriptor_buffer_ext"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT"),
		["shader_device_address"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"),
		["uniform_texel_buffer"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"),
		["resource_descriptor_buffer_ext"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT"),
		["video_decode_src_khr"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR"),
		["storage_texel_buffer"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"),
		["sampler_descriptor_buffer_ext"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT"),
		["video_decode_dst_khr"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR"),
		["uniform_buffer"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"),
		["video_encode_src_khr"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR"),
		["transform_feedback_buffer_ext"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"),
		["storage_buffer"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"),
		["video_encode_dst_khr"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR"),
		["transform_feedback_counter_buffer_ext"] = mod.VkBufferUsageFlagBits("VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkBufferUsageFlagBits")
	end

	return lookup[s] or
		error("unknown VkBufferUsageFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["cosited_even_valve"] = mod.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE("VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_COSITED_EVEN_BIT_VALVE"),
		["midpoint_valve"] = mod.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE("VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_MIDPOINT_BIT_VALVE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeRgbChromaOffsetFlagBitsVALVE")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeRgbChromaOffsetFlagBitsVALVE value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkFragmentShadingRateNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["1_invocation_per_4x2_pixels_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV"),
		["1_invocation_per_4x4_pixels_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV"),
		["2_invocations_per_pixel_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV"),
		["1_invocation_per_pixel_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV"),
		["no_invocations_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV"),
		["1_invocation_per_1x2_pixels_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV"),
		["16_invocations_per_pixel_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV"),
		["1_invocation_per_2x1_pixels_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV"),
		["8_invocations_per_pixel_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV"),
		["1_invocation_per_2x2_pixels_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV"),
		["4_invocations_per_pixel_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV"),
		["1_invocation_per_2x4_pixels_nv"] = mod.VkFragmentShadingRateNV("VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkFragmentShadingRateNV")
	end

	return lookup[s] or
		error(
			"unknown VkFragmentShadingRateNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoVP9Level = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["1_0"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_1_0"),
		["1_1"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_1_1"),
		["2_0"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_2_0"),
		["2_1"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_2_1"),
		["3_0"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_3_0"),
		["3_1"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_3_1"),
		["4_0"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_4_0"),
		["4_1"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_4_1"),
		["5_0"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_5_0"),
		["5_1"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_5_1"),
		["5_2"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_5_2"),
		["6_0"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_6_0"),
		["6_1"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_6_1"),
		["6_2"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_6_2"),
		["invalid"] = mod.StdVideoVP9Level("STD_VIDEO_VP9_LEVEL_INVALID"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoVP9Level")
	end

	return lookup[s] or
		error("unknown StdVideoVP9Level value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkValidationCacheHeaderVersionEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["one_ext"] = mod.VkValidationCacheHeaderVersionEXT("VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkValidationCacheHeaderVersionEXT")
	end

	return lookup[s] or
		error(
			"unknown VkValidationCacheHeaderVersionEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkLineRasterizationMode = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["rectangular_smooth_ext"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT"),
		["default_khr"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR"),
		["rectangular"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_RECTANGULAR"),
		["bresenham"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_BRESENHAM"),
		["rectangular_smooth_khr"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR"),
		["rectangular_smooth"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH"),
		["bresenham_khr"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR"),
		["default_ext"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT"),
		["rectangular_khr"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR"),
		["rectangular_ext"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT"),
		["default"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_DEFAULT"),
		["bresenham_ext"] = mod.VkLineRasterizationMode("VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkLineRasterizationMode")
	end

	return lookup[s] or
		error(
			"unknown VkLineRasterizationMode value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkCompareOp = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["less_or_equal"] = mod.VkCompareOp("VK_COMPARE_OP_LESS_OR_EQUAL"),
		["always"] = mod.VkCompareOp("VK_COMPARE_OP_ALWAYS"),
		["never"] = mod.VkCompareOp("VK_COMPARE_OP_NEVER"),
		["greater_or_equal"] = mod.VkCompareOp("VK_COMPARE_OP_GREATER_OR_EQUAL"),
		["less"] = mod.VkCompareOp("VK_COMPARE_OP_LESS"),
		["not_equal"] = mod.VkCompareOp("VK_COMPARE_OP_NOT_EQUAL"),
		["equal"] = mod.VkCompareOp("VK_COMPARE_OP_EQUAL"),
		["greater"] = mod.VkCompareOp("VK_COMPARE_OP_GREATER"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkCompareOp") end

	return lookup[s] or
		error("unknown VkCompareOp value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkAttachmentLoadOp = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["none_ext"] = mod.VkAttachmentLoadOp("VK_ATTACHMENT_LOAD_OP_NONE_EXT"),
		["clear"] = mod.VkAttachmentLoadOp("VK_ATTACHMENT_LOAD_OP_CLEAR"),
		["none_khr"] = mod.VkAttachmentLoadOp("VK_ATTACHMENT_LOAD_OP_NONE_KHR"),
		["dont_care"] = mod.VkAttachmentLoadOp("VK_ATTACHMENT_LOAD_OP_DONT_CARE"),
		["load"] = mod.VkAttachmentLoadOp("VK_ATTACHMENT_LOAD_OP_LOAD"),
		["none"] = mod.VkAttachmentLoadOp("VK_ATTACHMENT_LOAD_OP_NONE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAttachmentLoadOp")
	end

	return lookup[s] or
		error("unknown VkAttachmentLoadOp value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkBuildAccelerationStructureModeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["build_khr"] = mod.VkBuildAccelerationStructureModeKHR("VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR"),
		["update_khr"] = mod.VkBuildAccelerationStructureModeKHR("VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkBuildAccelerationStructureModeKHR")
	end

	return lookup[s] or
		error(
			"unknown VkBuildAccelerationStructureModeKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPipelineRobustnessBufferBehavior = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["device_default_ext"] = mod.VkPipelineRobustnessBufferBehavior("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT"),
		["robust_buffer_access_2_ext"] = mod.VkPipelineRobustnessBufferBehavior("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT"),
		["disabled_ext"] = mod.VkPipelineRobustnessBufferBehavior("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT"),
		["robust_buffer_access_ext"] = mod.VkPipelineRobustnessBufferBehavior("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT"),
		["robust_buffer_access"] = mod.VkPipelineRobustnessBufferBehavior("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS"),
		["device_default"] = mod.VkPipelineRobustnessBufferBehavior("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT"),
		["robust_buffer_access_2"] = mod.VkPipelineRobustnessBufferBehavior("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2"),
		["disabled"] = mod.VkPipelineRobustnessBufferBehavior("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineRobustnessBufferBehavior")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineRobustnessBufferBehavior value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkAccelerationStructureCreateFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["descriptor_buffer_capture_replay_ext"] = mod.VkAccelerationStructureCreateFlagBitsKHR("VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"),
		["device_address_capture_replay_khr"] = mod.VkAccelerationStructureCreateFlagBitsKHR("VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR"),
		["motion_nv"] = mod.VkAccelerationStructureCreateFlagBitsKHR("VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAccelerationStructureCreateFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkAccelerationStructureCreateFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkAttachmentStoreOp = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["none_qcom"] = mod.VkAttachmentStoreOp("VK_ATTACHMENT_STORE_OP_NONE_QCOM"),
		["none_ext"] = mod.VkAttachmentStoreOp("VK_ATTACHMENT_STORE_OP_NONE_EXT"),
		["none_khr"] = mod.VkAttachmentStoreOp("VK_ATTACHMENT_STORE_OP_NONE_KHR"),
		["dont_care"] = mod.VkAttachmentStoreOp("VK_ATTACHMENT_STORE_OP_DONT_CARE"),
		["store"] = mod.VkAttachmentStoreOp("VK_ATTACHMENT_STORE_OP_STORE"),
		["none"] = mod.VkAttachmentStoreOp("VK_ATTACHMENT_STORE_OP_NONE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAttachmentStoreOp")
	end

	return lookup[s] or
		error("unknown VkAttachmentStoreOp value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkMemoryUnmapFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["reserve_ext"] = mod.VkMemoryUnmapFlagBits("VK_MEMORY_UNMAP_RESERVE_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkMemoryUnmapFlagBits")
	end

	return lookup[s] or
		error("unknown VkMemoryUnmapFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkFragmentShadingRateCombinerOpKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["replace_khr"] = mod.VkFragmentShadingRateCombinerOpKHR("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR"),
		["min_khr"] = mod.VkFragmentShadingRateCombinerOpKHR("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR"),
		["max_khr"] = mod.VkFragmentShadingRateCombinerOpKHR("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR"),
		["mul_khr"] = mod.VkFragmentShadingRateCombinerOpKHR("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR"),
		["keep_khr"] = mod.VkFragmentShadingRateCombinerOpKHR("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkFragmentShadingRateCombinerOpKHR")
	end

	return lookup[s] or
		error(
			"unknown VkFragmentShadingRateCombinerOpKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkTimeDomainKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["query_performance_counter_khr"] = mod.VkTimeDomainKHR("VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR"),
		["query_performance_counter_ext"] = mod.VkTimeDomainKHR("VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT"),
		["device_khr"] = mod.VkTimeDomainKHR("VK_TIME_DOMAIN_DEVICE_KHR"),
		["clock_monotonic_raw_ext"] = mod.VkTimeDomainKHR("VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT"),
		["clock_monotonic_khr"] = mod.VkTimeDomainKHR("VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR"),
		["clock_monotonic_ext"] = mod.VkTimeDomainKHR("VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT"),
		["clock_monotonic_raw_khr"] = mod.VkTimeDomainKHR("VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR"),
		["device_ext"] = mod.VkTimeDomainKHR("VK_TIME_DOMAIN_DEVICE_EXT"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkTimeDomainKHR") end

	return lookup[s] or
		error("unknown VkTimeDomainKHR value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkPipelineRobustnessImageBehavior = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["device_default_ext"] = mod.VkPipelineRobustnessImageBehavior("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT"),
		["robust_image_access_2_ext"] = mod.VkPipelineRobustnessImageBehavior("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT"),
		["disabled_ext"] = mod.VkPipelineRobustnessImageBehavior("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT"),
		["robust_image_access_ext"] = mod.VkPipelineRobustnessImageBehavior("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT"),
		["robust_image_access"] = mod.VkPipelineRobustnessImageBehavior("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS"),
		["device_default"] = mod.VkPipelineRobustnessImageBehavior("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT"),
		["robust_image_access_2"] = mod.VkPipelineRobustnessImageBehavior("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2"),
		["disabled"] = mod.VkPipelineRobustnessImageBehavior("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineRobustnessImageBehavior")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineRobustnessImageBehavior value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPipelineBindPoint = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["ray_tracing_khr"] = mod.VkPipelineBindPoint("VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR"),
		["subpass_shading_huawei"] = mod.VkPipelineBindPoint("VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI"),
		["data_graph_arm"] = mod.VkPipelineBindPoint("VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM"),
		["graphics"] = mod.VkPipelineBindPoint("VK_PIPELINE_BIND_POINT_GRAPHICS"),
		["ray_tracing_nv"] = mod.VkPipelineBindPoint("VK_PIPELINE_BIND_POINT_RAY_TRACING_NV"),
		["compute"] = mod.VkPipelineBindPoint("VK_PIPELINE_BIND_POINT_COMPUTE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineBindPoint")
	end

	return lookup[s] or
		error("unknown VkPipelineBindPoint value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkAccelerationStructureMotionInstanceTypeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["static_nv"] = mod.VkAccelerationStructureMotionInstanceTypeNV("VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV"),
		["srt_motion_nv"] = mod.VkAccelerationStructureMotionInstanceTypeNV("VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV"),
		["matrix_motion_nv"] = mod.VkAccelerationStructureMotionInstanceTypeNV("VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAccelerationStructureMotionInstanceTypeNV")
	end

	return lookup[s] or
		error(
			"unknown VkAccelerationStructureMotionInstanceTypeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkImageViewCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["descriptor_buffer_capture_replay_ext"] = mod.VkImageViewCreateFlagBits("VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"),
		["fragment_density_map_deferred_ext"] = mod.VkImageViewCreateFlagBits("VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT"),
		["fragment_density_map_dynamic_ext"] = mod.VkImageViewCreateFlagBits("VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkImageViewCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkImageViewCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkCommandBufferLevel = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["primary"] = mod.VkCommandBufferLevel("VK_COMMAND_BUFFER_LEVEL_PRIMARY"),
		["secondary"] = mod.VkCommandBufferLevel("VK_COMMAND_BUFFER_LEVEL_SECONDARY"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCommandBufferLevel")
	end

	return lookup[s] or
		error("unknown VkCommandBufferLevel value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkShadingRatePaletteEntryNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["1_invocation_per_4x2_pixels_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV"),
		["1_invocation_per_4x4_pixels_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV"),
		["2_invocations_per_pixel_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV"),
		["1_invocation_per_pixel_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV"),
		["8_invocations_per_pixel_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV"),
		["1_invocation_per_1x2_pixels_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV"),
		["1_invocation_per_2x2_pixels_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV"),
		["1_invocation_per_2x1_pixels_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV"),
		["4_invocations_per_pixel_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV"),
		["no_invocations_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV"),
		["16_invocations_per_pixel_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV"),
		["1_invocation_per_2x4_pixels_nv"] = mod.VkShadingRatePaletteEntryNV("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkShadingRatePaletteEntryNV")
	end

	return lookup[s] or
		error(
			"unknown VkShadingRatePaletteEntryNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPipelineCacheCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["externally_synchronized"] = mod.VkPipelineCacheCreateFlagBits("VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"),
		["externally_synchronized_ext"] = mod.VkPipelineCacheCreateFlagBits("VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT"),
		["internally_synchronized_merge_khr"] = mod.VkPipelineCacheCreateFlagBits("VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineCacheCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineCacheCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkIndexType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["uint8"] = mod.VkIndexType("VK_INDEX_TYPE_UINT8"),
		["uint32"] = mod.VkIndexType("VK_INDEX_TYPE_UINT32"),
		["none_khr"] = mod.VkIndexType("VK_INDEX_TYPE_NONE_KHR"),
		["none_nv"] = mod.VkIndexType("VK_INDEX_TYPE_NONE_NV"),
		["uint8_ext"] = mod.VkIndexType("VK_INDEX_TYPE_UINT8_EXT"),
		["uint16"] = mod.VkIndexType("VK_INDEX_TYPE_UINT16"),
		["uint8_khr"] = mod.VkIndexType("VK_INDEX_TYPE_UINT8_KHR"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkIndexType") end

	return lookup[s] or
		error("unknown VkIndexType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeH265CapabilityFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["per_slice_segment_constant_qp_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR"),
		["b_frame_in_l1_list_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR"),
		["hrd_compliance_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR"),
		["multiple_tiles_per_slice_segment_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR"),
		["per_picture_type_min_max_qp_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR"),
		["prediction_weight_table_generated_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR"),
		["multiple_slice_segments_per_tile_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR"),
		["cu_qp_diff_wraparound_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR"),
		["row_unaligned_slice_segment_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR"),
		["b_picture_intra_refresh_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR"),
		["different_slice_segment_type_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR"),
		["b_frame_in_l0_list_khr"] = mod.VkVideoEncodeH265CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeH265CapabilityFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeH265CapabilityFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkColorComponentFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["a"] = mod.VkColorComponentFlagBits("VK_COLOR_COMPONENT_A_BIT"),
		["g"] = mod.VkColorComponentFlagBits("VK_COLOR_COMPONENT_G_BIT"),
		["r"] = mod.VkColorComponentFlagBits("VK_COLOR_COMPONENT_R_BIT"),
		["b"] = mod.VkColorComponentFlagBits("VK_COLOR_COMPONENT_B_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkColorComponentFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkColorComponentFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDebugReportFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["performance_warning_ext"] = mod.VkDebugReportFlagBitsEXT("VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"),
		["information_ext"] = mod.VkDebugReportFlagBitsEXT("VK_DEBUG_REPORT_INFORMATION_BIT_EXT"),
		["error_ext"] = mod.VkDebugReportFlagBitsEXT("VK_DEBUG_REPORT_ERROR_BIT_EXT"),
		["warning_ext"] = mod.VkDebugReportFlagBitsEXT("VK_DEBUG_REPORT_WARNING_BIT_EXT"),
		["debug_ext"] = mod.VkDebugReportFlagBitsEXT("VK_DEBUG_REPORT_DEBUG_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDebugReportFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkDebugReportFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSubpassContents = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["secondary_command_buffers"] = mod.VkSubpassContents("VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"),
		["inline"] = mod.VkSubpassContents("VK_SUBPASS_CONTENTS_INLINE"),
		["inline_and_secondary_command_buffers_khr"] = mod.VkSubpassContents("VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR"),
		["inline_and_secondary_command_buffers_ext"] = mod.VkSubpassContents("VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSubpassContents")
	end

	return lookup[s] or
		error("unknown VkSubpassContents value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkCoarseSampleOrderTypeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["sample_major_nv"] = mod.VkCoarseSampleOrderTypeNV("VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV"),
		["custom_nv"] = mod.VkCoarseSampleOrderTypeNV("VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV"),
		["pixel_major_nv"] = mod.VkCoarseSampleOrderTypeNV("VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV"),
		["default_nv"] = mod.VkCoarseSampleOrderTypeNV("VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCoarseSampleOrderTypeNV")
	end

	return lookup[s] or
		error(
			"unknown VkCoarseSampleOrderTypeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDeviceAddressBindingTypeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["unbind_ext"] = mod.VkDeviceAddressBindingTypeEXT("VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT"),
		["bind_ext"] = mod.VkDeviceAddressBindingTypeEXT("VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDeviceAddressBindingTypeEXT")
	end

	return lookup[s] or
		error(
			"unknown VkDeviceAddressBindingTypeEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkValidationFeatureEnableEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["best_practices_ext"] = mod.VkValidationFeatureEnableEXT("VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT"),
		["debug_printf_ext"] = mod.VkValidationFeatureEnableEXT("VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT"),
		["gpu_assisted_ext"] = mod.VkValidationFeatureEnableEXT("VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT"),
		["synchronization_validation_ext"] = mod.VkValidationFeatureEnableEXT("VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT"),
		["gpu_assisted_reserve_binding_slot_ext"] = mod.VkValidationFeatureEnableEXT("VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkValidationFeatureEnableEXT")
	end

	return lookup[s] or
		error(
			"unknown VkValidationFeatureEnableEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDeviceAddressBindingFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["internal_object_ext"] = mod.VkDeviceAddressBindingFlagBitsEXT("VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDeviceAddressBindingFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkDeviceAddressBindingFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPointClippingBehavior = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["all_clip_planes"] = mod.VkPointClippingBehavior("VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"),
		["user_clip_planes_only_khr"] = mod.VkPointClippingBehavior("VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR"),
		["user_clip_planes_only"] = mod.VkPointClippingBehavior("VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"),
		["all_clip_planes_khr"] = mod.VkPointClippingBehavior("VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPointClippingBehavior")
	end

	return lookup[s] or
		error(
			"unknown VkPointClippingBehavior value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkMicromapTypeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["opacity_micromap_ext"] = mod.VkMicromapTypeEXT("VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkMicromapTypeEXT")
	end

	return lookup[s] or
		error("unknown VkMicromapTypeEXT value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkMemoryMapFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["placed_ext"] = mod.VkMemoryMapFlagBits("VK_MEMORY_MAP_PLACED_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkMemoryMapFlagBits")
	end

	return lookup[s] or
		error("unknown VkMemoryMapFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkValidationFeatureDisableEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["thread_safety_ext"] = mod.VkValidationFeatureDisableEXT("VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT"),
		["shader_validation_cache_ext"] = mod.VkValidationFeatureDisableEXT("VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT"),
		["api_parameters_ext"] = mod.VkValidationFeatureDisableEXT("VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT"),
		["unique_handles_ext"] = mod.VkValidationFeatureDisableEXT("VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT"),
		["all_ext"] = mod.VkValidationFeatureDisableEXT("VK_VALIDATION_FEATURE_DISABLE_ALL_EXT"),
		["core_checks_ext"] = mod.VkValidationFeatureDisableEXT("VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT"),
		["shaders_ext"] = mod.VkValidationFeatureDisableEXT("VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT"),
		["object_lifetimes_ext"] = mod.VkValidationFeatureDisableEXT("VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkValidationFeatureDisableEXT")
	end

	return lookup[s] or
		error(
			"unknown VkValidationFeatureDisableEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkBuildMicromapModeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["build_ext"] = mod.VkBuildMicromapModeEXT("VK_BUILD_MICROMAP_MODE_BUILD_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkBuildMicromapModeEXT")
	end

	return lookup[s] or
		error("unknown VkBuildMicromapModeEXT value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkSparseMemoryBindFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["metadata"] = mod.VkSparseMemoryBindFlagBits("VK_SPARSE_MEMORY_BIND_METADATA_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSparseMemoryBindFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkSparseMemoryBindFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkCopyMicromapModeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["compact_ext"] = mod.VkCopyMicromapModeEXT("VK_COPY_MICROMAP_MODE_COMPACT_EXT"),
		["clone_ext"] = mod.VkCopyMicromapModeEXT("VK_COPY_MICROMAP_MODE_CLONE_EXT"),
		["deserialize_ext"] = mod.VkCopyMicromapModeEXT("VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT"),
		["serialize_ext"] = mod.VkCopyMicromapModeEXT("VK_COPY_MICROMAP_MODE_SERIALIZE_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCopyMicromapModeEXT")
	end

	return lookup[s] or
		error("unknown VkCopyMicromapModeEXT value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkSparseImageFormatFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["nonstandard_block_size"] = mod.VkSparseImageFormatFlagBits("VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT"),
		["aligned_mip_size"] = mod.VkSparseImageFormatFlagBits("VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"),
		["single_miptail"] = mod.VkSparseImageFormatFlagBits("VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSparseImageFormatFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkSparseImageFormatFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSamplerYcbcrModelConversion = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["ycbcr_identity_khr"] = mod.VkSamplerYcbcrModelConversion("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR"),
		["ycbcr_709_khr"] = mod.VkSamplerYcbcrModelConversion("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR"),
		["rgb_identity"] = mod.VkSamplerYcbcrModelConversion("VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"),
		["ycbcr_identity"] = mod.VkSamplerYcbcrModelConversion("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY"),
		["ycbcr_709"] = mod.VkSamplerYcbcrModelConversion("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"),
		["ycbcr_601"] = mod.VkSamplerYcbcrModelConversion("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"),
		["ycbcr_2020"] = mod.VkSamplerYcbcrModelConversion("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"),
		["ycbcr_2020_khr"] = mod.VkSamplerYcbcrModelConversion("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR"),
		["rgb_identity_khr"] = mod.VkSamplerYcbcrModelConversion("VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR"),
		["ycbcr_601_khr"] = mod.VkSamplerYcbcrModelConversion("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSamplerYcbcrModelConversion")
	end

	return lookup[s] or
		error(
			"unknown VkSamplerYcbcrModelConversion value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkOpacityMicromapFormatEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["2_state_ext"] = mod.VkOpacityMicromapFormatEXT("VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT"),
		["4_state_ext"] = mod.VkOpacityMicromapFormatEXT("VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkOpacityMicromapFormatEXT")
	end

	return lookup[s] or
		error(
			"unknown VkOpacityMicromapFormatEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkFenceCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["signaled"] = mod.VkFenceCreateFlagBits("VK_FENCE_CREATE_SIGNALED_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkFenceCreateFlagBits")
	end

	return lookup[s] or
		error("unknown VkFenceCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkOpacityMicromapSpecialIndexEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["fully_transparent_ext"] = mod.VkOpacityMicromapSpecialIndexEXT("VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT"),
		["fully_opaque_ext"] = mod.VkOpacityMicromapSpecialIndexEXT("VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT"),
		["fully_unknown_transparent_ext"] = mod.VkOpacityMicromapSpecialIndexEXT("VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT"),
		["cluster_geometry_disable_opacity_micromap_nv"] = mod.VkOpacityMicromapSpecialIndexEXT("VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV"),
		["fully_unknown_opaque_ext"] = mod.VkOpacityMicromapSpecialIndexEXT("VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkOpacityMicromapSpecialIndexEXT")
	end

	return lookup[s] or
		error(
			"unknown VkOpacityMicromapSpecialIndexEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDataGraphPipelineSessionBindPointARM = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["transient_arm"] = mod.VkDataGraphPipelineSessionBindPointARM("VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDataGraphPipelineSessionBindPointARM")
	end

	return lookup[s] or
		error(
			"unknown VkDataGraphPipelineSessionBindPointARM value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeH265CtbSizeFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["32_khr"] = mod.VkVideoEncodeH265CtbSizeFlagBitsKHR("VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR"),
		["16_khr"] = mod.VkVideoEncodeH265CtbSizeFlagBitsKHR("VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR"),
		["64_khr"] = mod.VkVideoEncodeH265CtbSizeFlagBitsKHR("VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeH265CtbSizeFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeH265CtbSizeFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkEventCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["device_only_khr"] = mod.VkEventCreateFlagBits("VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR"),
		["device_only"] = mod.VkEventCreateFlagBits("VK_EVENT_CREATE_DEVICE_ONLY_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkEventCreateFlagBits")
	end

	return lookup[s] or
		error("unknown VkEventCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkAddressCopyFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["protected_khr"] = mod.VkAddressCopyFlagBitsKHR("VK_ADDRESS_COPY_PROTECTED_BIT_KHR"),
		["sparse_khr"] = mod.VkAddressCopyFlagBitsKHR("VK_ADDRESS_COPY_SPARSE_BIT_KHR"),
		["device_local_khr"] = mod.VkAddressCopyFlagBitsKHR("VK_ADDRESS_COPY_DEVICE_LOCAL_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAddressCopyFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkAddressCopyFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSamplerYcbcrRange = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["itu_full"] = mod.VkSamplerYcbcrRange("VK_SAMPLER_YCBCR_RANGE_ITU_FULL"),
		["itu_narrow_khr"] = mod.VkSamplerYcbcrRange("VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR"),
		["itu_narrow"] = mod.VkSamplerYcbcrRange("VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"),
		["itu_full_khr"] = mod.VkSamplerYcbcrRange("VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSamplerYcbcrRange")
	end

	return lookup[s] or
		error("unknown VkSamplerYcbcrRange value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkDataGraphPipelinePropertyARM = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["identifier_arm"] = mod.VkDataGraphPipelinePropertyARM("VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM"),
		["creation_log_arm"] = mod.VkDataGraphPipelinePropertyARM("VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDataGraphPipelinePropertyARM")
	end

	return lookup[s] or
		error(
			"unknown VkDataGraphPipelinePropertyARM value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkQueryPipelineStatisticFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["geometry_shader_primitives"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"),
		["compute_shader_invocations"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"),
		["clipping_invocations"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"),
		["input_assembly_vertices"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"),
		["task_shader_invocations_ext"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT"),
		["clipping_primitives"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"),
		["input_assembly_primitives"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"),
		["mesh_shader_invocations_ext"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT"),
		["fragment_shader_invocations"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"),
		["vertex_shader_invocations"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"),
		["cluster_culling_shader_invocations_huawei"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI"),
		["tessellation_control_shader_patches"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"),
		["geometry_shader_invocations"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"),
		["tessellation_evaluation_shader_invocations"] = mod.VkQueryPipelineStatisticFlagBits("VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkQueryPipelineStatisticFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkQueryPipelineStatisticFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPhysicalDeviceDataGraphProcessingEngineTypeARM = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["default_arm"] = mod.VkPhysicalDeviceDataGraphProcessingEngineTypeARM("VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPhysicalDeviceDataGraphProcessingEngineTypeARM")
	end

	return lookup[s] or
		error(
			"unknown VkPhysicalDeviceDataGraphProcessingEngineTypeARM value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkChromaLocation = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["midpoint_khr"] = mod.VkChromaLocation("VK_CHROMA_LOCATION_MIDPOINT_KHR"),
		["cosited_even"] = mod.VkChromaLocation("VK_CHROMA_LOCATION_COSITED_EVEN"),
		["cosited_even_khr"] = mod.VkChromaLocation("VK_CHROMA_LOCATION_COSITED_EVEN_KHR"),
		["midpoint"] = mod.VkChromaLocation("VK_CHROMA_LOCATION_MIDPOINT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkChromaLocation")
	end

	return lookup[s] or
		error("unknown VkChromaLocation value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkCoverageReductionModeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["truncate_nv"] = mod.VkCoverageReductionModeNV("VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV"),
		["merge_nv"] = mod.VkCoverageReductionModeNV("VK_COVERAGE_REDUCTION_MODE_MERGE_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCoverageReductionModeNV")
	end

	return lookup[s] or
		error(
			"unknown VkCoverageReductionModeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeH265RateControlFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["attempt_hrd_compliance_khr"] = mod.VkVideoEncodeH265RateControlFlagBitsKHR("VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR"),
		["regular_gop_khr"] = mod.VkVideoEncodeH265RateControlFlagBitsKHR("VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR"),
		["reference_pattern_dyadic_khr"] = mod.VkVideoEncodeH265RateControlFlagBitsKHR("VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR"),
		["reference_pattern_flat_khr"] = mod.VkVideoEncodeH265RateControlFlagBitsKHR("VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR"),
		["temporal_sub_layer_pattern_dyadic_khr"] = mod.VkVideoEncodeH265RateControlFlagBitsKHR("VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeH265RateControlFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeH265RateControlFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkImageCompressionFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["fixed_rate_explicit_ext"] = mod.VkImageCompressionFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT"),
		["disabled_ext"] = mod.VkImageCompressionFlagBitsEXT("VK_IMAGE_COMPRESSION_DISABLED_EXT"),
		["fixed_rate_default_ext"] = mod.VkImageCompressionFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT"),
		["default_ext"] = mod.VkImageCompressionFlagBitsEXT("VK_IMAGE_COMPRESSION_DEFAULT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkImageCompressionFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkImageCompressionFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDescriptorUpdateTemplateType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["descriptor_set_khr"] = mod.VkDescriptorUpdateTemplateType("VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR"),
		["push_descriptors"] = mod.VkDescriptorUpdateTemplateType("VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS"),
		["push_descriptors_khr"] = mod.VkDescriptorUpdateTemplateType("VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR"),
		["descriptor_set"] = mod.VkDescriptorUpdateTemplateType("VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDescriptorUpdateTemplateType")
	end

	return lookup[s] or
		error(
			"unknown VkDescriptorUpdateTemplateType value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkImageCompressionFixedRateFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["6bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT"),
		["none_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT"),
		["7bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT"),
		["18bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT"),
		["8bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT"),
		["19bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT"),
		["9bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT"),
		["20bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT"),
		["10bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT"),
		["21bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT"),
		["11bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT"),
		["22bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT"),
		["1bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT"),
		["12bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT"),
		["23bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT"),
		["2bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT"),
		["13bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT"),
		["24bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT"),
		["3bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT"),
		["14bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT"),
		["4bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT"),
		["15bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT"),
		["5bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT"),
		["16bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT"),
		["17bpc_ext"] = mod.VkImageCompressionFixedRateFlagBitsEXT("VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkImageCompressionFixedRateFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkImageCompressionFixedRateFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSubgroupFeatureFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["arithmetic"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_ARITHMETIC_BIT"),
		["rotate"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_ROTATE_BIT"),
		["ballot"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_BALLOT_BIT"),
		["rotate_clustered"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT"),
		["shuffle"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_SHUFFLE_BIT"),
		["partitioned_nv"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV"),
		["shuffle_relative"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT"),
		["basic"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_BASIC_BIT"),
		["rotate_khr"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR"),
		["clustered"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_CLUSTERED_BIT"),
		["vote"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_VOTE_BIT"),
		["rotate_clustered_khr"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR"),
		["quad"] = mod.VkSubgroupFeatureFlagBits("VK_SUBGROUP_FEATURE_QUAD_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSubgroupFeatureFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkSubgroupFeatureFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkQueryPoolCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["reset_khr"] = mod.VkQueryPoolCreateFlagBits("VK_QUERY_POOL_CREATE_RESET_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkQueryPoolCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkQueryPoolCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDepthBiasRepresentationEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["least_representable_value_force_unorm_ext"] = mod.VkDepthBiasRepresentationEXT("VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT"),
		["least_representable_value_format_ext"] = mod.VkDepthBiasRepresentationEXT("VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT"),
		["float_ext"] = mod.VkDepthBiasRepresentationEXT("VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDepthBiasRepresentationEXT")
	end

	return lookup[s] or
		error(
			"unknown VkDepthBiasRepresentationEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkQueryResultFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["with_status_khr"] = mod.VkQueryResultFlagBits("VK_QUERY_RESULT_WITH_STATUS_BIT_KHR"),
		["with_availability"] = mod.VkQueryResultFlagBits("VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"),
		["partial"] = mod.VkQueryResultFlagBits("VK_QUERY_RESULT_PARTIAL_BIT"),
		["wait"] = mod.VkQueryResultFlagBits("VK_QUERY_RESULT_WAIT_BIT"),
		["64"] = mod.VkQueryResultFlagBits("VK_QUERY_RESULT_64_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkQueryResultFlagBits")
	end

	return lookup[s] or
		error("unknown VkQueryResultFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkRayTracingShaderGroupTypeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["general_nv"] = mod.VkRayTracingShaderGroupTypeKHR("VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV"),
		["triangles_hit_group_nv"] = mod.VkRayTracingShaderGroupTypeKHR("VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV"),
		["general_khr"] = mod.VkRayTracingShaderGroupTypeKHR("VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR"),
		["triangles_hit_group_khr"] = mod.VkRayTracingShaderGroupTypeKHR("VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR"),
		["procedural_hit_group_khr"] = mod.VkRayTracingShaderGroupTypeKHR("VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR"),
		["procedural_hit_group_nv"] = mod.VkRayTracingShaderGroupTypeKHR("VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkRayTracingShaderGroupTypeKHR")
	end

	return lookup[s] or
		error(
			"unknown VkRayTracingShaderGroupTypeKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkLayeredDriverUnderlyingApiMSFT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["d3d12_msft"] = mod.VkLayeredDriverUnderlyingApiMSFT("VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT"),
		["none_msft"] = mod.VkLayeredDriverUnderlyingApiMSFT("VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkLayeredDriverUnderlyingApiMSFT")
	end

	return lookup[s] or
		error(
			"unknown VkLayeredDriverUnderlyingApiMSFT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkFormatFeatureFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["fragment_shading_rate_attachment_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
		["sampled_image_ycbcr_conversion_chroma_reconstruction_explicit"] = mod.VkFormatFeatureFlagBits(
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"
		),
		["vertex_buffer"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"),
		["video_encode_dpb_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR"),
		["sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable"] = mod.VkFormatFeatureFlagBits(
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"
		),
		["cosited_chroma_samples"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT"),
		["sampled_image_filter_minmax"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT"),
		["storage_image_atomic"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"),
		["video_decode_output_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR"),
		["storage_texel_buffer_atomic"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),
		["acceleration_structure_vertex_buffer_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"),
		["storage_image"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"),
		["sampled_image_filter_cubic_ext"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT"),
		["blit_src"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_BLIT_SRC_BIT"),
		["video_encode_input_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR"),
		["blit_dst"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_BLIT_DST_BIT"),
		["sampled_image_filter_cubic_img"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG"),
		["sampled_image_filter_linear"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT"),
		["transfer_src_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR"),
		["midpoint_chroma_samples"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT"),
		["transfer_dst_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR"),
		["sampled_image_filter_minmax_ext"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT"),
		["midpoint_chroma_samples_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR"),
		["sampled_image_ycbcr_conversion_linear_filter_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR"),
		["color_attachment"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"),
		["disjoint"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_DISJOINT_BIT"),
		["transfer_src"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_TRANSFER_SRC_BIT"),
		["depth_stencil_attachment"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"),
		["transfer_dst"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_TRANSFER_DST_BIT"),
		["sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable_khr"] = mod.VkFormatFeatureFlagBits(
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR"
		),
		["uniform_texel_buffer"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),
		["cosited_chroma_samples_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR"),
		["disjoint_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_DISJOINT_BIT_KHR"),
		["storage_texel_buffer"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),
		["sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_khr"] = mod.VkFormatFeatureFlagBits(
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR"
		),
		["sampled_image_ycbcr_conversion_separate_reconstruction_filter_khr"] = mod.VkFormatFeatureFlagBits(
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR"
		),
		["sampled_image"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"),
		["video_decode_dpb_khr"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR"),
		["sampled_image_ycbcr_conversion_linear_filter"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"),
		["color_attachment_blend"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"),
		["fragment_density_map_ext"] = mod.VkFormatFeatureFlagBits("VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT"),
		["sampled_image_ycbcr_conversion_separate_reconstruction_filter"] = mod.VkFormatFeatureFlagBits(
			"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"
		),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkFormatFeatureFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkFormatFeatureFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeIntraRefreshModeFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["block_row_based_khr"] = mod.VkVideoEncodeIntraRefreshModeFlagBitsKHR("VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR"),
		["none_khr"] = mod.VkVideoEncodeIntraRefreshModeFlagBitsKHR("VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR"),
		["per_picture_partition_khr"] = mod.VkVideoEncodeIntraRefreshModeFlagBitsKHR("VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR"),
		["block_column_based_khr"] = mod.VkVideoEncodeIntraRefreshModeFlagBitsKHR("VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR"),
		["block_based_khr"] = mod.VkVideoEncodeIntraRefreshModeFlagBitsKHR("VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeIntraRefreshModeFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeIntraRefreshModeFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkExternalMemoryHandleTypeFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["d3d11_image_nv"] = mod.VkExternalMemoryHandleTypeFlagBitsNV("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"),
		["opaque_win32_kmt_nv"] = mod.VkExternalMemoryHandleTypeFlagBitsNV("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"),
		["opaque_win32_nv"] = mod.VkExternalMemoryHandleTypeFlagBitsNV("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"),
		["d3d11_image_kmt_nv"] = mod.VkExternalMemoryHandleTypeFlagBitsNV("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkExternalMemoryHandleTypeFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkExternalMemoryHandleTypeFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkGeometryTypeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["aabbs_khr"] = mod.VkGeometryTypeKHR("VK_GEOMETRY_TYPE_AABBS_KHR"),
		["aabbs_nv"] = mod.VkGeometryTypeKHR("VK_GEOMETRY_TYPE_AABBS_NV"),
		["instances_khr"] = mod.VkGeometryTypeKHR("VK_GEOMETRY_TYPE_INSTANCES_KHR"),
		["triangles_nv"] = mod.VkGeometryTypeKHR("VK_GEOMETRY_TYPE_TRIANGLES_NV"),
		["spheres_nv"] = mod.VkGeometryTypeKHR("VK_GEOMETRY_TYPE_SPHERES_NV"),
		["linear_swept_spheres_nv"] = mod.VkGeometryTypeKHR("VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV"),
		["triangles_khr"] = mod.VkGeometryTypeKHR("VK_GEOMETRY_TYPE_TRIANGLES_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkGeometryTypeKHR")
	end

	return lookup[s] or
		error("unknown VkGeometryTypeKHR value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkShaderFloatControlsIndependence = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["all"] = mod.VkShaderFloatControlsIndependence("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL"),
		["none_khr"] = mod.VkShaderFloatControlsIndependence("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR"),
		["32_only_khr"] = mod.VkShaderFloatControlsIndependence("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR"),
		["32_only"] = mod.VkShaderFloatControlsIndependence("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY"),
		["all_khr"] = mod.VkShaderFloatControlsIndependence("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR"),
		["none"] = mod.VkShaderFloatControlsIndependence("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkShaderFloatControlsIndependence")
	end

	return lookup[s] or
		error(
			"unknown VkShaderFloatControlsIndependence value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkProvokingVertexModeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["last_vertex_ext"] = mod.VkProvokingVertexModeEXT("VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT"),
		["first_vertex_ext"] = mod.VkProvokingVertexModeEXT("VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkProvokingVertexModeEXT")
	end

	return lookup[s] or
		error(
			"unknown VkProvokingVertexModeEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkExternalMemoryFeatureFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["importable_nv"] = mod.VkExternalMemoryFeatureFlagBitsNV("VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"),
		["exportable_nv"] = mod.VkExternalMemoryFeatureFlagBitsNV("VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"),
		["dedicated_only_nv"] = mod.VkExternalMemoryFeatureFlagBitsNV("VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkExternalMemoryFeatureFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkExternalMemoryFeatureFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDeviceMemoryReportEventTypeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["allocate_ext"] = mod.VkDeviceMemoryReportEventTypeEXT("VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT"),
		["free_ext"] = mod.VkDeviceMemoryReportEventTypeEXT("VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT"),
		["import_ext"] = mod.VkDeviceMemoryReportEventTypeEXT("VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT"),
		["unimport_ext"] = mod.VkDeviceMemoryReportEventTypeEXT("VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT"),
		["allocation_failed_ext"] = mod.VkDeviceMemoryReportEventTypeEXT("VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDeviceMemoryReportEventTypeEXT")
	end

	return lookup[s] or
		error(
			"unknown VkDeviceMemoryReportEventTypeEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPresentModeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["fifo_latest_ready_ext"] = mod.VkPresentModeKHR("VK_PRESENT_MODE_FIFO_LATEST_READY_EXT"),
		["fifo_relaxed_khr"] = mod.VkPresentModeKHR("VK_PRESENT_MODE_FIFO_RELAXED_KHR"),
		["fifo_latest_ready_khr"] = mod.VkPresentModeKHR("VK_PRESENT_MODE_FIFO_LATEST_READY_KHR"),
		["immediate_khr"] = mod.VkPresentModeKHR("VK_PRESENT_MODE_IMMEDIATE_KHR"),
		["shared_continuous_refresh_khr"] = mod.VkPresentModeKHR("VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"),
		["mailbox_khr"] = mod.VkPresentModeKHR("VK_PRESENT_MODE_MAILBOX_KHR"),
		["shared_demand_refresh_khr"] = mod.VkPresentModeKHR("VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"),
		["fifo_khr"] = mod.VkPresentModeKHR("VK_PRESENT_MODE_FIFO_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPresentModeKHR")
	end

	return lookup[s] or
		error("unknown VkPresentModeKHR value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkAccelerationStructureTypeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["top_level_nv"] = mod.VkAccelerationStructureTypeKHR("VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV"),
		["top_level_khr"] = mod.VkAccelerationStructureTypeKHR("VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR"),
		["bottom_level_khr"] = mod.VkAccelerationStructureTypeKHR("VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR"),
		["generic_khr"] = mod.VkAccelerationStructureTypeKHR("VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR"),
		["bottom_level_nv"] = mod.VkAccelerationStructureTypeKHR("VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAccelerationStructureTypeKHR")
	end

	return lookup[s] or
		error(
			"unknown VkAccelerationStructureTypeKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkOpticalFlowGridSizeFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["1x1_nv"] = mod.VkOpticalFlowGridSizeFlagBitsNV("VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV"),
		["8x8_nv"] = mod.VkOpticalFlowGridSizeFlagBitsNV("VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV"),
		["2x2_nv"] = mod.VkOpticalFlowGridSizeFlagBitsNV("VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV"),
		["unknown_nv"] = mod.VkOpticalFlowGridSizeFlagBitsNV("VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV"),
		["4x4_nv"] = mod.VkOpticalFlowGridSizeFlagBitsNV("VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkOpticalFlowGridSizeFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkOpticalFlowGridSizeFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSamplerReductionMode = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["max"] = mod.VkSamplerReductionMode("VK_SAMPLER_REDUCTION_MODE_MAX"),
		["max_ext"] = mod.VkSamplerReductionMode("VK_SAMPLER_REDUCTION_MODE_MAX_EXT"),
		["weighted_average_rangeclamp_qcom"] = mod.VkSamplerReductionMode("VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM"),
		["min_ext"] = mod.VkSamplerReductionMode("VK_SAMPLER_REDUCTION_MODE_MIN_EXT"),
		["weighted_average_ext"] = mod.VkSamplerReductionMode("VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT"),
		["min"] = mod.VkSamplerReductionMode("VK_SAMPLER_REDUCTION_MODE_MIN"),
		["weighted_average"] = mod.VkSamplerReductionMode("VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSamplerReductionMode")
	end

	return lookup[s] or
		error("unknown VkSamplerReductionMode value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkShaderStageFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["any_hit_nv"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_ANY_HIT_BIT_NV"),
		["raygen_khr"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_RAYGEN_BIT_KHR"),
		["subpass_shading_huawei"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI"),
		["any_hit_khr"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_ANY_HIT_BIT_KHR"),
		["geometry"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_GEOMETRY_BIT"),
		["closest_hit_khr"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR"),
		["intersection_nv"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_INTERSECTION_BIT_NV"),
		["miss_khr"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_MISS_BIT_KHR"),
		["callable_nv"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_CALLABLE_BIT_NV"),
		["intersection_khr"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_INTERSECTION_BIT_KHR"),
		["task_nv"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_TASK_BIT_NV"),
		["vertex"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_VERTEX_BIT"),
		["mesh_nv"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_MESH_BIT_NV"),
		["tessellation_control"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"),
		["miss_nv"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_MISS_BIT_NV"),
		["closest_hit_nv"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV"),
		["mesh_ext"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_MESH_BIT_EXT"),
		["callable_khr"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_CALLABLE_BIT_KHR"),
		["task_ext"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_TASK_BIT_EXT"),
		["all"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_ALL"),
		["cluster_culling_huawei"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI"),
		["fragment"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_FRAGMENT_BIT"),
		["tessellation_evaluation"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"),
		["raygen_nv"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_RAYGEN_BIT_NV"),
		["all_graphics"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_ALL_GRAPHICS"),
		["compute"] = mod.VkShaderStageFlagBits("VK_SHADER_STAGE_COMPUTE_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkShaderStageFlagBits")
	end

	return lookup[s] or
		error("unknown VkShaderStageFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkCopyAccelerationStructureModeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["compact_khr"] = mod.VkCopyAccelerationStructureModeKHR("VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR"),
		["serialize_khr"] = mod.VkCopyAccelerationStructureModeKHR("VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR"),
		["deserialize_khr"] = mod.VkCopyAccelerationStructureModeKHR("VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR"),
		["compact_nv"] = mod.VkCopyAccelerationStructureModeKHR("VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV"),
		["clone_khr"] = mod.VkCopyAccelerationStructureModeKHR("VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR"),
		["clone_nv"] = mod.VkCopyAccelerationStructureModeKHR("VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCopyAccelerationStructureModeKHR")
	end

	return lookup[s] or
		error(
			"unknown VkCopyAccelerationStructureModeKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkOpticalFlowUsageFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["output_nv"] = mod.VkOpticalFlowUsageFlagBitsNV("VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV"),
		["global_flow_nv"] = mod.VkOpticalFlowUsageFlagBitsNV("VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV"),
		["hint_nv"] = mod.VkOpticalFlowUsageFlagBitsNV("VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV"),
		["unknown_nv"] = mod.VkOpticalFlowUsageFlagBitsNV("VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV"),
		["input_nv"] = mod.VkOpticalFlowUsageFlagBitsNV("VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV"),
		["cost_nv"] = mod.VkOpticalFlowUsageFlagBitsNV("VK_OPTICAL_FLOW_USAGE_COST_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkOpticalFlowUsageFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkOpticalFlowUsageFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSemaphoreType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["binary"] = mod.VkSemaphoreType("VK_SEMAPHORE_TYPE_BINARY"),
		["timeline_khr"] = mod.VkSemaphoreType("VK_SEMAPHORE_TYPE_TIMELINE_KHR"),
		["binary_khr"] = mod.VkSemaphoreType("VK_SEMAPHORE_TYPE_BINARY_KHR"),
		["timeline"] = mod.VkSemaphoreType("VK_SEMAPHORE_TYPE_TIMELINE"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkSemaphoreType") end

	return lookup[s] or
		error("unknown VkSemaphoreType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkValidationCheckEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["all_ext"] = mod.VkValidationCheckEXT("VK_VALIDATION_CHECK_ALL_EXT"),
		["shaders_ext"] = mod.VkValidationCheckEXT("VK_VALIDATION_CHECK_SHADERS_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkValidationCheckEXT")
	end

	return lookup[s] or
		error("unknown VkValidationCheckEXT value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkAccelerationStructureMemoryRequirementsTypeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["update_scratch_nv"] = mod.VkAccelerationStructureMemoryRequirementsTypeNV("VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV"),
		["object_nv"] = mod.VkAccelerationStructureMemoryRequirementsTypeNV("VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV"),
		["build_scratch_nv"] = mod.VkAccelerationStructureMemoryRequirementsTypeNV("VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAccelerationStructureMemoryRequirementsTypeNV")
	end

	return lookup[s] or
		error(
			"unknown VkAccelerationStructureMemoryRequirementsTypeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkOpticalFlowSessionCreateFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["enable_hint_nv"] = mod.VkOpticalFlowSessionCreateFlagBitsNV("VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV"),
		["allow_regions_nv"] = mod.VkOpticalFlowSessionCreateFlagBitsNV("VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV"),
		["enable_cost_nv"] = mod.VkOpticalFlowSessionCreateFlagBitsNV("VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV"),
		["both_directions_nv"] = mod.VkOpticalFlowSessionCreateFlagBitsNV("VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV"),
		["enable_global_flow_nv"] = mod.VkOpticalFlowSessionCreateFlagBitsNV("VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkOpticalFlowSessionCreateFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkOpticalFlowSessionCreateFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkGeometryFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["no_duplicate_any_hit_invocation_khr"] = mod.VkGeometryFlagBitsKHR("VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR"),
		["opaque_khr"] = mod.VkGeometryFlagBitsKHR("VK_GEOMETRY_OPAQUE_BIT_KHR"),
		["no_duplicate_any_hit_invocation_nv"] = mod.VkGeometryFlagBitsKHR("VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV"),
		["opaque_nv"] = mod.VkGeometryFlagBitsKHR("VK_GEOMETRY_OPAQUE_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkGeometryFlagBitsKHR")
	end

	return lookup[s] or
		error("unknown VkGeometryFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkImageTiling = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["optimal"] = mod.VkImageTiling("VK_IMAGE_TILING_OPTIMAL"),
		["linear"] = mod.VkImageTiling("VK_IMAGE_TILING_LINEAR"),
		["drm_format_modifier_ext"] = mod.VkImageTiling("VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkImageTiling") end

	return lookup[s] or
		error("unknown VkImageTiling value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkDeviceFaultAddressTypeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["none_ext"] = mod.VkDeviceFaultAddressTypeEXT("VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT"),
		["instruction_pointer_fault_ext"] = mod.VkDeviceFaultAddressTypeEXT("VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT"),
		["read_invalid_ext"] = mod.VkDeviceFaultAddressTypeEXT("VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT"),
		["instruction_pointer_invalid_ext"] = mod.VkDeviceFaultAddressTypeEXT("VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT"),
		["write_invalid_ext"] = mod.VkDeviceFaultAddressTypeEXT("VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT"),
		["instruction_pointer_unknown_ext"] = mod.VkDeviceFaultAddressTypeEXT("VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT"),
		["execute_invalid_ext"] = mod.VkDeviceFaultAddressTypeEXT("VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDeviceFaultAddressTypeEXT")
	end

	return lookup[s] or
		error(
			"unknown VkDeviceFaultAddressTypeEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoDecodeH264FieldOrderCount = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["top"] = mod.StdVideoDecodeH264FieldOrderCount("STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_TOP"),
		["invalid"] = mod.StdVideoDecodeH264FieldOrderCount("STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_INVALID"),
		["bottom"] = mod.StdVideoDecodeH264FieldOrderCount("STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_BOTTOM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoDecodeH264FieldOrderCount")
	end

	return lookup[s] or
		error(
			"unknown StdVideoDecodeH264FieldOrderCount value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkClusterAccelerationStructureClusterFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["allow_disable_opacity_micromaps_nv"] = mod.VkClusterAccelerationStructureClusterFlagBitsNV("VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkClusterAccelerationStructureClusterFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkClusterAccelerationStructureClusterFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkImageType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["1d"] = mod.VkImageType("VK_IMAGE_TYPE_1D"),
		["3d"] = mod.VkImageType("VK_IMAGE_TYPE_3D"),
		["2d"] = mod.VkImageType("VK_IMAGE_TYPE_2D"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkImageType") end

	return lookup[s] or
		error("unknown VkImageType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkExternalSemaphoreFeatureFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["importable"] = mod.VkExternalSemaphoreFeatureFlagBits("VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"),
		["exportable"] = mod.VkExternalSemaphoreFeatureFlagBits("VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"),
		["importable_khr"] = mod.VkExternalSemaphoreFeatureFlagBits("VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR"),
		["exportable_khr"] = mod.VkExternalSemaphoreFeatureFlagBits("VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkExternalSemaphoreFeatureFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkExternalSemaphoreFeatureFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkImageCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["split_instance_bind_regions"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"),
		["split_instance_bind_regions_khr"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR"),
		["descriptor_buffer_capture_replay_ext"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"),
		["2d_array_compatible_khr"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR"),
		["mutable_format"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"),
		["block_texel_view_compatible_khr"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR"),
		["extended_usage"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"),
		["extended_usage_khr"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR"),
		["disjoint"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_DISJOINT_BIT"),
		["sparse_binding"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_SPARSE_BINDING_BIT"),
		["fragment_density_map_offset_qcom"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM"),
		["corner_sampled_nv"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV"),
		["sparse_residency"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"),
		["alias_khr"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_ALIAS_BIT_KHR"),
		["sample_locations_compatible_depth_ext"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT"),
		["sparse_aliased"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"),
		["disjoint_khr"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_DISJOINT_BIT_KHR"),
		["subsampled_ext"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT"),
		["protected"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_PROTECTED_BIT"),
		["2d_array_compatible"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT"),
		["multisampled_render_to_single_sampled_ext"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT"),
		["video_profile_independent_khr"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR"),
		["cube_compatible"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"),
		["2d_view_compatible_ext"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT"),
		["block_texel_view_compatible"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"),
		["alias"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_ALIAS_BIT"),
		["fragment_density_map_offset_ext"] = mod.VkImageCreateFlagBits("VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkImageCreateFlagBits")
	end

	return lookup[s] or
		error("unknown VkImageCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkGeometryInstanceFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["triangle_front_counterclockwise_nv"] = mod.VkGeometryInstanceFlagBitsKHR("VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV"),
		["force_no_opaque_khr"] = mod.VkGeometryInstanceFlagBitsKHR("VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR"),
		["force_opaque_nv"] = mod.VkGeometryInstanceFlagBitsKHR("VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV"),
		["force_opacity_micromap_2_state_ext"] = mod.VkGeometryInstanceFlagBitsKHR("VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT"),
		["force_no_opaque_nv"] = mod.VkGeometryInstanceFlagBitsKHR("VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV"),
		["disable_opacity_micromaps_ext"] = mod.VkGeometryInstanceFlagBitsKHR("VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT"),
		["triangle_facing_cull_disable_khr"] = mod.VkGeometryInstanceFlagBitsKHR("VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR"),
		["triangle_front_counterclockwise_khr"] = mod.VkGeometryInstanceFlagBitsKHR("VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR"),
		["triangle_flip_facing_khr"] = mod.VkGeometryInstanceFlagBitsKHR("VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR"),
		["triangle_cull_disable_nv"] = mod.VkGeometryInstanceFlagBitsKHR("VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV"),
		["force_opaque_khr"] = mod.VkGeometryInstanceFlagBitsKHR("VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkGeometryInstanceFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkGeometryInstanceFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkCullModeFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["front_and_back"] = mod.VkCullModeFlagBits("VK_CULL_MODE_FRONT_AND_BACK"),
		["front"] = mod.VkCullModeFlagBits("VK_CULL_MODE_FRONT_BIT"),
		["back"] = mod.VkCullModeFlagBits("VK_CULL_MODE_BACK_BIT"),
		["none"] = mod.VkCullModeFlagBits("VK_CULL_MODE_NONE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCullModeFlagBits")
	end

	return lookup[s] or
		error("unknown VkCullModeFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkClusterAccelerationStructureIndexFormatFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["8bit_nv"] = mod.VkClusterAccelerationStructureIndexFormatFlagBitsNV("VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV"),
		["32bit_nv"] = mod.VkClusterAccelerationStructureIndexFormatFlagBitsNV("VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV"),
		["16bit_nv"] = mod.VkClusterAccelerationStructureIndexFormatFlagBitsNV("VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkClusterAccelerationStructureIndexFormatFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkClusterAccelerationStructureIndexFormatFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkQueryType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["primitives_generated_ext"] = mod.VkQueryType("VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT"),
		["acceleration_structure_serialization_bottom_level_pointers_khr"] = mod.VkQueryType("VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR"),
		["acceleration_structure_size_khr"] = mod.VkQueryType("VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR"),
		["micromap_serialization_size_ext"] = mod.VkQueryType("VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT"),
		["occlusion"] = mod.VkQueryType("VK_QUERY_TYPE_OCCLUSION"),
		["pipeline_statistics"] = mod.VkQueryType("VK_QUERY_TYPE_PIPELINE_STATISTICS"),
		["timestamp"] = mod.VkQueryType("VK_QUERY_TYPE_TIMESTAMP"),
		["result_status_only_khr"] = mod.VkQueryType("VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR"),
		["transform_feedback_stream_ext"] = mod.VkQueryType("VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT"),
		["performance_query_khr"] = mod.VkQueryType("VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR"),
		["acceleration_structure_compacted_size_khr"] = mod.VkQueryType("VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR"),
		["acceleration_structure_serialization_size_khr"] = mod.VkQueryType("VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR"),
		["acceleration_structure_compacted_size_nv"] = mod.VkQueryType("VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV"),
		["performance_query_intel"] = mod.VkQueryType("VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL"),
		["video_encode_feedback_khr"] = mod.VkQueryType("VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR"),
		["mesh_primitives_generated_ext"] = mod.VkQueryType("VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT"),
		["micromap_compacted_size_ext"] = mod.VkQueryType("VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkQueryType") end

	return lookup[s] or
		error("unknown VkQueryType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoDecodeH264PictureLayoutFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["interlaced_separate_planes_khr"] = mod.VkVideoDecodeH264PictureLayoutFlagBitsKHR("VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR"),
		["interlaced_interleaved_lines_khr"] = mod.VkVideoDecodeH264PictureLayoutFlagBitsKHR("VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR"),
		["progressive_khr"] = mod.VkVideoDecodeH264PictureLayoutFlagBitsKHR("VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoDecodeH264PictureLayoutFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoDecodeH264PictureLayoutFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSemaphoreWaitFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["any_khr"] = mod.VkSemaphoreWaitFlagBits("VK_SEMAPHORE_WAIT_ANY_BIT_KHR"),
		["any"] = mod.VkSemaphoreWaitFlagBits("VK_SEMAPHORE_WAIT_ANY_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSemaphoreWaitFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkSemaphoreWaitFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPipelineDepthStencilStateCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["rasterization_order_attachment_depth_access_ext"] = mod.VkPipelineDepthStencilStateCreateFlagBits(
			"VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"
		),
		["rasterization_order_attachment_stencil_access_arm"] = mod.VkPipelineDepthStencilStateCreateFlagBits(
			"VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM"
		),
		["rasterization_order_attachment_depth_access_arm"] = mod.VkPipelineDepthStencilStateCreateFlagBits(
			"VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM"
		),
		["rasterization_order_attachment_stencil_access_ext"] = mod.VkPipelineDepthStencilStateCreateFlagBits(
			"VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"
		),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineDepthStencilStateCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineDepthStencilStateCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkBuildAccelerationStructureFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["prefer_fast_trace_khr"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR"),
		["prefer_fast_build_nv"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV"),
		["allow_data_access_khr"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR"),
		["prefer_fast_build_khr"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR"),
		["low_memory_nv"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV"),
		["allow_cluster_opacity_micromaps_nv"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV"),
		["low_memory_khr"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR"),
		["allow_compaction_nv"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV"),
		["allow_update_nv"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV"),
		["allow_opacity_micromap_update_ext"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT"),
		["allow_update_khr"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR"),
		["motion_nv"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV"),
		["allow_disable_opacity_micromaps_ext"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT"),
		["allow_compaction_khr"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR"),
		["prefer_fast_trace_nv"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV"),
		["allow_opacity_micromap_data_update_ext"] = mod.VkBuildAccelerationStructureFlagBitsKHR("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkBuildAccelerationStructureFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkBuildAccelerationStructureFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkConditionalRenderingFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["inverted_ext"] = mod.VkConditionalRenderingFlagBitsEXT("VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkConditionalRenderingFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkConditionalRenderingFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPipelineColorBlendStateCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["rasterization_order_attachment_access_ext"] = mod.VkPipelineColorBlendStateCreateFlagBits(
			"VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT"
		),
		["rasterization_order_attachment_access_arm"] = mod.VkPipelineColorBlendStateCreateFlagBits(
			"VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM"
		),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineColorBlendStateCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineColorBlendStateCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPipelineLayoutCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["independent_sets_ext"] = mod.VkPipelineLayoutCreateFlagBits("VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineLayoutCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineLayoutCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSamplerCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["non_seamless_cube_map_ext"] = mod.VkSamplerCreateFlagBits("VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT"),
		["descriptor_buffer_capture_replay_ext"] = mod.VkSamplerCreateFlagBits("VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"),
		["image_processing_qcom"] = mod.VkSamplerCreateFlagBits("VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM"),
		["subsampled_ext"] = mod.VkSamplerCreateFlagBits("VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT"),
		["subsampled_coarse_reconstruction_ext"] = mod.VkSamplerCreateFlagBits("VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSamplerCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkSamplerCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH265ChromaFormatIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["420"] = mod.StdVideoH265ChromaFormatIdc("STD_VIDEO_H265_CHROMA_FORMAT_IDC_420"),
		["422"] = mod.StdVideoH265ChromaFormatIdc("STD_VIDEO_H265_CHROMA_FORMAT_IDC_422"),
		["444"] = mod.StdVideoH265ChromaFormatIdc("STD_VIDEO_H265_CHROMA_FORMAT_IDC_444"),
		["invalid"] = mod.StdVideoH265ChromaFormatIdc("STD_VIDEO_H265_CHROMA_FORMAT_IDC_INVALID"),
		["monochrome"] = mod.StdVideoH265ChromaFormatIdc("STD_VIDEO_H265_CHROMA_FORMAT_IDC_MONOCHROME"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH265ChromaFormatIdc")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH265ChromaFormatIdc value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDeviceDiagnosticsConfigFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["enable_shader_debug_info_nv"] = mod.VkDeviceDiagnosticsConfigFlagBitsNV("VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV"),
		["enable_shader_error_reporting_nv"] = mod.VkDeviceDiagnosticsConfigFlagBitsNV("VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV"),
		["enable_automatic_checkpoints_nv"] = mod.VkDeviceDiagnosticsConfigFlagBitsNV("VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV"),
		["enable_resource_tracking_nv"] = mod.VkDeviceDiagnosticsConfigFlagBitsNV("VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDeviceDiagnosticsConfigFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkDeviceDiagnosticsConfigFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPipelineExecutableStatisticFormatKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["float64_khr"] = mod.VkPipelineExecutableStatisticFormatKHR("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR"),
		["int64_khr"] = mod.VkPipelineExecutableStatisticFormatKHR("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR"),
		["uint64_khr"] = mod.VkPipelineExecutableStatisticFormatKHR("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR"),
		["bool32_khr"] = mod.VkPipelineExecutableStatisticFormatKHR("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineExecutableStatisticFormatKHR")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineExecutableStatisticFormatKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkClusterAccelerationStructureTypeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["clusters_bottom_level_nv"] = mod.VkClusterAccelerationStructureTypeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV"),
		["triangle_cluster_nv"] = mod.VkClusterAccelerationStructureTypeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV"),
		["triangle_cluster_template_nv"] = mod.VkClusterAccelerationStructureTypeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkClusterAccelerationStructureTypeNV")
	end

	return lookup[s] or
		error(
			"unknown VkClusterAccelerationStructureTypeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkClusterAccelerationStructureOpTypeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["build_triangle_cluster_template_nv"] = mod.VkClusterAccelerationStructureOpTypeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV"),
		["move_objects_nv"] = mod.VkClusterAccelerationStructureOpTypeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV"),
		["get_cluster_template_indices_nv"] = mod.VkClusterAccelerationStructureOpTypeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV"),
		["build_clusters_bottom_level_nv"] = mod.VkClusterAccelerationStructureOpTypeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV"),
		["instantiate_triangle_cluster_nv"] = mod.VkClusterAccelerationStructureOpTypeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV"),
		["build_triangle_cluster_nv"] = mod.VkClusterAccelerationStructureOpTypeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkClusterAccelerationStructureOpTypeNV")
	end

	return lookup[s] or
		error(
			"unknown VkClusterAccelerationStructureOpTypeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH265LevelIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["1_0"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_1_0"),
		["2_0"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_2_0"),
		["2_1"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_2_1"),
		["3_0"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_3_0"),
		["3_1"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_3_1"),
		["4_0"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_4_0"),
		["4_1"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_4_1"),
		["5_0"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_5_0"),
		["5_1"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_5_1"),
		["5_2"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_5_2"),
		["6_0"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_6_0"),
		["6_1"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_6_1"),
		["6_2"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_6_2"),
		["invalid"] = mod.StdVideoH265LevelIdc("STD_VIDEO_H265_LEVEL_IDC_INVALID"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH265LevelIdc")
	end

	return lookup[s] or
		error("unknown StdVideoH265LevelIdc value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkPipelineCacheHeaderVersion = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["one"] = mod.VkPipelineCacheHeaderVersion("VK_PIPELINE_CACHE_HEADER_VERSION_ONE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineCacheHeaderVersion")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineCacheHeaderVersion value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkAntiLagModeAMD = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["on_amd"] = mod.VkAntiLagModeAMD("VK_ANTI_LAG_MODE_ON_AMD"),
		["driver_control_amd"] = mod.VkAntiLagModeAMD("VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD"),
		["off_amd"] = mod.VkAntiLagModeAMD("VK_ANTI_LAG_MODE_OFF_AMD"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAntiLagModeAMD")
	end

	return lookup[s] or
		error("unknown VkAntiLagModeAMD value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkSurfaceCounterFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["vblank_ext"] = mod.VkSurfaceCounterFlagBitsEXT("VK_SURFACE_COUNTER_VBLANK_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSurfaceCounterFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkSurfaceCounterFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkComponentTypeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["sint16_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_SINT16_KHR"),
		["uint16_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_UINT16_NV"),
		["sint32_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_SINT32_KHR"),
		["uint32_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_UINT32_NV"),
		["sint64_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_SINT64_KHR"),
		["uint64_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_UINT64_NV"),
		["uint16_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_UINT16_KHR"),
		["uint8_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_UINT8_KHR"),
		["uint32_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_UINT32_KHR"),
		["float_e5m2_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_FLOAT_E5M2_NV"),
		["bfloat16_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_BFLOAT16_KHR"),
		["sint8_packed_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_SINT8_PACKED_NV"),
		["uint8_packed_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_UINT8_PACKED_NV"),
		["uint64_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_UINT64_KHR"),
		["float8_e4m3_ext"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT"),
		["float64_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_FLOAT64_KHR"),
		["float8_e5m2_ext"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT"),
		["float16_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_FLOAT16_NV"),
		["float_e4m3_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_FLOAT_E4M3_NV"),
		["float32_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_FLOAT32_NV"),
		["sint8_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_SINT8_NV"),
		["float64_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_FLOAT64_NV"),
		["sint16_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_SINT16_NV"),
		["float16_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_FLOAT16_KHR"),
		["sint32_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_SINT32_NV"),
		["float32_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_FLOAT32_KHR"),
		["sint64_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_SINT64_NV"),
		["sint8_khr"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_SINT8_KHR"),
		["uint8_nv"] = mod.VkComponentTypeKHR("VK_COMPONENT_TYPE_UINT8_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkComponentTypeKHR")
	end

	return lookup[s] or
		error("unknown VkComponentTypeKHR value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkClusterAccelerationStructureOpModeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["implicit_destinations_nv"] = mod.VkClusterAccelerationStructureOpModeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV"),
		["explicit_destinations_nv"] = mod.VkClusterAccelerationStructureOpModeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV"),
		["compute_sizes_nv"] = mod.VkClusterAccelerationStructureOpModeNV("VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkClusterAccelerationStructureOpModeNV")
	end

	return lookup[s] or
		error(
			"unknown VkClusterAccelerationStructureOpModeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkAntiLagStageAMD = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["input_amd"] = mod.VkAntiLagStageAMD("VK_ANTI_LAG_STAGE_INPUT_AMD"),
		["present_amd"] = mod.VkAntiLagStageAMD("VK_ANTI_LAG_STAGE_PRESENT_AMD"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAntiLagStageAMD")
	end

	return lookup[s] or
		error("unknown VkAntiLagStageAMD value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkClusterAccelerationStructureAddressResolutionFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["indirected_dst_address_array_nv"] = mod.VkClusterAccelerationStructureAddressResolutionFlagBitsNV(
			"VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV"
		),
		["indirected_src_infos_count_nv"] = mod.VkClusterAccelerationStructureAddressResolutionFlagBitsNV(
			"VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV"
		),
		["indirected_dst_implicit_data_nv"] = mod.VkClusterAccelerationStructureAddressResolutionFlagBitsNV(
			"VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV"
		),
		["none_nv"] = mod.VkClusterAccelerationStructureAddressResolutionFlagBitsNV("VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV"),
		["indirected_scratch_data_nv"] = mod.VkClusterAccelerationStructureAddressResolutionFlagBitsNV(
			"VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV"
		),
		["indirected_src_infos_array_nv"] = mod.VkClusterAccelerationStructureAddressResolutionFlagBitsNV(
			"VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV"
		),
		["indirected_dst_sizes_array_nv"] = mod.VkClusterAccelerationStructureAddressResolutionFlagBitsNV(
			"VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV"
		),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkClusterAccelerationStructureAddressResolutionFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkClusterAccelerationStructureAddressResolutionFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkAttachmentDescriptionFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["may_alias"] = mod.VkAttachmentDescriptionFlagBits("VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAttachmentDescriptionFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkAttachmentDescriptionFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH265SliceType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["p"] = mod.StdVideoH265SliceType("STD_VIDEO_H265_SLICE_TYPE_P"),
		["invalid"] = mod.StdVideoH265SliceType("STD_VIDEO_H265_SLICE_TYPE_INVALID"),
		["b"] = mod.StdVideoH265SliceType("STD_VIDEO_H265_SLICE_TYPE_B"),
		["i"] = mod.StdVideoH265SliceType("STD_VIDEO_H265_SLICE_TYPE_I"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH265SliceType")
	end

	return lookup[s] or
		error("unknown StdVideoH265SliceType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkDisplayPowerStateEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["off_ext"] = mod.VkDisplayPowerStateEXT("VK_DISPLAY_POWER_STATE_OFF_EXT"),
		["on_ext"] = mod.VkDisplayPowerStateEXT("VK_DISPLAY_POWER_STATE_ON_EXT"),
		["suspend_ext"] = mod.VkDisplayPowerStateEXT("VK_DISPLAY_POWER_STATE_SUSPEND_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDisplayPowerStateEXT")
	end

	return lookup[s] or
		error("unknown VkDisplayPowerStateEXT value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkObjectType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["shader_module"] = mod.VkObjectType("VK_OBJECT_TYPE_SHADER_MODULE"),
		["shader_ext"] = mod.VkObjectType("VK_OBJECT_TYPE_SHADER_EXT"),
		["pipeline_cache"] = mod.VkObjectType("VK_OBJECT_TYPE_PIPELINE_CACHE"),
		["pipeline_binary_khr"] = mod.VkObjectType("VK_OBJECT_TYPE_PIPELINE_BINARY_KHR"),
		["pipeline_layout"] = mod.VkObjectType("VK_OBJECT_TYPE_PIPELINE_LAYOUT"),
		["render_pass"] = mod.VkObjectType("VK_OBJECT_TYPE_RENDER_PASS"),
		["descriptor_set_layout"] = mod.VkObjectType("VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"),
		["descriptor_pool"] = mod.VkObjectType("VK_OBJECT_TYPE_DESCRIPTOR_POOL"),
		["private_data_slot_ext"] = mod.VkObjectType("VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT"),
		["sampler_ycbcr_conversion_khr"] = mod.VkObjectType("VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR"),
		["command_pool"] = mod.VkObjectType("VK_OBJECT_TYPE_COMMAND_POOL"),
		["descriptor_update_template_khr"] = mod.VkObjectType("VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR"),
		["sampler_ycbcr_conversion"] = mod.VkObjectType("VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"),
		["indirect_execution_set_ext"] = mod.VkObjectType("VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT"),
		["descriptor_update_template"] = mod.VkObjectType("VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"),
		["instance"] = mod.VkObjectType("VK_OBJECT_TYPE_INSTANCE"),
		["private_data_slot"] = mod.VkObjectType("VK_OBJECT_TYPE_PRIVATE_DATA_SLOT"),
		["indirect_commands_layout_ext"] = mod.VkObjectType("VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT"),
		["surface_khr"] = mod.VkObjectType("VK_OBJECT_TYPE_SURFACE_KHR"),
		["external_compute_queue_nv"] = mod.VkObjectType("VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV"),
		["swapchain_khr"] = mod.VkObjectType("VK_OBJECT_TYPE_SWAPCHAIN_KHR"),
		["data_graph_pipeline_session_arm"] = mod.VkObjectType("VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM"),
		["display_khr"] = mod.VkObjectType("VK_OBJECT_TYPE_DISPLAY_KHR"),
		["unknown"] = mod.VkObjectType("VK_OBJECT_TYPE_UNKNOWN"),
		["display_mode_khr"] = mod.VkObjectType("VK_OBJECT_TYPE_DISPLAY_MODE_KHR"),
		["fence"] = mod.VkObjectType("VK_OBJECT_TYPE_FENCE"),
		["debug_report_callback_ext"] = mod.VkObjectType("VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"),
		["semaphore"] = mod.VkObjectType("VK_OBJECT_TYPE_SEMAPHORE"),
		["video_session_khr"] = mod.VkObjectType("VK_OBJECT_TYPE_VIDEO_SESSION_KHR"),
		["cu_function_nvx"] = mod.VkObjectType("VK_OBJECT_TYPE_CU_FUNCTION_NVX"),
		["video_session_parameters_khr"] = mod.VkObjectType("VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR"),
		["event"] = mod.VkObjectType("VK_OBJECT_TYPE_EVENT"),
		["cu_module_nvx"] = mod.VkObjectType("VK_OBJECT_TYPE_CU_MODULE_NVX"),
		["framebuffer"] = mod.VkObjectType("VK_OBJECT_TYPE_FRAMEBUFFER"),
		["descriptor_set"] = mod.VkObjectType("VK_OBJECT_TYPE_DESCRIPTOR_SET"),
		["device"] = mod.VkObjectType("VK_OBJECT_TYPE_DEVICE"),
		["buffer"] = mod.VkObjectType("VK_OBJECT_TYPE_BUFFER"),
		["micromap_ext"] = mod.VkObjectType("VK_OBJECT_TYPE_MICROMAP_EXT"),
		["acceleration_structure_khr"] = mod.VkObjectType("VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR"),
		["validation_cache_ext"] = mod.VkObjectType("VK_OBJECT_TYPE_VALIDATION_CACHE_EXT"),
		["physical_device"] = mod.VkObjectType("VK_OBJECT_TYPE_PHYSICAL_DEVICE"),
		["sampler"] = mod.VkObjectType("VK_OBJECT_TYPE_SAMPLER"),
		["acceleration_structure_nv"] = mod.VkObjectType("VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV"),
		["pipeline"] = mod.VkObjectType("VK_OBJECT_TYPE_PIPELINE"),
		["performance_configuration_intel"] = mod.VkObjectType("VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL"),
		["command_buffer"] = mod.VkObjectType("VK_OBJECT_TYPE_COMMAND_BUFFER"),
		["deferred_operation_khr"] = mod.VkObjectType("VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR"),
		["indirect_commands_layout_nv"] = mod.VkObjectType("VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV"),
		["device_memory"] = mod.VkObjectType("VK_OBJECT_TYPE_DEVICE_MEMORY"),
		["queue"] = mod.VkObjectType("VK_OBJECT_TYPE_QUEUE"),
		["buffer_collection_fuchsia"] = mod.VkObjectType("VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA"),
		["debug_utils_messenger_ext"] = mod.VkObjectType("VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"),
		["image"] = mod.VkObjectType("VK_OBJECT_TYPE_IMAGE"),
		["query_pool"] = mod.VkObjectType("VK_OBJECT_TYPE_QUERY_POOL"),
		["tensor_arm"] = mod.VkObjectType("VK_OBJECT_TYPE_TENSOR_ARM"),
		["buffer_view"] = mod.VkObjectType("VK_OBJECT_TYPE_BUFFER_VIEW"),
		["tensor_view_arm"] = mod.VkObjectType("VK_OBJECT_TYPE_TENSOR_VIEW_ARM"),
		["image_view"] = mod.VkObjectType("VK_OBJECT_TYPE_IMAGE_VIEW"),
		["optical_flow_session_nv"] = mod.VkObjectType("VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkObjectType") end

	return lookup[s] or
		error("unknown VkObjectType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.StdVideoH265PictureType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["idr"] = mod.StdVideoH265PictureType("STD_VIDEO_H265_PICTURE_TYPE_IDR"),
		["invalid"] = mod.StdVideoH265PictureType("STD_VIDEO_H265_PICTURE_TYPE_INVALID"),
		["p"] = mod.StdVideoH265PictureType("STD_VIDEO_H265_PICTURE_TYPE_P"),
		["b"] = mod.StdVideoH265PictureType("STD_VIDEO_H265_PICTURE_TYPE_B"),
		["i"] = mod.StdVideoH265PictureType("STD_VIDEO_H265_PICTURE_TYPE_I"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH265PictureType")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH265PictureType value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkQueryResultStatusKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["insufficient_bitstream_buffer_range_khr"] = mod.VkQueryResultStatusKHR("VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR"),
		["not_ready_khr"] = mod.VkQueryResultStatusKHR("VK_QUERY_RESULT_STATUS_NOT_READY_KHR"),
		["complete_khr"] = mod.VkQueryResultStatusKHR("VK_QUERY_RESULT_STATUS_COMPLETE_KHR"),
		["error_khr"] = mod.VkQueryResultStatusKHR("VK_QUERY_RESULT_STATUS_ERROR_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkQueryResultStatusKHR")
	end

	return lookup[s] or
		error("unknown VkQueryResultStatusKHR value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkPerformanceCounterUnitKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["bytes_khr"] = mod.VkPerformanceCounterUnitKHR("VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR"),
		["bytes_per_second_khr"] = mod.VkPerformanceCounterUnitKHR("VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR"),
		["kelvin_khr"] = mod.VkPerformanceCounterUnitKHR("VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR"),
		["watts_khr"] = mod.VkPerformanceCounterUnitKHR("VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR"),
		["volts_khr"] = mod.VkPerformanceCounterUnitKHR("VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR"),
		["amps_khr"] = mod.VkPerformanceCounterUnitKHR("VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR"),
		["cycles_khr"] = mod.VkPerformanceCounterUnitKHR("VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR"),
		["percentage_khr"] = mod.VkPerformanceCounterUnitKHR("VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR"),
		["hertz_khr"] = mod.VkPerformanceCounterUnitKHR("VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR"),
		["nanoseconds_khr"] = mod.VkPerformanceCounterUnitKHR("VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR"),
		["generic_khr"] = mod.VkPerformanceCounterUnitKHR("VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPerformanceCounterUnitKHR")
	end

	return lookup[s] or
		error(
			"unknown VkPerformanceCounterUnitKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkShaderCodeTypeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["spirv_ext"] = mod.VkShaderCodeTypeEXT("VK_SHADER_CODE_TYPE_SPIRV_EXT"),
		["binary_ext"] = mod.VkShaderCodeTypeEXT("VK_SHADER_CODE_TYPE_BINARY_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkShaderCodeTypeEXT")
	end

	return lookup[s] or
		error("unknown VkShaderCodeTypeEXT value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoCodecOperationFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["encode_h265_khr"] = mod.VkVideoCodecOperationFlagBitsKHR("VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR"),
		["decode_av1_khr"] = mod.VkVideoCodecOperationFlagBitsKHR("VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR"),
		["none_khr"] = mod.VkVideoCodecOperationFlagBitsKHR("VK_VIDEO_CODEC_OPERATION_NONE_KHR"),
		["decode_h264_khr"] = mod.VkVideoCodecOperationFlagBitsKHR("VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR"),
		["encode_av1_khr"] = mod.VkVideoCodecOperationFlagBitsKHR("VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR"),
		["encode_h264_khr"] = mod.VkVideoCodecOperationFlagBitsKHR("VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR"),
		["decode_h265_khr"] = mod.VkVideoCodecOperationFlagBitsKHR("VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR"),
		["decode_vp9_khr"] = mod.VkVideoCodecOperationFlagBitsKHR("VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoCodecOperationFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoCodecOperationFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264ChromaFormatIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["420"] = mod.StdVideoH264ChromaFormatIdc("STD_VIDEO_H264_CHROMA_FORMAT_IDC_420"),
		["422"] = mod.StdVideoH264ChromaFormatIdc("STD_VIDEO_H264_CHROMA_FORMAT_IDC_422"),
		["444"] = mod.StdVideoH264ChromaFormatIdc("STD_VIDEO_H264_CHROMA_FORMAT_IDC_444"),
		["invalid"] = mod.StdVideoH264ChromaFormatIdc("STD_VIDEO_H264_CHROMA_FORMAT_IDC_INVALID"),
		["monochrome"] = mod.StdVideoH264ChromaFormatIdc("STD_VIDEO_H264_CHROMA_FORMAT_IDC_MONOCHROME"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264ChromaFormatIdc")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH264ChromaFormatIdc value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkShaderCreateFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["dispatch_base_ext"] = mod.VkShaderCreateFlagBitsEXT("VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT"),
		["indirect_bindable_ext"] = mod.VkShaderCreateFlagBitsEXT("VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT"),
		["require_full_subgroups_ext"] = mod.VkShaderCreateFlagBitsEXT("VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT"),
		["fragment_shading_rate_attachment_ext"] = mod.VkShaderCreateFlagBitsEXT("VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT"),
		["link_stage_ext"] = mod.VkShaderCreateFlagBitsEXT("VK_SHADER_CREATE_LINK_STAGE_BIT_EXT"),
		["no_task_shader_ext"] = mod.VkShaderCreateFlagBitsEXT("VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT"),
		["fragment_density_map_attachment_ext"] = mod.VkShaderCreateFlagBitsEXT("VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"),
		["allow_varying_subgroup_size_ext"] = mod.VkShaderCreateFlagBitsEXT("VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkShaderCreateFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkShaderCreateFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPerformanceCounterScopeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["performance_counter_scope_command_khr"] = mod.VkPerformanceCounterScopeKHR("VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR"),
		["query_scope_command_buffer_khr"] = mod.VkPerformanceCounterScopeKHR("VK_QUERY_SCOPE_COMMAND_BUFFER_KHR"),
		["performance_counter_scope_command_buffer_khr"] = mod.VkPerformanceCounterScopeKHR("VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR"),
		["query_scope_command_khr"] = mod.VkPerformanceCounterScopeKHR("VK_QUERY_SCOPE_COMMAND_KHR"),
		["performance_counter_scope_render_pass_khr"] = mod.VkPerformanceCounterScopeKHR("VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR"),
		["query_scope_render_pass_khr"] = mod.VkPerformanceCounterScopeKHR("VK_QUERY_SCOPE_RENDER_PASS_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPerformanceCounterScopeKHR")
	end

	return lookup[s] or
		error(
			"unknown VkPerformanceCounterScopeKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264ProfileIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["invalid"] = mod.StdVideoH264ProfileIdc("STD_VIDEO_H264_PROFILE_IDC_INVALID"),
		["baseline"] = mod.StdVideoH264ProfileIdc("STD_VIDEO_H264_PROFILE_IDC_BASELINE"),
		["main"] = mod.StdVideoH264ProfileIdc("STD_VIDEO_H264_PROFILE_IDC_MAIN"),
		["high"] = mod.StdVideoH264ProfileIdc("STD_VIDEO_H264_PROFILE_IDC_HIGH"),
		["high_444_predictive"] = mod.StdVideoH264ProfileIdc("STD_VIDEO_H264_PROFILE_IDC_HIGH_444_PREDICTIVE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264ProfileIdc")
	end

	return lookup[s] or
		error("unknown StdVideoH264ProfileIdc value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoChromaSubsamplingFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["invalid_khr"] = mod.VkVideoChromaSubsamplingFlagBitsKHR("VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR"),
		["422_khr"] = mod.VkVideoChromaSubsamplingFlagBitsKHR("VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR"),
		["monochrome_khr"] = mod.VkVideoChromaSubsamplingFlagBitsKHR("VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR"),
		["444_khr"] = mod.VkVideoChromaSubsamplingFlagBitsKHR("VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR"),
		["420_khr"] = mod.VkVideoChromaSubsamplingFlagBitsKHR("VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoChromaSubsamplingFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoChromaSubsamplingFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPartitionedAccelerationStructureOpTypeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["write_instance_nv"] = mod.VkPartitionedAccelerationStructureOpTypeNV("VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV"),
		["update_instance_nv"] = mod.VkPartitionedAccelerationStructureOpTypeNV("VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV"),
		["write_partition_translation_nv"] = mod.VkPartitionedAccelerationStructureOpTypeNV("VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPartitionedAccelerationStructureOpTypeNV")
	end

	return lookup[s] or
		error(
			"unknown VkPartitionedAccelerationStructureOpTypeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264LevelIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["1_3"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_1_3"),
		["2_2"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_2_2"),
		["3_2"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_3_2"),
		["4_2"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_4_2"),
		["invalid"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_INVALID"),
		["1_0"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_1_0"),
		["1_1"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_1_1"),
		["2_0"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_2_0"),
		["2_1"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_2_1"),
		["3_0"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_3_0"),
		["3_1"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_3_1"),
		["4_0"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_4_0"),
		["4_1"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_4_1"),
		["5_0"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_5_0"),
		["5_1"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_5_1"),
		["5_2"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_5_2"),
		["6_0"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_6_0"),
		["6_1"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_6_1"),
		["6_2"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_6_2"),
		["1_2"] = mod.StdVideoH264LevelIdc("STD_VIDEO_H264_LEVEL_IDC_1_2"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264LevelIdc")
	end

	return lookup[s] or
		error("unknown StdVideoH264LevelIdc value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkPartitionedAccelerationStructureInstanceFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["triangle_facing_cull_disable_nv"] = mod.VkPartitionedAccelerationStructureInstanceFlagBitsNV(
			"VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV"
		),
		["triangle_flip_facing_nv"] = mod.VkPartitionedAccelerationStructureInstanceFlagBitsNV("VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV"),
		["force_opaque_nv"] = mod.VkPartitionedAccelerationStructureInstanceFlagBitsNV("VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV"),
		["enable_explicit_bounding_box_nv"] = mod.VkPartitionedAccelerationStructureInstanceFlagBitsNV(
			"VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV"
		),
		["force_no_opaque_nv"] = mod.VkPartitionedAccelerationStructureInstanceFlagBitsNV("VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPartitionedAccelerationStructureInstanceFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkPartitionedAccelerationStructureInstanceFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoComponentBitDepthFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["12_khr"] = mod.VkVideoComponentBitDepthFlagBitsKHR("VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR"),
		["invalid_khr"] = mod.VkVideoComponentBitDepthFlagBitsKHR("VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR"),
		["8_khr"] = mod.VkVideoComponentBitDepthFlagBitsKHR("VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR"),
		["10_khr"] = mod.VkVideoComponentBitDepthFlagBitsKHR("VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoComponentBitDepthFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoComponentBitDepthFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkAccelerationStructureCompatibilityKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["incompatible_khr"] = mod.VkAccelerationStructureCompatibilityKHR("VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR"),
		["compatible_khr"] = mod.VkAccelerationStructureCompatibilityKHR("VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAccelerationStructureCompatibilityKHR")
	end

	return lookup[s] or
		error(
			"unknown VkAccelerationStructureCompatibilityKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoCapabilityFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["separate_reference_images_khr"] = mod.VkVideoCapabilityFlagBitsKHR("VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR"),
		["protected_content_khr"] = mod.VkVideoCapabilityFlagBitsKHR("VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoCapabilityFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoCapabilityFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSampleCountFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["32"] = mod.VkSampleCountFlagBits("VK_SAMPLE_COUNT_32_BIT"),
		["16"] = mod.VkSampleCountFlagBits("VK_SAMPLE_COUNT_16_BIT"),
		["64"] = mod.VkSampleCountFlagBits("VK_SAMPLE_COUNT_64_BIT"),
		["4"] = mod.VkSampleCountFlagBits("VK_SAMPLE_COUNT_4_BIT"),
		["2"] = mod.VkSampleCountFlagBits("VK_SAMPLE_COUNT_2_BIT"),
		["8"] = mod.VkSampleCountFlagBits("VK_SAMPLE_COUNT_8_BIT"),
		["1"] = mod.VkSampleCountFlagBits("VK_SAMPLE_COUNT_1_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSampleCountFlagBits")
	end

	return lookup[s] or
		error("unknown VkSampleCountFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoSessionCreateFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["protected_content_khr"] = mod.VkVideoSessionCreateFlagBitsKHR("VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR"),
		["inline_queries_khr"] = mod.VkVideoSessionCreateFlagBitsKHR("VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR"),
		["allow_encode_quantization_delta_map_khr"] = mod.VkVideoSessionCreateFlagBitsKHR("VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR"),
		["inline_session_parameters_khr"] = mod.VkVideoSessionCreateFlagBitsKHR("VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR"),
		["allow_encode_emphasis_map_khr"] = mod.VkVideoSessionCreateFlagBitsKHR("VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR"),
		["allow_encode_parameter_optimizations_khr"] = mod.VkVideoSessionCreateFlagBitsKHR("VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoSessionCreateFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoSessionCreateFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkBuildMicromapFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["allow_compaction_ext"] = mod.VkBuildMicromapFlagBitsEXT("VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT"),
		["prefer_fast_build_ext"] = mod.VkBuildMicromapFlagBitsEXT("VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT"),
		["prefer_fast_trace_ext"] = mod.VkBuildMicromapFlagBitsEXT("VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkBuildMicromapFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkBuildMicromapFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkImageUsageFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["fragment_shading_rate_attachment_khr"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
		["tile_memory_qcom"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM"),
		["video_encode_dpb_khr"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR"),
		["sampled"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_SAMPLED_BIT"),
		["transfer_dst"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_TRANSFER_DST_BIT"),
		["invocation_mask_huawei"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI"),
		["transfer_src"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_TRANSFER_SRC_BIT"),
		["color_attachment"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"),
		["sample_weight_qcom"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM"),
		["video_encode_dst_khr"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR"),
		["depth_stencil_attachment"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"),
		["sample_block_match_qcom"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM"),
		["video_encode_src_khr"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR"),
		["transient_attachment"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"),
		["tensor_aliasing_arm"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM"),
		["video_encode_emphasis_map_khr"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR"),
		["input_attachment"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"),
		["storage"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_STORAGE_BIT"),
		["video_encode_quantization_delta_map_khr"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR"),
		["host_transfer"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_HOST_TRANSFER_BIT"),
		["video_decode_dst_khr"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR"),
		["attachment_feedback_loop_ext"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"),
		["video_decode_dpb_khr"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR"),
		["shading_rate_image_nv"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV"),
		["video_decode_src_khr"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR"),
		["fragment_density_map_ext"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT"),
		["host_transfer_ext"] = mod.VkImageUsageFlagBits("VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkImageUsageFlagBits")
	end

	return lookup[s] or
		error("unknown VkImageUsageFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkMicromapCreateFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["device_address_capture_replay_ext"] = mod.VkMicromapCreateFlagBitsEXT("VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkMicromapCreateFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkMicromapCreateFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["intra_refresh_khr"] = mod.VkVideoEncodeFlagBitsKHR("VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR"),
		["with_emphasis_map_khr"] = mod.VkVideoEncodeFlagBitsKHR("VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR"),
		["with_quantization_delta_map_khr"] = mod.VkVideoEncodeFlagBitsKHR("VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoSessionParametersCreateFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["quantization_map_compatible_khr"] = mod.VkVideoSessionParametersCreateFlagBitsKHR("VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoSessionParametersCreateFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoSessionParametersCreateFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264AspectRatioIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["extended_sar"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_EXTENDED_SAR"),
		["3_2"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_3_2"),
		["invalid"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_INVALID"),
		["unspecified"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_UNSPECIFIED"),
		["square"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_SQUARE"),
		["12_11"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_12_11"),
		["10_11"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_10_11"),
		["16_11"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_16_11"),
		["40_33"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_40_33"),
		["24_11"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_24_11"),
		["20_11"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_20_11"),
		["32_11"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_32_11"),
		["80_33"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_80_33"),
		["18_11"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_18_11"),
		["15_11"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_15_11"),
		["64_33"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_64_33"),
		["160_99"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_160_99"),
		["4_3"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_4_3"),
		["2_1"] = mod.StdVideoH264AspectRatioIdc("STD_VIDEO_H264_ASPECT_RATIO_IDC_2_1"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264AspectRatioIdc")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH264AspectRatioIdc value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeCapabilityFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["preceding_externally_encoded_bytes_khr"] = mod.VkVideoEncodeCapabilityFlagBitsKHR("VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR"),
		["emphasis_map_khr"] = mod.VkVideoEncodeCapabilityFlagBitsKHR("VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR"),
		["quantization_delta_map_khr"] = mod.VkVideoEncodeCapabilityFlagBitsKHR("VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR"),
		["insufficient_bitstream_buffer_range_detection_khr"] = mod.VkVideoEncodeCapabilityFlagBitsKHR(
			"VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR"
		),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeCapabilityFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeCapabilityFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoCodingControlFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["encode_rate_control_khr"] = mod.VkVideoCodingControlFlagBitsKHR("VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR"),
		["reset_khr"] = mod.VkVideoCodingControlFlagBitsKHR("VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR"),
		["encode_quality_level_khr"] = mod.VkVideoCodingControlFlagBitsKHR("VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoCodingControlFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoCodingControlFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkMemoryAllocateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["device_address_khr"] = mod.VkMemoryAllocateFlagBits("VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR"),
		["device_address_capture_replay"] = mod.VkMemoryAllocateFlagBits("VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"),
		["zero_initialize_ext"] = mod.VkMemoryAllocateFlagBits("VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT"),
		["device_mask"] = mod.VkMemoryAllocateFlagBits("VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"),
		["device_mask_khr"] = mod.VkMemoryAllocateFlagBits("VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR"),
		["device_address_capture_replay_khr"] = mod.VkMemoryAllocateFlagBits("VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR"),
		["device_address"] = mod.VkMemoryAllocateFlagBits("VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkMemoryAllocateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkMemoryAllocateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVendorId = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["mobileye"] = mod.VkVendorId("VK_VENDOR_ID_MOBILEYE"),
		["kazan"] = mod.VkVendorId("VK_VENDOR_ID_KAZAN"),
		["pocl"] = mod.VkVendorId("VK_VENDOR_ID_POCL"),
		["khronos"] = mod.VkVendorId("VK_VENDOR_ID_KHRONOS"),
		["mesa"] = mod.VkVendorId("VK_VENDOR_ID_MESA"),
		["viv"] = mod.VkVendorId("VK_VENDOR_ID_VIV"),
		["codeplay"] = mod.VkVendorId("VK_VENDOR_ID_CODEPLAY"),
		["vsi"] = mod.VkVendorId("VK_VENDOR_ID_VSI"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkVendorId") end

	return lookup[s] or
		error("unknown VkVendorId value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeRateControlModeFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["vbr_khr"] = mod.VkVideoEncodeRateControlModeFlagBitsKHR("VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"),
		["cbr_khr"] = mod.VkVideoEncodeRateControlModeFlagBitsKHR("VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR"),
		["disabled_khr"] = mod.VkVideoEncodeRateControlModeFlagBitsKHR("VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR"),
		["default_khr"] = mod.VkVideoEncodeRateControlModeFlagBitsKHR("VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeRateControlModeFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeRateControlModeFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkResult = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["error_unknown"] = mod.VkResult("VK_ERROR_UNKNOWN"),
		["error_validation_failed"] = mod.VkResult("VK_ERROR_VALIDATION_FAILED"),
		["error_out_of_pool_memory"] = mod.VkResult("VK_ERROR_OUT_OF_POOL_MEMORY"),
		["error_invalid_external_handle"] = mod.VkResult("VK_ERROR_INVALID_EXTERNAL_HANDLE"),
		["error_incompatible_shader_binary_ext"] = mod.VkResult("VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT"),
		["error_fragmentation"] = mod.VkResult("VK_ERROR_FRAGMENTATION"),
		["error_pipeline_compile_required_ext"] = mod.VkResult("VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT"),
		["error_invalid_opaque_capture_address"] = mod.VkResult("VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"),
		["pipeline_compile_required_ext"] = mod.VkResult("VK_PIPELINE_COMPILE_REQUIRED_EXT"),
		["pipeline_compile_required"] = mod.VkResult("VK_PIPELINE_COMPILE_REQUIRED"),
		["error_invalid_opaque_capture_address_khr"] = mod.VkResult("VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR"),
		["error_not_permitted"] = mod.VkResult("VK_ERROR_NOT_PERMITTED"),
		["error_invalid_device_address_ext"] = mod.VkResult("VK_ERROR_INVALID_DEVICE_ADDRESS_EXT"),
		["error_surface_lost_khr"] = mod.VkResult("VK_ERROR_SURFACE_LOST_KHR"),
		["error_not_permitted_khr"] = mod.VkResult("VK_ERROR_NOT_PERMITTED_KHR"),
		["error_native_window_in_use_khr"] = mod.VkResult("VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"),
		["error_not_permitted_ext"] = mod.VkResult("VK_ERROR_NOT_PERMITTED_EXT"),
		["suboptimal_khr"] = mod.VkResult("VK_SUBOPTIMAL_KHR"),
		["error_fragmentation_ext"] = mod.VkResult("VK_ERROR_FRAGMENTATION_EXT"),
		["error_out_of_date_khr"] = mod.VkResult("VK_ERROR_OUT_OF_DATE_KHR"),
		["error_invalid_external_handle_khr"] = mod.VkResult("VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR"),
		["error_incompatible_display_khr"] = mod.VkResult("VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"),
		["error_out_of_pool_memory_khr"] = mod.VkResult("VK_ERROR_OUT_OF_POOL_MEMORY_KHR"),
		["error_invalid_shader_nv"] = mod.VkResult("VK_ERROR_INVALID_SHADER_NV"),
		["error_validation_failed_ext"] = mod.VkResult("VK_ERROR_VALIDATION_FAILED_EXT"),
		["error_image_usage_not_supported_khr"] = mod.VkResult("VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR"),
		["success"] = mod.VkResult("VK_SUCCESS"),
		["error_video_picture_layout_not_supported_khr"] = mod.VkResult("VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR"),
		["not_ready"] = mod.VkResult("VK_NOT_READY"),
		["error_video_profile_operation_not_supported_khr"] = mod.VkResult("VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR"),
		["error_not_enough_space_khr"] = mod.VkResult("VK_ERROR_NOT_ENOUGH_SPACE_KHR"),
		["event_set"] = mod.VkResult("VK_EVENT_SET"),
		["pipeline_binary_missing_khr"] = mod.VkResult("VK_PIPELINE_BINARY_MISSING_KHR"),
		["event_reset"] = mod.VkResult("VK_EVENT_RESET"),
		["incompatible_shader_binary_ext"] = mod.VkResult("VK_INCOMPATIBLE_SHADER_BINARY_EXT"),
		["incomplete"] = mod.VkResult("VK_INCOMPLETE"),
		["error_compression_exhausted_ext"] = mod.VkResult("VK_ERROR_COMPRESSION_EXHAUSTED_EXT"),
		["error_out_of_host_memory"] = mod.VkResult("VK_ERROR_OUT_OF_HOST_MEMORY"),
		["error_invalid_video_std_parameters_khr"] = mod.VkResult("VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR"),
		["error_out_of_device_memory"] = mod.VkResult("VK_ERROR_OUT_OF_DEVICE_MEMORY"),
		["operation_not_deferred_khr"] = mod.VkResult("VK_OPERATION_NOT_DEFERRED_KHR"),
		["error_initialization_failed"] = mod.VkResult("VK_ERROR_INITIALIZATION_FAILED"),
		["operation_deferred_khr"] = mod.VkResult("VK_OPERATION_DEFERRED_KHR"),
		["error_device_lost"] = mod.VkResult("VK_ERROR_DEVICE_LOST"),
		["thread_done_khr"] = mod.VkResult("VK_THREAD_DONE_KHR"),
		["error_memory_map_failed"] = mod.VkResult("VK_ERROR_MEMORY_MAP_FAILED"),
		["thread_idle_khr"] = mod.VkResult("VK_THREAD_IDLE_KHR"),
		["error_layer_not_present"] = mod.VkResult("VK_ERROR_LAYER_NOT_PRESENT"),
		["error_full_screen_exclusive_mode_lost_ext"] = mod.VkResult("VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT"),
		["error_extension_not_present"] = mod.VkResult("VK_ERROR_EXTENSION_NOT_PRESENT"),
		["error_invalid_drm_format_modifier_plane_layout_ext"] = mod.VkResult("VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT"),
		["error_feature_not_present"] = mod.VkResult("VK_ERROR_FEATURE_NOT_PRESENT"),
		["error_video_std_version_not_supported_khr"] = mod.VkResult("VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR"),
		["error_incompatible_driver"] = mod.VkResult("VK_ERROR_INCOMPATIBLE_DRIVER"),
		["error_video_profile_codec_not_supported_khr"] = mod.VkResult("VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR"),
		["error_too_many_objects"] = mod.VkResult("VK_ERROR_TOO_MANY_OBJECTS"),
		["error_video_profile_format_not_supported_khr"] = mod.VkResult("VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR"),
		["error_format_not_supported"] = mod.VkResult("VK_ERROR_FORMAT_NOT_SUPPORTED"),
		["timeout"] = mod.VkResult("VK_TIMEOUT"),
		["error_fragmented_pool"] = mod.VkResult("VK_ERROR_FRAGMENTED_POOL"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkResult") end

	return lookup[s] or
		error("unknown VkResult value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeFeedbackFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["bitstream_has_overrides_khr"] = mod.VkVideoEncodeFeedbackFlagBitsKHR("VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR"),
		["bitstream_bytes_written_khr"] = mod.VkVideoEncodeFeedbackFlagBitsKHR("VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR"),
		["bitstream_buffer_offset_khr"] = mod.VkVideoEncodeFeedbackFlagBitsKHR("VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeFeedbackFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeFeedbackFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkExternalMemoryHandleTypeFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["d3d11_texture_kmt"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"),
		["mtltexture_ext"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT"),
		["opaque_fd"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"),
		["mtlheap_ext"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT"),
		["d3d12_resource"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"),
		["opaque_fd_khr"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"),
		["dma_buf_ext"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT"),
		["opaque_win32_khr"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"),
		["android_hardware_buffer_android"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID"),
		["opaque_win32_kmt_khr"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"),
		["host_allocation_ext"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT"),
		["d3d11_texture_khr"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR"),
		["host_mapped_foreign_memory_ext"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT"),
		["d3d11_texture_kmt_khr"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR"),
		["zircon_vmo_fuchsia"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA"),
		["d3d12_heap_khr"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR"),
		["opaque_win32"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"),
		["rdma_address_nv"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV"),
		["d3d12_resource_khr"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR"),
		["opaque_win32_kmt"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"),
		["screen_buffer_qnx"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX"),
		["d3d12_heap"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"),
		["d3d11_texture"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"),
		["mtlbuffer_ext"] = mod.VkExternalMemoryHandleTypeFlagBits("VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkExternalMemoryHandleTypeFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkExternalMemoryHandleTypeFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSystemAllocationScope = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["cache"] = mod.VkSystemAllocationScope("VK_SYSTEM_ALLOCATION_SCOPE_CACHE"),
		["object"] = mod.VkSystemAllocationScope("VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"),
		["instance"] = mod.VkSystemAllocationScope("VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"),
		["command"] = mod.VkSystemAllocationScope("VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"),
		["device"] = mod.VkSystemAllocationScope("VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSystemAllocationScope")
	end

	return lookup[s] or
		error(
			"unknown VkSystemAllocationScope value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkExportMetalObjectTypeFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["metal_command_queue_ext"] = mod.VkExportMetalObjectTypeFlagBitsEXT("VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT"),
		["metal_iosurface_ext"] = mod.VkExportMetalObjectTypeFlagBitsEXT("VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT"),
		["metal_buffer_ext"] = mod.VkExportMetalObjectTypeFlagBitsEXT("VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT"),
		["metal_shared_event_ext"] = mod.VkExportMetalObjectTypeFlagBitsEXT("VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT"),
		["metal_device_ext"] = mod.VkExportMetalObjectTypeFlagBitsEXT("VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT"),
		["metal_texture_ext"] = mod.VkExportMetalObjectTypeFlagBitsEXT("VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkExportMetalObjectTypeFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkExportMetalObjectTypeFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkFrontFace = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["counter_clockwise"] = mod.VkFrontFace("VK_FRONT_FACE_COUNTER_CLOCKWISE"),
		["clockwise"] = mod.VkFrontFace("VK_FRONT_FACE_CLOCKWISE"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkFrontFace") end

	return lookup[s] or
		error("unknown VkFrontFace value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkInstanceCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["enumerate_portability_khr"] = mod.VkInstanceCreateFlagBits("VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkInstanceCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkInstanceCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkInternalAllocationType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["executable"] = mod.VkInternalAllocationType("VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkInternalAllocationType")
	end

	return lookup[s] or
		error(
			"unknown VkInternalAllocationType value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVertexInputRate = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["vertex"] = mod.VkVertexInputRate("VK_VERTEX_INPUT_RATE_VERTEX"),
		["instance"] = mod.VkVertexInputRate("VK_VERTEX_INPUT_RATE_INSTANCE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVertexInputRate")
	end

	return lookup[s] or
		error("unknown VkVertexInputRate value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkRayTracingInvocationReorderModeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["reorder_nv"] = mod.VkRayTracingInvocationReorderModeNV("VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV"),
		["none_nv"] = mod.VkRayTracingInvocationReorderModeNV("VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkRayTracingInvocationReorderModeNV")
	end

	return lookup[s] or
		error(
			"unknown VkRayTracingInvocationReorderModeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkFormat = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["r64g64_sint"] = mod.VkFormat("VK_FORMAT_R64G64_SINT"),
		["r64g64_sfloat"] = mod.VkFormat("VK_FORMAT_R64G64_SFLOAT"),
		["a2r10g10b10_sscaled_pack32"] = mod.VkFormat("VK_FORMAT_A2R10G10B10_SSCALED_PACK32"),
		["a2r10g10b10_uint_pack32"] = mod.VkFormat("VK_FORMAT_A2R10G10B10_UINT_PACK32"),
		["a2r10g10b10_sint_pack32"] = mod.VkFormat("VK_FORMAT_A2R10G10B10_SINT_PACK32"),
		["a2b10g10r10_unorm_pack32"] = mod.VkFormat("VK_FORMAT_A2B10G10R10_UNORM_PACK32"),
		["a2b10g10r10_snorm_pack32"] = mod.VkFormat("VK_FORMAT_A2B10G10R10_SNORM_PACK32"),
		["a2b10g10r10_uscaled_pack32"] = mod.VkFormat("VK_FORMAT_A2B10G10R10_USCALED_PACK32"),
		["a2b10g10r10_sscaled_pack32"] = mod.VkFormat("VK_FORMAT_A2B10G10R10_SSCALED_PACK32"),
		["a2b10g10r10_uint_pack32"] = mod.VkFormat("VK_FORMAT_A2B10G10R10_UINT_PACK32"),
		["a2b10g10r10_sint_pack32"] = mod.VkFormat("VK_FORMAT_A2B10G10R10_SINT_PACK32"),
		["r16_unorm"] = mod.VkFormat("VK_FORMAT_R16_UNORM"),
		["r16_snorm"] = mod.VkFormat("VK_FORMAT_R16_SNORM"),
		["r16_uscaled"] = mod.VkFormat("VK_FORMAT_R16_USCALED"),
		["r16_sscaled"] = mod.VkFormat("VK_FORMAT_R16_SSCALED"),
		["r16_uint"] = mod.VkFormat("VK_FORMAT_R16_UINT"),
		["r16_sint"] = mod.VkFormat("VK_FORMAT_R16_SINT"),
		["r16_sfloat"] = mod.VkFormat("VK_FORMAT_R16_SFLOAT"),
		["r16g16_unorm"] = mod.VkFormat("VK_FORMAT_R16G16_UNORM"),
		["r16g16_snorm"] = mod.VkFormat("VK_FORMAT_R16G16_SNORM"),
		["r16g16_uscaled"] = mod.VkFormat("VK_FORMAT_R16G16_USCALED"),
		["r16g16_sscaled"] = mod.VkFormat("VK_FORMAT_R16G16_SSCALED"),
		["r16g16_uint"] = mod.VkFormat("VK_FORMAT_R16G16_UINT"),
		["r16g16_sint"] = mod.VkFormat("VK_FORMAT_R16G16_SINT"),
		["r16g16_sfloat"] = mod.VkFormat("VK_FORMAT_R16G16_SFLOAT"),
		["r16g16b16_unorm"] = mod.VkFormat("VK_FORMAT_R16G16B16_UNORM"),
		["r16g16b16_snorm"] = mod.VkFormat("VK_FORMAT_R16G16B16_SNORM"),
		["r16g16b16_uscaled"] = mod.VkFormat("VK_FORMAT_R16G16B16_USCALED"),
		["r16g16b16_sscaled"] = mod.VkFormat("VK_FORMAT_R16G16B16_SSCALED"),
		["r16g16b16_uint"] = mod.VkFormat("VK_FORMAT_R16G16B16_UINT"),
		["r16g16b16_sint"] = mod.VkFormat("VK_FORMAT_R16G16B16_SINT"),
		["r16g16b16_sfloat"] = mod.VkFormat("VK_FORMAT_R16G16B16_SFLOAT"),
		["r16g16b16a16_unorm"] = mod.VkFormat("VK_FORMAT_R16G16B16A16_UNORM"),
		["r16g16b16a16_snorm"] = mod.VkFormat("VK_FORMAT_R16G16B16A16_SNORM"),
		["r16g16b16a16_uscaled"] = mod.VkFormat("VK_FORMAT_R16G16B16A16_USCALED"),
		["r16g16b16a16_sscaled"] = mod.VkFormat("VK_FORMAT_R16G16B16A16_SSCALED"),
		["r16g16b16a16_uint"] = mod.VkFormat("VK_FORMAT_R16G16B16A16_UINT"),
		["r16g16b16a16_sint"] = mod.VkFormat("VK_FORMAT_R16G16B16A16_SINT"),
		["r16g16b16a16_sfloat"] = mod.VkFormat("VK_FORMAT_R16G16B16A16_SFLOAT"),
		["r32_uint"] = mod.VkFormat("VK_FORMAT_R32_UINT"),
		["r32_sint"] = mod.VkFormat("VK_FORMAT_R32_SINT"),
		["r32_sfloat"] = mod.VkFormat("VK_FORMAT_R32_SFLOAT"),
		["r32g32_uint"] = mod.VkFormat("VK_FORMAT_R32G32_UINT"),
		["r32g32_sint"] = mod.VkFormat("VK_FORMAT_R32G32_SINT"),
		["r32g32_sfloat"] = mod.VkFormat("VK_FORMAT_R32G32_SFLOAT"),
		["r32g32b32_uint"] = mod.VkFormat("VK_FORMAT_R32G32B32_UINT"),
		["r32g32b32_sint"] = mod.VkFormat("VK_FORMAT_R32G32B32_SINT"),
		["r32g32b32_sfloat"] = mod.VkFormat("VK_FORMAT_R32G32B32_SFLOAT"),
		["r32g32b32a32_uint"] = mod.VkFormat("VK_FORMAT_R32G32B32A32_UINT"),
		["r32g32b32a32_sint"] = mod.VkFormat("VK_FORMAT_R32G32B32A32_SINT"),
		["r32g32b32a32_sfloat"] = mod.VkFormat("VK_FORMAT_R32G32B32A32_SFLOAT"),
		["r64_uint"] = mod.VkFormat("VK_FORMAT_R64_UINT"),
		["undefined"] = mod.VkFormat("VK_FORMAT_UNDEFINED"),
		["r64_sint"] = mod.VkFormat("VK_FORMAT_R64_SINT"),
		["r4g4_unorm_pack8"] = mod.VkFormat("VK_FORMAT_R4G4_UNORM_PACK8"),
		["r64_sfloat"] = mod.VkFormat("VK_FORMAT_R64_SFLOAT"),
		["r4g4b4a4_unorm_pack16"] = mod.VkFormat("VK_FORMAT_R4G4B4A4_UNORM_PACK16"),
		["astc_10x5_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK"),
		["b4g4r4a4_unorm_pack16"] = mod.VkFormat("VK_FORMAT_B4G4R4A4_UNORM_PACK16"),
		["astc_10x6_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK"),
		["r5g6b5_unorm_pack16"] = mod.VkFormat("VK_FORMAT_R5G6B5_UNORM_PACK16"),
		["astc_10x8_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK"),
		["b5g6r5_unorm_pack16"] = mod.VkFormat("VK_FORMAT_B5G6R5_UNORM_PACK16"),
		["astc_10x10_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK"),
		["r5g5b5a1_unorm_pack16"] = mod.VkFormat("VK_FORMAT_R5G5B5A1_UNORM_PACK16"),
		["astc_12x10_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK"),
		["b5g5r5a1_unorm_pack16"] = mod.VkFormat("VK_FORMAT_B5G5R5A1_UNORM_PACK16"),
		["astc_12x12_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK"),
		["a1r5g5b5_unorm_pack16"] = mod.VkFormat("VK_FORMAT_A1R5G5B5_UNORM_PACK16"),
		["a1b5g5r5_unorm_pack16"] = mod.VkFormat("VK_FORMAT_A1B5G5R5_UNORM_PACK16"),
		["r8_unorm"] = mod.VkFormat("VK_FORMAT_R8_UNORM"),
		["a8_unorm"] = mod.VkFormat("VK_FORMAT_A8_UNORM"),
		["r8_snorm"] = mod.VkFormat("VK_FORMAT_R8_SNORM"),
		["pvrtc1_2bpp_unorm_block_img"] = mod.VkFormat("VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"),
		["r8_uscaled"] = mod.VkFormat("VK_FORMAT_R8_USCALED"),
		["pvrtc1_4bpp_unorm_block_img"] = mod.VkFormat("VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"),
		["r8_sscaled"] = mod.VkFormat("VK_FORMAT_R8_SSCALED"),
		["pvrtc2_2bpp_unorm_block_img"] = mod.VkFormat("VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"),
		["r8_uint"] = mod.VkFormat("VK_FORMAT_R8_UINT"),
		["pvrtc2_4bpp_unorm_block_img"] = mod.VkFormat("VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"),
		["r8_sint"] = mod.VkFormat("VK_FORMAT_R8_SINT"),
		["pvrtc1_2bpp_srgb_block_img"] = mod.VkFormat("VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"),
		["r8_srgb"] = mod.VkFormat("VK_FORMAT_R8_SRGB"),
		["pvrtc1_4bpp_srgb_block_img"] = mod.VkFormat("VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"),
		["r8g8_unorm"] = mod.VkFormat("VK_FORMAT_R8G8_UNORM"),
		["pvrtc2_2bpp_srgb_block_img"] = mod.VkFormat("VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"),
		["r8g8_snorm"] = mod.VkFormat("VK_FORMAT_R8G8_SNORM"),
		["pvrtc2_4bpp_srgb_block_img"] = mod.VkFormat("VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"),
		["r8g8_uscaled"] = mod.VkFormat("VK_FORMAT_R8G8_USCALED"),
		["r8_bool_arm"] = mod.VkFormat("VK_FORMAT_R8_BOOL_ARM"),
		["r8g8_sscaled"] = mod.VkFormat("VK_FORMAT_R8G8_SSCALED"),
		["r16g16_sfixed5_nv"] = mod.VkFormat("VK_FORMAT_R16G16_SFIXED5_NV"),
		["r8g8_uint"] = mod.VkFormat("VK_FORMAT_R8G8_UINT"),
		["r10x6_uint_pack16_arm"] = mod.VkFormat("VK_FORMAT_R10X6_UINT_PACK16_ARM"),
		["r8g8_sint"] = mod.VkFormat("VK_FORMAT_R8G8_SINT"),
		["r10x6g10x6_uint_2pack16_arm"] = mod.VkFormat("VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM"),
		["r8g8_srgb"] = mod.VkFormat("VK_FORMAT_R8G8_SRGB"),
		["r10x6g10x6b10x6a10x6_uint_4pack16_arm"] = mod.VkFormat("VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM"),
		["r8g8b8_unorm"] = mod.VkFormat("VK_FORMAT_R8G8B8_UNORM"),
		["r12x4_uint_pack16_arm"] = mod.VkFormat("VK_FORMAT_R12X4_UINT_PACK16_ARM"),
		["r8g8b8_snorm"] = mod.VkFormat("VK_FORMAT_R8G8B8_SNORM"),
		["r12x4g12x4_uint_2pack16_arm"] = mod.VkFormat("VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM"),
		["r8g8b8_uscaled"] = mod.VkFormat("VK_FORMAT_R8G8B8_USCALED"),
		["r12x4g12x4b12x4a12x4_uint_4pack16_arm"] = mod.VkFormat("VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM"),
		["r8g8b8_sscaled"] = mod.VkFormat("VK_FORMAT_R8G8B8_SSCALED"),
		["r14x2_uint_pack16_arm"] = mod.VkFormat("VK_FORMAT_R14X2_UINT_PACK16_ARM"),
		["r8g8b8_uint"] = mod.VkFormat("VK_FORMAT_R8G8B8_UINT"),
		["r14x2g14x2_uint_2pack16_arm"] = mod.VkFormat("VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM"),
		["r8g8b8_sint"] = mod.VkFormat("VK_FORMAT_R8G8B8_SINT"),
		["r14x2g14x2b14x2a14x2_uint_4pack16_arm"] = mod.VkFormat("VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM"),
		["r8g8b8_srgb"] = mod.VkFormat("VK_FORMAT_R8G8B8_SRGB"),
		["r14x2_unorm_pack16_arm"] = mod.VkFormat("VK_FORMAT_R14X2_UNORM_PACK16_ARM"),
		["b8g8r8_unorm"] = mod.VkFormat("VK_FORMAT_B8G8R8_UNORM"),
		["r14x2g14x2_unorm_2pack16_arm"] = mod.VkFormat("VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM"),
		["b8g8r8_snorm"] = mod.VkFormat("VK_FORMAT_B8G8R8_SNORM"),
		["r14x2g14x2b14x2a14x2_unorm_4pack16_arm"] = mod.VkFormat("VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM"),
		["b8g8r8_uscaled"] = mod.VkFormat("VK_FORMAT_B8G8R8_USCALED"),
		["g14x2_b14x2r14x2_2plane_420_unorm_3pack16_arm"] = mod.VkFormat("VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM"),
		["b8g8r8_sscaled"] = mod.VkFormat("VK_FORMAT_B8G8R8_SSCALED"),
		["g14x2_b14x2r14x2_2plane_422_unorm_3pack16_arm"] = mod.VkFormat("VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM"),
		["b8g8r8_uint"] = mod.VkFormat("VK_FORMAT_B8G8R8_UINT"),
		["astc_4x4_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT"),
		["b8g8r8_sint"] = mod.VkFormat("VK_FORMAT_B8G8R8_SINT"),
		["astc_5x4_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT"),
		["b8g8r8_srgb"] = mod.VkFormat("VK_FORMAT_B8G8R8_SRGB"),
		["astc_5x5_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT"),
		["r8g8b8a8_unorm"] = mod.VkFormat("VK_FORMAT_R8G8B8A8_UNORM"),
		["astc_6x5_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT"),
		["r8g8b8a8_snorm"] = mod.VkFormat("VK_FORMAT_R8G8B8A8_SNORM"),
		["astc_6x6_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT"),
		["r8g8b8a8_uscaled"] = mod.VkFormat("VK_FORMAT_R8G8B8A8_USCALED"),
		["astc_8x5_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT"),
		["r8g8b8a8_sscaled"] = mod.VkFormat("VK_FORMAT_R8G8B8A8_SSCALED"),
		["astc_8x6_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT"),
		["r8g8b8a8_uint"] = mod.VkFormat("VK_FORMAT_R8G8B8A8_UINT"),
		["astc_8x8_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT"),
		["r8g8b8a8_sint"] = mod.VkFormat("VK_FORMAT_R8G8B8A8_SINT"),
		["astc_10x5_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT"),
		["r8g8b8a8_srgb"] = mod.VkFormat("VK_FORMAT_R8G8B8A8_SRGB"),
		["astc_10x6_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT"),
		["b8g8r8a8_unorm"] = mod.VkFormat("VK_FORMAT_B8G8R8A8_UNORM"),
		["astc_10x8_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT"),
		["b8g8r8a8_snorm"] = mod.VkFormat("VK_FORMAT_B8G8R8A8_SNORM"),
		["astc_10x10_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT"),
		["b8g8r8a8_uscaled"] = mod.VkFormat("VK_FORMAT_B8G8R8A8_USCALED"),
		["astc_12x10_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT"),
		["b8g8r8a8_sscaled"] = mod.VkFormat("VK_FORMAT_B8G8R8A8_SSCALED"),
		["astc_12x12_sfloat_block_ext"] = mod.VkFormat("VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT"),
		["b8g8r8a8_uint"] = mod.VkFormat("VK_FORMAT_B8G8R8A8_UINT"),
		["g8b8g8r8_422_unorm_khr"] = mod.VkFormat("VK_FORMAT_G8B8G8R8_422_UNORM_KHR"),
		["b8g8r8a8_sint"] = mod.VkFormat("VK_FORMAT_B8G8R8A8_SINT"),
		["b8g8r8g8_422_unorm_khr"] = mod.VkFormat("VK_FORMAT_B8G8R8G8_422_UNORM_KHR"),
		["b8g8r8a8_srgb"] = mod.VkFormat("VK_FORMAT_B8G8R8A8_SRGB"),
		["g8_b8_r8_3plane_420_unorm_khr"] = mod.VkFormat("VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR"),
		["a8b8g8r8_unorm_pack32"] = mod.VkFormat("VK_FORMAT_A8B8G8R8_UNORM_PACK32"),
		["g8_b8r8_2plane_420_unorm_khr"] = mod.VkFormat("VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR"),
		["a8b8g8r8_snorm_pack32"] = mod.VkFormat("VK_FORMAT_A8B8G8R8_SNORM_PACK32"),
		["g8_b8_r8_3plane_422_unorm_khr"] = mod.VkFormat("VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR"),
		["a8b8g8r8_uscaled_pack32"] = mod.VkFormat("VK_FORMAT_A8B8G8R8_USCALED_PACK32"),
		["g8_b8r8_2plane_422_unorm_khr"] = mod.VkFormat("VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR"),
		["a8b8g8r8_sscaled_pack32"] = mod.VkFormat("VK_FORMAT_A8B8G8R8_SSCALED_PACK32"),
		["g8_b8_r8_3plane_444_unorm_khr"] = mod.VkFormat("VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR"),
		["a8b8g8r8_uint_pack32"] = mod.VkFormat("VK_FORMAT_A8B8G8R8_UINT_PACK32"),
		["r10x6_unorm_pack16_khr"] = mod.VkFormat("VK_FORMAT_R10X6_UNORM_PACK16_KHR"),
		["a8b8g8r8_sint_pack32"] = mod.VkFormat("VK_FORMAT_A8B8G8R8_SINT_PACK32"),
		["r10x6g10x6_unorm_2pack16_khr"] = mod.VkFormat("VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR"),
		["a8b8g8r8_srgb_pack32"] = mod.VkFormat("VK_FORMAT_A8B8G8R8_SRGB_PACK32"),
		["r10x6g10x6b10x6a10x6_unorm_4pack16_khr"] = mod.VkFormat("VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR"),
		["a2r10g10b10_unorm_pack32"] = mod.VkFormat("VK_FORMAT_A2R10G10B10_UNORM_PACK32"),
		["g10x6b10x6g10x6r10x6_422_unorm_4pack16_khr"] = mod.VkFormat("VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR"),
		["a2r10g10b10_snorm_pack32"] = mod.VkFormat("VK_FORMAT_A2R10G10B10_SNORM_PACK32"),
		["b10x6g10x6r10x6g10x6_422_unorm_4pack16_khr"] = mod.VkFormat("VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR"),
		["a2r10g10b10_uscaled_pack32"] = mod.VkFormat("VK_FORMAT_A2R10G10B10_USCALED_PACK32"),
		["g10x6_b10x6_r10x6_3plane_420_unorm_3pack16_khr"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR"),
		["r64g64b64_sint"] = mod.VkFormat("VK_FORMAT_R64G64B64_SINT"),
		["g10x6_b10x6r10x6_2plane_420_unorm_3pack16_khr"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR"),
		["r64g64b64_sfloat"] = mod.VkFormat("VK_FORMAT_R64G64B64_SFLOAT"),
		["g10x6_b10x6_r10x6_3plane_422_unorm_3pack16_khr"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR"),
		["r64g64b64a64_uint"] = mod.VkFormat("VK_FORMAT_R64G64B64A64_UINT"),
		["g10x6_b10x6r10x6_2plane_422_unorm_3pack16_khr"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR"),
		["r64g64b64a64_sint"] = mod.VkFormat("VK_FORMAT_R64G64B64A64_SINT"),
		["g10x6_b10x6_r10x6_3plane_444_unorm_3pack16_khr"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR"),
		["r64g64b64a64_sfloat"] = mod.VkFormat("VK_FORMAT_R64G64B64A64_SFLOAT"),
		["r12x4_unorm_pack16_khr"] = mod.VkFormat("VK_FORMAT_R12X4_UNORM_PACK16_KHR"),
		["b10g11r11_ufloat_pack32"] = mod.VkFormat("VK_FORMAT_B10G11R11_UFLOAT_PACK32"),
		["r12x4g12x4_unorm_2pack16_khr"] = mod.VkFormat("VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR"),
		["e5b9g9r9_ufloat_pack32"] = mod.VkFormat("VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"),
		["r12x4g12x4b12x4a12x4_unorm_4pack16_khr"] = mod.VkFormat("VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR"),
		["d16_unorm"] = mod.VkFormat("VK_FORMAT_D16_UNORM"),
		["g12x4b12x4g12x4r12x4_422_unorm_4pack16_khr"] = mod.VkFormat("VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR"),
		["x8_d24_unorm_pack32"] = mod.VkFormat("VK_FORMAT_X8_D24_UNORM_PACK32"),
		["b12x4g12x4r12x4g12x4_422_unorm_4pack16_khr"] = mod.VkFormat("VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR"),
		["d32_sfloat"] = mod.VkFormat("VK_FORMAT_D32_SFLOAT"),
		["g12x4_b12x4_r12x4_3plane_420_unorm_3pack16_khr"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR"),
		["s8_uint"] = mod.VkFormat("VK_FORMAT_S8_UINT"),
		["g12x4_b12x4r12x4_2plane_420_unorm_3pack16_khr"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR"),
		["d16_unorm_s8_uint"] = mod.VkFormat("VK_FORMAT_D16_UNORM_S8_UINT"),
		["g12x4_b12x4_r12x4_3plane_422_unorm_3pack16_khr"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR"),
		["d24_unorm_s8_uint"] = mod.VkFormat("VK_FORMAT_D24_UNORM_S8_UINT"),
		["g12x4_b12x4r12x4_2plane_422_unorm_3pack16_khr"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR"),
		["d32_sfloat_s8_uint"] = mod.VkFormat("VK_FORMAT_D32_SFLOAT_S8_UINT"),
		["g12x4_b12x4_r12x4_3plane_444_unorm_3pack16_khr"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR"),
		["bc1_rgb_unorm_block"] = mod.VkFormat("VK_FORMAT_BC1_RGB_UNORM_BLOCK"),
		["g16b16g16r16_422_unorm_khr"] = mod.VkFormat("VK_FORMAT_G16B16G16R16_422_UNORM_KHR"),
		["bc1_rgb_srgb_block"] = mod.VkFormat("VK_FORMAT_BC1_RGB_SRGB_BLOCK"),
		["b16g16r16g16_422_unorm_khr"] = mod.VkFormat("VK_FORMAT_B16G16R16G16_422_UNORM_KHR"),
		["bc1_rgba_unorm_block"] = mod.VkFormat("VK_FORMAT_BC1_RGBA_UNORM_BLOCK"),
		["g16_b16_r16_3plane_420_unorm_khr"] = mod.VkFormat("VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR"),
		["bc1_rgba_srgb_block"] = mod.VkFormat("VK_FORMAT_BC1_RGBA_SRGB_BLOCK"),
		["g16_b16r16_2plane_420_unorm_khr"] = mod.VkFormat("VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR"),
		["bc2_unorm_block"] = mod.VkFormat("VK_FORMAT_BC2_UNORM_BLOCK"),
		["g16_b16_r16_3plane_422_unorm_khr"] = mod.VkFormat("VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR"),
		["bc2_srgb_block"] = mod.VkFormat("VK_FORMAT_BC2_SRGB_BLOCK"),
		["g16_b16r16_2plane_422_unorm_khr"] = mod.VkFormat("VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR"),
		["bc3_unorm_block"] = mod.VkFormat("VK_FORMAT_BC3_UNORM_BLOCK"),
		["g16_b16_r16_3plane_444_unorm_khr"] = mod.VkFormat("VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR"),
		["bc3_srgb_block"] = mod.VkFormat("VK_FORMAT_BC3_SRGB_BLOCK"),
		["g8_b8r8_2plane_444_unorm_ext"] = mod.VkFormat("VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT"),
		["bc4_unorm_block"] = mod.VkFormat("VK_FORMAT_BC4_UNORM_BLOCK"),
		["g10x6_b10x6r10x6_2plane_444_unorm_3pack16_ext"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT"),
		["bc4_snorm_block"] = mod.VkFormat("VK_FORMAT_BC4_SNORM_BLOCK"),
		["g12x4_b12x4r12x4_2plane_444_unorm_3pack16_ext"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT"),
		["bc5_unorm_block"] = mod.VkFormat("VK_FORMAT_BC5_UNORM_BLOCK"),
		["g16_b16r16_2plane_444_unorm_ext"] = mod.VkFormat("VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT"),
		["bc5_snorm_block"] = mod.VkFormat("VK_FORMAT_BC5_SNORM_BLOCK"),
		["bc6h_ufloat_block"] = mod.VkFormat("VK_FORMAT_BC6H_UFLOAT_BLOCK"),
		["bc6h_sfloat_block"] = mod.VkFormat("VK_FORMAT_BC6H_SFLOAT_BLOCK"),
		["bc7_unorm_block"] = mod.VkFormat("VK_FORMAT_BC7_UNORM_BLOCK"),
		["bc7_srgb_block"] = mod.VkFormat("VK_FORMAT_BC7_SRGB_BLOCK"),
		["etc2_r8g8b8_unorm_block"] = mod.VkFormat("VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"),
		["etc2_r8g8b8_srgb_block"] = mod.VkFormat("VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"),
		["etc2_r8g8b8a1_unorm_block"] = mod.VkFormat("VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"),
		["etc2_r8g8b8a1_srgb_block"] = mod.VkFormat("VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"),
		["etc2_r8g8b8a8_unorm_block"] = mod.VkFormat("VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"),
		["etc2_r8g8b8a8_srgb_block"] = mod.VkFormat("VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"),
		["eac_r11_unorm_block"] = mod.VkFormat("VK_FORMAT_EAC_R11_UNORM_BLOCK"),
		["eac_r11_snorm_block"] = mod.VkFormat("VK_FORMAT_EAC_R11_SNORM_BLOCK"),
		["eac_r11g11_unorm_block"] = mod.VkFormat("VK_FORMAT_EAC_R11G11_UNORM_BLOCK"),
		["eac_r11g11_snorm_block"] = mod.VkFormat("VK_FORMAT_EAC_R11G11_SNORM_BLOCK"),
		["astc_4x4_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_4x4_UNORM_BLOCK"),
		["astc_4x4_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_4x4_SRGB_BLOCK"),
		["astc_5x4_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_5x4_UNORM_BLOCK"),
		["astc_5x4_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_5x4_SRGB_BLOCK"),
		["astc_5x5_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_5x5_UNORM_BLOCK"),
		["astc_5x5_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_5x5_SRGB_BLOCK"),
		["astc_6x5_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_6x5_UNORM_BLOCK"),
		["astc_6x5_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_6x5_SRGB_BLOCK"),
		["astc_6x6_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_6x6_UNORM_BLOCK"),
		["astc_6x6_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_6x6_SRGB_BLOCK"),
		["astc_8x5_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_8x5_UNORM_BLOCK"),
		["astc_8x5_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_8x5_SRGB_BLOCK"),
		["astc_8x6_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_8x6_UNORM_BLOCK"),
		["astc_8x6_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_8x6_SRGB_BLOCK"),
		["astc_8x8_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_8x8_UNORM_BLOCK"),
		["astc_8x8_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_8x8_SRGB_BLOCK"),
		["astc_10x5_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x5_UNORM_BLOCK"),
		["astc_10x5_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x5_SRGB_BLOCK"),
		["astc_10x6_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x6_UNORM_BLOCK"),
		["astc_10x6_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x6_SRGB_BLOCK"),
		["astc_10x8_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x8_UNORM_BLOCK"),
		["astc_10x8_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x8_SRGB_BLOCK"),
		["astc_10x10_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x10_UNORM_BLOCK"),
		["astc_10x10_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_10x10_SRGB_BLOCK"),
		["astc_12x10_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_12x10_UNORM_BLOCK"),
		["astc_12x10_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_12x10_SRGB_BLOCK"),
		["astc_12x12_unorm_block"] = mod.VkFormat("VK_FORMAT_ASTC_12x12_UNORM_BLOCK"),
		["astc_12x12_srgb_block"] = mod.VkFormat("VK_FORMAT_ASTC_12x12_SRGB_BLOCK"),
		["g8b8g8r8_422_unorm"] = mod.VkFormat("VK_FORMAT_G8B8G8R8_422_UNORM"),
		["b8g8r8g8_422_unorm"] = mod.VkFormat("VK_FORMAT_B8G8R8G8_422_UNORM"),
		["g8_b8_r8_3plane_420_unorm"] = mod.VkFormat("VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM"),
		["g8_b8r8_2plane_420_unorm"] = mod.VkFormat("VK_FORMAT_G8_B8R8_2PLANE_420_UNORM"),
		["a8_unorm_khr"] = mod.VkFormat("VK_FORMAT_A8_UNORM_KHR"),
		["a1b5g5r5_unorm_pack16_khr"] = mod.VkFormat("VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR"),
		["r16g16_s10_5_nv"] = mod.VkFormat("VK_FORMAT_R16G16_S10_5_NV"),
		["a4b4g4r4_unorm_pack16_ext"] = mod.VkFormat("VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT"),
		["a4r4g4b4_unorm_pack16_ext"] = mod.VkFormat("VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT"),
		["astc_8x8_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK"),
		["r64g64b64_uint"] = mod.VkFormat("VK_FORMAT_R64G64B64_UINT"),
		["g8_b8_r8_3plane_422_unorm"] = mod.VkFormat("VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM"),
		["g8_b8r8_2plane_422_unorm"] = mod.VkFormat("VK_FORMAT_G8_B8R8_2PLANE_422_UNORM"),
		["g8_b8_r8_3plane_444_unorm"] = mod.VkFormat("VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM"),
		["r10x6_unorm_pack16"] = mod.VkFormat("VK_FORMAT_R10X6_UNORM_PACK16"),
		["r10x6g10x6_unorm_2pack16"] = mod.VkFormat("VK_FORMAT_R10X6G10X6_UNORM_2PACK16"),
		["r10x6g10x6b10x6a10x6_unorm_4pack16"] = mod.VkFormat("VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16"),
		["g10x6b10x6g10x6r10x6_422_unorm_4pack16"] = mod.VkFormat("VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"),
		["b10x6g10x6r10x6g10x6_422_unorm_4pack16"] = mod.VkFormat("VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"),
		["g10x6_b10x6_r10x6_3plane_420_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"),
		["g10x6_b10x6r10x6_2plane_420_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"),
		["g10x6_b10x6_r10x6_3plane_422_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"),
		["g10x6_b10x6r10x6_2plane_422_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"),
		["g10x6_b10x6_r10x6_3plane_444_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"),
		["r12x4_unorm_pack16"] = mod.VkFormat("VK_FORMAT_R12X4_UNORM_PACK16"),
		["r12x4g12x4_unorm_2pack16"] = mod.VkFormat("VK_FORMAT_R12X4G12X4_UNORM_2PACK16"),
		["r12x4g12x4b12x4a12x4_unorm_4pack16"] = mod.VkFormat("VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16"),
		["g12x4b12x4g12x4r12x4_422_unorm_4pack16"] = mod.VkFormat("VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"),
		["b12x4g12x4r12x4g12x4_422_unorm_4pack16"] = mod.VkFormat("VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"),
		["g12x4_b12x4_r12x4_3plane_420_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"),
		["g12x4_b12x4r12x4_2plane_420_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"),
		["g12x4_b12x4_r12x4_3plane_422_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"),
		["g12x4_b12x4r12x4_2plane_422_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"),
		["g12x4_b12x4_r12x4_3plane_444_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"),
		["g16b16g16r16_422_unorm"] = mod.VkFormat("VK_FORMAT_G16B16G16R16_422_UNORM"),
		["b16g16r16g16_422_unorm"] = mod.VkFormat("VK_FORMAT_B16G16R16G16_422_UNORM"),
		["g16_b16_r16_3plane_420_unorm"] = mod.VkFormat("VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM"),
		["g16_b16r16_2plane_420_unorm"] = mod.VkFormat("VK_FORMAT_G16_B16R16_2PLANE_420_UNORM"),
		["g16_b16_r16_3plane_422_unorm"] = mod.VkFormat("VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM"),
		["g16_b16r16_2plane_422_unorm"] = mod.VkFormat("VK_FORMAT_G16_B16R16_2PLANE_422_UNORM"),
		["g16_b16_r16_3plane_444_unorm"] = mod.VkFormat("VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM"),
		["g8_b8r8_2plane_444_unorm"] = mod.VkFormat("VK_FORMAT_G8_B8R8_2PLANE_444_UNORM"),
		["g10x6_b10x6r10x6_2plane_444_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16"),
		["g12x4_b12x4r12x4_2plane_444_unorm_3pack16"] = mod.VkFormat("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16"),
		["g16_b16r16_2plane_444_unorm"] = mod.VkFormat("VK_FORMAT_G16_B16R16_2PLANE_444_UNORM"),
		["a4r4g4b4_unorm_pack16"] = mod.VkFormat("VK_FORMAT_A4R4G4B4_UNORM_PACK16"),
		["a4b4g4r4_unorm_pack16"] = mod.VkFormat("VK_FORMAT_A4B4G4R4_UNORM_PACK16"),
		["astc_4x4_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK"),
		["astc_5x4_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK"),
		["astc_5x5_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK"),
		["astc_6x5_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK"),
		["astc_6x6_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK"),
		["astc_8x5_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK"),
		["astc_8x6_sfloat_block"] = mod.VkFormat("VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK"),
		["r64g64_uint"] = mod.VkFormat("VK_FORMAT_R64G64_UINT"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkFormat") end

	return lookup[s] or
		error("unknown VkFormat value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkPrimitiveTopology = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["triangle_strip"] = mod.VkPrimitiveTopology("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"),
		["triangle_fan"] = mod.VkPrimitiveTopology("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"),
		["line_list_with_adjacency"] = mod.VkPrimitiveTopology("VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"),
		["line_strip_with_adjacency"] = mod.VkPrimitiveTopology("VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"),
		["point_list"] = mod.VkPrimitiveTopology("VK_PRIMITIVE_TOPOLOGY_POINT_LIST"),
		["patch_list"] = mod.VkPrimitiveTopology("VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"),
		["line_list"] = mod.VkPrimitiveTopology("VK_PRIMITIVE_TOPOLOGY_LINE_LIST"),
		["triangle_strip_with_adjacency"] = mod.VkPrimitiveTopology("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"),
		["line_strip"] = mod.VkPrimitiveTopology("VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"),
		["triangle_list_with_adjacency"] = mod.VkPrimitiveTopology("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"),
		["triangle_list"] = mod.VkPrimitiveTopology("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPrimitiveTopology")
	end

	return lookup[s] or
		error("unknown VkPrimitiveTopology value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkMemoryPropertyFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["device_coherent_amd"] = mod.VkMemoryPropertyFlagBits("VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD"),
		["device_local"] = mod.VkMemoryPropertyFlagBits("VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"),
		["device_uncached_amd"] = mod.VkMemoryPropertyFlagBits("VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD"),
		["host_visible"] = mod.VkMemoryPropertyFlagBits("VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"),
		["rdma_capable_nv"] = mod.VkMemoryPropertyFlagBits("VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV"),
		["protected"] = mod.VkMemoryPropertyFlagBits("VK_MEMORY_PROPERTY_PROTECTED_BIT"),
		["host_cached"] = mod.VkMemoryPropertyFlagBits("VK_MEMORY_PROPERTY_HOST_CACHED_BIT"),
		["lazily_allocated"] = mod.VkMemoryPropertyFlagBits("VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"),
		["host_coherent"] = mod.VkMemoryPropertyFlagBits("VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkMemoryPropertyFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkMemoryPropertyFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkCooperativeVectorMatrixLayoutNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["column_major_nv"] = mod.VkCooperativeVectorMatrixLayoutNV("VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV"),
		["training_optimal_nv"] = mod.VkCooperativeVectorMatrixLayoutNV("VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV"),
		["row_major_nv"] = mod.VkCooperativeVectorMatrixLayoutNV("VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV"),
		["inferencing_optimal_nv"] = mod.VkCooperativeVectorMatrixLayoutNV("VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCooperativeVectorMatrixLayoutNV")
	end

	return lookup[s] or
		error(
			"unknown VkCooperativeVectorMatrixLayoutNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkQueryPoolSamplingModeINTEL = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["manual_intel"] = mod.VkQueryPoolSamplingModeINTEL("VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkQueryPoolSamplingModeINTEL")
	end

	return lookup[s] or
		error(
			"unknown VkQueryPoolSamplingModeINTEL value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPolygonMode = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["fill"] = mod.VkPolygonMode("VK_POLYGON_MODE_FILL"),
		["fill_rectangle_nv"] = mod.VkPolygonMode("VK_POLYGON_MODE_FILL_RECTANGLE_NV"),
		["line"] = mod.VkPolygonMode("VK_POLYGON_MODE_LINE"),
		["point"] = mod.VkPolygonMode("VK_POLYGON_MODE_POINT"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkPolygonMode") end

	return lookup[s] or
		error("unknown VkPolygonMode value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkPerformanceOverrideTypeINTEL = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["null_hardware_intel"] = mod.VkPerformanceOverrideTypeINTEL("VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL"),
		["flush_gpu_caches_intel"] = mod.VkPerformanceOverrideTypeINTEL("VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPerformanceOverrideTypeINTEL")
	end

	return lookup[s] or
		error(
			"unknown VkPerformanceOverrideTypeINTEL value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264CabacInitIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["2"] = mod.StdVideoH264CabacInitIdc("STD_VIDEO_H264_CABAC_INIT_IDC_2"),
		["invalid"] = mod.StdVideoH264CabacInitIdc("STD_VIDEO_H264_CABAC_INIT_IDC_INVALID"),
		["0"] = mod.StdVideoH264CabacInitIdc("STD_VIDEO_H264_CABAC_INIT_IDC_0"),
		["1"] = mod.StdVideoH264CabacInitIdc("STD_VIDEO_H264_CABAC_INIT_IDC_1"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264CabacInitIdc")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH264CabacInitIdc value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkQueueFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["transfer"] = mod.VkQueueFlagBits("VK_QUEUE_TRANSFER_BIT"),
		["video_decode_khr"] = mod.VkQueueFlagBits("VK_QUEUE_VIDEO_DECODE_BIT_KHR"),
		["data_graph_arm"] = mod.VkQueueFlagBits("VK_QUEUE_DATA_GRAPH_BIT_ARM"),
		["video_encode_khr"] = mod.VkQueueFlagBits("VK_QUEUE_VIDEO_ENCODE_BIT_KHR"),
		["protected"] = mod.VkQueueFlagBits("VK_QUEUE_PROTECTED_BIT"),
		["optical_flow_nv"] = mod.VkQueueFlagBits("VK_QUEUE_OPTICAL_FLOW_BIT_NV"),
		["graphics"] = mod.VkQueueFlagBits("VK_QUEUE_GRAPHICS_BIT"),
		["sparse_binding"] = mod.VkQueueFlagBits("VK_QUEUE_SPARSE_BINDING_BIT"),
		["compute"] = mod.VkQueueFlagBits("VK_QUEUE_COMPUTE_BIT"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkQueueFlagBits") end

	return lookup[s] or
		error("unknown VkQueueFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkPerformanceParameterTypeINTEL = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["stream_marker_valid_bits_intel"] = mod.VkPerformanceParameterTypeINTEL("VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL"),
		["hw_counters_supported_intel"] = mod.VkPerformanceParameterTypeINTEL("VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPerformanceParameterTypeINTEL")
	end

	return lookup[s] or
		error(
			"unknown VkPerformanceParameterTypeINTEL value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkStencilOp = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["replace"] = mod.VkStencilOp("VK_STENCIL_OP_REPLACE"),
		["keep"] = mod.VkStencilOp("VK_STENCIL_OP_KEEP"),
		["invert"] = mod.VkStencilOp("VK_STENCIL_OP_INVERT"),
		["zero"] = mod.VkStencilOp("VK_STENCIL_OP_ZERO"),
		["increment_and_wrap"] = mod.VkStencilOp("VK_STENCIL_OP_INCREMENT_AND_WRAP"),
		["decrement_and_wrap"] = mod.VkStencilOp("VK_STENCIL_OP_DECREMENT_AND_WRAP"),
		["increment_and_clamp"] = mod.VkStencilOp("VK_STENCIL_OP_INCREMENT_AND_CLAMP"),
		["decrement_and_clamp"] = mod.VkStencilOp("VK_STENCIL_OP_DECREMENT_AND_CLAMP"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkStencilOp") end

	return lookup[s] or
		error("unknown VkStencilOp value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.StdVideoH264DisableDeblockingFilterIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["invalid"] = mod.StdVideoH264DisableDeblockingFilterIdc("STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_INVALID"),
		["enabled"] = mod.StdVideoH264DisableDeblockingFilterIdc("STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_ENABLED"),
		["partial"] = mod.StdVideoH264DisableDeblockingFilterIdc("STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_PARTIAL"),
		["disabled"] = mod.StdVideoH264DisableDeblockingFilterIdc("STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_DISABLED"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264DisableDeblockingFilterIdc")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH264DisableDeblockingFilterIdc value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPerformanceValueTypeINTEL = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["uint32_intel"] = mod.VkPerformanceValueTypeINTEL("VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL"),
		["uint64_intel"] = mod.VkPerformanceValueTypeINTEL("VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL"),
		["float_intel"] = mod.VkPerformanceValueTypeINTEL("VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL"),
		["string_intel"] = mod.VkPerformanceValueTypeINTEL("VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL"),
		["bool_intel"] = mod.VkPerformanceValueTypeINTEL("VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPerformanceValueTypeINTEL")
	end

	return lookup[s] or
		error(
			"unknown VkPerformanceValueTypeINTEL value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkExternalFenceHandleTypeFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["opaque_win32"] = mod.VkExternalFenceHandleTypeFlagBits("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"),
		["sync_fd_khr"] = mod.VkExternalFenceHandleTypeFlagBits("VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR"),
		["opaque_win32_kmt_khr"] = mod.VkExternalFenceHandleTypeFlagBits("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"),
		["opaque_win32_kmt"] = mod.VkExternalFenceHandleTypeFlagBits("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"),
		["opaque_fd"] = mod.VkExternalFenceHandleTypeFlagBits("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"),
		["opaque_win32_khr"] = mod.VkExternalFenceHandleTypeFlagBits("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"),
		["sync_fd"] = mod.VkExternalFenceHandleTypeFlagBits("VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"),
		["opaque_fd_khr"] = mod.VkExternalFenceHandleTypeFlagBits("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkExternalFenceHandleTypeFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkExternalFenceHandleTypeFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264SliceType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["b"] = mod.StdVideoH264SliceType("STD_VIDEO_H264_SLICE_TYPE_B"),
		["invalid"] = mod.StdVideoH264SliceType("STD_VIDEO_H264_SLICE_TYPE_INVALID"),
		["p"] = mod.StdVideoH264SliceType("STD_VIDEO_H264_SLICE_TYPE_P"),
		["i"] = mod.StdVideoH264SliceType("STD_VIDEO_H264_SLICE_TYPE_I"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264SliceType")
	end

	return lookup[s] or
		error("unknown StdVideoH264SliceType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeUsageFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["streaming_khr"] = mod.VkVideoEncodeUsageFlagBitsKHR("VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR"),
		["default_khr"] = mod.VkVideoEncodeUsageFlagBitsKHR("VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR"),
		["recording_khr"] = mod.VkVideoEncodeUsageFlagBitsKHR("VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR"),
		["transcoding_khr"] = mod.VkVideoEncodeUsageFlagBitsKHR("VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR"),
		["conferencing_khr"] = mod.VkVideoEncodeUsageFlagBitsKHR("VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeUsageFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeUsageFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkCompositeAlphaFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["inherit_khr"] = mod.VkCompositeAlphaFlagBitsKHR("VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"),
		["opaque_khr"] = mod.VkCompositeAlphaFlagBitsKHR("VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"),
		["post_multiplied_khr"] = mod.VkCompositeAlphaFlagBitsKHR("VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"),
		["pre_multiplied_khr"] = mod.VkCompositeAlphaFlagBitsKHR("VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCompositeAlphaFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkCompositeAlphaFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkIndirectCommandsTokenTypeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["draw_tasks_nv"] = mod.VkIndirectCommandsTokenTypeNV("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV"),
		["shader_group_nv"] = mod.VkIndirectCommandsTokenTypeNV("VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV"),
		["state_flags_nv"] = mod.VkIndirectCommandsTokenTypeNV("VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV"),
		["index_buffer_nv"] = mod.VkIndirectCommandsTokenTypeNV("VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV"),
		["vertex_buffer_nv"] = mod.VkIndirectCommandsTokenTypeNV("VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV"),
		["push_constant_nv"] = mod.VkIndirectCommandsTokenTypeNV("VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV"),
		["dispatch_nv"] = mod.VkIndirectCommandsTokenTypeNV("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV"),
		["draw_indexed_nv"] = mod.VkIndirectCommandsTokenTypeNV("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV"),
		["pipeline_nv"] = mod.VkIndirectCommandsTokenTypeNV("VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV"),
		["draw_nv"] = mod.VkIndirectCommandsTokenTypeNV("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV"),
		["draw_mesh_tasks_nv"] = mod.VkIndirectCommandsTokenTypeNV("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkIndirectCommandsTokenTypeNV")
	end

	return lookup[s] or
		error(
			"unknown VkIndirectCommandsTokenTypeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264PictureType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["idr"] = mod.StdVideoH264PictureType("STD_VIDEO_H264_PICTURE_TYPE_IDR"),
		["invalid"] = mod.StdVideoH264PictureType("STD_VIDEO_H264_PICTURE_TYPE_INVALID"),
		["p"] = mod.StdVideoH264PictureType("STD_VIDEO_H264_PICTURE_TYPE_P"),
		["b"] = mod.StdVideoH264PictureType("STD_VIDEO_H264_PICTURE_TYPE_B"),
		["i"] = mod.StdVideoH264PictureType("STD_VIDEO_H264_PICTURE_TYPE_I"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264PictureType")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH264PictureType value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkExternalFenceFeatureFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["importable"] = mod.VkExternalFenceFeatureFlagBits("VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"),
		["exportable"] = mod.VkExternalFenceFeatureFlagBits("VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"),
		["importable_khr"] = mod.VkExternalFenceFeatureFlagBits("VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR"),
		["exportable_khr"] = mod.VkExternalFenceFeatureFlagBits("VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkExternalFenceFeatureFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkExternalFenceFeatureFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH265AspectRatioIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["extended_sar"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_EXTENDED_SAR"),
		["3_2"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_3_2"),
		["invalid"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_INVALID"),
		["unspecified"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_UNSPECIFIED"),
		["square"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_SQUARE"),
		["12_11"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_12_11"),
		["10_11"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_10_11"),
		["16_11"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_16_11"),
		["40_33"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_40_33"),
		["24_11"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_24_11"),
		["20_11"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_20_11"),
		["32_11"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_32_11"),
		["80_33"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_80_33"),
		["18_11"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_18_11"),
		["15_11"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_15_11"),
		["64_33"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_64_33"),
		["160_99"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_160_99"),
		["4_3"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_4_3"),
		["2_1"] = mod.StdVideoH265AspectRatioIdc("STD_VIDEO_H265_ASPECT_RATIO_IDC_2_1"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH265AspectRatioIdc")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH265AspectRatioIdc value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeContentFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["default_khr"] = mod.VkVideoEncodeContentFlagBitsKHR("VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR"),
		["rendered_khr"] = mod.VkVideoEncodeContentFlagBitsKHR("VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR"),
		["desktop_khr"] = mod.VkVideoEncodeContentFlagBitsKHR("VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR"),
		["camera_khr"] = mod.VkVideoEncodeContentFlagBitsKHR("VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeContentFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeContentFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoVP9Profile = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["3"] = mod.StdVideoVP9Profile("STD_VIDEO_VP9_PROFILE_3"),
		["invalid"] = mod.StdVideoVP9Profile("STD_VIDEO_VP9_PROFILE_INVALID"),
		["0"] = mod.StdVideoVP9Profile("STD_VIDEO_VP9_PROFILE_0"),
		["2"] = mod.StdVideoVP9Profile("STD_VIDEO_VP9_PROFILE_2"),
		["1"] = mod.StdVideoVP9Profile("STD_VIDEO_VP9_PROFILE_1"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoVP9Profile")
	end

	return lookup[s] or
		error("unknown StdVideoVP9Profile value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeH264StdFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["weighted_pred_flag_set_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR"),
		["direct_8x8_inference_flag_unset_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR"),
		["qpprime_y_zero_transform_bypass_flag_set_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR"),
		["deblocking_filter_disabled_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR"),
		["scaling_matrix_present_flag_set_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR"),
		["chroma_qp_index_offset_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR"),
		["deblocking_filter_enabled_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR"),
		["second_chroma_qp_index_offset_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR"),
		["deblocking_filter_partial_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR"),
		["pic_init_qp_minus26_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR"),
		["separate_color_plane_flag_set_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR"),
		["weighted_bipred_idc_explicit_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR"),
		["weighted_bipred_idc_implicit_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR"),
		["transform_8x8_mode_flag_set_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR"),
		["constrained_intra_pred_flag_set_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR"),
		["different_slice_qp_delta_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR"),
		["entropy_coding_mode_flag_unset_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR"),
		["slice_qp_delta_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR"),
		["direct_spatial_mv_pred_flag_unset_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR"),
		["entropy_coding_mode_flag_set_khr"] = mod.VkVideoEncodeH264StdFlagBitsKHR("VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeH264StdFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeH264StdFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSubmitFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["protected_khr"] = mod.VkSubmitFlagBits("VK_SUBMIT_PROTECTED_BIT_KHR"),
		["protected"] = mod.VkSubmitFlagBits("VK_SUBMIT_PROTECTED_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSubmitFlagBits")
	end

	return lookup[s] or
		error("unknown VkSubmitFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkViewportCoordinateSwizzleNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["negative_w_nv"] = mod.VkViewportCoordinateSwizzleNV("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV"),
		["negative_y_nv"] = mod.VkViewportCoordinateSwizzleNV("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV"),
		["positive_w_nv"] = mod.VkViewportCoordinateSwizzleNV("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV"),
		["positive_x_nv"] = mod.VkViewportCoordinateSwizzleNV("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV"),
		["negative_z_nv"] = mod.VkViewportCoordinateSwizzleNV("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV"),
		["negative_x_nv"] = mod.VkViewportCoordinateSwizzleNV("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV"),
		["positive_z_nv"] = mod.VkViewportCoordinateSwizzleNV("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV"),
		["positive_y_nv"] = mod.VkViewportCoordinateSwizzleNV("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkViewportCoordinateSwizzleNV")
	end

	return lookup[s] or
		error(
			"unknown VkViewportCoordinateSwizzleNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPipelineCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["create_defer_compile_nv"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV"),
		["create_rendering_fragment_density_map_attachment_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"),
		["create_rendering_fragment_shading_rate_attachment_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
		["create_capture_statistics_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR"),
		["create_capture_internal_representations_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR"),
		["create_indirect_bindable_nv"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV"),
		["create_disable_optimization"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"),
		["create_library_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_LIBRARY_BIT_KHR"),
		["create_allow_derivatives"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"),
		["create_descriptor_buffer_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT"),
		["create_derivative"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_DERIVATIVE_BIT"),
		["create_retain_link_time_optimization_info_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT"),
		["create_view_index_from_device_index"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"),
		["create_link_time_optimization_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT"),
		["create_dispatch_base"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_DISPATCH_BASE"),
		["create_ray_tracing_allow_motion_nv"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV"),
		["create_fail_on_pipeline_compile_required"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"),
		["create_color_attachment_feedback_loop_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"),
		["create_early_return_on_failure"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT"),
		["create_depth_stencil_attachment_feedback_loop_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"),
		["create_no_protected_access"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT"),
		["create_ray_tracing_opacity_micromap_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT"),
		["create_protected_access_only"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT"),
		["create_view_index_from_device_index_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR"),
		["create_ray_tracing_no_null_any_hit_shaders_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR"),
		["create_dispatch_base_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_DISPATCH_BASE_KHR"),
		["create_ray_tracing_no_null_closest_hit_shaders_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR"),
		["rasterization_state_create_fragment_density_map_attachment_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"),
		["create_ray_tracing_no_null_miss_shaders_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR"),
		["rasterization_state_create_fragment_shading_rate_attachment_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
		["create_ray_tracing_no_null_intersection_shaders_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR"),
		["create_fail_on_pipeline_compile_required_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT"),
		["create_ray_tracing_skip_triangles_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"),
		["create_early_return_on_failure_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT"),
		["create_ray_tracing_skip_aabbs_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR"),
		["create_no_protected_access_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT"),
		["create_ray_tracing_shader_group_handle_capture_replay_khr"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR"),
		["create_protected_access_only_ext"] = mod.VkPipelineCreateFlagBits("VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeH265StdFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["weighted_pred_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR"),
		["dependent_slice_segments_enabled_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR"),
		["weighted_bipred_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR"),
		["dependent_slice_segment_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR"),
		["log2_parallel_merge_level_minus2_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR"),
		["slice_qp_delta_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR"),
		["sign_data_hiding_enabled_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR"),
		["different_slice_qp_delta_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR"),
		["transform_skip_enabled_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR"),
		["separate_color_plane_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR"),
		["transform_skip_enabled_flag_unset_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR"),
		["sample_adaptive_offset_enabled_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR"),
		["pps_slice_chroma_qp_offsets_present_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR"),
		["scaling_list_data_present_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR"),
		["transquant_bypass_enabled_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR"),
		["pcm_enabled_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR"),
		["constrained_intra_pred_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR"),
		["sps_temporal_mvp_enabled_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR"),
		["entropy_coding_sync_enabled_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR"),
		["init_qp_minus26_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR"),
		["deblocking_filter_override_enabled_flag_set_khr"] = mod.VkVideoEncodeH265StdFlagBitsKHR("VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeH265StdFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeH265StdFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkIndirectStateFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["frontface_nv"] = mod.VkIndirectStateFlagBitsNV("VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkIndirectStateFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkIndirectStateFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkRenderingFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["suspending_khr"] = mod.VkRenderingFlagBits("VK_RENDERING_SUSPENDING_BIT_KHR"),
		["contents_secondary_command_buffers"] = mod.VkRenderingFlagBits("VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT"),
		["enable_legacy_dithering_ext"] = mod.VkRenderingFlagBits("VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT"),
		["suspending"] = mod.VkRenderingFlagBits("VK_RENDERING_SUSPENDING_BIT"),
		["contents_inline_khr"] = mod.VkRenderingFlagBits("VK_RENDERING_CONTENTS_INLINE_BIT_KHR"),
		["resuming"] = mod.VkRenderingFlagBits("VK_RENDERING_RESUMING_BIT"),
		["per_layer_fragment_density_valve"] = mod.VkRenderingFlagBits("VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE"),
		["contents_inline_ext"] = mod.VkRenderingFlagBits("VK_RENDERING_CONTENTS_INLINE_BIT_EXT"),
		["resuming_khr"] = mod.VkRenderingFlagBits("VK_RENDERING_RESUMING_BIT_KHR"),
		["contents_secondary_command_buffers_khr"] = mod.VkRenderingFlagBits("VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkRenderingFlagBits")
	end

	return lookup[s] or
		error("unknown VkRenderingFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkSemaphoreImportFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["temporary"] = mod.VkSemaphoreImportFlagBits("VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"),
		["temporary_khr"] = mod.VkSemaphoreImportFlagBits("VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSemaphoreImportFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkSemaphoreImportFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkBorderColor = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["int_opaque_black"] = mod.VkBorderColor("VK_BORDER_COLOR_INT_OPAQUE_BLACK"),
		["int_custom_ext"] = mod.VkBorderColor("VK_BORDER_COLOR_INT_CUSTOM_EXT"),
		["float_transparent_black"] = mod.VkBorderColor("VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"),
		["float_custom_ext"] = mod.VkBorderColor("VK_BORDER_COLOR_FLOAT_CUSTOM_EXT"),
		["int_transparent_black"] = mod.VkBorderColor("VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"),
		["int_opaque_white"] = mod.VkBorderColor("VK_BORDER_COLOR_INT_OPAQUE_WHITE"),
		["float_opaque_black"] = mod.VkBorderColor("VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"),
		["float_opaque_white"] = mod.VkBorderColor("VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkBorderColor") end

	return lookup[s] or
		error("unknown VkBorderColor value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkIndirectCommandsLayoutUsageFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["explicit_preprocess_nv"] = mod.VkIndirectCommandsLayoutUsageFlagBitsNV("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV"),
		["unordered_sequences_nv"] = mod.VkIndirectCommandsLayoutUsageFlagBitsNV("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV"),
		["indexed_sequences_nv"] = mod.VkIndirectCommandsLayoutUsageFlagBitsNV("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkIndirectCommandsLayoutUsageFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkIndirectCommandsLayoutUsageFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDeviceEventTypeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["display_hotplug_ext"] = mod.VkDeviceEventTypeEXT("VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDeviceEventTypeEXT")
	end

	return lookup[s] or
		error("unknown VkDeviceEventTypeEXT value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkOutOfBandQueueTypeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["present_nv"] = mod.VkOutOfBandQueueTypeNV("VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV"),
		["render_nv"] = mod.VkOutOfBandQueueTypeNV("VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkOutOfBandQueueTypeNV")
	end

	return lookup[s] or
		error("unknown VkOutOfBandQueueTypeNV value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkExternalSemaphoreHandleTypeFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["d3d12_fence_khr"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR"),
		["opaque_fd"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"),
		["sync_fd"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"),
		["sync_fd_khr"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR"),
		["opaque_win32"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"),
		["d3d12_fence"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"),
		["opaque_fd_khr"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR"),
		["opaque_win32_kmt"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"),
		["zircon_event_fuchsia"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA"),
		["opaque_win32_khr"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR"),
		["opaque_win32_kmt_khr"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR"),
		["d3d11_fence"] = mod.VkExternalSemaphoreHandleTypeFlagBits("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkExternalSemaphoreHandleTypeFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkExternalSemaphoreHandleTypeFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDynamicState = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["depth_write_enable"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE"),
		["depth_compare_op"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_COMPARE_OP"),
		["depth_bounds_test_enable"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE"),
		["stencil_test_enable"] = mod.VkDynamicState("VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE"),
		["stencil_op"] = mod.VkDynamicState("VK_DYNAMIC_STATE_STENCIL_OP"),
		["rasterizer_discard_enable"] = mod.VkDynamicState("VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE"),
		["depth_bias_enable"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE"),
		["primitive_restart_enable"] = mod.VkDynamicState("VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE"),
		["line_stipple"] = mod.VkDynamicState("VK_DYNAMIC_STATE_LINE_STIPPLE"),
		["viewport_w_scaling_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV"),
		["discard_rectangle_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT"),
		["discard_rectangle_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT"),
		["discard_rectangle_mode_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT"),
		["sample_locations_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT"),
		["ray_tracing_pipeline_stack_size_khr"] = mod.VkDynamicState("VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR"),
		["viewport_shading_rate_palette_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV"),
		["polygon_mode_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_POLYGON_MODE_EXT"),
		["rasterization_samples_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT"),
		["sample_mask_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_SAMPLE_MASK_EXT"),
		["alpha_to_coverage_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT"),
		["alpha_to_one_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT"),
		["logic_op_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT"),
		["color_blend_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT"),
		["color_blend_equation_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT"),
		["color_write_mask_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT"),
		["tessellation_domain_origin_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT"),
		["rasterization_stream_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT"),
		["conservative_rasterization_mode_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT"),
		["extra_primitive_overestimation_size_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT"),
		["depth_clip_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT"),
		["sample_locations_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT"),
		["color_blend_advanced_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT"),
		["provoking_vertex_mode_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT"),
		["line_rasterization_mode_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT"),
		["line_stipple_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT"),
		["depth_clip_negative_one_to_one_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT"),
		["viewport_w_scaling_enable_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV"),
		["viewport_swizzle_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV"),
		["line_stipple_khr"] = mod.VkDynamicState("VK_DYNAMIC_STATE_LINE_STIPPLE_KHR"),
		["coverage_to_color_enable_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV"),
		["primitive_restart_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT"),
		["coverage_to_color_location_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV"),
		["depth_bias_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT"),
		["coverage_modulation_mode_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV"),
		["rasterizer_discard_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT"),
		["coverage_modulation_table_enable_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV"),
		["stencil_op_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_STENCIL_OP_EXT"),
		["coverage_modulation_table_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV"),
		["stencil_test_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT"),
		["shading_rate_image_enable_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV"),
		["depth_bounds_test_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT"),
		["representative_fragment_test_enable_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV"),
		["depth_compare_op_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT"),
		["coverage_reduction_mode_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV"),
		["depth_write_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT"),
		["attachment_feedback_loop_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT"),
		["depth_test_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT"),
		["depth_clamp_range_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT"),
		["vertex_input_binding_stride_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT"),
		["viewport"] = mod.VkDynamicState("VK_DYNAMIC_STATE_VIEWPORT"),
		["scissor_with_count_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT"),
		["scissor"] = mod.VkDynamicState("VK_DYNAMIC_STATE_SCISSOR"),
		["viewport_with_count_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT"),
		["line_width"] = mod.VkDynamicState("VK_DYNAMIC_STATE_LINE_WIDTH"),
		["primitive_topology_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT"),
		["depth_bias"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_BIAS"),
		["front_face_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_FRONT_FACE_EXT"),
		["blend_constants"] = mod.VkDynamicState("VK_DYNAMIC_STATE_BLEND_CONSTANTS"),
		["cull_mode_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_CULL_MODE_EXT"),
		["depth_bounds"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_BOUNDS"),
		["line_stipple_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_LINE_STIPPLE_EXT"),
		["stencil_compare_mask"] = mod.VkDynamicState("VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"),
		["depth_clamp_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT"),
		["stencil_write_mask"] = mod.VkDynamicState("VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"),
		["viewport_coarse_sample_order_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV"),
		["stencil_reference"] = mod.VkDynamicState("VK_DYNAMIC_STATE_STENCIL_REFERENCE"),
		["logic_op_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_LOGIC_OP_EXT"),
		["cull_mode"] = mod.VkDynamicState("VK_DYNAMIC_STATE_CULL_MODE"),
		["exclusive_scissor_enable_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV"),
		["front_face"] = mod.VkDynamicState("VK_DYNAMIC_STATE_FRONT_FACE"),
		["vertex_input_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_VERTEX_INPUT_EXT"),
		["primitive_topology"] = mod.VkDynamicState("VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY"),
		["exclusive_scissor_nv"] = mod.VkDynamicState("VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV"),
		["viewport_with_count"] = mod.VkDynamicState("VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT"),
		["fragment_shading_rate_khr"] = mod.VkDynamicState("VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR"),
		["scissor_with_count"] = mod.VkDynamicState("VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT"),
		["patch_control_points_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT"),
		["vertex_input_binding_stride"] = mod.VkDynamicState("VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE"),
		["color_write_enable_ext"] = mod.VkDynamicState("VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT"),
		["depth_test_enable"] = mod.VkDynamicState("VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkDynamicState") end

	return lookup[s] or
		error("unknown VkDynamicState value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkScopeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["device_nv"] = mod.VkScopeKHR("VK_SCOPE_DEVICE_NV"),
		["queue_family_nv"] = mod.VkScopeKHR("VK_SCOPE_QUEUE_FAMILY_NV"),
		["device_khr"] = mod.VkScopeKHR("VK_SCOPE_DEVICE_KHR"),
		["subgroup_nv"] = mod.VkScopeKHR("VK_SCOPE_SUBGROUP_NV"),
		["subgroup_khr"] = mod.VkScopeKHR("VK_SCOPE_SUBGROUP_KHR"),
		["workgroup_nv"] = mod.VkScopeKHR("VK_SCOPE_WORKGROUP_NV"),
		["queue_family_khr"] = mod.VkScopeKHR("VK_SCOPE_QUEUE_FAMILY_KHR"),
		["workgroup_khr"] = mod.VkScopeKHR("VK_SCOPE_WORKGROUP_KHR"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkScopeKHR") end

	return lookup[s] or
		error("unknown VkScopeKHR value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkDriverId = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["intel_proprietary_windows_khr"] = mod.VkDriverId("VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR"),
		["amd_proprietary"] = mod.VkDriverId("VK_DRIVER_ID_AMD_PROPRIETARY"),
		["amd_open_source"] = mod.VkDriverId("VK_DRIVER_ID_AMD_OPEN_SOURCE"),
		["mesa_radv"] = mod.VkDriverId("VK_DRIVER_ID_MESA_RADV"),
		["nvidia_proprietary"] = mod.VkDriverId("VK_DRIVER_ID_NVIDIA_PROPRIETARY"),
		["intel_proprietary_windows"] = mod.VkDriverId("VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS"),
		["intel_open_source_mesa"] = mod.VkDriverId("VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA"),
		["imagination_proprietary"] = mod.VkDriverId("VK_DRIVER_ID_IMAGINATION_PROPRIETARY"),
		["qualcomm_proprietary"] = mod.VkDriverId("VK_DRIVER_ID_QUALCOMM_PROPRIETARY"),
		["arm_proprietary"] = mod.VkDriverId("VK_DRIVER_ID_ARM_PROPRIETARY"),
		["google_swiftshader"] = mod.VkDriverId("VK_DRIVER_ID_GOOGLE_SWIFTSHADER"),
		["ggp_proprietary"] = mod.VkDriverId("VK_DRIVER_ID_GGP_PROPRIETARY"),
		["broadcom_proprietary"] = mod.VkDriverId("VK_DRIVER_ID_BROADCOM_PROPRIETARY"),
		["mesa_llvmpipe"] = mod.VkDriverId("VK_DRIVER_ID_MESA_LLVMPIPE"),
		["moltenvk"] = mod.VkDriverId("VK_DRIVER_ID_MOLTENVK"),
		["coreavi_proprietary"] = mod.VkDriverId("VK_DRIVER_ID_COREAVI_PROPRIETARY"),
		["juice_proprietary"] = mod.VkDriverId("VK_DRIVER_ID_JUICE_PROPRIETARY"),
		["verisilicon_proprietary"] = mod.VkDriverId("VK_DRIVER_ID_VERISILICON_PROPRIETARY"),
		["mesa_turnip"] = mod.VkDriverId("VK_DRIVER_ID_MESA_TURNIP"),
		["mesa_v3dv"] = mod.VkDriverId("VK_DRIVER_ID_MESA_V3DV"),
		["mesa_panvk"] = mod.VkDriverId("VK_DRIVER_ID_MESA_PANVK"),
		["samsung_proprietary"] = mod.VkDriverId("VK_DRIVER_ID_SAMSUNG_PROPRIETARY"),
		["mesa_venus"] = mod.VkDriverId("VK_DRIVER_ID_MESA_VENUS"),
		["mesa_dozen"] = mod.VkDriverId("VK_DRIVER_ID_MESA_DOZEN"),
		["mesa_nvk"] = mod.VkDriverId("VK_DRIVER_ID_MESA_NVK"),
		["broadcom_proprietary_khr"] = mod.VkDriverId("VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR"),
		["imagination_open_source_mesa"] = mod.VkDriverId("VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA"),
		["ggp_proprietary_khr"] = mod.VkDriverId("VK_DRIVER_ID_GGP_PROPRIETARY_KHR"),
		["mesa_honeykrisp"] = mod.VkDriverId("VK_DRIVER_ID_MESA_HONEYKRISP"),
		["google_swiftshader_khr"] = mod.VkDriverId("VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR"),
		["vulkan_sc_emulation_on_vulkan"] = mod.VkDriverId("VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN"),
		["arm_proprietary_khr"] = mod.VkDriverId("VK_DRIVER_ID_ARM_PROPRIETARY_KHR"),
		["amd_proprietary_khr"] = mod.VkDriverId("VK_DRIVER_ID_AMD_PROPRIETARY_KHR"),
		["qualcomm_proprietary_khr"] = mod.VkDriverId("VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR"),
		["amd_open_source_khr"] = mod.VkDriverId("VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR"),
		["imagination_proprietary_khr"] = mod.VkDriverId("VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR"),
		["mesa_radv_khr"] = mod.VkDriverId("VK_DRIVER_ID_MESA_RADV_KHR"),
		["intel_open_source_mesa_khr"] = mod.VkDriverId("VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR"),
		["nvidia_proprietary_khr"] = mod.VkDriverId("VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkDriverId") end

	return lookup[s] or
		error("unknown VkDriverId value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkShaderInfoTypeAMD = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["binary_amd"] = mod.VkShaderInfoTypeAMD("VK_SHADER_INFO_TYPE_BINARY_AMD"),
		["disassembly_amd"] = mod.VkShaderInfoTypeAMD("VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD"),
		["statistics_amd"] = mod.VkShaderInfoTypeAMD("VK_SHADER_INFO_TYPE_STATISTICS_AMD"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkShaderInfoTypeAMD")
	end

	return lookup[s] or
		error("unknown VkShaderInfoTypeAMD value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkRayTracingLssIndexingModeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["successive_nv"] = mod.VkRayTracingLssIndexingModeNV("VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV"),
		["list_nv"] = mod.VkRayTracingLssIndexingModeNV("VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkRayTracingLssIndexingModeNV")
	end

	return lookup[s] or
		error(
			"unknown VkRayTracingLssIndexingModeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkFilter = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["cubic_img"] = mod.VkFilter("VK_FILTER_CUBIC_IMG"),
		["cubic_ext"] = mod.VkFilter("VK_FILTER_CUBIC_EXT"),
		["linear"] = mod.VkFilter("VK_FILTER_LINEAR"),
		["nearest"] = mod.VkFilter("VK_FILTER_NEAREST"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkFilter") end

	return lookup[s] or
		error("unknown VkFilter value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkDiscardRectangleModeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["inclusive_ext"] = mod.VkDiscardRectangleModeEXT("VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT"),
		["exclusive_ext"] = mod.VkDiscardRectangleModeEXT("VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDiscardRectangleModeEXT")
	end

	return lookup[s] or
		error(
			"unknown VkDiscardRectangleModeEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkRasterizationOrderAMD = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["relaxed_amd"] = mod.VkRasterizationOrderAMD("VK_RASTERIZATION_ORDER_RELAXED_AMD"),
		["strict_amd"] = mod.VkRasterizationOrderAMD("VK_RASTERIZATION_ORDER_STRICT_AMD"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkRasterizationOrderAMD")
	end

	return lookup[s] or
		error(
			"unknown VkRasterizationOrderAMD value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkFenceImportFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["temporary"] = mod.VkFenceImportFlagBits("VK_FENCE_IMPORT_TEMPORARY_BIT"),
		["temporary_khr"] = mod.VkFenceImportFlagBits("VK_FENCE_IMPORT_TEMPORARY_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkFenceImportFlagBits")
	end

	return lookup[s] or
		error("unknown VkFenceImportFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkDebugReportObjectTypeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["sampler_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"),
		["descriptor_pool_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"),
		["descriptor_set_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"),
		["framebuffer_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"),
		["command_pool_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"),
		["surface_khr_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"),
		["unknown_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"),
		["swapchain_khr_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"),
		["instance_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"),
		["debug_report_callback_ext_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT"),
		["display_khr_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT"),
		["display_mode_khr_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT"),
		["validation_cache_ext_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT"),
		["sampler_ycbcr_conversion_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"),
		["descriptor_update_template_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"),
		["cu_module_nvx_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT"),
		["physical_device_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"),
		["queue_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"),
		["semaphore_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"),
		["command_buffer_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"),
		["fence_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"),
		["device_memory_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"),
		["buffer_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"),
		["device_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"),
		["image_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"),
		["sampler_ycbcr_conversion_khr_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT"),
		["event_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"),
		["descriptor_update_template_khr_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT"),
		["query_pool_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"),
		["validation_cache_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT"),
		["buffer_view_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"),
		["debug_report_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT"),
		["image_view_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"),
		["buffer_collection_fuchsia_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT"),
		["shader_module_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"),
		["cuda_function_nv_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT"),
		["pipeline_cache_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"),
		["cuda_module_nv_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT"),
		["pipeline_layout_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"),
		["acceleration_structure_nv_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT"),
		["render_pass_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"),
		["acceleration_structure_khr_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT"),
		["pipeline_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"),
		["cu_function_nvx_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT"),
		["descriptor_set_layout_ext"] = mod.VkDebugReportObjectTypeEXT("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDebugReportObjectTypeEXT")
	end

	return lookup[s] or
		error(
			"unknown VkDebugReportObjectTypeEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoAV1TransferCharacteristics = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["bt_2020_10"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_10_BIT"),
		["bt_2020_12"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_12_BIT"),
		["smpte_2084"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_2084"),
		["smpte_428"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_428"),
		["hlg"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_HLG"),
		["bt_709"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_709"),
		["unspecified"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_UNSPECIFIED"),
		["reserved_3"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_3"),
		["reserved_0"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_0"),
		["bt_470_b_g"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_B_G"),
		["linear"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LINEAR"),
		["bt_601"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_601"),
		["srgb"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SRGB"),
		["smpte_240"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_240"),
		["iec_61966"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_IEC_61966"),
		["invalid"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_INVALID"),
		["bt_1361"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_1361"),
		["bt_470_m"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_M"),
		["log_100"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100"),
		["log_100_sqrt10"] = mod.StdVideoAV1TransferCharacteristics("STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100_SQRT10"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoAV1TransferCharacteristics")
	end

	return lookup[s] or
		error(
			"unknown StdVideoAV1TransferCharacteristics value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSamplerAddressMode = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["repeat"] = mod.VkSamplerAddressMode("VK_SAMPLER_ADDRESS_MODE_REPEAT"),
		["clamp_to_border"] = mod.VkSamplerAddressMode("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),
		["mirror_clamp_to_edge"] = mod.VkSamplerAddressMode("VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"),
		["mirrored_repeat"] = mod.VkSamplerAddressMode("VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"),
		["mirror_clamp_to_edge_khr"] = mod.VkSamplerAddressMode("VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR"),
		["clamp_to_edge"] = mod.VkSamplerAddressMode("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSamplerAddressMode")
	end

	return lookup[s] or
		error("unknown VkSamplerAddressMode value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkHostImageCopyFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["memcpy"] = mod.VkHostImageCopyFlagBits("VK_HOST_IMAGE_COPY_MEMCPY"),
		["memcpy_ext"] = mod.VkHostImageCopyFlagBits("VK_HOST_IMAGE_COPY_MEMCPY_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkHostImageCopyFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkHostImageCopyFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPipelineShaderStageCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["require_full_subgroups_ext"] = mod.VkPipelineShaderStageCreateFlagBits("VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT"),
		["allow_varying_subgroup_size_ext"] = mod.VkPipelineShaderStageCreateFlagBits("VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT"),
		["require_full_subgroups"] = mod.VkPipelineShaderStageCreateFlagBits("VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT"),
		["allow_varying_subgroup_size"] = mod.VkPipelineShaderStageCreateFlagBits("VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineShaderStageCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineShaderStageCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSwapchainCreateFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["protected_khr"] = mod.VkSwapchainCreateFlagBitsKHR("VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR"),
		["mutable_format_khr"] = mod.VkSwapchainCreateFlagBitsKHR("VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR"),
		["split_instance_bind_regions_khr"] = mod.VkSwapchainCreateFlagBitsKHR("VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR"),
		["deferred_memory_allocation_ext"] = mod.VkSwapchainCreateFlagBitsKHR("VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT"),
		["present_wait_2_khr"] = mod.VkSwapchainCreateFlagBitsKHR("VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR"),
		["present_id_2_khr"] = mod.VkSwapchainCreateFlagBitsKHR("VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR"),
		["deferred_memory_allocation_khr"] = mod.VkSwapchainCreateFlagBitsKHR("VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSwapchainCreateFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkSwapchainCreateFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoAV1TxMode = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["largest"] = mod.StdVideoAV1TxMode("STD_VIDEO_AV1_TX_MODE_LARGEST"),
		["invalid"] = mod.StdVideoAV1TxMode("STD_VIDEO_AV1_TX_MODE_INVALID"),
		["only_4x4"] = mod.StdVideoAV1TxMode("STD_VIDEO_AV1_TX_MODE_ONLY_4X4"),
		["select"] = mod.StdVideoAV1TxMode("STD_VIDEO_AV1_TX_MODE_SELECT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoAV1TxMode")
	end

	return lookup[s] or
		error("unknown StdVideoAV1TxMode value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkPerformanceCounterDescriptionFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["performance_impacting_khr"] = mod.VkPerformanceCounterDescriptionFlagBitsKHR("VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR"),
		["concurrently_impacted_khr"] = mod.VkPerformanceCounterDescriptionFlagBitsKHR("VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPerformanceCounterDescriptionFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkPerformanceCounterDescriptionFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkFramebufferCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["imageless"] = mod.VkFramebufferCreateFlagBits("VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT"),
		["imageless_khr"] = mod.VkFramebufferCreateFlagBits("VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkFramebufferCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkFramebufferCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoAV1Profile = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["main"] = mod.StdVideoAV1Profile("STD_VIDEO_AV1_PROFILE_MAIN"),
		["high"] = mod.StdVideoAV1Profile("STD_VIDEO_AV1_PROFILE_HIGH"),
		["invalid"] = mod.StdVideoAV1Profile("STD_VIDEO_AV1_PROFILE_INVALID"),
		["professional"] = mod.StdVideoAV1Profile("STD_VIDEO_AV1_PROFILE_PROFESSIONAL"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoAV1Profile")
	end

	return lookup[s] or
		error("unknown StdVideoAV1Profile value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkColorSpaceKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["color_space_extended_srgb_nonlinear_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"),
		["color_space_display_native_amd"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_DISPLAY_NATIVE_AMD"),
		["color_space_srgb_nonlinear_khr"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"),
		["color_space_display_p3_nonlinear_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"),
		["color_space_extended_srgb_linear_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"),
		["color_space_display_p3_linear_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT"),
		["color_space_dci_p3_nonlinear_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"),
		["color_space_bt709_linear_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_BT709_LINEAR_EXT"),
		["color_space_bt709_nonlinear_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_BT709_NONLINEAR_EXT"),
		["color_space_bt2020_linear_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_BT2020_LINEAR_EXT"),
		["color_space_hdr10_st2084_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_HDR10_ST2084_EXT"),
		["color_space_dolbyvision_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_DOLBYVISION_EXT"),
		["color_space_hdr10_hlg_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_HDR10_HLG_EXT"),
		["color_space_adobergb_linear_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"),
		["color_space_dci_p3_linear_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_DCI_P3_LINEAR_EXT"),
		["color_space_adobergb_nonlinear_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"),
		["colorspace_srgb_nonlinear_khr"] = mod.VkColorSpaceKHR("VK_COLORSPACE_SRGB_NONLINEAR_KHR"),
		["color_space_pass_through_ext"] = mod.VkColorSpaceKHR("VK_COLOR_SPACE_PASS_THROUGH_EXT"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkColorSpaceKHR") end

	return lookup[s] or
		error("unknown VkColorSpaceKHR value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkSamplerMipmapMode = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["linear"] = mod.VkSamplerMipmapMode("VK_SAMPLER_MIPMAP_MODE_LINEAR"),
		["nearest"] = mod.VkSamplerMipmapMode("VK_SAMPLER_MIPMAP_MODE_NEAREST"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSamplerMipmapMode")
	end

	return lookup[s] or
		error("unknown VkSamplerMipmapMode value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkToolPurposeFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["validation_ext"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_VALIDATION_BIT_EXT"),
		["tracing"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_TRACING_BIT"),
		["profiling_ext"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_PROFILING_BIT_EXT"),
		["additional_features"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT"),
		["tracing_ext"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_TRACING_BIT_EXT"),
		["modifying_features"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT"),
		["additional_features_ext"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT"),
		["debug_reporting_ext"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"),
		["validation"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_VALIDATION_BIT"),
		["modifying_features_ext"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT"),
		["debug_markers_ext"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"),
		["profiling"] = mod.VkToolPurposeFlagBits("VK_TOOL_PURPOSE_PROFILING_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkToolPurposeFlagBits")
	end

	return lookup[s] or
		error("unknown VkToolPurposeFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkRenderPassCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["transform_qcom"] = mod.VkRenderPassCreateFlagBits("VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM"),
		["per_layer_fragment_density_valve"] = mod.VkRenderPassCreateFlagBits("VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkRenderPassCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkRenderPassCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkResolveModeFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["sample_zero"] = mod.VkResolveModeFlagBits("VK_RESOLVE_MODE_SAMPLE_ZERO_BIT"),
		["none_khr"] = mod.VkResolveModeFlagBits("VK_RESOLVE_MODE_NONE_KHR"),
		["min"] = mod.VkResolveModeFlagBits("VK_RESOLVE_MODE_MIN_BIT"),
		["external_format_downsample_android"] = mod.VkResolveModeFlagBits("VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID"),
		["average"] = mod.VkResolveModeFlagBits("VK_RESOLVE_MODE_AVERAGE_BIT"),
		["min_khr"] = mod.VkResolveModeFlagBits("VK_RESOLVE_MODE_MIN_BIT_KHR"),
		["sample_zero_khr"] = mod.VkResolveModeFlagBits("VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR"),
		["max"] = mod.VkResolveModeFlagBits("VK_RESOLVE_MODE_MAX_BIT"),
		["max_khr"] = mod.VkResolveModeFlagBits("VK_RESOLVE_MODE_MAX_BIT_KHR"),
		["average_khr"] = mod.VkResolveModeFlagBits("VK_RESOLVE_MODE_AVERAGE_BIT_KHR"),
		["none"] = mod.VkResolveModeFlagBits("VK_RESOLVE_MODE_NONE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkResolveModeFlagBits")
	end

	return lookup[s] or
		error("unknown VkResolveModeFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkDescriptorType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["partitioned_acceleration_structure_nv"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV"),
		["inline_uniform_block_ext"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT"),
		["mutable_valve"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_MUTABLE_VALVE"),
		["acceleration_structure_khr"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR"),
		["sampler"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_SAMPLER"),
		["acceleration_structure_nv"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV"),
		["sampled_image"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"),
		["input_attachment"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"),
		["storage_image"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"),
		["uniform_texel_buffer"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"),
		["uniform_buffer_dynamic"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"),
		["tensor_arm"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_TENSOR_ARM"),
		["storage_texel_buffer"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"),
		["combined_image_sampler"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),
		["inline_uniform_block"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK"),
		["uniform_buffer"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"),
		["sample_weight_image_qcom"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM"),
		["storage_buffer"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"),
		["block_match_image_qcom"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM"),
		["storage_buffer_dynamic"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"),
		["mutable_ext"] = mod.VkDescriptorType("VK_DESCRIPTOR_TYPE_MUTABLE_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDescriptorType")
	end

	return lookup[s] or
		error("unknown VkDescriptorType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkPresentGravityFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["max_ext"] = mod.VkPresentGravityFlagBitsKHR("VK_PRESENT_GRAVITY_MAX_BIT_EXT"),
		["min_khr"] = mod.VkPresentGravityFlagBitsKHR("VK_PRESENT_GRAVITY_MIN_BIT_KHR"),
		["centered_ext"] = mod.VkPresentGravityFlagBitsKHR("VK_PRESENT_GRAVITY_CENTERED_BIT_EXT"),
		["max_khr"] = mod.VkPresentGravityFlagBitsKHR("VK_PRESENT_GRAVITY_MAX_BIT_KHR"),
		["centered_khr"] = mod.VkPresentGravityFlagBitsKHR("VK_PRESENT_GRAVITY_CENTERED_BIT_KHR"),
		["min_ext"] = mod.VkPresentGravityFlagBitsKHR("VK_PRESENT_GRAVITY_MIN_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPresentGravityFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkPresentGravityFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkBlockMatchWindowCompareModeQCOM = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["max_qcom"] = mod.VkBlockMatchWindowCompareModeQCOM("VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM"),
		["min_qcom"] = mod.VkBlockMatchWindowCompareModeQCOM("VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkBlockMatchWindowCompareModeQCOM")
	end

	return lookup[s] or
		error(
			"unknown VkBlockMatchWindowCompareModeQCOM value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSubpassDescriptionFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["tile_shading_apron_qcom"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM"),
		["rasterization_order_attachment_depth_access_arm"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM"),
		["rasterization_order_attachment_color_access_ext"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT"),
		["per_view_attributes_nvx"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX"),
		["rasterization_order_attachment_stencil_access_arm"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM"),
		["enable_legacy_dithering_ext"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT"),
		["per_view_position_x_only_nvx"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX"),
		["fragment_region_qcom"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM"),
		["rasterization_order_attachment_depth_access_ext"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"),
		["shader_resolve_qcom"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM"),
		["rasterization_order_attachment_color_access_arm"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM"),
		["rasterization_order_attachment_stencil_access_ext"] = mod.VkSubpassDescriptionFlagBits("VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSubpassDescriptionFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkSubpassDescriptionFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkConservativeRasterizationModeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["overestimate_ext"] = mod.VkConservativeRasterizationModeEXT("VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT"),
		["disabled_ext"] = mod.VkConservativeRasterizationModeEXT("VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT"),
		["underestimate_ext"] = mod.VkConservativeRasterizationModeEXT("VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkConservativeRasterizationModeEXT")
	end

	return lookup[s] or
		error(
			"unknown VkConservativeRasterizationModeEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkCommandBufferUsageFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["simultaneous_use"] = mod.VkCommandBufferUsageFlagBits("VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"),
		["render_pass_continue"] = mod.VkCommandBufferUsageFlagBits("VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"),
		["one_time_submit"] = mod.VkCommandBufferUsageFlagBits("VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCommandBufferUsageFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkCommandBufferUsageFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDeviceGroupPresentModeFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["local_khr"] = mod.VkDeviceGroupPresentModeFlagBitsKHR("VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR"),
		["local_multi_device_khr"] = mod.VkDeviceGroupPresentModeFlagBitsKHR("VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR"),
		["sum_khr"] = mod.VkDeviceGroupPresentModeFlagBitsKHR("VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR"),
		["remote_khr"] = mod.VkDeviceGroupPresentModeFlagBitsKHR("VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDeviceGroupPresentModeFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkDeviceGroupPresentModeFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDescriptorBindingFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["partially_bound_ext"] = mod.VkDescriptorBindingFlagBits("VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT"),
		["update_after_bind"] = mod.VkDescriptorBindingFlagBits("VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT"),
		["variable_descriptor_count"] = mod.VkDescriptorBindingFlagBits("VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT"),
		["variable_descriptor_count_ext"] = mod.VkDescriptorBindingFlagBits("VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT"),
		["update_unused_while_pending"] = mod.VkDescriptorBindingFlagBits("VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT"),
		["update_after_bind_ext"] = mod.VkDescriptorBindingFlagBits("VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"),
		["update_unused_while_pending_ext"] = mod.VkDescriptorBindingFlagBits("VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT"),
		["partially_bound"] = mod.VkDescriptorBindingFlagBits("VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDescriptorBindingFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkDescriptorBindingFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkRayTracingLssPrimitiveEndCapsModeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["chained_nv"] = mod.VkRayTracingLssPrimitiveEndCapsModeNV("VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV"),
		["none_nv"] = mod.VkRayTracingLssPrimitiveEndCapsModeNV("VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkRayTracingLssPrimitiveEndCapsModeNV")
	end

	return lookup[s] or
		error(
			"unknown VkRayTracingLssPrimitiveEndCapsModeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDebugUtilsMessageSeverityFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["verbose_ext"] = mod.VkDebugUtilsMessageSeverityFlagBitsEXT("VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT"),
		["error_ext"] = mod.VkDebugUtilsMessageSeverityFlagBitsEXT("VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT"),
		["warning_ext"] = mod.VkDebugUtilsMessageSeverityFlagBitsEXT("VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT"),
		["info_ext"] = mod.VkDebugUtilsMessageSeverityFlagBitsEXT("VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDebugUtilsMessageSeverityFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkDebugUtilsMessageSeverityFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPerformanceCounterStorageKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["int32_khr"] = mod.VkPerformanceCounterStorageKHR("VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR"),
		["float64_khr"] = mod.VkPerformanceCounterStorageKHR("VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR"),
		["float32_khr"] = mod.VkPerformanceCounterStorageKHR("VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR"),
		["int64_khr"] = mod.VkPerformanceCounterStorageKHR("VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR"),
		["uint32_khr"] = mod.VkPerformanceCounterStorageKHR("VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR"),
		["uint64_khr"] = mod.VkPerformanceCounterStorageKHR("VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPerformanceCounterStorageKHR")
	end

	return lookup[s] or
		error(
			"unknown VkPerformanceCounterStorageKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeAV1RateControlGroupKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["predictive_khr"] = mod.VkVideoEncodeAV1RateControlGroupKHR("VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR"),
		["intra_khr"] = mod.VkVideoEncodeAV1RateControlGroupKHR("VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR"),
		["bipredictive_khr"] = mod.VkVideoEncodeAV1RateControlGroupKHR("VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeAV1RateControlGroupKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeAV1RateControlGroupKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeH265TransformBlockSizeFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["32_khr"] = mod.VkVideoEncodeH265TransformBlockSizeFlagBitsKHR("VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR"),
		["16_khr"] = mod.VkVideoEncodeH265TransformBlockSizeFlagBitsKHR("VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR"),
		["8_khr"] = mod.VkVideoEncodeH265TransformBlockSizeFlagBitsKHR("VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR"),
		["4_khr"] = mod.VkVideoEncodeH265TransformBlockSizeFlagBitsKHR("VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeH265TransformBlockSizeFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeH265TransformBlockSizeFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoAV1ColorPrimaries = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["generic_film"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_GENERIC_FILM"),
		["xyz"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_XYZ"),
		["smpte_431"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_431"),
		["bt_470_b_g"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_B_G"),
		["invalid"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_INVALID"),
		["bt_601"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_BT_601"),
		["ebu_3213"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_EBU_3213"),
		["smpte_240"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_240"),
		["smpte_432"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_432"),
		["bt_unspecified"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_BT_UNSPECIFIED"),
		["bt_470_m"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_M"),
		["bt_709"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_BT_709"),
		["unspecified"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_UNSPECIFIED"),
		["bt_2020"] = mod.StdVideoAV1ColorPrimaries("STD_VIDEO_AV1_COLOR_PRIMARIES_BT_2020"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoAV1ColorPrimaries")
	end

	return lookup[s] or
		error(
			"unknown StdVideoAV1ColorPrimaries value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkQueryControlFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["precise"] = mod.VkQueryControlFlagBits("VK_QUERY_CONTROL_PRECISE_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkQueryControlFlagBits")
	end

	return lookup[s] or
		error("unknown VkQueryControlFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkDeviceQueueCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["protected"] = mod.VkDeviceQueueCreateFlagBits("VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDeviceQueueCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkDeviceQueueCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264NonVclNaluType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["aud"] = mod.StdVideoH264NonVclNaluType("STD_VIDEO_H264_NON_VCL_NALU_TYPE_AUD"),
		["invalid"] = mod.StdVideoH264NonVclNaluType("STD_VIDEO_H264_NON_VCL_NALU_TYPE_INVALID"),
		["prefix"] = mod.StdVideoH264NonVclNaluType("STD_VIDEO_H264_NON_VCL_NALU_TYPE_PREFIX"),
		["end_of_sequence"] = mod.StdVideoH264NonVclNaluType("STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_SEQUENCE"),
		["sps"] = mod.StdVideoH264NonVclNaluType("STD_VIDEO_H264_NON_VCL_NALU_TYPE_SPS"),
		["end_of_stream"] = mod.StdVideoH264NonVclNaluType("STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_STREAM"),
		["pps"] = mod.StdVideoH264NonVclNaluType("STD_VIDEO_H264_NON_VCL_NALU_TYPE_PPS"),
		["precoded"] = mod.StdVideoH264NonVclNaluType("STD_VIDEO_H264_NON_VCL_NALU_TYPE_PRECODED"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264NonVclNaluType")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH264NonVclNaluType value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDescriptorPoolCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["host_only_valve"] = mod.VkDescriptorPoolCreateFlagBits("VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE"),
		["update_after_bind"] = mod.VkDescriptorPoolCreateFlagBits("VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT"),
		["allow_overallocation_pools_nv"] = mod.VkDescriptorPoolCreateFlagBits("VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV"),
		["host_only_ext"] = mod.VkDescriptorPoolCreateFlagBits("VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT"),
		["update_after_bind_ext"] = mod.VkDescriptorPoolCreateFlagBits("VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT"),
		["free_descriptor_set"] = mod.VkDescriptorPoolCreateFlagBits("VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),
		["allow_overallocation_sets_nv"] = mod.VkDescriptorPoolCreateFlagBits("VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDescriptorPoolCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkDescriptorPoolCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkCommandPoolCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["reset_command_buffer"] = mod.VkCommandPoolCreateFlagBits("VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),
		["transient"] = mod.VkCommandPoolCreateFlagBits("VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),
		["protected"] = mod.VkCommandPoolCreateFlagBits("VK_COMMAND_POOL_CREATE_PROTECTED_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCommandPoolCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkCommandPoolCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkMemoryOverallocationBehaviorAMD = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["default_amd"] = mod.VkMemoryOverallocationBehaviorAMD("VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD"),
		["allowed_amd"] = mod.VkMemoryOverallocationBehaviorAMD("VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD"),
		["disallowed_amd"] = mod.VkMemoryOverallocationBehaviorAMD("VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkMemoryOverallocationBehaviorAMD")
	end

	return lookup[s] or
		error(
			"unknown VkMemoryOverallocationBehaviorAMD value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264ModificationOfPicNumsIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["invalid"] = mod.StdVideoH264ModificationOfPicNumsIdc("STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_INVALID"),
		["short_term_subtract"] = mod.StdVideoH264ModificationOfPicNumsIdc("STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_SUBTRACT"),
		["short_term_add"] = mod.StdVideoH264ModificationOfPicNumsIdc("STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_ADD"),
		["end"] = mod.StdVideoH264ModificationOfPicNumsIdc("STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_END"),
		["long_term"] = mod.StdVideoH264ModificationOfPicNumsIdc("STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_LONG_TERM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264ModificationOfPicNumsIdc")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH264ModificationOfPicNumsIdc value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkTileShadingRenderPassFlagBitsQCOM = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["per_tile_execution_qcom"] = mod.VkTileShadingRenderPassFlagBitsQCOM("VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM"),
		["enable_qcom"] = mod.VkTileShadingRenderPassFlagBitsQCOM("VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkTileShadingRenderPassFlagBitsQCOM")
	end

	return lookup[s] or
		error(
			"unknown VkTileShadingRenderPassFlagBitsQCOM value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264WeightedBipredIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["explicit"] = mod.StdVideoH264WeightedBipredIdc("STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT"),
		["implicit"] = mod.StdVideoH264WeightedBipredIdc("STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_IMPLICIT"),
		["invalid"] = mod.StdVideoH264WeightedBipredIdc("STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_INVALID"),
		["default"] = mod.StdVideoH264WeightedBipredIdc("STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_DEFAULT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264WeightedBipredIdc")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH264WeightedBipredIdc value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoVP9FrameType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["non_key"] = mod.StdVideoVP9FrameType("STD_VIDEO_VP9_FRAME_TYPE_NON_KEY"),
		["key"] = mod.StdVideoVP9FrameType("STD_VIDEO_VP9_FRAME_TYPE_KEY"),
		["invalid"] = mod.StdVideoVP9FrameType("STD_VIDEO_VP9_FRAME_TYPE_INVALID"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoVP9FrameType")
	end

	return lookup[s] or
		error("unknown StdVideoVP9FrameType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkCommandPoolResetFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["release_resources"] = mod.VkCommandPoolResetFlagBits("VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCommandPoolResetFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkCommandPoolResetFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264MemMgmtControlOp = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["invalid"] = mod.StdVideoH264MemMgmtControlOp("STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_INVALID"),
		["unmark_long_term"] = mod.StdVideoH264MemMgmtControlOp("STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_LONG_TERM"),
		["mark_current_as_long_term"] = mod.StdVideoH264MemMgmtControlOp("STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_CURRENT_AS_LONG_TERM"),
		["mark_long_term"] = mod.StdVideoH264MemMgmtControlOp("STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_LONG_TERM"),
		["unmark_all"] = mod.StdVideoH264MemMgmtControlOp("STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_ALL"),
		["set_max_long_term_index"] = mod.StdVideoH264MemMgmtControlOp("STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_SET_MAX_LONG_TERM_INDEX"),
		["end"] = mod.StdVideoH264MemMgmtControlOp("STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_END"),
		["unmark_short_term"] = mod.StdVideoH264MemMgmtControlOp("STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_SHORT_TERM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264MemMgmtControlOp")
	end

	return lookup[s] or
		error(
			"unknown StdVideoH264MemMgmtControlOp value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeAV1PredictionModeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["bidirectional_compound_khr"] = mod.VkVideoEncodeAV1PredictionModeKHR("VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR"),
		["intra_only_khr"] = mod.VkVideoEncodeAV1PredictionModeKHR("VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR"),
		["unidirectional_compound_khr"] = mod.VkVideoEncodeAV1PredictionModeKHR("VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR"),
		["single_reference_khr"] = mod.VkVideoEncodeAV1PredictionModeKHR("VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeAV1PredictionModeKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeAV1PredictionModeKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoAV1FrameType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["invalid"] = mod.StdVideoAV1FrameType("STD_VIDEO_AV1_FRAME_TYPE_INVALID"),
		["key"] = mod.StdVideoAV1FrameType("STD_VIDEO_AV1_FRAME_TYPE_KEY"),
		["switch"] = mod.StdVideoAV1FrameType("STD_VIDEO_AV1_FRAME_TYPE_SWITCH"),
		["inter"] = mod.StdVideoAV1FrameType("STD_VIDEO_AV1_FRAME_TYPE_INTER"),
		["intra_only"] = mod.StdVideoAV1FrameType("STD_VIDEO_AV1_FRAME_TYPE_INTRA_ONLY"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoAV1FrameType")
	end

	return lookup[s] or
		error("unknown StdVideoAV1FrameType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.StdVideoVP9ReferenceName = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["intra_frame"] = mod.StdVideoVP9ReferenceName("STD_VIDEO_VP9_REFERENCE_NAME_INTRA_FRAME"),
		["invalid"] = mod.StdVideoVP9ReferenceName("STD_VIDEO_VP9_REFERENCE_NAME_INVALID"),
		["last_frame"] = mod.StdVideoVP9ReferenceName("STD_VIDEO_VP9_REFERENCE_NAME_LAST_FRAME"),
		["golden_frame"] = mod.StdVideoVP9ReferenceName("STD_VIDEO_VP9_REFERENCE_NAME_GOLDEN_FRAME"),
		["altref_frame"] = mod.StdVideoVP9ReferenceName("STD_VIDEO_VP9_REFERENCE_NAME_ALTREF_FRAME"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoVP9ReferenceName")
	end

	return lookup[s] or
		error(
			"unknown StdVideoVP9ReferenceName value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkImageViewType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["1d"] = mod.VkImageViewType("VK_IMAGE_VIEW_TYPE_1D"),
		["cube_array"] = mod.VkImageViewType("VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"),
		["2d"] = mod.VkImageViewType("VK_IMAGE_VIEW_TYPE_2D"),
		["2d_array"] = mod.VkImageViewType("VK_IMAGE_VIEW_TYPE_2D_ARRAY"),
		["cube"] = mod.VkImageViewType("VK_IMAGE_VIEW_TYPE_CUBE"),
		["3d"] = mod.VkImageViewType("VK_IMAGE_VIEW_TYPE_3D"),
		["1d_array"] = mod.VkImageViewType("VK_IMAGE_VIEW_TYPE_1D_ARRAY"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkImageViewType") end

	return lookup[s] or
		error("unknown VkImageViewType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoDecodeUsageFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["offline_khr"] = mod.VkVideoDecodeUsageFlagBitsKHR("VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR"),
		["streaming_khr"] = mod.VkVideoDecodeUsageFlagBitsKHR("VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR"),
		["transcoding_khr"] = mod.VkVideoDecodeUsageFlagBitsKHR("VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR"),
		["default_khr"] = mod.VkVideoDecodeUsageFlagBitsKHR("VK_VIDEO_DECODE_USAGE_DEFAULT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoDecodeUsageFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoDecodeUsageFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkMemoryHeapFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["tile_memory_qcom"] = mod.VkMemoryHeapFlagBits("VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM"),
		["device_local"] = mod.VkMemoryHeapFlagBits("VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"),
		["multi_instance_khr"] = mod.VkMemoryHeapFlagBits("VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR"),
		["multi_instance"] = mod.VkMemoryHeapFlagBits("VK_MEMORY_HEAP_MULTI_INSTANCE_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkMemoryHeapFlagBits")
	end

	return lookup[s] or
		error("unknown VkMemoryHeapFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeAV1RateControlFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["regular_gop_khr"] = mod.VkVideoEncodeAV1RateControlFlagBitsKHR("VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR"),
		["reference_pattern_flat_khr"] = mod.VkVideoEncodeAV1RateControlFlagBitsKHR("VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR"),
		["reference_pattern_dyadic_khr"] = mod.VkVideoEncodeAV1RateControlFlagBitsKHR("VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR"),
		["temporal_layer_pattern_dyadic_khr"] = mod.VkVideoEncodeAV1RateControlFlagBitsKHR("VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeAV1RateControlFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeAV1RateControlFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDescriptorSetLayoutCreateFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["update_after_bind_pool"] = mod.VkDescriptorSetLayoutCreateFlagBits("VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT"),
		["indirect_bindable_nv"] = mod.VkDescriptorSetLayoutCreateFlagBits("VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV"),
		["push_descriptor"] = mod.VkDescriptorSetLayoutCreateFlagBits("VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT"),
		["host_only_pool_ext"] = mod.VkDescriptorSetLayoutCreateFlagBits("VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT"),
		["descriptor_buffer_ext"] = mod.VkDescriptorSetLayoutCreateFlagBits("VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT"),
		["per_stage_nv"] = mod.VkDescriptorSetLayoutCreateFlagBits("VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV"),
		["embedded_immutable_samplers_ext"] = mod.VkDescriptorSetLayoutCreateFlagBits("VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT"),
		["push_descriptor_khr"] = mod.VkDescriptorSetLayoutCreateFlagBits("VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR"),
		["host_only_pool_valve"] = mod.VkDescriptorSetLayoutCreateFlagBits("VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE"),
		["update_after_bind_pool_ext"] = mod.VkDescriptorSetLayoutCreateFlagBits("VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDescriptorSetLayoutCreateFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkDescriptorSetLayoutCreateFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoAV1ReferenceName = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["intra_frame"] = mod.StdVideoAV1ReferenceName("STD_VIDEO_AV1_REFERENCE_NAME_INTRA_FRAME"),
		["bwdref_frame"] = mod.StdVideoAV1ReferenceName("STD_VIDEO_AV1_REFERENCE_NAME_BWDREF_FRAME"),
		["last_frame"] = mod.StdVideoAV1ReferenceName("STD_VIDEO_AV1_REFERENCE_NAME_LAST_FRAME"),
		["altref2_frame"] = mod.StdVideoAV1ReferenceName("STD_VIDEO_AV1_REFERENCE_NAME_ALTREF2_FRAME"),
		["golden_frame"] = mod.StdVideoAV1ReferenceName("STD_VIDEO_AV1_REFERENCE_NAME_GOLDEN_FRAME"),
		["altref_frame"] = mod.StdVideoAV1ReferenceName("STD_VIDEO_AV1_REFERENCE_NAME_ALTREF_FRAME"),
		["invalid"] = mod.StdVideoAV1ReferenceName("STD_VIDEO_AV1_REFERENCE_NAME_INVALID"),
		["last2_frame"] = mod.StdVideoAV1ReferenceName("STD_VIDEO_AV1_REFERENCE_NAME_LAST2_FRAME"),
		["last3_frame"] = mod.StdVideoAV1ReferenceName("STD_VIDEO_AV1_REFERENCE_NAME_LAST3_FRAME"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoAV1ReferenceName")
	end

	return lookup[s] or
		error(
			"unknown StdVideoAV1ReferenceName value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoVP9InterpolationFilter = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["eighttap_smooth"] = mod.StdVideoVP9InterpolationFilter("STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH"),
		["invalid"] = mod.StdVideoVP9InterpolationFilter("STD_VIDEO_VP9_INTERPOLATION_FILTER_INVALID"),
		["eighttap_sharp"] = mod.StdVideoVP9InterpolationFilter("STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP_SHARP"),
		["bilinear"] = mod.StdVideoVP9InterpolationFilter("STD_VIDEO_VP9_INTERPOLATION_FILTER_BILINEAR"),
		["eighttap"] = mod.StdVideoVP9InterpolationFilter("STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP"),
		["switchable"] = mod.StdVideoVP9InterpolationFilter("STD_VIDEO_VP9_INTERPOLATION_FILTER_SWITCHABLE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoVP9InterpolationFilter")
	end

	return lookup[s] or
		error(
			"unknown StdVideoVP9InterpolationFilter value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH265ProfileIdc = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["format_range_extensions"] = mod.StdVideoH265ProfileIdc("STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS"),
		["scc_extensions"] = mod.StdVideoH265ProfileIdc("STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS"),
		["main"] = mod.StdVideoH265ProfileIdc("STD_VIDEO_H265_PROFILE_IDC_MAIN"),
		["main_10"] = mod.StdVideoH265ProfileIdc("STD_VIDEO_H265_PROFILE_IDC_MAIN_10"),
		["invalid"] = mod.StdVideoH265ProfileIdc("STD_VIDEO_H265_PROFILE_IDC_INVALID"),
		["main_still_picture"] = mod.StdVideoH265ProfileIdc("STD_VIDEO_H265_PROFILE_IDC_MAIN_STILL_PICTURE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH265ProfileIdc")
	end

	return lookup[s] or
		error("unknown StdVideoH265ProfileIdc value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeAV1CapabilityFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["generate_obu_extension_header_khr"] = mod.VkVideoEncodeAV1CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR"),
		["motion_vector_scaling_khr"] = mod.VkVideoEncodeAV1CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR"),
		["primary_reference_cdf_only_khr"] = mod.VkVideoEncodeAV1CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR"),
		["compound_prediction_intra_refresh_khr"] = mod.VkVideoEncodeAV1CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR"),
		["per_rate_control_group_min_max_q_index_khr"] = mod.VkVideoEncodeAV1CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR"),
		["frame_size_override_khr"] = mod.VkVideoEncodeAV1CapabilityFlagBitsKHR("VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeAV1CapabilityFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeAV1CapabilityFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkCommandBufferResetFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["release_resources"] = mod.VkCommandBufferResetFlagBits("VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCommandBufferResetFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkCommandBufferResetFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPeerMemoryFeatureFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["copy_dst"] = mod.VkPeerMemoryFeatureFlagBits("VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"),
		["copy_src_khr"] = mod.VkPeerMemoryFeatureFlagBits("VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR"),
		["generic_dst_khr"] = mod.VkPeerMemoryFeatureFlagBits("VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR"),
		["generic_src"] = mod.VkPeerMemoryFeatureFlagBits("VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"),
		["copy_dst_khr"] = mod.VkPeerMemoryFeatureFlagBits("VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR"),
		["copy_src"] = mod.VkPeerMemoryFeatureFlagBits("VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"),
		["generic_dst"] = mod.VkPeerMemoryFeatureFlagBits("VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"),
		["generic_src_khr"] = mod.VkPeerMemoryFeatureFlagBits("VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPeerMemoryFeatureFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkPeerMemoryFeatureFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSharingMode = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["concurrent"] = mod.VkSharingMode("VK_SHARING_MODE_CONCURRENT"),
		["exclusive"] = mod.VkSharingMode("VK_SHARING_MODE_EXCLUSIVE"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkSharingMode") end

	return lookup[s] or
		error("unknown VkSharingMode value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkPhysicalDeviceType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["cpu"] = mod.VkPhysicalDeviceType("VK_PHYSICAL_DEVICE_TYPE_CPU"),
		["integrated_gpu"] = mod.VkPhysicalDeviceType("VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"),
		["discrete_gpu"] = mod.VkPhysicalDeviceType("VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"),
		["virtual_gpu"] = mod.VkPhysicalDeviceType("VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"),
		["other"] = mod.VkPhysicalDeviceType("VK_PHYSICAL_DEVICE_TYPE_OTHER"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPhysicalDeviceType")
	end

	return lookup[s] or
		error("unknown VkPhysicalDeviceType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkStencilFaceFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["face_front"] = mod.VkStencilFaceFlagBits("VK_STENCIL_FACE_FRONT_BIT"),
		["face_front_and_back"] = mod.VkStencilFaceFlagBits("VK_STENCIL_FACE_FRONT_AND_BACK"),
		["front_and_back"] = mod.VkStencilFaceFlagBits("VK_STENCIL_FRONT_AND_BACK"),
		["face_back"] = mod.VkStencilFaceFlagBits("VK_STENCIL_FACE_BACK_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkStencilFaceFlagBits")
	end

	return lookup[s] or
		error("unknown VkStencilFaceFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkFrameBoundaryFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["frame_end_ext"] = mod.VkFrameBoundaryFlagBitsEXT("VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkFrameBoundaryFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkFrameBoundaryFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkComponentSwizzle = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["one"] = mod.VkComponentSwizzle("VK_COMPONENT_SWIZZLE_ONE"),
		["a"] = mod.VkComponentSwizzle("VK_COMPONENT_SWIZZLE_A"),
		["identity"] = mod.VkComponentSwizzle("VK_COMPONENT_SWIZZLE_IDENTITY"),
		["b"] = mod.VkComponentSwizzle("VK_COMPONENT_SWIZZLE_B"),
		["g"] = mod.VkComponentSwizzle("VK_COMPONENT_SWIZZLE_G"),
		["r"] = mod.VkComponentSwizzle("VK_COMPONENT_SWIZZLE_R"),
		["zero"] = mod.VkComponentSwizzle("VK_COMPONENT_SWIZZLE_ZERO"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkComponentSwizzle")
	end

	return lookup[s] or
		error("unknown VkComponentSwizzle value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.StdVideoAV1InterpolationFilter = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["eighttap_smooth"] = mod.StdVideoAV1InterpolationFilter("STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH"),
		["invalid"] = mod.StdVideoAV1InterpolationFilter("STD_VIDEO_AV1_INTERPOLATION_FILTER_INVALID"),
		["eighttap_sharp"] = mod.StdVideoAV1InterpolationFilter("STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP"),
		["bilinear"] = mod.StdVideoAV1InterpolationFilter("STD_VIDEO_AV1_INTERPOLATION_FILTER_BILINEAR"),
		["eighttap"] = mod.StdVideoAV1InterpolationFilter("STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP"),
		["switchable"] = mod.StdVideoAV1InterpolationFilter("STD_VIDEO_AV1_INTERPOLATION_FILTER_SWITCHABLE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoAV1InterpolationFilter")
	end

	return lookup[s] or
		error(
			"unknown StdVideoAV1InterpolationFilter value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkVideoEncodeAV1StdFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["delta_q_khr"] = mod.VkVideoEncodeAV1StdFlagBitsKHR("VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR"),
		["primary_ref_frame_khr"] = mod.VkVideoEncodeAV1StdFlagBitsKHR("VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR"),
		["skip_mode_present_unset_khr"] = mod.VkVideoEncodeAV1StdFlagBitsKHR("VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR"),
		["uniform_tile_spacing_flag_set_khr"] = mod.VkVideoEncodeAV1StdFlagBitsKHR("VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeAV1StdFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeAV1StdFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPipelineStageFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["ray_tracing_shader_nv"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV"),
		["vertex_shader"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"),
		["conditional_rendering_ext"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT"),
		["acceleration_structure_build_nv"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV"),
		["tessellation_control_shader"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT"),
		["task_shader_nv"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"),
		["tessellation_evaluation_shader"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"),
		["mesh_shader_nv"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"),
		["geometry_shader"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"),
		["command_preprocess_nv"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV"),
		["fragment_shader"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"),
		["early_fragment_tests"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"),
		["late_fragment_tests"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"),
		["color_attachment_output"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"),
		["compute_shader"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"),
		["shading_rate_image_nv"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV"),
		["all_graphics"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"),
		["none"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_NONE"),
		["none_khr"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_NONE_KHR"),
		["host"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_HOST_BIT"),
		["all_commands"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"),
		["transform_feedback_ext"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT"),
		["acceleration_structure_build_khr"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"),
		["transfer"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_TRANSFER_BIT"),
		["ray_tracing_shader_khr"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR"),
		["fragment_density_process_ext"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT"),
		["task_shader_ext"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT"),
		["top_of_pipe"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"),
		["mesh_shader_ext"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT"),
		["draw_indirect"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"),
		["bottom_of_pipe"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"),
		["command_preprocess_ext"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT"),
		["vertex_input"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"),
		["fragment_shading_rate_attachment_khr"] = mod.VkPipelineStageFlagBits("VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineStageFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineStageFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPresentScalingFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["one_to_one_khr"] = mod.VkPresentScalingFlagBitsKHR("VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR"),
		["one_to_one_ext"] = mod.VkPresentScalingFlagBitsKHR("VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT"),
		["aspect_ratio_stretch_khr"] = mod.VkPresentScalingFlagBitsKHR("VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR"),
		["aspect_ratio_stretch_ext"] = mod.VkPresentScalingFlagBitsKHR("VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT"),
		["stretch_khr"] = mod.VkPresentScalingFlagBitsKHR("VK_PRESENT_SCALING_STRETCH_BIT_KHR"),
		["stretch_ext"] = mod.VkPresentScalingFlagBitsKHR("VK_PRESENT_SCALING_STRETCH_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPresentScalingFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkPresentScalingFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkBlendOverlapEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["disjoint_ext"] = mod.VkBlendOverlapEXT("VK_BLEND_OVERLAP_DISJOINT_EXT"),
		["uncorrelated_ext"] = mod.VkBlendOverlapEXT("VK_BLEND_OVERLAP_UNCORRELATED_EXT"),
		["conjoint_ext"] = mod.VkBlendOverlapEXT("VK_BLEND_OVERLAP_CONJOINT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkBlendOverlapEXT")
	end

	return lookup[s] or
		error("unknown VkBlendOverlapEXT value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.StdVideoVP9ColorSpace = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["unknown"] = mod.StdVideoVP9ColorSpace("STD_VIDEO_VP9_COLOR_SPACE_UNKNOWN"),
		["rgb"] = mod.StdVideoVP9ColorSpace("STD_VIDEO_VP9_COLOR_SPACE_RGB"),
		["bt_601"] = mod.StdVideoVP9ColorSpace("STD_VIDEO_VP9_COLOR_SPACE_BT_601"),
		["smpte_240"] = mod.StdVideoVP9ColorSpace("STD_VIDEO_VP9_COLOR_SPACE_SMPTE_240"),
		["invalid"] = mod.StdVideoVP9ColorSpace("STD_VIDEO_VP9_COLOR_SPACE_INVALID"),
		["smpte_170"] = mod.StdVideoVP9ColorSpace("STD_VIDEO_VP9_COLOR_SPACE_SMPTE_170"),
		["bt_709"] = mod.StdVideoVP9ColorSpace("STD_VIDEO_VP9_COLOR_SPACE_BT_709"),
		["reserved"] = mod.StdVideoVP9ColorSpace("STD_VIDEO_VP9_COLOR_SPACE_RESERVED"),
		["bt_2020"] = mod.StdVideoVP9ColorSpace("STD_VIDEO_VP9_COLOR_SPACE_BT_2020"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoVP9ColorSpace")
	end

	return lookup[s] or
		error("unknown StdVideoVP9ColorSpace value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkDependencyFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["asymmetric_event_khr"] = mod.VkDependencyFlagBits("VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR"),
		["by_region"] = mod.VkDependencyFlagBits("VK_DEPENDENCY_BY_REGION_BIT"),
		["feedback_loop_ext"] = mod.VkDependencyFlagBits("VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT"),
		["view_local_khr"] = mod.VkDependencyFlagBits("VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR"),
		["device_group"] = mod.VkDependencyFlagBits("VK_DEPENDENCY_DEVICE_GROUP_BIT"),
		["queue_family_ownership_transfer_use_all_stages_khr"] = mod.VkDependencyFlagBits("VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR"),
		["device_group_khr"] = mod.VkDependencyFlagBits("VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR"),
		["view_local"] = mod.VkDependencyFlagBits("VK_DEPENDENCY_VIEW_LOCAL_BIT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDependencyFlagBits")
	end

	return lookup[s] or
		error("unknown VkDependencyFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.StdVideoAV1Level = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["7_3"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_7_3"),
		["2_2"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_2_2"),
		["3_2"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_3_2"),
		["4_2"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_4_2"),
		["invalid"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_INVALID"),
		["5_2"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_5_2"),
		["7_1"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_7_1"),
		["7_0"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_7_0"),
		["6_3"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_6_3"),
		["6_2"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_6_2"),
		["5_0"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_5_0"),
		["5_1"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_5_1"),
		["2_0"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_2_0"),
		["2_1"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_2_1"),
		["3_0"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_3_0"),
		["3_1"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_3_1"),
		["4_0"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_4_0"),
		["4_1"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_4_1"),
		["2_3"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_2_3"),
		["3_3"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_3_3"),
		["5_3"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_5_3"),
		["6_0"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_6_0"),
		["6_1"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_6_1"),
		["4_3"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_4_3"),
		["7_2"] = mod.StdVideoAV1Level("STD_VIDEO_AV1_LEVEL_7_2"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoAV1Level")
	end

	return lookup[s] or
		error("unknown StdVideoAV1Level value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeAV1SuperblockSizeFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["128_khr"] = mod.VkVideoEncodeAV1SuperblockSizeFlagBitsKHR("VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR"),
		["64_khr"] = mod.VkVideoEncodeAV1SuperblockSizeFlagBitsKHR("VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeAV1SuperblockSizeFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeAV1SuperblockSizeFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkLogicOp = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["set"] = mod.VkLogicOp("VK_LOGIC_OP_SET"),
		["equivalent"] = mod.VkLogicOp("VK_LOGIC_OP_EQUIVALENT"),
		["invert"] = mod.VkLogicOp("VK_LOGIC_OP_INVERT"),
		["or_reverse"] = mod.VkLogicOp("VK_LOGIC_OP_OR_REVERSE"),
		["nand"] = mod.VkLogicOp("VK_LOGIC_OP_NAND"),
		["and_reverse"] = mod.VkLogicOp("VK_LOGIC_OP_AND_REVERSE"),
		["copy_inverted"] = mod.VkLogicOp("VK_LOGIC_OP_COPY_INVERTED"),
		["or_inverted"] = mod.VkLogicOp("VK_LOGIC_OP_OR_INVERTED"),
		["and_inverted"] = mod.VkLogicOp("VK_LOGIC_OP_AND_INVERTED"),
		["and"] = mod.VkLogicOp("VK_LOGIC_OP_AND"),
		["no_op"] = mod.VkLogicOp("VK_LOGIC_OP_NO_OP"),
		["clear"] = mod.VkLogicOp("VK_LOGIC_OP_CLEAR"),
		["xor"] = mod.VkLogicOp("VK_LOGIC_OP_XOR"),
		["copy"] = mod.VkLogicOp("VK_LOGIC_OP_COPY"),
		["or"] = mod.VkLogicOp("VK_LOGIC_OP_OR"),
		["nor"] = mod.VkLogicOp("VK_LOGIC_OP_NOR"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkLogicOp") end

	return lookup[s] or
		error("unknown VkLogicOp value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkImageLayout = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["shader_read_only_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"),
		["transfer_src_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"),
		["transfer_dst_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),
		["preinitialized"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_PREINITIALIZED"),
		["attachment_feedback_loop_optimal_ext"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT"),
		["video_encode_quantization_map_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR"),
		["zero_initialized_ext"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT"),
		["video_encode_dst_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR"),
		["stencil_attachment_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL"),
		["video_encode_src_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR"),
		["stencil_read_only_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL"),
		["tensor_aliasing_arm"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM"),
		["read_only_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL"),
		["attachment_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL"),
		["rendering_local_read"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ"),
		["stencil_attachment_optimal_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR"),
		["stencil_read_only_optimal_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR"),
		["read_only_optimal_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR"),
		["attachment_optimal_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR"),
		["undefined"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_UNDEFINED"),
		["depth_read_only_optimal_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR"),
		["depth_attachment_optimal_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR"),
		["rendering_local_read_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR"),
		["shading_rate_optimal_nv"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV"),
		["depth_attachment_stencil_read_only_optimal_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR"),
		["depth_read_only_stencil_attachment_optimal_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR"),
		["depth_read_only_stencil_attachment_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"),
		["video_encode_dpb_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR"),
		["fragment_density_map_optimal_ext"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT"),
		["depth_attachment_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL"),
		["depth_read_only_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL"),
		["fragment_shading_rate_attachment_optimal_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR"),
		["video_decode_src_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR"),
		["present_src_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"),
		["general"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_GENERAL"),
		["video_decode_dst_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR"),
		["color_attachment_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"),
		["video_decode_dpb_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR"),
		["depth_stencil_attachment_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"),
		["depth_attachment_stencil_read_only_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"),
		["depth_stencil_read_only_optimal"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"),
		["shared_present_khr"] = mod.VkImageLayout("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkImageLayout") end

	return lookup[s] or
		error("unknown VkImageLayout value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkDirectDriverLoadingModeLUNARG = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["inclusive_lunarg"] = mod.VkDirectDriverLoadingModeLUNARG("VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG"),
		["exclusive_lunarg"] = mod.VkDirectDriverLoadingModeLUNARG("VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDirectDriverLoadingModeLUNARG")
	end

	return lookup[s] or
		error(
			"unknown VkDirectDriverLoadingModeLUNARG value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDisplayEventTypeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["first_pixel_out_ext"] = mod.VkDisplayEventTypeEXT("VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDisplayEventTypeEXT")
	end

	return lookup[s] or
		error("unknown VkDisplayEventTypeEXT value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeTuningModeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["ultra_low_latency_khr"] = mod.VkVideoEncodeTuningModeKHR("VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR"),
		["lossless_khr"] = mod.VkVideoEncodeTuningModeKHR("VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR"),
		["default_khr"] = mod.VkVideoEncodeTuningModeKHR("VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR"),
		["high_quality_khr"] = mod.VkVideoEncodeTuningModeKHR("VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR"),
		["low_latency_khr"] = mod.VkVideoEncodeTuningModeKHR("VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeTuningModeKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeTuningModeKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoAV1FrameRestorationType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["invalid"] = mod.StdVideoAV1FrameRestorationType("STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_INVALID"),
		["wiener"] = mod.StdVideoAV1FrameRestorationType("STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_WIENER"),
		["sgrproj"] = mod.StdVideoAV1FrameRestorationType("STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SGRPROJ"),
		["switchable"] = mod.StdVideoAV1FrameRestorationType("STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SWITCHABLE"),
		["none"] = mod.StdVideoAV1FrameRestorationType("STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_NONE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoAV1FrameRestorationType")
	end

	return lookup[s] or
		error(
			"unknown StdVideoAV1FrameRestorationType value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.StdVideoH264PocType = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["2"] = mod.StdVideoH264PocType("STD_VIDEO_H264_POC_TYPE_2"),
		["invalid"] = mod.StdVideoH264PocType("STD_VIDEO_H264_POC_TYPE_INVALID"),
		["0"] = mod.StdVideoH264PocType("STD_VIDEO_H264_POC_TYPE_0"),
		["1"] = mod.StdVideoH264PocType("STD_VIDEO_H264_POC_TYPE_1"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "StdVideoH264PocType")
	end

	return lookup[s] or
		error("unknown StdVideoH264PocType value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoDecodeCapabilityFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["dpb_and_output_distinct_khr"] = mod.VkVideoDecodeCapabilityFlagBitsKHR("VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR"),
		["dpb_and_output_coincide_khr"] = mod.VkVideoDecodeCapabilityFlagBitsKHR("VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoDecodeCapabilityFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoDecodeCapabilityFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkBlendFactor = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["src_alpha"] = mod.VkBlendFactor("VK_BLEND_FACTOR_SRC_ALPHA"),
		["one_minus_src_alpha"] = mod.VkBlendFactor("VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"),
		["dst_alpha"] = mod.VkBlendFactor("VK_BLEND_FACTOR_DST_ALPHA"),
		["one_minus_dst_alpha"] = mod.VkBlendFactor("VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"),
		["one"] = mod.VkBlendFactor("VK_BLEND_FACTOR_ONE"),
		["one_minus_constant_color"] = mod.VkBlendFactor("VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"),
		["constant_alpha"] = mod.VkBlendFactor("VK_BLEND_FACTOR_CONSTANT_ALPHA"),
		["one_minus_constant_alpha"] = mod.VkBlendFactor("VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"),
		["src_alpha_saturate"] = mod.VkBlendFactor("VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"),
		["src1_color"] = mod.VkBlendFactor("VK_BLEND_FACTOR_SRC1_COLOR"),
		["one_minus_src1_color"] = mod.VkBlendFactor("VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"),
		["src1_alpha"] = mod.VkBlendFactor("VK_BLEND_FACTOR_SRC1_ALPHA"),
		["src_color"] = mod.VkBlendFactor("VK_BLEND_FACTOR_SRC_COLOR"),
		["one_minus_src1_alpha"] = mod.VkBlendFactor("VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"),
		["one_minus_src_color"] = mod.VkBlendFactor("VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"),
		["constant_color"] = mod.VkBlendFactor("VK_BLEND_FACTOR_CONSTANT_COLOR"),
		["dst_color"] = mod.VkBlendFactor("VK_BLEND_FACTOR_DST_COLOR"),
		["zero"] = mod.VkBlendFactor("VK_BLEND_FACTOR_ZERO"),
		["one_minus_dst_color"] = mod.VkBlendFactor("VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkBlendFactor") end

	return lookup[s] or
		error("unknown VkBlendFactor value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkExternalMemoryFeatureFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["exportable"] = mod.VkExternalMemoryFeatureFlagBits("VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"),
		["importable_khr"] = mod.VkExternalMemoryFeatureFlagBits("VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR"),
		["dedicated_only"] = mod.VkExternalMemoryFeatureFlagBits("VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"),
		["exportable_khr"] = mod.VkExternalMemoryFeatureFlagBits("VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR"),
		["importable"] = mod.VkExternalMemoryFeatureFlagBits("VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"),
		["dedicated_only_khr"] = mod.VkExternalMemoryFeatureFlagBits("VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkExternalMemoryFeatureFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkExternalMemoryFeatureFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPerformanceConfigurationTypeINTEL = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["command_queue_metrics_discovery_activated_intel"] = mod.VkPerformanceConfigurationTypeINTEL(
			"VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL"
		),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPerformanceConfigurationTypeINTEL")
	end

	return lookup[s] or
		error(
			"unknown VkPerformanceConfigurationTypeINTEL value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkShaderGroupShaderKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["any_hit_khr"] = mod.VkShaderGroupShaderKHR("VK_SHADER_GROUP_SHADER_ANY_HIT_KHR"),
		["intersection_khr"] = mod.VkShaderGroupShaderKHR("VK_SHADER_GROUP_SHADER_INTERSECTION_KHR"),
		["general_khr"] = mod.VkShaderGroupShaderKHR("VK_SHADER_GROUP_SHADER_GENERAL_KHR"),
		["closest_hit_khr"] = mod.VkShaderGroupShaderKHR("VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkShaderGroupShaderKHR")
	end

	return lookup[s] or
		error("unknown VkShaderGroupShaderKHR value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkIndirectExecutionSetInfoTypeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["pipelines_ext"] = mod.VkIndirectExecutionSetInfoTypeEXT("VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT"),
		["shader_objects_ext"] = mod.VkIndirectExecutionSetInfoTypeEXT("VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkIndirectExecutionSetInfoTypeEXT")
	end

	return lookup[s] or
		error(
			"unknown VkIndirectExecutionSetInfoTypeEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkImageAspectFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["none_khr"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_NONE_KHR"),
		["plane_2_khr"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_PLANE_2_BIT_KHR"),
		["memory_plane_1_ext"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT"),
		["metadata"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_METADATA_BIT"),
		["depth"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_DEPTH_BIT"),
		["memory_plane_2_ext"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT"),
		["plane_0"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_PLANE_0_BIT"),
		["plane_0_khr"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_PLANE_0_BIT_KHR"),
		["memory_plane_3_ext"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT"),
		["plane_1"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_PLANE_1_BIT"),
		["memory_plane_0_ext"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT"),
		["stencil"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_STENCIL_BIT"),
		["plane_2"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_PLANE_2_BIT"),
		["color"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_COLOR_BIT"),
		["plane_1_khr"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_PLANE_1_BIT_KHR"),
		["none"] = mod.VkImageAspectFlagBits("VK_IMAGE_ASPECT_NONE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkImageAspectFlagBits")
	end

	return lookup[s] or
		error("unknown VkImageAspectFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkOpticalFlowExecuteFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["disable_temporal_hints_nv"] = mod.VkOpticalFlowExecuteFlagBitsNV("VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkOpticalFlowExecuteFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkOpticalFlowExecuteFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkClusterAccelerationStructureGeometryFlagBitsNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["no_duplicate_anyhit_invocation_nv"] = mod.VkClusterAccelerationStructureGeometryFlagBitsNV(
			"VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV"
		),
		["cull_disable_nv"] = mod.VkClusterAccelerationStructureGeometryFlagBitsNV("VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV"),
		["opaque_nv"] = mod.VkClusterAccelerationStructureGeometryFlagBitsNV("VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkClusterAccelerationStructureGeometryFlagBitsNV")
	end

	return lookup[s] or
		error(
			"unknown VkClusterAccelerationStructureGeometryFlagBitsNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkIndirectCommandsTokenTypeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["draw_indexed_count_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT"),
		["trace_rays2_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT"),
		["execution_set_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT"),
		["draw_mesh_tasks_count_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT"),
		["push_constant_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT"),
		["draw_mesh_tasks_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT"),
		["sequence_index_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT"),
		["draw_mesh_tasks_count_nv_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT"),
		["index_buffer_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT"),
		["draw_mesh_tasks_nv_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT"),
		["vertex_buffer_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT"),
		["dispatch_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT"),
		["draw_indexed_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT"),
		["draw_count_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT"),
		["draw_ext"] = mod.VkIndirectCommandsTokenTypeEXT("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkIndirectCommandsTokenTypeEXT")
	end

	return lookup[s] or
		error(
			"unknown VkIndirectCommandsTokenTypeEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDisplaySurfaceStereoTypeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["inband_displayport_nv"] = mod.VkDisplaySurfaceStereoTypeNV("VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV"),
		["onboard_din_nv"] = mod.VkDisplaySurfaceStereoTypeNV("VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV"),
		["hdmi_3d_nv"] = mod.VkDisplaySurfaceStereoTypeNV("VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV"),
		["none_nv"] = mod.VkDisplaySurfaceStereoTypeNV("VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDisplaySurfaceStereoTypeNV")
	end

	return lookup[s] or
		error(
			"unknown VkDisplaySurfaceStereoTypeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkCubicFilterWeightsQCOM = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["catmull_rom_qcom"] = mod.VkCubicFilterWeightsQCOM("VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM"),
		["mitchell_netravali_qcom"] = mod.VkCubicFilterWeightsQCOM("VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM"),
		["zero_tangent_cardinal_qcom"] = mod.VkCubicFilterWeightsQCOM("VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM"),
		["b_spline_qcom"] = mod.VkCubicFilterWeightsQCOM("VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCubicFilterWeightsQCOM")
	end

	return lookup[s] or
		error(
			"unknown VkCubicFilterWeightsQCOM value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDisplayPlaneAlphaFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["per_pixel_khr"] = mod.VkDisplayPlaneAlphaFlagBitsKHR("VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"),
		["global_khr"] = mod.VkDisplayPlaneAlphaFlagBitsKHR("VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"),
		["opaque_khr"] = mod.VkDisplayPlaneAlphaFlagBitsKHR("VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"),
		["per_pixel_premultiplied_khr"] = mod.VkDisplayPlaneAlphaFlagBitsKHR("VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDisplayPlaneAlphaFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkDisplayPlaneAlphaFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPhysicalDeviceDataGraphOperationTypeARM = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["spirv_extended_instruction_set_arm"] = mod.VkPhysicalDeviceDataGraphOperationTypeARM("VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPhysicalDeviceDataGraphOperationTypeARM")
	end

	return lookup[s] or
		error(
			"unknown VkPhysicalDeviceDataGraphOperationTypeARM value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDataGraphPipelineSessionBindPointTypeARM = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["memory_arm"] = mod.VkDataGraphPipelineSessionBindPointTypeARM("VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDataGraphPipelineSessionBindPointTypeARM")
	end

	return lookup[s] or
		error(
			"unknown VkDataGraphPipelineSessionBindPointTypeARM value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDebugUtilsMessageTypeFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["device_address_binding_ext"] = mod.VkDebugUtilsMessageTypeFlagBitsEXT("VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT"),
		["validation_ext"] = mod.VkDebugUtilsMessageTypeFlagBitsEXT("VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT"),
		["general_ext"] = mod.VkDebugUtilsMessageTypeFlagBitsEXT("VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT"),
		["performance_ext"] = mod.VkDebugUtilsMessageTypeFlagBitsEXT("VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDebugUtilsMessageTypeFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkDebugUtilsMessageTypeFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkCoverageModulationModeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["rgb_nv"] = mod.VkCoverageModulationModeNV("VK_COVERAGE_MODULATION_MODE_RGB_NV"),
		["rgba_nv"] = mod.VkCoverageModulationModeNV("VK_COVERAGE_MODULATION_MODE_RGBA_NV"),
		["alpha_nv"] = mod.VkCoverageModulationModeNV("VK_COVERAGE_MODULATION_MODE_ALPHA_NV"),
		["none_nv"] = mod.VkCoverageModulationModeNV("VK_COVERAGE_MODULATION_MODE_NONE_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkCoverageModulationModeNV")
	end

	return lookup[s] or
		error(
			"unknown VkCoverageModulationModeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPipelineCreationFeedbackFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["application_pipeline_cache_hit"] = mod.VkPipelineCreationFeedbackFlagBits("VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT"),
		["application_pipeline_cache_hit_ext"] = mod.VkPipelineCreationFeedbackFlagBits("VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT"),
		["base_pipeline_acceleration"] = mod.VkPipelineCreationFeedbackFlagBits("VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT"),
		["base_pipeline_acceleration_ext"] = mod.VkPipelineCreationFeedbackFlagBits("VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT"),
		["valid"] = mod.VkPipelineCreationFeedbackFlagBits("VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT"),
		["valid_ext"] = mod.VkPipelineCreationFeedbackFlagBits("VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPipelineCreationFeedbackFlagBits")
	end

	return lookup[s] or
		error(
			"unknown VkPipelineCreationFeedbackFlagBits value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkOpticalFlowSessionBindingPointNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["global_flow_nv"] = mod.VkOpticalFlowSessionBindingPointNV("VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV"),
		["reference_nv"] = mod.VkOpticalFlowSessionBindingPointNV("VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV"),
		["input_nv"] = mod.VkOpticalFlowSessionBindingPointNV("VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV"),
		["flow_vector_nv"] = mod.VkOpticalFlowSessionBindingPointNV("VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV"),
		["backward_flow_vector_nv"] = mod.VkOpticalFlowSessionBindingPointNV("VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV"),
		["backward_cost_nv"] = mod.VkOpticalFlowSessionBindingPointNV("VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV"),
		["hint_nv"] = mod.VkOpticalFlowSessionBindingPointNV("VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV"),
		["unknown_nv"] = mod.VkOpticalFlowSessionBindingPointNV("VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV"),
		["cost_nv"] = mod.VkOpticalFlowSessionBindingPointNV("VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkOpticalFlowSessionBindingPointNV")
	end

	return lookup[s] or
		error(
			"unknown VkOpticalFlowSessionBindingPointNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkOpticalFlowPerformanceLevelNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["medium_nv"] = mod.VkOpticalFlowPerformanceLevelNV("VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV"),
		["unknown_nv"] = mod.VkOpticalFlowPerformanceLevelNV("VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV"),
		["slow_nv"] = mod.VkOpticalFlowPerformanceLevelNV("VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV"),
		["fast_nv"] = mod.VkOpticalFlowPerformanceLevelNV("VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkOpticalFlowPerformanceLevelNV")
	end

	return lookup[s] or
		error(
			"unknown VkOpticalFlowPerformanceLevelNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDefaultVertexAttributeValueKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["zero_zero_zero_zero_khr"] = mod.VkDefaultVertexAttributeValueKHR("VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR"),
		["zero_zero_zero_one_khr"] = mod.VkDefaultVertexAttributeValueKHR("VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDefaultVertexAttributeValueKHR")
	end

	return lookup[s] or
		error(
			"unknown VkDefaultVertexAttributeValueKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkTensorTilingARM = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["linear_arm"] = mod.VkTensorTilingARM("VK_TENSOR_TILING_LINEAR_ARM"),
		["optimal_arm"] = mod.VkTensorTilingARM("VK_TENSOR_TILING_OPTIMAL_ARM"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkTensorTilingARM")
	end

	return lookup[s] or
		error("unknown VkTensorTilingARM value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkBlendOp = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["src_in_ext"] = mod.VkBlendOp("VK_BLEND_OP_SRC_IN_EXT"),
		["dst_in_ext"] = mod.VkBlendOp("VK_BLEND_OP_DST_IN_EXT"),
		["src_out_ext"] = mod.VkBlendOp("VK_BLEND_OP_SRC_OUT_EXT"),
		["dst_out_ext"] = mod.VkBlendOp("VK_BLEND_OP_DST_OUT_EXT"),
		["max"] = mod.VkBlendOp("VK_BLEND_OP_MAX"),
		["invert_ext"] = mod.VkBlendOp("VK_BLEND_OP_INVERT_EXT"),
		["invert_rgb_ext"] = mod.VkBlendOp("VK_BLEND_OP_INVERT_RGB_EXT"),
		["lineardodge_ext"] = mod.VkBlendOp("VK_BLEND_OP_LINEARDODGE_EXT"),
		["linearburn_ext"] = mod.VkBlendOp("VK_BLEND_OP_LINEARBURN_EXT"),
		["screen_ext"] = mod.VkBlendOp("VK_BLEND_OP_SCREEN_EXT"),
		["overlay_ext"] = mod.VkBlendOp("VK_BLEND_OP_OVERLAY_EXT"),
		["darken_ext"] = mod.VkBlendOp("VK_BLEND_OP_DARKEN_EXT"),
		["lighten_ext"] = mod.VkBlendOp("VK_BLEND_OP_LIGHTEN_EXT"),
		["colordodge_ext"] = mod.VkBlendOp("VK_BLEND_OP_COLORDODGE_EXT"),
		["colorburn_ext"] = mod.VkBlendOp("VK_BLEND_OP_COLORBURN_EXT"),
		["blue_ext"] = mod.VkBlendOp("VK_BLEND_OP_BLUE_EXT"),
		["hardlight_ext"] = mod.VkBlendOp("VK_BLEND_OP_HARDLIGHT_EXT"),
		["green_ext"] = mod.VkBlendOp("VK_BLEND_OP_GREEN_EXT"),
		["softlight_ext"] = mod.VkBlendOp("VK_BLEND_OP_SOFTLIGHT_EXT"),
		["red_ext"] = mod.VkBlendOp("VK_BLEND_OP_RED_EXT"),
		["difference_ext"] = mod.VkBlendOp("VK_BLEND_OP_DIFFERENCE_EXT"),
		["invert_ovg_ext"] = mod.VkBlendOp("VK_BLEND_OP_INVERT_OVG_EXT"),
		["plus_clamped_ext"] = mod.VkBlendOp("VK_BLEND_OP_PLUS_CLAMPED_EXT"),
		["contrast_ext"] = mod.VkBlendOp("VK_BLEND_OP_CONTRAST_EXT"),
		["plus_clamped_alpha_ext"] = mod.VkBlendOp("VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT"),
		["minus_clamped_ext"] = mod.VkBlendOp("VK_BLEND_OP_MINUS_CLAMPED_EXT"),
		["plus_darker_ext"] = mod.VkBlendOp("VK_BLEND_OP_PLUS_DARKER_EXT"),
		["minus_ext"] = mod.VkBlendOp("VK_BLEND_OP_MINUS_EXT"),
		["add"] = mod.VkBlendOp("VK_BLEND_OP_ADD"),
		["plus_ext"] = mod.VkBlendOp("VK_BLEND_OP_PLUS_EXT"),
		["subtract"] = mod.VkBlendOp("VK_BLEND_OP_SUBTRACT"),
		["hsl_luminosity_ext"] = mod.VkBlendOp("VK_BLEND_OP_HSL_LUMINOSITY_EXT"),
		["reverse_subtract"] = mod.VkBlendOp("VK_BLEND_OP_REVERSE_SUBTRACT"),
		["hsl_color_ext"] = mod.VkBlendOp("VK_BLEND_OP_HSL_COLOR_EXT"),
		["zero_ext"] = mod.VkBlendOp("VK_BLEND_OP_ZERO_EXT"),
		["hsl_saturation_ext"] = mod.VkBlendOp("VK_BLEND_OP_HSL_SATURATION_EXT"),
		["src_ext"] = mod.VkBlendOp("VK_BLEND_OP_SRC_EXT"),
		["hsl_hue_ext"] = mod.VkBlendOp("VK_BLEND_OP_HSL_HUE_EXT"),
		["dst_ext"] = mod.VkBlendOp("VK_BLEND_OP_DST_EXT"),
		["hardmix_ext"] = mod.VkBlendOp("VK_BLEND_OP_HARDMIX_EXT"),
		["src_over_ext"] = mod.VkBlendOp("VK_BLEND_OP_SRC_OVER_EXT"),
		["pinlight_ext"] = mod.VkBlendOp("VK_BLEND_OP_PINLIGHT_EXT"),
		["dst_over_ext"] = mod.VkBlendOp("VK_BLEND_OP_DST_OVER_EXT"),
		["linearlight_ext"] = mod.VkBlendOp("VK_BLEND_OP_LINEARLIGHT_EXT"),
		["vividlight_ext"] = mod.VkBlendOp("VK_BLEND_OP_VIVIDLIGHT_EXT"),
		["xor_ext"] = mod.VkBlendOp("VK_BLEND_OP_XOR_EXT"),
		["multiply_ext"] = mod.VkBlendOp("VK_BLEND_OP_MULTIPLY_EXT"),
		["min"] = mod.VkBlendOp("VK_BLEND_OP_MIN"),
		["dst_atop_ext"] = mod.VkBlendOp("VK_BLEND_OP_DST_ATOP_EXT"),
		["exclusion_ext"] = mod.VkBlendOp("VK_BLEND_OP_EXCLUSION_EXT"),
		["src_atop_ext"] = mod.VkBlendOp("VK_BLEND_OP_SRC_ATOP_EXT"),
	}

	if type(s) == "table" then return combine_flags(lookup, s, "VkBlendOp") end

	return lookup[s] or
		error("unknown VkBlendOp value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkSubpassMergeStatusEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["disallowed_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT"),
		["not_merged_side_effects_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT"),
		["not_merged_insufficient_storage_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT"),
		["not_merged_samples_mismatch_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT"),
		["not_merged_depth_stencil_count_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT"),
		["not_merged_views_mismatch_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT"),
		["not_merged_resolve_attachment_reuse_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT"),
		["not_merged_aliasing_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT"),
		["not_merged_single_subpass_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT"),
		["not_merged_dependencies_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT"),
		["not_merged_unspecified_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT"),
		["not_merged_incompatible_input_attachment_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT"),
		["not_merged_too_many_attachments_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT"),
		["merged_ext"] = mod.VkSubpassMergeStatusEXT("VK_SUBPASS_MERGE_STATUS_MERGED_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSubpassMergeStatusEXT")
	end

	return lookup[s] or
		error(
			"unknown VkSubpassMergeStatusEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDepthClampModeEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["user_defined_range_ext"] = mod.VkDepthClampModeEXT("VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT"),
		["viewport_range_ext"] = mod.VkDepthClampModeEXT("VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDepthClampModeEXT")
	end

	return lookup[s] or
		error("unknown VkDepthClampModeEXT value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkAccelerationStructureBuildTypeKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["host_khr"] = mod.VkAccelerationStructureBuildTypeKHR("VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR"),
		["device_khr"] = mod.VkAccelerationStructureBuildTypeKHR("VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR"),
		["host_or_device_khr"] = mod.VkAccelerationStructureBuildTypeKHR("VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAccelerationStructureBuildTypeKHR")
	end

	return lookup[s] or
		error(
			"unknown VkAccelerationStructureBuildTypeKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkIndirectCommandsInputModeFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["vulkan_index_buffer_ext"] = mod.VkIndirectCommandsInputModeFlagBitsEXT("VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT"),
		["dxgi_index_buffer_ext"] = mod.VkIndirectCommandsInputModeFlagBitsEXT("VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkIndirectCommandsInputModeFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkIndirectCommandsInputModeFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkSurfaceTransformFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["rotate_180_khr"] = mod.VkSurfaceTransformFlagBitsKHR("VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"),
		["inherit_khr"] = mod.VkSurfaceTransformFlagBitsKHR("VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"),
		["identity_khr"] = mod.VkSurfaceTransformFlagBitsKHR("VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"),
		["horizontal_mirror_khr"] = mod.VkSurfaceTransformFlagBitsKHR("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"),
		["horizontal_mirror_rotate_90_khr"] = mod.VkSurfaceTransformFlagBitsKHR("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"),
		["horizontal_mirror_rotate_180_khr"] = mod.VkSurfaceTransformFlagBitsKHR("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"),
		["rotate_270_khr"] = mod.VkSurfaceTransformFlagBitsKHR("VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"),
		["rotate_90_khr"] = mod.VkSurfaceTransformFlagBitsKHR("VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"),
		["horizontal_mirror_rotate_270_khr"] = mod.VkSurfaceTransformFlagBitsKHR("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkSurfaceTransformFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkSurfaceTransformFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkPhysicalDeviceLayeredApiKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["vulkan_khr"] = mod.VkPhysicalDeviceLayeredApiKHR("VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR"),
		["d3d12_khr"] = mod.VkPhysicalDeviceLayeredApiKHR("VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR"),
		["metal_khr"] = mod.VkPhysicalDeviceLayeredApiKHR("VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR"),
		["opengles_khr"] = mod.VkPhysicalDeviceLayeredApiKHR("VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR"),
		["opengl_khr"] = mod.VkPhysicalDeviceLayeredApiKHR("VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkPhysicalDeviceLayeredApiKHR")
	end

	return lookup[s] or
		error(
			"unknown VkPhysicalDeviceLayeredApiKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkLatencyMarkerNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["input_sample_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_INPUT_SAMPLE_NV"),
		["trigger_flash_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_TRIGGER_FLASH_NV"),
		["simulation_start_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_SIMULATION_START_NV"),
		["simulation_end_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_SIMULATION_END_NV"),
		["out_of_band_present_end_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV"),
		["rendersubmit_start_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_RENDERSUBMIT_START_NV"),
		["out_of_band_present_start_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV"),
		["rendersubmit_end_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_RENDERSUBMIT_END_NV"),
		["out_of_band_rendersubmit_end_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV"),
		["present_start_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_PRESENT_START_NV"),
		["out_of_band_rendersubmit_start_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV"),
		["present_end_nv"] = mod.VkLatencyMarkerNV("VK_LATENCY_MARKER_PRESENT_END_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkLatencyMarkerNV")
	end

	return lookup[s] or
		error("unknown VkLatencyMarkerNV value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkTessellationDomainOrigin = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["upper_left"] = mod.VkTessellationDomainOrigin("VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"),
		["lower_left_khr"] = mod.VkTessellationDomainOrigin("VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR"),
		["lower_left"] = mod.VkTessellationDomainOrigin("VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"),
		["upper_left_khr"] = mod.VkTessellationDomainOrigin("VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkTessellationDomainOrigin")
	end

	return lookup[s] or
		error(
			"unknown VkTessellationDomainOrigin value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkIndirectCommandsLayoutUsageFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["explicit_preprocess_ext"] = mod.VkIndirectCommandsLayoutUsageFlagBitsEXT("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT"),
		["unordered_sequences_ext"] = mod.VkIndirectCommandsLayoutUsageFlagBitsEXT("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkIndirectCommandsLayoutUsageFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkIndirectCommandsLayoutUsageFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkAccessFlagBits = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["acceleration_structure_write_nv"] = mod.VkAccessFlagBits("VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV"),
		["depth_stencil_attachment_read"] = mod.VkAccessFlagBits("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"),
		["command_preprocess_read_nv"] = mod.VkAccessFlagBits("VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV"),
		["depth_stencil_attachment_write"] = mod.VkAccessFlagBits("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"),
		["transfer_read"] = mod.VkAccessFlagBits("VK_ACCESS_TRANSFER_READ_BIT"),
		["transfer_write"] = mod.VkAccessFlagBits("VK_ACCESS_TRANSFER_WRITE_BIT"),
		["host_read"] = mod.VkAccessFlagBits("VK_ACCESS_HOST_READ_BIT"),
		["host_write"] = mod.VkAccessFlagBits("VK_ACCESS_HOST_WRITE_BIT"),
		["memory_read"] = mod.VkAccessFlagBits("VK_ACCESS_MEMORY_READ_BIT"),
		["memory_write"] = mod.VkAccessFlagBits("VK_ACCESS_MEMORY_WRITE_BIT"),
		["transform_feedback_write_ext"] = mod.VkAccessFlagBits("VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"),
		["transform_feedback_counter_read_ext"] = mod.VkAccessFlagBits("VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"),
		["transform_feedback_counter_write_ext"] = mod.VkAccessFlagBits("VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"),
		["conditional_rendering_read_ext"] = mod.VkAccessFlagBits("VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT"),
		["none_khr"] = mod.VkAccessFlagBits("VK_ACCESS_NONE_KHR"),
		["color_attachment_read_noncoherent_ext"] = mod.VkAccessFlagBits("VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"),
		["indirect_command_read"] = mod.VkAccessFlagBits("VK_ACCESS_INDIRECT_COMMAND_READ_BIT"),
		["acceleration_structure_read_khr"] = mod.VkAccessFlagBits("VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR"),
		["index_read"] = mod.VkAccessFlagBits("VK_ACCESS_INDEX_READ_BIT"),
		["acceleration_structure_write_khr"] = mod.VkAccessFlagBits("VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"),
		["vertex_attribute_read"] = mod.VkAccessFlagBits("VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"),
		["fragment_density_map_read_ext"] = mod.VkAccessFlagBits("VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"),
		["uniform_read"] = mod.VkAccessFlagBits("VK_ACCESS_UNIFORM_READ_BIT"),
		["fragment_shading_rate_attachment_read_khr"] = mod.VkAccessFlagBits("VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"),
		["input_attachment_read"] = mod.VkAccessFlagBits("VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"),
		["command_preprocess_read_ext"] = mod.VkAccessFlagBits("VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT"),
		["shader_read"] = mod.VkAccessFlagBits("VK_ACCESS_SHADER_READ_BIT"),
		["command_preprocess_write_ext"] = mod.VkAccessFlagBits("VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT"),
		["shader_write"] = mod.VkAccessFlagBits("VK_ACCESS_SHADER_WRITE_BIT"),
		["shading_rate_image_read_nv"] = mod.VkAccessFlagBits("VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV"),
		["color_attachment_read"] = mod.VkAccessFlagBits("VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"),
		["command_preprocess_write_nv"] = mod.VkAccessFlagBits("VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV"),
		["acceleration_structure_read_nv"] = mod.VkAccessFlagBits("VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV"),
		["color_attachment_write"] = mod.VkAccessFlagBits("VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"),
		["none"] = mod.VkAccessFlagBits("VK_ACCESS_NONE"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkAccessFlagBits")
	end

	return lookup[s] or
		error("unknown VkAccessFlagBits value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkQueueGlobalPriority = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["low_ext"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT"),
		["medium_ext"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT"),
		["high_ext"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT"),
		["realtime_ext"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT"),
		["realtime_khr"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR"),
		["low"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_LOW"),
		["high_khr"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR"),
		["medium"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_MEDIUM"),
		["medium_khr"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR"),
		["high"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_HIGH"),
		["low_khr"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR"),
		["realtime"] = mod.VkQueueGlobalPriority("VK_QUEUE_GLOBAL_PRIORITY_REALTIME"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkQueueGlobalPriority")
	end

	return lookup[s] or
		error("unknown VkQueueGlobalPriority value: " .. tostring(s) .. " (must be lowercase)")
end
mod.e.VkVideoEncodeH264RateControlFlagBitsKHR = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["attempt_hrd_compliance_khr"] = mod.VkVideoEncodeH264RateControlFlagBitsKHR("VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR"),
		["regular_gop_khr"] = mod.VkVideoEncodeH264RateControlFlagBitsKHR("VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR"),
		["reference_pattern_dyadic_khr"] = mod.VkVideoEncodeH264RateControlFlagBitsKHR("VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR"),
		["reference_pattern_flat_khr"] = mod.VkVideoEncodeH264RateControlFlagBitsKHR("VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR"),
		["temporal_layer_pattern_dyadic_khr"] = mod.VkVideoEncodeH264RateControlFlagBitsKHR("VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkVideoEncodeH264RateControlFlagBitsKHR")
	end

	return lookup[s] or
		error(
			"unknown VkVideoEncodeH264RateControlFlagBitsKHR value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkDeviceFaultVendorBinaryHeaderVersionEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["one_ext"] = mod.VkDeviceFaultVendorBinaryHeaderVersionEXT("VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkDeviceFaultVendorBinaryHeaderVersionEXT")
	end

	return lookup[s] or
		error(
			"unknown VkDeviceFaultVendorBinaryHeaderVersionEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkFragmentShadingRateTypeNV = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["fragment_size_nv"] = mod.VkFragmentShadingRateTypeNV("VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV"),
		["enums_nv"] = mod.VkFragmentShadingRateTypeNV("VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkFragmentShadingRateTypeNV")
	end

	return lookup[s] or
		error(
			"unknown VkFragmentShadingRateTypeNV value: " .. tostring(s) .. " (must be lowercase)"
		)
end
mod.e.VkGraphicsPipelineLibraryFlagBitsEXT = function(s)
	if type(s) == "number" then return s end

	local lookup = {
		["fragment_shader_ext"] = mod.VkGraphicsPipelineLibraryFlagBitsEXT("VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT"),
		["pre_rasterization_shaders_ext"] = mod.VkGraphicsPipelineLibraryFlagBitsEXT("VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT"),
		["vertex_input_interface_ext"] = mod.VkGraphicsPipelineLibraryFlagBitsEXT("VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT"),
		["fragment_output_interface_ext"] = mod.VkGraphicsPipelineLibraryFlagBitsEXT("VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT"),
	}

	if type(s) == "table" then
		return combine_flags(lookup, s, "VkGraphicsPipelineLibraryFlagBitsEXT")
	end

	return lookup[s] or
		error(
			"unknown VkGraphicsPipelineLibraryFlagBitsEXT value: " .. tostring(s) .. " (must be lowercase)"
		)
end

-- Helper to fill struct fields with enum translation
local function fill_struct(ctype, field_info, t)
	if t == nil then return nil end

	local obj = N(ctype)

	for k, v in pairs(t) do
		local info = field_info[k]

		if info then
			if info.enum_lookup then
				obj[k] = info.enum_lookup(v)
			elseif info.struct_fill then
				info.struct_fill(obj[k], v)
			else
				obj[k] = v
			end
		else
			obj[k] = v
		end
	end

	return obj
end

-- Struct builders with enum translation (for nested structs)
mod.s = {}
mod.s.PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxIndirectPipelineCount = t.maxIndirectPipelineCount,
			maxIndirectShaderObjectCount = t.maxIndirectShaderObjectCount,
			maxIndirectSequenceCount = t.maxIndirectSequenceCount,
			maxIndirectCommandsTokenCount = t.maxIndirectCommandsTokenCount,
			maxIndirectCommandsTokenOffset = t.maxIndirectCommandsTokenOffset,
			maxIndirectCommandsIndirectStride = t.maxIndirectCommandsIndirectStride,
			supportedIndirectCommandsInputModes = t.supportedIndirectCommandsInputModes,
			supportedIndirectCommandsShaderStages = t.supportedIndirectCommandsShaderStages and
				mod.e.VkShaderStageFlagBits(t.supportedIndirectCommandsShaderStages),
			supportedIndirectCommandsShaderStagesPipelineBinding = t.supportedIndirectCommandsShaderStagesPipelineBinding and
				mod.e.VkShaderStageFlagBits(t.supportedIndirectCommandsShaderStagesPipelineBinding),
			supportedIndirectCommandsShaderStagesShaderBinding = t.supportedIndirectCommandsShaderStagesShaderBinding and
				mod.e.VkShaderStageFlagBits(t.supportedIndirectCommandsShaderStagesShaderBinding),
			deviceGeneratedCommandsTransformFeedback = t.deviceGeneratedCommandsTransformFeedback,
			deviceGeneratedCommandsMultiDrawIndirectCount = t.deviceGeneratedCommandsMultiDrawIndirectCount,
		}
	)
end
mod.s.GeneratedCommandsMemoryRequirementsInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGeneratedCommandsMemoryRequirementsInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			indirectExecutionSet = t.indirectExecutionSet,
			indirectCommandsLayout = t.indirectCommandsLayout,
			maxSequenceCount = t.maxSequenceCount,
			maxDrawCount = t.maxDrawCount,
		}
	)
end
mod.s.LayerSettingEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkLayerSettingEXT(
		{
			pLayerName = t.pLayerName,
			pSettingName = t.pSettingName,
			type = t.type and mod.e.VkLayerSettingTypeEXT(t.type),
			valueCount = t.valueCount,
			pValues = t.pValues,
		}
	)
end
mod.s.IndirectExecutionSetPipelineInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkIndirectExecutionSetPipelineInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			initialPipeline = t.initialPipeline,
			maxPipelineCount = t.maxPipelineCount,
		}
	)
end
mod.s.LayerSettingsCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkLayerSettingsCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			settingCount = t.settingCount,
			pSettings = t.pSettings,
		}
	)
end
mod.s.IndirectExecutionSetShaderLayoutInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkIndirectExecutionSetShaderLayoutInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			setLayoutCount = t.setLayoutCount,
			pSetLayouts = t.pSetLayouts,
		}
	)
end
mod.s.IndirectExecutionSetShaderInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkIndirectExecutionSetShaderInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderCount = t.shaderCount,
			pInitialShaders = t.pInitialShaders,
			pSetLayoutInfos = t.pSetLayoutInfos,
			maxShaderCount = t.maxShaderCount,
			pushConstantRangeCount = t.pushConstantRangeCount,
			pPushConstantRanges = t.pPushConstantRanges,
		}
	)
end
mod.s.PhysicalDeviceShaderCoreBuiltinsFeaturesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderCoreBuiltins = t.shaderCoreBuiltins,
		}
	)
end
mod.s.PhysicalDeviceShaderCoreBuiltinsPropertiesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderCoreMask = t.shaderCoreMask,
			shaderCoreCount = t.shaderCoreCount,
			shaderWarpsPerCore = t.shaderWarpsPerCore,
		}
	)
end
mod.s.IndirectExecutionSetCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkIndirectExecutionSetCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type and mod.e.VkIndirectExecutionSetInfoTypeEXT(t.type),
			info = t.info,
		}
	)
end
mod.s.GeneratedCommandsInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGeneratedCommandsInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderStages = t.shaderStages and mod.e.VkShaderStageFlagBits(t.shaderStages),
			indirectExecutionSet = t.indirectExecutionSet,
			indirectCommandsLayout = t.indirectCommandsLayout,
			indirectAddress = t.indirectAddress,
			indirectAddressSize = t.indirectAddressSize,
			preprocessAddress = t.preprocessAddress,
			preprocessSize = t.preprocessSize,
			maxSequenceCount = t.maxSequenceCount,
			sequenceCountAddress = t.sequenceCountAddress,
			maxDrawCount = t.maxDrawCount,
		}
	)
end
mod.s.PhysicalDeviceShaderCoreProperties2AMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderCoreProperties2AMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderCoreFeatures = t.shaderCoreFeatures,
			activeComputeUnitCount = t.activeComputeUnitCount,
		}
	)
end
mod.s.PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineLibraryGroupHandles = t.pipelineLibraryGroupHandles,
		}
	)
end
mod.s.WriteIndirectExecutionSetPipelineEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkWriteIndirectExecutionSetPipelineEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			index = t.index,
			pipeline = t.pipeline,
		}
	)
end
mod.s.PhysicalDeviceCoherentMemoryFeaturesAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCoherentMemoryFeaturesAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceCoherentMemory = t.deviceCoherentMemory,
		}
	)
end
mod.s.PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dynamicRenderingUnusedAttachments = t.dynamicRenderingUnusedAttachments,
		}
	)
end
mod.s.IndirectCommandsIndexBufferTokenEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkIndirectCommandsIndexBufferTokenEXT({
		mode = t.mode and mod.e.VkIndirectCommandsInputModeFlagBitsEXT(t.mode),
	})
end
mod.s.IndirectCommandsExecutionSetTokenEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkIndirectCommandsExecutionSetTokenEXT(
		{
			type = t.type and mod.e.VkIndirectExecutionSetInfoTypeEXT(t.type),
			shaderStages = t.shaderStages and mod.e.VkShaderStageFlagBits(t.shaderStages),
		}
	)
end
mod.s.PhysicalDeviceShaderImageAtomicInt64FeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderImageInt64Atomics = t.shaderImageInt64Atomics,
			sparseImageInt64Atomics = t.sparseImageInt64Atomics,
		}
	)
end
mod.s.IndirectCommandsLayoutTokenEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkIndirectCommandsLayoutTokenEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type and mod.e.VkIndirectCommandsTokenTypeEXT(t.type),
			data = t.data,
			offset = t.offset,
		}
	)
end
mod.s.PhysicalDeviceMemoryBudgetPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMemoryBudgetPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			heapBudget = t.heapBudget,
			heapUsage = t.heapUsage,
		}
	)
end
mod.s.BindIndexBufferIndirectCommandEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindIndexBufferIndirectCommandEXT(
		{
			bufferAddress = t.bufferAddress,
			size = t.size,
			indexType = t.indexType and mod.e.VkIndexType(t.indexType),
		}
	)
end
mod.s.PhysicalDeviceMemoryPriorityFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMemoryPriorityFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memoryPriority = t.memoryPriority,
		}
	)
end
mod.s.GeneratedCommandsShaderInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGeneratedCommandsShaderInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderCount = t.shaderCount,
			pShaders = t.pShaders,
		}
	)
end
mod.s.MemoryPriorityAllocateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryPriorityAllocateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			priority = t.priority,
		}
	)
end
mod.s.PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dedicatedAllocationImageAliasing = t.dedicatedAllocationImageAliasing,
		}
	)
end
mod.s.LatencySleepInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkLatencySleepInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			signalSemaphore = t.signalSemaphore,
			value = t.value,
		}
	)
end
mod.s.PhysicalDeviceBufferDeviceAddressFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			bufferDeviceAddress = t.bufferDeviceAddress,
			bufferDeviceAddressCaptureReplay = t.bufferDeviceAddressCaptureReplay,
			bufferDeviceAddressMultiDevice = t.bufferDeviceAddressMultiDevice,
		}
	)
end
mod.s.SetLatencyMarkerInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSetLatencyMarkerInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentID = t.presentID,
			marker = t.marker and mod.e.VkLatencyMarkerNV(t.marker),
		}
	)
end
mod.s.LatencyTimingsFrameReportNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkLatencyTimingsFrameReportNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentID = t.presentID,
			inputSampleTimeUs = t.inputSampleTimeUs,
			simStartTimeUs = t.simStartTimeUs,
			simEndTimeUs = t.simEndTimeUs,
			renderSubmitStartTimeUs = t.renderSubmitStartTimeUs,
			renderSubmitEndTimeUs = t.renderSubmitEndTimeUs,
			presentStartTimeUs = t.presentStartTimeUs,
			presentEndTimeUs = t.presentEndTimeUs,
			driverStartTimeUs = t.driverStartTimeUs,
			driverEndTimeUs = t.driverEndTimeUs,
			osRenderQueueStartTimeUs = t.osRenderQueueStartTimeUs,
			osRenderQueueEndTimeUs = t.osRenderQueueEndTimeUs,
			gpuRenderStartTimeUs = t.gpuRenderStartTimeUs,
			gpuRenderEndTimeUs = t.gpuRenderEndTimeUs,
		}
	)
end
mod.s.BufferDeviceAddressCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferDeviceAddressCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceAddress = t.deviceAddress,
		}
	)
end
mod.s.GetLatencyMarkerInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGetLatencyMarkerInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			timingCount = t.timingCount,
			pTimings = t.pTimings,
		}
	)
end
mod.s.PhysicalDeviceImageAlignmentControlPropertiesMESA = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageAlignmentControlPropertiesMESA(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			supportedImageAlignmentMask = t.supportedImageAlignmentMask,
		}
	)
end
mod.s.LatencySubmissionPresentIdNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkLatencySubmissionPresentIdNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentID = t.presentID,
		}
	)
end
mod.s.SwapchainLatencyCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSwapchainLatencyCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			latencyModeEnable = t.latencyModeEnable,
		}
	)
end
mod.s.PhysicalDevicePerStageDescriptorSetFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePerStageDescriptorSetFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			perStageDescriptorSet = t.perStageDescriptorSet,
			dynamicPipelineLayout = t.dynamicPipelineLayout,
		}
	)
end
mod.s.OutOfBandQueueTypeInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkOutOfBandQueueTypeInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			queueType = t.queueType and mod.e.VkOutOfBandQueueTypeNV(t.queueType),
		}
	)
end
mod.s.LatencySurfaceCapabilitiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkLatencySurfaceCapabilitiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentModeCount = t.presentModeCount,
			pPresentModes = t.pPresentModes,
		}
	)
end
mod.s.PhysicalDeviceDepthClampControlFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDepthClampControlFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			depthClampControl = t.depthClampControl,
		}
	)
end
mod.s.PipelineViewportDepthClampControlCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineViewportDepthClampControlCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			depthClampMode = t.depthClampMode and mod.e.VkDepthClampModeEXT(t.depthClampMode),
			pDepthClampRange = t.pDepthClampRange,
		}
	)
end
mod.s.PhysicalDeviceHdrVividFeaturesHUAWEI = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceHdrVividFeaturesHUAWEI(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			hdrVivid = t.hdrVivid,
		}
	)
end
mod.s.DirectDriverLoadingInfoLUNARG = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDirectDriverLoadingInfoLUNARG(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			pfnGetInstanceProcAddr = t.pfnGetInstanceProcAddr,
		}
	)
end
mod.s.HdrVividDynamicMetadataHUAWEI = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkHdrVividDynamicMetadataHUAWEI(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dynamicMetadataSize = t.dynamicMetadataSize,
			pDynamicMetadata = t.pDynamicMetadata,
		}
	)
end
mod.s.DirectDriverLoadingListLUNARG = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDirectDriverLoadingListLUNARG(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			mode = t.mode and mod.e.VkDirectDriverLoadingModeLUNARG(t.mode),
			driverCount = t.driverCount,
			pDrivers = t.pDrivers,
		}
	)
end
mod.s.SamplerBlockMatchWindowCreateInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSamplerBlockMatchWindowCreateInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			windowExtent = t.windowExtent,
			windowCompareMode = t.windowCompareMode and
				mod.e.VkBlockMatchWindowCompareModeQCOM(t.windowCompareMode),
		}
	)
end
mod.s.ValidationFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkValidationFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			enabledValidationFeatureCount = t.enabledValidationFeatureCount,
			pEnabledValidationFeatures = t.pEnabledValidationFeatures,
			disabledValidationFeatureCount = t.disabledValidationFeatureCount,
			pDisabledValidationFeatures = t.pDisabledValidationFeatures,
		}
	)
end
mod.s.CooperativeMatrixFlexibleDimensionsPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCooperativeMatrixFlexibleDimensionsPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			MGranularity = t.MGranularity,
			NGranularity = t.NGranularity,
			KGranularity = t.KGranularity,
			AType = t.AType and mod.e.VkComponentTypeKHR(t.AType),
			BType = t.BType and mod.e.VkComponentTypeKHR(t.BType),
			CType = t.CType and mod.e.VkComponentTypeKHR(t.CType),
			ResultType = t.ResultType and mod.e.VkComponentTypeKHR(t.ResultType),
			saturatingAccumulation = t.saturatingAccumulation,
			scope = t.scope and mod.e.VkScopeKHR(t.scope),
			workgroupInvocations = t.workgroupInvocations,
		}
	)
end
mod.s.PhysicalDeviceCooperativeMatrix2FeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCooperativeMatrix2FeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cooperativeMatrixWorkgroupScope = t.cooperativeMatrixWorkgroupScope,
			cooperativeMatrixFlexibleDimensions = t.cooperativeMatrixFlexibleDimensions,
			cooperativeMatrixReductions = t.cooperativeMatrixReductions,
			cooperativeMatrixConversions = t.cooperativeMatrixConversions,
			cooperativeMatrixPerElementOperations = t.cooperativeMatrixPerElementOperations,
			cooperativeMatrixTensorAddressing = t.cooperativeMatrixTensorAddressing,
			cooperativeMatrixBlockLoads = t.cooperativeMatrixBlockLoads,
		}
	)
end
mod.s.PhysicalDeviceCubicWeightsFeaturesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCubicWeightsFeaturesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			selectableCubicWeights = t.selectableCubicWeights,
		}
	)
end
mod.s.CooperativeMatrixPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCooperativeMatrixPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			MSize = t.MSize,
			NSize = t.NSize,
			KSize = t.KSize,
			AType = t.AType,
			BType = t.BType,
			CType = t.CType,
			DType = t.DType,
			scope = t.scope,
		}
	)
end
mod.s.SamplerCubicWeightsCreateInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSamplerCubicWeightsCreateInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cubicWeights = t.cubicWeights and mod.e.VkCubicFilterWeightsQCOM(t.cubicWeights),
		}
	)
end
mod.s.PhysicalDeviceCooperativeMatrixFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCooperativeMatrixFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cooperativeMatrix = t.cooperativeMatrix,
			cooperativeMatrixRobustBufferAccess = t.cooperativeMatrixRobustBufferAccess,
		}
	)
end
mod.s.PhysicalDeviceCooperativeMatrixPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCooperativeMatrixPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cooperativeMatrixSupportedStages = t.cooperativeMatrixSupportedStages and
				mod.e.VkShaderStageFlagBits(t.cooperativeMatrixSupportedStages),
		}
	)
end
mod.s.PhysicalDeviceCooperativeMatrix2PropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCooperativeMatrix2PropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cooperativeMatrixWorkgroupScopeMaxWorkgroupSize = t.cooperativeMatrixWorkgroupScopeMaxWorkgroupSize,
			cooperativeMatrixFlexibleDimensionsMaxDimension = t.cooperativeMatrixFlexibleDimensionsMaxDimension,
			cooperativeMatrixWorkgroupScopeReservedSharedMemory = t.cooperativeMatrixWorkgroupScopeReservedSharedMemory,
		}
	)
end
mod.s.PhysicalDeviceYcbcrDegammaFeaturesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			ycbcrDegamma = t.ycbcrDegamma,
		}
	)
end
mod.s.SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			enableYDegamma = t.enableYDegamma,
			enableCbCrDegamma = t.enableCbCrDegamma,
		}
	)
end
mod.s.PhysicalDevicePipelineOpacityMicromapFeaturesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineOpacityMicromap = t.pipelineOpacityMicromap,
		}
	)
end
mod.s.PhysicalDeviceCoverageReductionModeFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCoverageReductionModeFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			coverageReductionMode = t.coverageReductionMode,
		}
	)
end
mod.s.PhysicalDeviceCubicClampFeaturesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCubicClampFeaturesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cubicRangeClamp = t.cubicRangeClamp,
		}
	)
end
mod.s.TensorDescriptionARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTensorDescriptionARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tiling = t.tiling and mod.e.VkTensorTilingARM(t.tiling),
			format = t.format and mod.e.VkFormat(t.format),
			dimensionCount = t.dimensionCount,
			pDimensions = t.pDimensions,
			pStrides = t.pStrides,
			usage = t.usage,
		}
	)
end
mod.s.FramebufferMixedSamplesCombinationNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFramebufferMixedSamplesCombinationNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			coverageReductionMode = t.coverageReductionMode and
				mod.e.VkCoverageReductionModeNV(t.coverageReductionMode),
			rasterizationSamples = t.rasterizationSamples and mod.e.VkSampleCountFlagBits(t.rasterizationSamples),
			depthStencilSamples = t.depthStencilSamples and mod.e.VkSampleCountFlagBits(t.depthStencilSamples),
			colorSamples = t.colorSamples and mod.e.VkSampleCountFlagBits(t.colorSamples),
		}
	)
end
mod.s.PhysicalDeviceVertexAttributeRobustnessFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vertexAttributeRobustness = t.vertexAttributeRobustness,
		}
	)
end
mod.s.PhysicalDeviceDataGraphFeaturesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDataGraphFeaturesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dataGraph = t.dataGraph,
			dataGraphUpdateAfterBind = t.dataGraphUpdateAfterBind,
			dataGraphSpecializationConstants = t.dataGraphSpecializationConstants,
			dataGraphDescriptorBuffer = t.dataGraphDescriptorBuffer,
			dataGraphShaderModule = t.dataGraphShaderModule,
		}
	)
end
mod.s.PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			attachmentFeedbackLoopDynamicState = t.attachmentFeedbackLoopDynamicState,
		}
	)
end
mod.s.TensorViewCreateInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTensorViewCreateInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			tensor = t.tensor,
			format = t.format and mod.e.VkFormat(t.format),
		}
	)
end
mod.s.TensorMemoryRequirementsInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTensorMemoryRequirementsInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tensor = t.tensor,
		}
	)
end
mod.s.BindTensorMemoryInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindTensorMemoryInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tensor = t.tensor,
			memory = t.memory,
			memoryOffset = t.memoryOffset,
		}
	)
end
mod.s.DataGraphPipelineConstantARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineConstantARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			id = t.id,
			pConstantData = t.pConstantData,
		}
	)
end
mod.s.DataGraphPipelineResourceInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineResourceInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			descriptorSet = t.descriptorSet,
			binding = t.binding,
			arrayElement = t.arrayElement,
		}
	)
end
mod.s.PhysicalDeviceDepthBiasControlFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDepthBiasControlFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			depthBiasControl = t.depthBiasControl,
			leastRepresentableValueForceUnormRepresentation = t.leastRepresentableValueForceUnormRepresentation,
			floatRepresentation = t.floatRepresentation,
			depthBiasExact = t.depthBiasExact,
		}
	)
end
mod.s.DataGraphPipelineCompilerControlCreateInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineCompilerControlCreateInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pVendorOptions = t.pVendorOptions,
		}
	)
end
mod.s.PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxFragmentDensityMapLayers = t.maxFragmentDensityMapLayers,
		}
	)
end
mod.s.PhysicalDeviceTensorPropertiesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTensorPropertiesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxTensorDimensionCount = t.maxTensorDimensionCount,
			maxTensorElements = t.maxTensorElements,
			maxPerDimensionTensorElements = t.maxPerDimensionTensorElements,
			maxTensorStride = t.maxTensorStride,
			maxTensorSize = t.maxTensorSize,
			maxTensorShaderAccessArrayLength = t.maxTensorShaderAccessArrayLength,
			maxTensorShaderAccessSize = t.maxTensorShaderAccessSize,
			maxDescriptorSetStorageTensors = t.maxDescriptorSetStorageTensors,
			maxPerStageDescriptorSetStorageTensors = t.maxPerStageDescriptorSetStorageTensors,
			maxDescriptorSetUpdateAfterBindStorageTensors = t.maxDescriptorSetUpdateAfterBindStorageTensors,
			maxPerStageDescriptorUpdateAfterBindStorageTensors = t.maxPerStageDescriptorUpdateAfterBindStorageTensors,
			shaderStorageTensorArrayNonUniformIndexingNative = t.shaderStorageTensorArrayNonUniformIndexingNative,
			shaderTensorSupportedStages = t.shaderTensorSupportedStages and
				mod.e.VkShaderStageFlagBits(t.shaderTensorSupportedStages),
		}
	)
end
mod.s.PipelineFragmentDensityMapLayeredCreateInfoVALVE = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxFragmentDensityMapLayers = t.maxFragmentDensityMapLayers,
		}
	)
end
mod.s.DepthBiasInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDepthBiasInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			depthBiasConstantFactor = t.depthBiasConstantFactor,
			depthBiasClamp = t.depthBiasClamp,
			depthBiasSlopeFactor = t.depthBiasSlopeFactor,
		}
	)
end
mod.s.DataGraphPipelineShaderModuleCreateInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineShaderModuleCreateInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			module = t.module,
			pName = t.pName,
			pSpecializationInfo = t.pSpecializationInfo,
			constantCount = t.constantCount,
			pConstants = t.pConstants,
		}
	)
end
mod.s.PhysicalDeviceDescriptorPoolOverallocationFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			descriptorPoolOverallocation = t.descriptorPoolOverallocation,
		}
	)
end
mod.s.DataGraphPipelineSessionCreateInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineSessionCreateInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			dataGraphPipeline = t.dataGraphPipeline,
		}
	)
end
mod.s.PhysicalDevicePresentMeteringFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePresentMeteringFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentMetering = t.presentMetering,
		}
	)
end
mod.s.DataGraphPipelineSessionBindPointRequirementARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineSessionBindPointRequirementARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			bindPoint = t.bindPoint and mod.e.VkDataGraphPipelineSessionBindPointARM(t.bindPoint),
			bindPointType = t.bindPointType and
				mod.e.VkDataGraphPipelineSessionBindPointTypeARM(t.bindPointType),
			numObjects = t.numObjects,
		}
	)
end
mod.s.PhysicalDeviceTileMemoryHeapFeaturesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tileMemoryHeap = t.tileMemoryHeap,
		}
	)
end
mod.s.PhysicalDeviceProvokingVertexFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceProvokingVertexFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			provokingVertexLast = t.provokingVertexLast,
			transformFeedbackPreservesProvokingVertex = t.transformFeedbackPreservesProvokingVertex,
		}
	)
end
mod.s.DataGraphPipelineSessionMemoryRequirementsInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineSessionMemoryRequirementsInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			session = t.session,
			bindPoint = t.bindPoint and mod.e.VkDataGraphPipelineSessionBindPointARM(t.bindPoint),
			objectIndex = t.objectIndex,
		}
	)
end
mod.s.BindDataGraphPipelineSessionMemoryInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindDataGraphPipelineSessionMemoryInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			session = t.session,
			bindPoint = t.bindPoint and mod.e.VkDataGraphPipelineSessionBindPointARM(t.bindPoint),
			objectIndex = t.objectIndex,
			memory = t.memory,
			memoryOffset = t.memoryOffset,
		}
	)
end
mod.s.DataGraphPipelineInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dataGraphPipeline = t.dataGraphPipeline,
		}
	)
end
mod.s.DataGraphPipelinePropertyQueryResultARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelinePropertyQueryResultARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			property = t.property and mod.e.VkDataGraphPipelinePropertyARM(t.property),
			isText = t.isText,
			dataSize = t.dataSize,
			pData = t.pData,
		}
	)
end
mod.s.PipelineRasterizationProvokingVertexStateCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			provokingVertexMode = t.provokingVertexMode and mod.e.VkProvokingVertexModeEXT(t.provokingVertexMode),
		}
	)
end
mod.s.PhysicalDeviceDeviceMemoryReportFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceMemoryReport = t.deviceMemoryReport,
		}
	)
end
mod.s.DataGraphPipelineDispatchInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineDispatchInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
		}
	)
end
mod.s.DeviceMemoryReportCallbackDataEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceMemoryReportCallbackDataEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			type = t.type and mod.e.VkDeviceMemoryReportEventTypeEXT(t.type),
			memoryObjectId = t.memoryObjectId,
			size = t.size,
			objectType = t.objectType and mod.e.VkObjectType(t.objectType),
			objectHandle = t.objectHandle,
			heapIndex = t.heapIndex,
		}
	)
end
mod.s.PhysicalDeviceDataGraphOperationSupportARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDataGraphOperationSupportARM(
		{
			operationType = t.operationType and
				mod.e.VkPhysicalDeviceDataGraphOperationTypeARM(t.operationType),
			name = t.name,
			version = t.version,
		}
	)
end
mod.s.HeadlessSurfaceCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkHeadlessSurfaceCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
		}
	)
end
mod.s.QueueFamilyDataGraphPropertiesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueueFamilyDataGraphPropertiesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			engine = t.engine,
			operation = t.operation,
		}
	)
end
mod.s.DataGraphProcessingEngineCreateInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphProcessingEngineCreateInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			processingEngineCount = t.processingEngineCount,
			pProcessingEngines = t.pProcessingEngines,
		}
	)
end
mod.s.PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			queueFamilyIndex = t.queueFamilyIndex,
			engineType = t.engineType and
				mod.e.VkPhysicalDeviceDataGraphProcessingEngineTypeARM(t.engineType),
		}
	)
end
mod.s.QueueFamilyDataGraphProcessingEnginePropertiesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueueFamilyDataGraphProcessingEnginePropertiesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			foreignSemaphoreHandleTypes = t.foreignSemaphoreHandleTypes and
				mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.foreignSemaphoreHandleTypes),
			foreignMemoryHandleTypes = t.foreignMemoryHandleTypes and
				mod.e.VkExternalMemoryHandleTypeFlagBits(t.foreignMemoryHandleTypes),
		}
	)
end
mod.s.DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dimension = t.dimension,
			zeroCount = t.zeroCount,
			groupSize = t.groupSize,
		}
	)
end
mod.s.PhysicalDeviceRawAccessChainsFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRawAccessChainsFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderRawAccessChains = t.shaderRawAccessChains,
		}
	)
end
mod.s.PhysicalDeviceShaderAtomicFloatFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderBufferFloat32Atomics = t.shaderBufferFloat32Atomics,
			shaderBufferFloat32AtomicAdd = t.shaderBufferFloat32AtomicAdd,
			shaderBufferFloat64Atomics = t.shaderBufferFloat64Atomics,
			shaderBufferFloat64AtomicAdd = t.shaderBufferFloat64AtomicAdd,
			shaderSharedFloat32Atomics = t.shaderSharedFloat32Atomics,
			shaderSharedFloat32AtomicAdd = t.shaderSharedFloat32AtomicAdd,
			shaderSharedFloat64Atomics = t.shaderSharedFloat64Atomics,
			shaderSharedFloat64AtomicAdd = t.shaderSharedFloat64AtomicAdd,
			shaderImageFloat32Atomics = t.shaderImageFloat32Atomics,
			shaderImageFloat32AtomicAdd = t.shaderImageFloat32AtomicAdd,
			sparseImageFloat32Atomics = t.sparseImageFloat32Atomics,
			sparseImageFloat32AtomicAdd = t.sparseImageFloat32AtomicAdd,
		}
	)
end
mod.s.SamplerCustomBorderColorCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSamplerCustomBorderColorCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			customBorderColor = t.customBorderColor,
			format = t.format and mod.e.VkFormat(t.format),
		}
	)
end
mod.s.ExternalComputeQueueDeviceCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalComputeQueueDeviceCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			reservedExternalQueues = t.reservedExternalQueues,
		}
	)
end
mod.s.PhysicalDeviceCustomBorderColorPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCustomBorderColorPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxCustomBorderColorSamplers = t.maxCustomBorderColorSamplers,
		}
	)
end
mod.s.ExternalComputeQueueCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalComputeQueueCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			preferredQueue = t.preferredQueue,
		}
	)
end
mod.s.PhysicalDeviceCustomBorderColorFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCustomBorderColorFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			customBorderColors = t.customBorderColors,
			customBorderColorWithoutFormat = t.customBorderColorWithoutFormat,
		}
	)
end
mod.s.ExternalComputeQueueDataParamsNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalComputeQueueDataParamsNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceIndex = t.deviceIndex,
		}
	)
end
mod.s.PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			combinedImageSamplerDensityMapDescriptorSize = t.combinedImageSamplerDensityMapDescriptorSize,
		}
	)
end
mod.s.PhysicalDeviceSubgroupProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSubgroupProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			subgroupSize = t.subgroupSize,
			supportedStages = t.supportedStages and mod.e.VkShaderStageFlagBits(t.supportedStages),
			supportedOperations = t.supportedOperations and mod.e.VkSubgroupFeatureFlagBits(t.supportedOperations),
			quadOperationsInAllStages = t.quadOperationsInAllStages,
		}
	)
end
mod.s.PhysicalDeviceDescriptorBufferFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDescriptorBufferFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			descriptorBuffer = t.descriptorBuffer,
			descriptorBufferCaptureReplay = t.descriptorBufferCaptureReplay,
			descriptorBufferImageLayoutIgnored = t.descriptorBufferImageLayoutIgnored,
			descriptorBufferPushDescriptors = t.descriptorBufferPushDescriptors,
		}
	)
end
mod.s.BindBufferMemoryInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindBufferMemoryInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			buffer = t.buffer,
			memory = t.memory,
			memoryOffset = t.memoryOffset,
		}
	)
end
mod.s.BindImageMemoryInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindImageMemoryInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			image = t.image,
			memory = t.memory,
			memoryOffset = t.memoryOffset,
		}
	)
end
mod.s.PhysicalDevice16BitStorageFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevice16BitStorageFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			storageBuffer16BitAccess = t.storageBuffer16BitAccess,
			uniformAndStorageBuffer16BitAccess = t.uniformAndStorageBuffer16BitAccess,
			storagePushConstant16 = t.storagePushConstant16,
			storageInputOutput16 = t.storageInputOutput16,
		}
	)
end
mod.s.DescriptorBufferBindingPushDescriptorBufferHandleEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			buffer = t.buffer,
		}
	)
end
mod.s.SurfaceCapabilitiesPresentBarrierNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfaceCapabilitiesPresentBarrierNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentBarrierSupported = t.presentBarrierSupported,
		}
	)
end
mod.s.SwapchainPresentBarrierCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSwapchainPresentBarrierCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentBarrierEnable = t.presentBarrierEnable,
		}
	)
end
mod.s.MemoryDedicatedRequirements = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryDedicatedRequirements(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			prefersDedicatedAllocation = t.prefersDedicatedAllocation,
			requiresDedicatedAllocation = t.requiresDedicatedAllocation,
		}
	)
end
mod.s.PhysicalDeviceVulkan11Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVulkan11Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			storageBuffer16BitAccess = t.storageBuffer16BitAccess,
			uniformAndStorageBuffer16BitAccess = t.uniformAndStorageBuffer16BitAccess,
			storagePushConstant16 = t.storagePushConstant16,
			storageInputOutput16 = t.storageInputOutput16,
			multiview = t.multiview,
			multiviewGeometryShader = t.multiviewGeometryShader,
			multiviewTessellationShader = t.multiviewTessellationShader,
			variablePointersStorageBuffer = t.variablePointersStorageBuffer,
			variablePointers = t.variablePointers,
			protectedMemory = t.protectedMemory,
			samplerYcbcrConversion = t.samplerYcbcrConversion,
			shaderDrawParameters = t.shaderDrawParameters,
		}
	)
end
mod.s.PhysicalDeviceVulkan11Properties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVulkan11Properties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceUUID = t.deviceUUID,
			driverUUID = t.driverUUID,
			deviceLUID = t.deviceLUID,
			deviceNodeMask = t.deviceNodeMask,
			deviceLUIDValid = t.deviceLUIDValid,
			subgroupSize = t.subgroupSize,
			subgroupSupportedStages = t.subgroupSupportedStages and
				mod.e.VkShaderStageFlagBits(t.subgroupSupportedStages),
			subgroupSupportedOperations = t.subgroupSupportedOperations and
				mod.e.VkSubgroupFeatureFlagBits(t.subgroupSupportedOperations),
			subgroupQuadOperationsInAllStages = t.subgroupQuadOperationsInAllStages,
			pointClippingBehavior = t.pointClippingBehavior and
				mod.e.VkPointClippingBehavior(t.pointClippingBehavior),
			maxMultiviewViewCount = t.maxMultiviewViewCount,
			maxMultiviewInstanceIndex = t.maxMultiviewInstanceIndex,
			protectedNoFault = t.protectedNoFault,
			maxPerSetDescriptors = t.maxPerSetDescriptors,
			maxMemoryAllocationSize = t.maxMemoryAllocationSize,
		}
	)
end
mod.s.MemoryDedicatedAllocateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryDedicatedAllocateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			image = t.image,
			buffer = t.buffer,
		}
	)
end
mod.s.MemoryAllocateFlagsInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryAllocateFlagsInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkMemoryAllocateFlagBits(t.flags),
			deviceMask = t.deviceMask,
		}
	)
end
mod.s.ClusterAccelerationStructureMoveObjectsInputNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkClusterAccelerationStructureMoveObjectsInputNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type and mod.e.VkClusterAccelerationStructureTypeNV(t.type),
			noMoveOverlap = t.noMoveOverlap,
			maxMovedBytes = t.maxMovedBytes,
		}
	)
end
mod.s.DescriptorGetInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorGetInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type and mod.e.VkDescriptorType(t.type),
			data = t.data,
		}
	)
end
mod.s.ExportMetalCommandQueueInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportMetalCommandQueueInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			queue = t.queue,
			mtlCommandQueue = t.mtlCommandQueue,
		}
	)
end
mod.s.ImageCaptureDescriptorDataInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageCaptureDescriptorDataInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			image = t.image,
		}
	)
end
mod.s.ImageViewCaptureDescriptorDataInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageViewCaptureDescriptorDataInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageView = t.imageView,
		}
	)
end
mod.s.ImageViewCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageViewCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkImageViewCreateFlagBits(t.flags),
			image = t.image,
			viewType = t.viewType and mod.e.VkImageViewType(t.viewType),
			format = t.format and mod.e.VkFormat(t.format),
			components = t.components,
			subresourceRange = t.subresourceRange,
		}
	)
end
mod.s.OpaqueCaptureDescriptorDataCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkOpaqueCaptureDescriptorDataCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			opaqueCaptureDescriptorData = t.opaqueCaptureDescriptorData,
		}
	)
end
mod.s.MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			perViewRenderAreaCount = t.perViewRenderAreaCount,
			pPerViewRenderAreas = t.pPerViewRenderAreas,
		}
	)
end
mod.s.ShaderModuleCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkShaderModuleCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			codeSize = t.codeSize,
			pCode = t.pCode,
		}
	)
end
mod.s.DeviceGroupBindSparseInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceGroupBindSparseInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			resourceDeviceIndex = t.resourceDeviceIndex,
			memoryDeviceIndex = t.memoryDeviceIndex,
		}
	)
end
mod.s.ImportMetalTextureInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImportMetalTextureInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			plane = t.plane and mod.e.VkImageAspectFlagBits(t.plane),
			mtlTexture = t.mtlTexture,
		}
	)
end
mod.s.PipelineCacheCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineCacheCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkPipelineCacheCreateFlagBits(t.flags),
			initialDataSize = t.initialDataSize,
			pInitialData = t.pInitialData,
		}
	)
end
mod.s.BindBufferMemoryDeviceGroupInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindBufferMemoryDeviceGroupInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceIndexCount = t.deviceIndexCount,
			pDeviceIndices = t.pDeviceIndices,
		}
	)
end
mod.s.ClusterAccelerationStructureCommandsInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkClusterAccelerationStructureCommandsInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			input = t.input,
			dstImplicitData = t.dstImplicitData,
			scratchData = t.scratchData,
			dstAddressesArray = t.dstAddressesArray,
			dstSizesArray = t.dstSizesArray,
			srcInfosArray = t.srcInfosArray,
			srcInfosCount = t.srcInfosCount,
			addressResolutionFlags = t.addressResolutionFlags,
		}
	)
end
mod.s.ExportMetalSharedEventInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportMetalSharedEventInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			semaphore = t.semaphore,
			event = t.event,
			mtlSharedEvent = t.mtlSharedEvent,
		}
	)
end
mod.s.BindImageMemoryDeviceGroupInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindImageMemoryDeviceGroupInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceIndexCount = t.deviceIndexCount,
			pDeviceIndices = t.pDeviceIndices,
			splitInstanceBindRegionCount = t.splitInstanceBindRegionCount,
			pSplitInstanceBindRegions = t.pSplitInstanceBindRegions,
		}
	)
end
mod.s.ImportMetalSharedEventInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImportMetalSharedEventInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			mtlSharedEvent = t.mtlSharedEvent,
		}
	)
end
mod.s.PhysicalDeviceGroupProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceGroupProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			physicalDeviceCount = t.physicalDeviceCount,
			physicalDevices = t.physicalDevices,
			subsetAllocation = t.subsetAllocation,
		}
	)
end
mod.s.SwapchainPresentFenceInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSwapchainPresentFenceInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchainCount = t.swapchainCount,
			pFences = t.pFences,
		}
	)
end
mod.s.SwapchainPresentModesCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSwapchainPresentModesCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentModeCount = t.presentModeCount,
			pPresentModes = t.pPresentModes,
		}
	)
end
mod.s.SwapchainPresentModeInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSwapchainPresentModeInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchainCount = t.swapchainCount,
			pPresentModes = t.pPresentModes,
		}
	)
end
mod.s.BufferMemoryRequirementsInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferMemoryRequirementsInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			buffer = t.buffer,
		}
	)
end
mod.s.ImageMemoryRequirementsInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageMemoryRequirementsInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			image = t.image,
		}
	)
end
mod.s.ImageSparseMemoryRequirementsInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageSparseMemoryRequirementsInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			image = t.image,
		}
	)
end
mod.s.PhysicalDeviceDiagnosticsConfigFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			diagnosticsConfig = t.diagnosticsConfig,
		}
	)
end
mod.s.ReleaseSwapchainImagesInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkReleaseSwapchainImagesInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchain = t.swapchain,
			imageIndexCount = t.imageIndexCount,
			pImageIndices = t.pImageIndices,
		}
	)
end
mod.s.SparseImageMemoryRequirements2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSparseImageMemoryRequirements2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memoryRequirements = t.memoryRequirements,
		}
	)
end
mod.s.PhysicalDeviceFeatures2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFeatures2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			features = t.features,
		}
	)
end
mod.s.PhysicalDeviceProperties2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceProperties2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			properties = t.properties,
		}
	)
end
mod.s.FormatProperties2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFormatProperties2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			formatProperties = t.formatProperties,
		}
	)
end
mod.s.ImageFormatProperties2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageFormatProperties2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageFormatProperties = t.imageFormatProperties,
		}
	)
end
mod.s.PipelineVertexInputStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineVertexInputStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			vertexBindingDescriptionCount = t.vertexBindingDescriptionCount,
			pVertexBindingDescriptions = t.pVertexBindingDescriptions,
			vertexAttributeDescriptionCount = t.vertexAttributeDescriptionCount,
			pVertexAttributeDescriptions = t.pVertexAttributeDescriptions,
		}
	)
end
mod.s.PhysicalDeviceImageFormatInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageFormatInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			format = t.format and mod.e.VkFormat(t.format),
			type = t.type and mod.e.VkImageType(t.type),
			tiling = t.tiling and mod.e.VkImageTiling(t.tiling),
			usage = t.usage and mod.e.VkImageUsageFlagBits(t.usage),
			flags = t.flags and mod.e.VkImageCreateFlagBits(t.flags),
		}
	)
end
mod.s.QueueFamilyProperties2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueueFamilyProperties2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			queueFamilyProperties = t.queueFamilyProperties,
		}
	)
end
mod.s.PhysicalDeviceMemoryProperties2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMemoryProperties2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memoryProperties = t.memoryProperties,
		}
	)
end
mod.s.PipelineInputAssemblyStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineInputAssemblyStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			topology = t.topology and mod.e.VkPrimitiveTopology(t.topology),
			primitiveRestartEnable = t.primitiveRestartEnable,
		}
	)
end
mod.s.SparseImageFormatProperties2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSparseImageFormatProperties2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			properties = t.properties,
		}
	)
end
mod.s.PhysicalDeviceSparseImageFormatInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSparseImageFormatInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			format = t.format and mod.e.VkFormat(t.format),
			type = t.type and mod.e.VkImageType(t.type),
			samples = t.samples and mod.e.VkSampleCountFlagBits(t.samples),
			usage = t.usage and mod.e.VkImageUsageFlagBits(t.usage),
			tiling = t.tiling and mod.e.VkImageTiling(t.tiling),
		}
	)
end
mod.s.PhysicalDevicePointClippingProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePointClippingProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pointClippingBehavior = t.pointClippingBehavior and
				mod.e.VkPointClippingBehavior(t.pointClippingBehavior),
		}
	)
end
mod.s.ViSurfaceCreateInfoNN = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkViSurfaceCreateInfoNN(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			window = t.window,
		}
	)
end
mod.s.InputAttachmentAspectReference = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkInputAttachmentAspectReference(
		{
			subpass = t.subpass,
			inputAttachmentIndex = t.inputAttachmentIndex,
			aspectMask = t.aspectMask and mod.e.VkImageAspectFlagBits(t.aspectMask),
		}
	)
end
mod.s.RenderPassInputAttachmentAspectCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassInputAttachmentAspectCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			aspectReferenceCount = t.aspectReferenceCount,
			pAspectReferences = t.pAspectReferences,
		}
	)
end
mod.s.ImageViewUsageCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageViewUsageCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			usage = t.usage and mod.e.VkImageUsageFlagBits(t.usage),
		}
	)
end
mod.s.PipelineTessellationDomainOriginStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineTessellationDomainOriginStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			domainOrigin = t.domainOrigin and mod.e.VkTessellationDomainOrigin(t.domainOrigin),
		}
	)
end
mod.s.ExternalFormatANDROID = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalFormatANDROID(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			externalFormat = t.externalFormat,
		}
	)
end
mod.s.RenderPassMultiviewCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassMultiviewCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			subpassCount = t.subpassCount,
			pViewMasks = t.pViewMasks,
			dependencyCount = t.dependencyCount,
			pViewOffsets = t.pViewOffsets,
			correlationMaskCount = t.correlationMaskCount,
			pCorrelationMasks = t.pCorrelationMasks,
		}
	)
end
mod.s.PhysicalDeviceVulkan12Properties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVulkan12Properties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			driverID = t.driverID and mod.e.VkDriverId(t.driverID),
			driverName = t.driverName,
			driverInfo = t.driverInfo,
			conformanceVersion = t.conformanceVersion,
			denormBehaviorIndependence = t.denormBehaviorIndependence and
				mod.e.VkShaderFloatControlsIndependence(t.denormBehaviorIndependence),
			roundingModeIndependence = t.roundingModeIndependence and
				mod.e.VkShaderFloatControlsIndependence(t.roundingModeIndependence),
			shaderSignedZeroInfNanPreserveFloat16 = t.shaderSignedZeroInfNanPreserveFloat16,
			shaderSignedZeroInfNanPreserveFloat32 = t.shaderSignedZeroInfNanPreserveFloat32,
			shaderSignedZeroInfNanPreserveFloat64 = t.shaderSignedZeroInfNanPreserveFloat64,
			shaderDenormPreserveFloat16 = t.shaderDenormPreserveFloat16,
			shaderDenormPreserveFloat32 = t.shaderDenormPreserveFloat32,
			shaderDenormPreserveFloat64 = t.shaderDenormPreserveFloat64,
			shaderDenormFlushToZeroFloat16 = t.shaderDenormFlushToZeroFloat16,
			shaderDenormFlushToZeroFloat32 = t.shaderDenormFlushToZeroFloat32,
			shaderDenormFlushToZeroFloat64 = t.shaderDenormFlushToZeroFloat64,
			shaderRoundingModeRTEFloat16 = t.shaderRoundingModeRTEFloat16,
			shaderRoundingModeRTEFloat32 = t.shaderRoundingModeRTEFloat32,
			shaderRoundingModeRTEFloat64 = t.shaderRoundingModeRTEFloat64,
			shaderRoundingModeRTZFloat16 = t.shaderRoundingModeRTZFloat16,
			shaderRoundingModeRTZFloat32 = t.shaderRoundingModeRTZFloat32,
			shaderRoundingModeRTZFloat64 = t.shaderRoundingModeRTZFloat64,
			maxUpdateAfterBindDescriptorsInAllPools = t.maxUpdateAfterBindDescriptorsInAllPools,
			shaderUniformBufferArrayNonUniformIndexingNative = t.shaderUniformBufferArrayNonUniformIndexingNative,
			shaderSampledImageArrayNonUniformIndexingNative = t.shaderSampledImageArrayNonUniformIndexingNative,
			shaderStorageBufferArrayNonUniformIndexingNative = t.shaderStorageBufferArrayNonUniformIndexingNative,
			shaderStorageImageArrayNonUniformIndexingNative = t.shaderStorageImageArrayNonUniformIndexingNative,
			shaderInputAttachmentArrayNonUniformIndexingNative = t.shaderInputAttachmentArrayNonUniformIndexingNative,
			robustBufferAccessUpdateAfterBind = t.robustBufferAccessUpdateAfterBind,
			quadDivergentImplicitLod = t.quadDivergentImplicitLod,
			maxPerStageDescriptorUpdateAfterBindSamplers = t.maxPerStageDescriptorUpdateAfterBindSamplers,
			maxPerStageDescriptorUpdateAfterBindUniformBuffers = t.maxPerStageDescriptorUpdateAfterBindUniformBuffers,
			maxPerStageDescriptorUpdateAfterBindStorageBuffers = t.maxPerStageDescriptorUpdateAfterBindStorageBuffers,
			maxPerStageDescriptorUpdateAfterBindSampledImages = t.maxPerStageDescriptorUpdateAfterBindSampledImages,
			maxPerStageDescriptorUpdateAfterBindStorageImages = t.maxPerStageDescriptorUpdateAfterBindStorageImages,
			maxPerStageDescriptorUpdateAfterBindInputAttachments = t.maxPerStageDescriptorUpdateAfterBindInputAttachments,
			maxPerStageUpdateAfterBindResources = t.maxPerStageUpdateAfterBindResources,
			maxDescriptorSetUpdateAfterBindSamplers = t.maxDescriptorSetUpdateAfterBindSamplers,
			maxDescriptorSetUpdateAfterBindUniformBuffers = t.maxDescriptorSetUpdateAfterBindUniformBuffers,
			maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = t.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic,
			maxDescriptorSetUpdateAfterBindStorageBuffers = t.maxDescriptorSetUpdateAfterBindStorageBuffers,
			maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = t.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic,
			maxDescriptorSetUpdateAfterBindSampledImages = t.maxDescriptorSetUpdateAfterBindSampledImages,
			maxDescriptorSetUpdateAfterBindStorageImages = t.maxDescriptorSetUpdateAfterBindStorageImages,
			maxDescriptorSetUpdateAfterBindInputAttachments = t.maxDescriptorSetUpdateAfterBindInputAttachments,
			supportedDepthResolveModes = t.supportedDepthResolveModes and
				mod.e.VkResolveModeFlagBits(t.supportedDepthResolveModes),
			supportedStencilResolveModes = t.supportedStencilResolveModes and
				mod.e.VkResolveModeFlagBits(t.supportedStencilResolveModes),
			independentResolveNone = t.independentResolveNone,
			independentResolve = t.independentResolve,
			filterMinmaxSingleComponentFormats = t.filterMinmaxSingleComponentFormats,
			filterMinmaxImageComponentMapping = t.filterMinmaxImageComponentMapping,
			maxTimelineSemaphoreValueDifference = t.maxTimelineSemaphoreValueDifference,
			framebufferIntegerColorSampleCounts = t.framebufferIntegerColorSampleCounts and
				mod.e.VkSampleCountFlagBits(t.framebufferIntegerColorSampleCounts),
		}
	)
end
mod.s.PhysicalDeviceTileShadingPropertiesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTileShadingPropertiesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxApronSize = t.maxApronSize,
			preferNonCoherent = t.preferNonCoherent,
			tileGranularity = t.tileGranularity,
			maxTileShadingRate = t.maxTileShadingRate,
		}
	)
end
mod.s.WaylandSurfaceCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkWaylandSurfaceCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			display = t.display,
			surface = t.surface,
		}
	)
end
mod.s.PhysicalDeviceMultiviewFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMultiviewFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			multiview = t.multiview,
			multiviewGeometryShader = t.multiviewGeometryShader,
			multiviewTessellationShader = t.multiviewTessellationShader,
		}
	)
end
mod.s.RayTracingPipelineClusterAccelerationStructureCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			allowClusterAccelerationStructure = t.allowClusterAccelerationStructure,
		}
	)
end
mod.s.RenderPassTileShadingCreateInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassTileShadingCreateInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			tileApronSize = t.tileApronSize,
		}
	)
end
mod.s.PhysicalDeviceMultiviewProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMultiviewProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxMultiviewViewCount = t.maxMultiviewViewCount,
			maxMultiviewInstanceIndex = t.maxMultiviewInstanceIndex,
		}
	)
end
mod.s.PerTileBeginInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPerTileBeginInfoQCOM({
		sType = t.sType and mod.e.VkStructureType(t.sType),
		pNext = t.pNext,
	})
end
mod.s.PerTileEndInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPerTileEndInfoQCOM({
		sType = t.sType and mod.e.VkStructureType(t.sType),
		pNext = t.pNext,
	})
end
mod.s.PhysicalDeviceVariablePointersFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVariablePointersFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			variablePointersStorageBuffer = t.variablePointersStorageBuffer,
			variablePointers = t.variablePointers,
		}
	)
end
mod.s.AndroidHardwareBufferFormatResolvePropertiesANDROID = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAndroidHardwareBufferFormatResolvePropertiesANDROID(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			colorAttachmentFormat = t.colorAttachmentFormat and mod.e.VkFormat(t.colorAttachmentFormat),
		}
	)
end
mod.s.PhysicalDeviceProtectedMemoryFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceProtectedMemoryFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			protectedMemory = t.protectedMemory,
		}
	)
end
mod.s.PhysicalDeviceProtectedMemoryProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceProtectedMemoryProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			protectedNoFault = t.protectedNoFault,
		}
	)
end
mod.s.DeviceQueueInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceQueueInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkDeviceQueueCreateFlagBits(t.flags),
			queueFamilyIndex = t.queueFamilyIndex,
			queueIndex = t.queueIndex,
		}
	)
end
mod.s.ProtectedSubmitInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkProtectedSubmitInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			protectedSubmit = t.protectedSubmit,
		}
	)
end
mod.s.SamplerYcbcrConversionCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSamplerYcbcrConversionCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			format = t.format and mod.e.VkFormat(t.format),
			ycbcrModel = t.ycbcrModel and mod.e.VkSamplerYcbcrModelConversion(t.ycbcrModel),
			ycbcrRange = t.ycbcrRange and mod.e.VkSamplerYcbcrRange(t.ycbcrRange),
			components = t.components,
			xChromaOffset = t.xChromaOffset and mod.e.VkChromaLocation(t.xChromaOffset),
			yChromaOffset = t.yChromaOffset and mod.e.VkChromaLocation(t.yChromaOffset),
			chromaFilter = t.chromaFilter and mod.e.VkFilter(t.chromaFilter),
			forceExplicitReconstruction = t.forceExplicitReconstruction,
		}
	)
end
mod.s.QueryLowLatencySupportNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueryLowLatencySupportNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pQueriedLowLatencyData = t.pQueriedLowLatencyData,
		}
	)
end
mod.s.IOSSurfaceCreateInfoMVK = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkIOSSurfaceCreateInfoMVK(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			pView = t.pView,
		}
	)
end
mod.s.SamplerYcbcrConversionInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSamplerYcbcrConversionInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			conversion = t.conversion,
		}
	)
end
mod.s.PhysicalDeviceDescriptorBufferPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDescriptorBufferPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			combinedImageSamplerDescriptorSingleArray = t.combinedImageSamplerDescriptorSingleArray,
			bufferlessPushDescriptors = t.bufferlessPushDescriptors,
			allowSamplerImageViewPostSubmitCreation = t.allowSamplerImageViewPostSubmitCreation,
			descriptorBufferOffsetAlignment = t.descriptorBufferOffsetAlignment,
			maxDescriptorBufferBindings = t.maxDescriptorBufferBindings,
			maxResourceDescriptorBufferBindings = t.maxResourceDescriptorBufferBindings,
			maxSamplerDescriptorBufferBindings = t.maxSamplerDescriptorBufferBindings,
			maxEmbeddedImmutableSamplerBindings = t.maxEmbeddedImmutableSamplerBindings,
			maxEmbeddedImmutableSamplers = t.maxEmbeddedImmutableSamplers,
			bufferCaptureReplayDescriptorDataSize = t.bufferCaptureReplayDescriptorDataSize,
			imageCaptureReplayDescriptorDataSize = t.imageCaptureReplayDescriptorDataSize,
			imageViewCaptureReplayDescriptorDataSize = t.imageViewCaptureReplayDescriptorDataSize,
			samplerCaptureReplayDescriptorDataSize = t.samplerCaptureReplayDescriptorDataSize,
			accelerationStructureCaptureReplayDescriptorDataSize = t.accelerationStructureCaptureReplayDescriptorDataSize,
			samplerDescriptorSize = t.samplerDescriptorSize,
			combinedImageSamplerDescriptorSize = t.combinedImageSamplerDescriptorSize,
			sampledImageDescriptorSize = t.sampledImageDescriptorSize,
			storageImageDescriptorSize = t.storageImageDescriptorSize,
			uniformTexelBufferDescriptorSize = t.uniformTexelBufferDescriptorSize,
			robustUniformTexelBufferDescriptorSize = t.robustUniformTexelBufferDescriptorSize,
			storageTexelBufferDescriptorSize = t.storageTexelBufferDescriptorSize,
			robustStorageTexelBufferDescriptorSize = t.robustStorageTexelBufferDescriptorSize,
			uniformBufferDescriptorSize = t.uniformBufferDescriptorSize,
			robustUniformBufferDescriptorSize = t.robustUniformBufferDescriptorSize,
			storageBufferDescriptorSize = t.storageBufferDescriptorSize,
			robustStorageBufferDescriptorSize = t.robustStorageBufferDescriptorSize,
			inputAttachmentDescriptorSize = t.inputAttachmentDescriptorSize,
			accelerationStructureDescriptorSize = t.accelerationStructureDescriptorSize,
			maxSamplerDescriptorBufferRange = t.maxSamplerDescriptorBufferRange,
			maxResourceDescriptorBufferRange = t.maxResourceDescriptorBufferRange,
			samplerDescriptorBufferAddressSpaceSize = t.samplerDescriptorBufferAddressSpaceSize,
			resourceDescriptorBufferAddressSpaceSize = t.resourceDescriptorBufferAddressSpaceSize,
			descriptorBufferAddressSpaceSize = t.descriptorBufferAddressSpaceSize,
		}
	)
end
mod.s.BindImagePlaneMemoryInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindImagePlaneMemoryInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			planeAspect = t.planeAspect and mod.e.VkImageAspectFlagBits(t.planeAspect),
		}
	)
end
mod.s.ImagePlaneMemoryRequirementsInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImagePlaneMemoryRequirementsInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			planeAspect = t.planeAspect and mod.e.VkImageAspectFlagBits(t.planeAspect),
		}
	)
end
mod.s.PhysicalDeviceSamplerYcbcrConversionFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSamplerYcbcrConversionFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			samplerYcbcrConversion = t.samplerYcbcrConversion,
		}
	)
end
mod.s.BuildPartitionedAccelerationStructureIndirectCommandNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBuildPartitionedAccelerationStructureIndirectCommandNV(
		{
			opType = t.opType and mod.e.VkPartitionedAccelerationStructureOpTypeNV(t.opType),
			argCount = t.argCount,
			argData = t.argData,
		}
	)
end
mod.s.SamplerYcbcrConversionImageFormatProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSamplerYcbcrConversionImageFormatProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			combinedImageSamplerDescriptorCount = t.combinedImageSamplerDescriptorCount,
		}
	)
end
mod.s.DescriptorUpdateTemplateEntry = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorUpdateTemplateEntry(
		{
			dstBinding = t.dstBinding,
			dstArrayElement = t.dstArrayElement,
			descriptorCount = t.descriptorCount,
			descriptorType = t.descriptorType and mod.e.VkDescriptorType(t.descriptorType),
			offset = t.offset,
			stride = t.stride,
		}
	)
end
mod.s.DescriptorUpdateTemplateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorUpdateTemplateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			descriptorUpdateEntryCount = t.descriptorUpdateEntryCount,
			pDescriptorUpdateEntries = t.pDescriptorUpdateEntries,
			templateType = t.templateType and mod.e.VkDescriptorUpdateTemplateType(t.templateType),
			descriptorSetLayout = t.descriptorSetLayout,
			pipelineBindPoint = t.pipelineBindPoint and mod.e.VkPipelineBindPoint(t.pipelineBindPoint),
			pipelineLayout = t.pipelineLayout,
			set = t.set,
		}
	)
end
mod.s.ExternalMemoryProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalMemoryProperties(
		{
			externalMemoryFeatures = t.externalMemoryFeatures and
				mod.e.VkExternalMemoryFeatureFlagBits(t.externalMemoryFeatures),
			exportFromImportedHandleTypes = t.exportFromImportedHandleTypes and
				mod.e.VkExternalMemoryHandleTypeFlagBits(t.exportFromImportedHandleTypes),
			compatibleHandleTypes = t.compatibleHandleTypes and
				mod.e.VkExternalMemoryHandleTypeFlagBits(t.compatibleHandleTypes),
		}
	)
end
mod.s.PhysicalDeviceExternalImageFormatInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExternalImageFormatInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleType = t.handleType and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType),
		}
	)
end
mod.s.ExternalImageFormatProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalImageFormatProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			externalMemoryProperties = t.externalMemoryProperties,
		}
	)
end
mod.s.WriteDescriptorSetPartitionedAccelerationStructureNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkWriteDescriptorSetPartitionedAccelerationStructureNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			accelerationStructureCount = t.accelerationStructureCount,
			pAccelerationStructures = t.pAccelerationStructures,
		}
	)
end
mod.s.PhysicalDeviceExternalBufferInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExternalBufferInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkBufferCreateFlagBits(t.flags),
			usage = t.usage and mod.e.VkBufferUsageFlagBits(t.usage),
			handleType = t.handleType and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType),
		}
	)
end
mod.s.ExternalBufferProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalBufferProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			externalMemoryProperties = t.externalMemoryProperties,
		}
	)
end
mod.s.PhysicalDeviceIDProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceIDProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceUUID = t.deviceUUID,
			driverUUID = t.driverUUID,
			deviceLUID = t.deviceLUID,
			deviceNodeMask = t.deviceNodeMask,
			deviceLUIDValid = t.deviceLUIDValid,
		}
	)
end
mod.s.MetalSurfaceCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMetalSurfaceCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			pLayer = t.pLayer,
		}
	)
end
mod.s.BuildPartitionedAccelerationStructureInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBuildPartitionedAccelerationStructureInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			input = t.input,
			srcAccelerationStructureData = t.srcAccelerationStructureData,
			dstAccelerationStructureData = t.dstAccelerationStructureData,
			scratchData = t.scratchData,
			srcInfos = t.srcInfos,
			srcInfosCount = t.srcInfosCount,
		}
	)
end
mod.s.QueueFamilyQueryResultStatusPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueueFamilyQueryResultStatusPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			queryResultStatusSupport = t.queryResultStatusSupport,
		}
	)
end
mod.s.QueueFamilyVideoPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueueFamilyVideoPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoCodecOperations = t.videoCodecOperations,
		}
	)
end
mod.s.ExternalMemoryImageCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalMemoryImageCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleTypes = t.handleTypes and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleTypes),
		}
	)
end
mod.s.ExternalMemoryBufferCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalMemoryBufferCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleTypes = t.handleTypes and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleTypes),
		}
	)
end
mod.s.ExportMemoryAllocateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportMemoryAllocateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleTypes = t.handleTypes and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleTypes),
		}
	)
end
mod.s.PhysicalDeviceExternalFenceInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExternalFenceInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleType = t.handleType and mod.e.VkExternalFenceHandleTypeFlagBits(t.handleType),
		}
	)
end
mod.s.ExternalFenceProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalFenceProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			exportFromImportedHandleTypes = t.exportFromImportedHandleTypes and
				mod.e.VkExternalFenceHandleTypeFlagBits(t.exportFromImportedHandleTypes),
			compatibleHandleTypes = t.compatibleHandleTypes and
				mod.e.VkExternalFenceHandleTypeFlagBits(t.compatibleHandleTypes),
			externalFenceFeatures = t.externalFenceFeatures and
				mod.e.VkExternalFenceFeatureFlagBits(t.externalFenceFeatures),
		}
	)
end
mod.s.ImportMemoryFdInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImportMemoryFdInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleType = t.handleType and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType),
			fd = t.fd,
		}
	)
end
mod.s.ExportSemaphoreCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportSemaphoreCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleTypes = t.handleTypes and mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.handleTypes),
		}
	)
end
mod.s.PhysicalDeviceExternalSemaphoreInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExternalSemaphoreInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleType = t.handleType and mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.handleType),
		}
	)
end
mod.s.MemoryGetFdInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryGetFdInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memory = t.memory,
			handleType = t.handleType and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType),
		}
	)
end
mod.s.PhysicalDeviceMaintenance3Properties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance3Properties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxPerSetDescriptors = t.maxPerSetDescriptors,
			maxMemoryAllocationSize = t.maxMemoryAllocationSize,
		}
	)
end
mod.s.DescriptorSetLayoutSupport = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorSetLayoutSupport(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			supported = t.supported,
		}
	)
end
mod.s.PhysicalDeviceVideoFormatInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVideoFormatInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageUsage = t.imageUsage and mod.e.VkImageUsageFlagBits(t.imageUsage),
		}
	)
end
mod.s.VideoFormatPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoFormatPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			format = t.format and mod.e.VkFormat(t.format),
			componentMapping = t.componentMapping,
			imageCreateFlags = t.imageCreateFlags and mod.e.VkImageCreateFlagBits(t.imageCreateFlags),
			imageType = t.imageType and mod.e.VkImageType(t.imageType),
			imageTiling = t.imageTiling and mod.e.VkImageTiling(t.imageTiling),
			imageUsageFlags = t.imageUsageFlags and mod.e.VkImageUsageFlagBits(t.imageUsageFlags),
		}
	)
end
mod.s.VideoPictureResourceInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoPictureResourceInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			codedOffset = t.codedOffset,
			codedExtent = t.codedExtent,
			baseArrayLayer = t.baseArrayLayer,
			imageViewBinding = t.imageViewBinding,
		}
	)
end
mod.s.VideoReferenceSlotInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoReferenceSlotInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			slotIndex = t.slotIndex,
			pPictureResource = t.pPictureResource,
		}
	)
end
mod.s.VideoSessionMemoryRequirementsKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoSessionMemoryRequirementsKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memoryBindIndex = t.memoryBindIndex,
			memoryRequirements = t.memoryRequirements,
		}
	)
end
mod.s.BindVideoSessionMemoryInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindVideoSessionMemoryInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memoryBindIndex = t.memoryBindIndex,
			memory = t.memory,
			memoryOffset = t.memoryOffset,
			memorySize = t.memorySize,
		}
	)
end
mod.s.VideoSessionCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoSessionCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			queueFamilyIndex = t.queueFamilyIndex,
			flags = t.flags,
			pVideoProfile = t.pVideoProfile,
			pictureFormat = t.pictureFormat and mod.e.VkFormat(t.pictureFormat),
			maxCodedExtent = t.maxCodedExtent,
			referencePictureFormat = t.referencePictureFormat and mod.e.VkFormat(t.referencePictureFormat),
			maxDpbSlots = t.maxDpbSlots,
			maxActiveReferencePictures = t.maxActiveReferencePictures,
			pStdHeaderVersion = t.pStdHeaderVersion,
		}
	)
end
mod.s.ImportSemaphoreFdInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImportSemaphoreFdInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			semaphore = t.semaphore,
			flags = t.flags and mod.e.VkSemaphoreImportFlagBits(t.flags),
			handleType = t.handleType and mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.handleType),
			fd = t.fd,
		}
	)
end
mod.s.SemaphoreGetFdInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSemaphoreGetFdInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			semaphore = t.semaphore,
			handleType = t.handleType and mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.handleType),
		}
	)
end
mod.s.VideoSessionParametersUpdateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoSessionParametersUpdateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			updateSequenceCount = t.updateSequenceCount,
		}
	)
end
mod.s.VideoBeginCodingInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoBeginCodingInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			videoSession = t.videoSession,
			videoSessionParameters = t.videoSessionParameters,
			referenceSlotCount = t.referenceSlotCount,
			pReferenceSlots = t.pReferenceSlots,
		}
	)
end
mod.s.StdVideoAV1LoopRestoration = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoAV1LoopRestoration(
		{
			FrameRestorationType = t.FrameRestorationType and
				mod.e.StdVideoAV1FrameRestorationType(t.FrameRestorationType),
			LoopRestorationSize = t.LoopRestorationSize,
		}
	)
end
mod.s.StdVideoH264SequenceParameterSetVui = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoH264SequenceParameterSetVui(
		{
			flags = t.flags,
			aspect_ratio_idc = t.aspect_ratio_idc and mod.e.StdVideoH264AspectRatioIdc(t.aspect_ratio_idc),
			sar_width = t.sar_width,
			sar_height = t.sar_height,
			video_format = t.video_format,
			colour_primaries = t.colour_primaries,
			transfer_characteristics = t.transfer_characteristics,
			matrix_coefficients = t.matrix_coefficients,
			num_units_in_tick = t.num_units_in_tick,
			time_scale = t.time_scale,
			max_num_reorder_frames = t.max_num_reorder_frames,
			max_dec_frame_buffering = t.max_dec_frame_buffering,
			chroma_sample_loc_type_top_field = t.chroma_sample_loc_type_top_field,
			chroma_sample_loc_type_bottom_field = t.chroma_sample_loc_type_bottom_field,
			reserved1 = t.reserved1,
			pHrdParameters = t.pHrdParameters,
		}
	)
end
mod.s.StdVideoH264SequenceParameterSet = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoH264SequenceParameterSet(
		{
			flags = t.flags,
			profile_idc = t.profile_idc and mod.e.StdVideoH264ProfileIdc(t.profile_idc),
			level_idc = t.level_idc and mod.e.StdVideoH264LevelIdc(t.level_idc),
			chroma_format_idc = t.chroma_format_idc and mod.e.StdVideoH264ChromaFormatIdc(t.chroma_format_idc),
			seq_parameter_set_id = t.seq_parameter_set_id,
			bit_depth_luma_minus8 = t.bit_depth_luma_minus8,
			bit_depth_chroma_minus8 = t.bit_depth_chroma_minus8,
			log2_max_frame_num_minus4 = t.log2_max_frame_num_minus4,
			pic_order_cnt_type = t.pic_order_cnt_type and mod.e.StdVideoH264PocType(t.pic_order_cnt_type),
			offset_for_non_ref_pic = t.offset_for_non_ref_pic,
			offset_for_top_to_bottom_field = t.offset_for_top_to_bottom_field,
			log2_max_pic_order_cnt_lsb_minus4 = t.log2_max_pic_order_cnt_lsb_minus4,
			num_ref_frames_in_pic_order_cnt_cycle = t.num_ref_frames_in_pic_order_cnt_cycle,
			max_num_ref_frames = t.max_num_ref_frames,
			reserved1 = t.reserved1,
			pic_width_in_mbs_minus1 = t.pic_width_in_mbs_minus1,
			pic_height_in_map_units_minus1 = t.pic_height_in_map_units_minus1,
			frame_crop_left_offset = t.frame_crop_left_offset,
			frame_crop_right_offset = t.frame_crop_right_offset,
			frame_crop_top_offset = t.frame_crop_top_offset,
			frame_crop_bottom_offset = t.frame_crop_bottom_offset,
			reserved2 = t.reserved2,
			pOffsetForRefFrame = t.pOffsetForRefFrame,
			pScalingLists = t.pScalingLists,
			pSequenceParameterSetVui = t.pSequenceParameterSetVui,
		}
	)
end
mod.s.PhysicalDeviceVideoEncodeAV1FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoEncodeAV1 = t.videoEncodeAV1,
		}
	)
end
mod.s.VideoEncodeAV1CapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeAV1CapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			maxLevel = t.maxLevel and mod.e.StdVideoAV1Level(t.maxLevel),
			codedPictureAlignment = t.codedPictureAlignment,
			maxTiles = t.maxTiles,
			minTileSize = t.minTileSize,
			maxTileSize = t.maxTileSize,
			superblockSizes = t.superblockSizes,
			maxSingleReferenceCount = t.maxSingleReferenceCount,
			singleReferenceNameMask = t.singleReferenceNameMask,
			maxUnidirectionalCompoundReferenceCount = t.maxUnidirectionalCompoundReferenceCount,
			maxUnidirectionalCompoundGroup1ReferenceCount = t.maxUnidirectionalCompoundGroup1ReferenceCount,
			unidirectionalCompoundReferenceNameMask = t.unidirectionalCompoundReferenceNameMask,
			maxBidirectionalCompoundReferenceCount = t.maxBidirectionalCompoundReferenceCount,
			maxBidirectionalCompoundGroup1ReferenceCount = t.maxBidirectionalCompoundGroup1ReferenceCount,
			maxBidirectionalCompoundGroup2ReferenceCount = t.maxBidirectionalCompoundGroup2ReferenceCount,
			bidirectionalCompoundReferenceNameMask = t.bidirectionalCompoundReferenceNameMask,
			maxTemporalLayerCount = t.maxTemporalLayerCount,
			maxSpatialLayerCount = t.maxSpatialLayerCount,
			maxOperatingPoints = t.maxOperatingPoints,
			minQIndex = t.minQIndex,
			maxQIndex = t.maxQIndex,
			prefersGopRemainingFrames = t.prefersGopRemainingFrames,
			requiresGopRemainingFrames = t.requiresGopRemainingFrames,
			stdSyntaxFlags = t.stdSyntaxFlags,
		}
	)
end
mod.s.VideoEncodeAV1QualityLevelPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeAV1QualityLevelPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			preferredRateControlFlags = t.preferredRateControlFlags,
			preferredGopFrameCount = t.preferredGopFrameCount,
			preferredKeyFramePeriod = t.preferredKeyFramePeriod,
			preferredConsecutiveBipredictiveFrameCount = t.preferredConsecutiveBipredictiveFrameCount,
			preferredTemporalLayerCount = t.preferredTemporalLayerCount,
			preferredConstantQIndex = t.preferredConstantQIndex,
			preferredMaxSingleReferenceCount = t.preferredMaxSingleReferenceCount,
			preferredSingleReferenceNameMask = t.preferredSingleReferenceNameMask,
			preferredMaxUnidirectionalCompoundReferenceCount = t.preferredMaxUnidirectionalCompoundReferenceCount,
			preferredMaxUnidirectionalCompoundGroup1ReferenceCount = t.preferredMaxUnidirectionalCompoundGroup1ReferenceCount,
			preferredUnidirectionalCompoundReferenceNameMask = t.preferredUnidirectionalCompoundReferenceNameMask,
			preferredMaxBidirectionalCompoundReferenceCount = t.preferredMaxBidirectionalCompoundReferenceCount,
			preferredMaxBidirectionalCompoundGroup1ReferenceCount = t.preferredMaxBidirectionalCompoundGroup1ReferenceCount,
			preferredMaxBidirectionalCompoundGroup2ReferenceCount = t.preferredMaxBidirectionalCompoundGroup2ReferenceCount,
			preferredBidirectionalCompoundReferenceNameMask = t.preferredBidirectionalCompoundReferenceNameMask,
		}
	)
end
mod.s.VideoEncodeAV1SessionCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeAV1SessionCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			useMaxLevel = t.useMaxLevel,
			maxLevel = t.maxLevel and mod.e.StdVideoAV1Level(t.maxLevel),
		}
	)
end
mod.s.VideoEncodeAV1SessionParametersCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeAV1SessionParametersCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdSequenceHeader = t.pStdSequenceHeader,
			pStdDecoderModelInfo = t.pStdDecoderModelInfo,
			stdOperatingPointCount = t.stdOperatingPointCount,
			pStdOperatingPoints = t.pStdOperatingPoints,
		}
	)
end
mod.s.VideoEncodeAV1PictureInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeAV1PictureInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			predictionMode = t.predictionMode and mod.e.VkVideoEncodeAV1PredictionModeKHR(t.predictionMode),
			rateControlGroup = t.rateControlGroup and
				mod.e.VkVideoEncodeAV1RateControlGroupKHR(t.rateControlGroup),
			constantQIndex = t.constantQIndex,
			pStdPictureInfo = t.pStdPictureInfo,
			referenceNameSlotIndices = t.referenceNameSlotIndices,
			primaryReferenceCdfOnly = t.primaryReferenceCdfOnly,
			generateObuExtensionHeader = t.generateObuExtensionHeader,
		}
	)
end
mod.s.VideoEncodeAV1DpbSlotInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeAV1DpbSlotInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdReferenceInfo = t.pStdReferenceInfo,
		}
	)
end
mod.s.VideoEncodeAV1ProfileInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeAV1ProfileInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stdProfile = t.stdProfile and mod.e.StdVideoAV1Profile(t.stdProfile),
		}
	)
end
mod.s.VideoEncodeAV1GopRemainingFrameInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeAV1GopRemainingFrameInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			useGopRemainingFrames = t.useGopRemainingFrames,
			gopRemainingIntra = t.gopRemainingIntra,
			gopRemainingPredictive = t.gopRemainingPredictive,
			gopRemainingBipredictive = t.gopRemainingBipredictive,
		}
	)
end
mod.s.VideoEncodeAV1RateControlInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeAV1RateControlInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			gopFrameCount = t.gopFrameCount,
			keyFramePeriod = t.keyFramePeriod,
			consecutiveBipredictiveFrameCount = t.consecutiveBipredictiveFrameCount,
			temporalLayerCount = t.temporalLayerCount,
		}
	)
end
mod.s.VideoEncodeAV1RateControlLayerInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeAV1RateControlLayerInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			useMinQIndex = t.useMinQIndex,
			minQIndex = t.minQIndex,
			useMaxQIndex = t.useMaxQIndex,
			maxQIndex = t.maxQIndex,
			useMaxFrameSize = t.useMaxFrameSize,
			maxFrameSize = t.maxFrameSize,
		}
	)
end
mod.s.PhysicalDeviceFaultFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFaultFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceFault = t.deviceFault,
			deviceFaultVendorBinary = t.deviceFaultVendorBinary,
		}
	)
end
mod.s.DeviceFaultCountsEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceFaultCountsEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			addressInfoCount = t.addressInfoCount,
			vendorInfoCount = t.vendorInfoCount,
			vendorBinarySize = t.vendorBinarySize,
		}
	)
end
mod.s.DeviceFaultAddressInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceFaultAddressInfoEXT(
		{
			addressType = t.addressType and mod.e.VkDeviceFaultAddressTypeEXT(t.addressType),
			reportedAddress = t.reportedAddress,
			addressPrecision = t.addressPrecision,
		}
	)
end
mod.s.DeviceFaultInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceFaultInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			description = t.description,
			pAddressInfos = t.pAddressInfos,
			pVendorInfos = t.pVendorInfos,
			pVendorBinaryData = t.pVendorBinaryData,
		}
	)
end
mod.s.DeviceFaultVendorBinaryHeaderVersionOneEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceFaultVendorBinaryHeaderVersionOneEXT(
		{
			headerSize = t.headerSize,
			headerVersion = t.headerVersion and
				mod.e.VkDeviceFaultVendorBinaryHeaderVersionEXT(t.headerVersion),
			vendorID = t.vendorID,
			deviceID = t.deviceID,
			driverVersion = t.driverVersion,
			pipelineCacheUUID = t.pipelineCacheUUID,
			applicationNameOffset = t.applicationNameOffset,
			applicationVersion = t.applicationVersion,
			engineNameOffset = t.engineNameOffset,
			engineVersion = t.engineVersion,
			apiVersion = t.apiVersion,
		}
	)
end
mod.s.PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rasterizationOrderColorAttachmentAccess = t.rasterizationOrderColorAttachmentAccess,
			rasterizationOrderDepthAttachmentAccess = t.rasterizationOrderDepthAttachmentAccess,
			rasterizationOrderStencilAttachmentAccess = t.rasterizationOrderStencilAttachmentAccess,
		}
	)
end
mod.s.PhysicalDeviceRGBA10X6FormatsFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			formatRgba10x6WithoutYCbCrSampler = t.formatRgba10x6WithoutYCbCrSampler,
		}
	)
end
mod.s.PhysicalDeviceMutableDescriptorTypeFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			mutableDescriptorType = t.mutableDescriptorType,
		}
	)
end
mod.s.MutableDescriptorTypeCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMutableDescriptorTypeCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			mutableDescriptorTypeListCount = t.mutableDescriptorTypeListCount,
			pMutableDescriptorTypeLists = t.pMutableDescriptorTypeLists,
		}
	)
end
mod.s.FrameBoundaryTensorsARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFrameBoundaryTensorsARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tensorCount = t.tensorCount,
			pTensors = t.pTensors,
		}
	)
end
mod.s.PhysicalDeviceVertexInputDynamicStateFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vertexInputDynamicState = t.vertexInputDynamicState,
		}
	)
end
mod.s.VertexInputBindingDescription2EXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVertexInputBindingDescription2EXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			binding = t.binding,
			stride = t.stride,
			inputRate = t.inputRate and mod.e.VkVertexInputRate(t.inputRate),
			divisor = t.divisor,
		}
	)
end
mod.s.VertexInputAttributeDescription2EXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVertexInputAttributeDescription2EXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			location = t.location,
			binding = t.binding,
			format = t.format and mod.e.VkFormat(t.format),
			offset = t.offset,
		}
	)
end
mod.s.PhysicalDeviceDrmPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDrmPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			hasPrimary = t.hasPrimary,
			hasRender = t.hasRender,
			primaryMajor = t.primaryMajor,
			primaryMinor = t.primaryMinor,
			renderMajor = t.renderMajor,
			renderMinor = t.renderMinor,
		}
	)
end
mod.s.DebugReportCallbackCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDebugReportCallbackCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			pfnCallback = t.pfnCallback,
			pUserData = t.pUserData,
		}
	)
end
mod.s.PhysicalDeviceAddressBindingReportFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceAddressBindingReportFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			reportAddressBinding = t.reportAddressBinding,
		}
	)
end
mod.s.DeviceAddressBindingCallbackDataEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceAddressBindingCallbackDataEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			baseAddress = t.baseAddress,
			size = t.size,
			bindingType = t.bindingType and mod.e.VkDeviceAddressBindingTypeEXT(t.bindingType),
		}
	)
end
mod.s.PhysicalDeviceShaderModuleIdentifierFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderModuleIdentifier = t.shaderModuleIdentifier,
		}
	)
end
mod.s.PhysicalDeviceShaderModuleIdentifierPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderModuleIdentifierAlgorithmUUID = t.shaderModuleIdentifierAlgorithmUUID,
		}
	)
end
mod.s.PipelineShaderStageModuleIdentifierCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineShaderStageModuleIdentifierCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			identifierSize = t.identifierSize,
			pIdentifier = t.pIdentifier,
		}
	)
end
mod.s.PhysicalDeviceDepthClipControlFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDepthClipControlFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			depthClipControl = t.depthClipControl,
		}
	)
end
mod.s.PipelineViewportDepthClipControlCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineViewportDepthClipControlCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			negativeOneToOne = t.negativeOneToOne,
		}
	)
end
mod.s.PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			primitiveTopologyListRestart = t.primitiveTopologyListRestart,
			primitiveTopologyPatchListRestart = t.primitiveTopologyPatchListRestart,
		}
	)
end
mod.s.RayTracingShaderGroupCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRayTracingShaderGroupCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type and mod.e.VkRayTracingShaderGroupTypeKHR(t.type),
			generalShader = t.generalShader,
			closestHitShader = t.closestHitShader,
			anyHitShader = t.anyHitShader,
			intersectionShader = t.intersectionShader,
		}
	)
end
mod.s.RayTracingPipelineCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRayTracingPipelineCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkPipelineCreateFlagBits(t.flags),
			stageCount = t.stageCount,
			pStages = t.pStages,
			groupCount = t.groupCount,
			pGroups = t.pGroups,
			maxRecursionDepth = t.maxRecursionDepth,
			layout = t.layout,
			basePipelineHandle = t.basePipelineHandle,
			basePipelineIndex = t.basePipelineIndex,
		}
	)
end
mod.s.PipelineRasterizationStateRasterizationOrderAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineRasterizationStateRasterizationOrderAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rasterizationOrder = t.rasterizationOrder and mod.e.VkRasterizationOrderAMD(t.rasterizationOrder),
		}
	)
end
mod.s.GeometryTrianglesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGeometryTrianglesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vertexData = t.vertexData,
			vertexOffset = t.vertexOffset,
			vertexCount = t.vertexCount,
			vertexStride = t.vertexStride,
			vertexFormat = t.vertexFormat and mod.e.VkFormat(t.vertexFormat),
			indexData = t.indexData,
			indexOffset = t.indexOffset,
			indexCount = t.indexCount,
			indexType = t.indexType and mod.e.VkIndexType(t.indexType),
			transformData = t.transformData,
			transformOffset = t.transformOffset,
		}
	)
end
mod.s.GeometryAABBNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGeometryAABBNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			aabbData = t.aabbData,
			numAABBs = t.numAABBs,
			stride = t.stride,
			offset = t.offset,
		}
	)
end
mod.s.DebugMarkerObjectNameInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDebugMarkerObjectNameInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			objectType = t.objectType and mod.e.VkDebugReportObjectTypeEXT(t.objectType),
			object = t.object,
			pObjectName = t.pObjectName,
		}
	)
end
mod.s.DebugMarkerObjectTagInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDebugMarkerObjectTagInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			objectType = t.objectType and mod.e.VkDebugReportObjectTypeEXT(t.objectType),
			object = t.object,
			tagName = t.tagName,
			tagSize = t.tagSize,
			pTag = t.pTag,
		}
	)
end
mod.s.GeometryNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGeometryNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			geometryType = t.geometryType and mod.e.VkGeometryTypeKHR(t.geometryType),
			geometry = t.geometry,
			flags = t.flags,
		}
	)
end
mod.s.DebugMarkerMarkerInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDebugMarkerMarkerInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pMarkerName = t.pMarkerName,
			color = t.color,
		}
	)
end
mod.s.AccelerationStructureCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			compactedSize = t.compactedSize,
			info = t.info,
		}
	)
end
mod.s.BindAccelerationStructureMemoryInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindAccelerationStructureMemoryInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			accelerationStructure = t.accelerationStructure,
			memory = t.memory,
			memoryOffset = t.memoryOffset,
			deviceIndexCount = t.deviceIndexCount,
			pDeviceIndices = t.pDeviceIndices,
		}
	)
end
mod.s.WriteDescriptorSetAccelerationStructureNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkWriteDescriptorSetAccelerationStructureNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			accelerationStructureCount = t.accelerationStructureCount,
			pAccelerationStructures = t.pAccelerationStructures,
		}
	)
end
mod.s.AccelerationStructureMemoryRequirementsInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureMemoryRequirementsInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type and mod.e.VkAccelerationStructureMemoryRequirementsTypeNV(t.type),
			accelerationStructure = t.accelerationStructure,
		}
	)
end
mod.s.PhysicalDeviceRayTracingPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRayTracingPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderGroupHandleSize = t.shaderGroupHandleSize,
			maxRecursionDepth = t.maxRecursionDepth,
			maxShaderGroupStride = t.maxShaderGroupStride,
			shaderGroupBaseAlignment = t.shaderGroupBaseAlignment,
			maxGeometryCount = t.maxGeometryCount,
			maxInstanceCount = t.maxInstanceCount,
			maxTriangleCount = t.maxTriangleCount,
			maxDescriptorSetAccelerationStructures = t.maxDescriptorSetAccelerationStructures,
		}
	)
end
mod.s.PhysicalDeviceVulkan14Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVulkan14Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			globalPriorityQuery = t.globalPriorityQuery,
			shaderSubgroupRotate = t.shaderSubgroupRotate,
			shaderSubgroupRotateClustered = t.shaderSubgroupRotateClustered,
			shaderFloatControls2 = t.shaderFloatControls2,
			shaderExpectAssume = t.shaderExpectAssume,
			rectangularLines = t.rectangularLines,
			bresenhamLines = t.bresenhamLines,
			smoothLines = t.smoothLines,
			stippledRectangularLines = t.stippledRectangularLines,
			stippledBresenhamLines = t.stippledBresenhamLines,
			stippledSmoothLines = t.stippledSmoothLines,
			vertexAttributeInstanceRateDivisor = t.vertexAttributeInstanceRateDivisor,
			vertexAttributeInstanceRateZeroDivisor = t.vertexAttributeInstanceRateZeroDivisor,
			indexTypeUint8 = t.indexTypeUint8,
			dynamicRenderingLocalRead = t.dynamicRenderingLocalRead,
			maintenance5 = t.maintenance5,
			maintenance6 = t.maintenance6,
			pipelineProtectedAccess = t.pipelineProtectedAccess,
			pipelineRobustness = t.pipelineRobustness,
			hostImageCopy = t.hostImageCopy,
			pushDescriptor = t.pushDescriptor,
		}
	)
end
mod.s.DedicatedAllocationImageCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDedicatedAllocationImageCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dedicatedAllocation = t.dedicatedAllocation,
		}
	)
end
mod.s.DedicatedAllocationBufferCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDedicatedAllocationBufferCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dedicatedAllocation = t.dedicatedAllocation,
		}
	)
end
mod.s.DedicatedAllocationMemoryAllocateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDedicatedAllocationMemoryAllocateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			image = t.image,
			buffer = t.buffer,
		}
	)
end
mod.s.PhysicalDeviceTransformFeedbackFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTransformFeedbackFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			transformFeedback = t.transformFeedback,
			geometryStreams = t.geometryStreams,
		}
	)
end
mod.s.PhysicalDeviceTransformFeedbackPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTransformFeedbackPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxTransformFeedbackStreams = t.maxTransformFeedbackStreams,
			maxTransformFeedbackBuffers = t.maxTransformFeedbackBuffers,
			maxTransformFeedbackBufferSize = t.maxTransformFeedbackBufferSize,
			maxTransformFeedbackStreamDataSize = t.maxTransformFeedbackStreamDataSize,
			maxTransformFeedbackBufferDataSize = t.maxTransformFeedbackBufferDataSize,
			maxTransformFeedbackBufferDataStride = t.maxTransformFeedbackBufferDataStride,
			transformFeedbackQueries = t.transformFeedbackQueries,
			transformFeedbackStreamsLinesTriangles = t.transformFeedbackStreamsLinesTriangles,
			transformFeedbackRasterizationStreamSelect = t.transformFeedbackRasterizationStreamSelect,
			transformFeedbackDraw = t.transformFeedbackDraw,
		}
	)
end
mod.s.PhysicalDeviceVulkan14Properties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVulkan14Properties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			lineSubPixelPrecisionBits = t.lineSubPixelPrecisionBits,
			maxVertexAttribDivisor = t.maxVertexAttribDivisor,
			supportsNonZeroFirstInstance = t.supportsNonZeroFirstInstance,
			maxPushDescriptors = t.maxPushDescriptors,
			dynamicRenderingLocalReadDepthStencilAttachments = t.dynamicRenderingLocalReadDepthStencilAttachments,
			dynamicRenderingLocalReadMultisampledAttachments = t.dynamicRenderingLocalReadMultisampledAttachments,
			earlyFragmentMultisampleCoverageAfterSampleCounting = t.earlyFragmentMultisampleCoverageAfterSampleCounting,
			earlyFragmentSampleMaskTestBeforeSampleCounting = t.earlyFragmentSampleMaskTestBeforeSampleCounting,
			depthStencilSwizzleOneSupport = t.depthStencilSwizzleOneSupport,
			polygonModePointSize = t.polygonModePointSize,
			nonStrictSinglePixelWideLinesUseParallelogram = t.nonStrictSinglePixelWideLinesUseParallelogram,
			nonStrictWideLinesUseParallelogram = t.nonStrictWideLinesUseParallelogram,
			blockTexelViewCompatibleMultipleLayers = t.blockTexelViewCompatibleMultipleLayers,
			maxCombinedImageSamplerDescriptorCount = t.maxCombinedImageSamplerDescriptorCount,
			fragmentShadingRateClampCombinerInputs = t.fragmentShadingRateClampCombinerInputs,
			defaultRobustnessStorageBuffers = t.defaultRobustnessStorageBuffers and
				mod.e.VkPipelineRobustnessBufferBehavior(t.defaultRobustnessStorageBuffers),
			defaultRobustnessUniformBuffers = t.defaultRobustnessUniformBuffers and
				mod.e.VkPipelineRobustnessBufferBehavior(t.defaultRobustnessUniformBuffers),
			defaultRobustnessVertexInputs = t.defaultRobustnessVertexInputs and
				mod.e.VkPipelineRobustnessBufferBehavior(t.defaultRobustnessVertexInputs),
			defaultRobustnessImages = t.defaultRobustnessImages and
				mod.e.VkPipelineRobustnessImageBehavior(t.defaultRobustnessImages),
			copySrcLayoutCount = t.copySrcLayoutCount,
			pCopySrcLayouts = t.pCopySrcLayouts,
			copyDstLayoutCount = t.copyDstLayoutCount,
			pCopyDstLayouts = t.pCopyDstLayouts,
			optimalTilingLayoutUUID = t.optimalTilingLayoutUUID,
			identicalMemoryTypeRequirements = t.identicalMemoryTypeRequirements,
		}
	)
end
mod.s.SurfaceProtectedCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfaceProtectedCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			supportsProtected = t.supportsProtected,
		}
	)
end
mod.s.PipelineRasterizationStateStreamCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineRasterizationStateStreamCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			rasterizationStream = t.rasterizationStream,
		}
	)
end
mod.s.PresentRegionsKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPresentRegionsKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchainCount = t.swapchainCount,
			pRegions = t.pRegions,
		}
	)
end
mod.s.PhysicalDeviceOpticalFlowFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceOpticalFlowFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			opticalFlow = t.opticalFlow,
		}
	)
end
mod.s.PhysicalDeviceOpticalFlowPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceOpticalFlowPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			supportedOutputGridSizes = t.supportedOutputGridSizes,
			supportedHintGridSizes = t.supportedHintGridSizes,
			hintSupported = t.hintSupported,
			costSupported = t.costSupported,
			bidirectionalFlowSupported = t.bidirectionalFlowSupported,
			globalFlowSupported = t.globalFlowSupported,
			minWidth = t.minWidth,
			minHeight = t.minHeight,
			maxWidth = t.maxWidth,
			maxHeight = t.maxHeight,
			maxNumRegionsOfInterest = t.maxNumRegionsOfInterest,
		}
	)
end
mod.s.PhysicalDevicePresentWaitFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePresentWaitFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentWait = t.presentWait,
		}
	)
end
mod.s.OpticalFlowImageFormatInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkOpticalFlowImageFormatInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			usage = t.usage,
		}
	)
end
mod.s.OpticalFlowImageFormatPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkOpticalFlowImageFormatPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			format = t.format and mod.e.VkFormat(t.format),
		}
	)
end
mod.s.OpticalFlowSessionCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkOpticalFlowSessionCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			width = t.width,
			height = t.height,
			imageFormat = t.imageFormat and mod.e.VkFormat(t.imageFormat),
			flowVectorFormat = t.flowVectorFormat and mod.e.VkFormat(t.flowVectorFormat),
			costFormat = t.costFormat and mod.e.VkFormat(t.costFormat),
			outputGridSize = t.outputGridSize,
			hintGridSize = t.hintGridSize,
			performanceLevel = t.performanceLevel and mod.e.VkOpticalFlowPerformanceLevelNV(t.performanceLevel),
			flags = t.flags,
		}
	)
end
mod.s.DeviceQueueGlobalPriorityCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceQueueGlobalPriorityCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			globalPriority = t.globalPriority and mod.e.VkQueueGlobalPriority(t.globalPriority),
		}
	)
end
mod.s.PhysicalDeviceGlobalPriorityQueryFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceGlobalPriorityQueryFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			globalPriorityQuery = t.globalPriorityQuery,
		}
	)
end
mod.s.QueueFamilyGlobalPriorityProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueueFamilyGlobalPriorityProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			priorityCount = t.priorityCount,
			priorities = t.priorities and mod.e.VkQueueGlobalPriority(t.priorities),
		}
	)
end
mod.s.OpticalFlowSessionCreatePrivateDataInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkOpticalFlowSessionCreatePrivateDataInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			id = t.id,
			size = t.size,
			pPrivateData = t.pPrivateData,
		}
	)
end
mod.s.PhysicalDeviceShaderSubgroupRotateFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderSubgroupRotateFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderSubgroupRotate = t.shaderSubgroupRotate,
			shaderSubgroupRotateClustered = t.shaderSubgroupRotateClustered,
		}
	)
end
mod.s.PhysicalDeviceShaderFloatControls2Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderFloatControls2Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderFloatControls2 = t.shaderFloatControls2,
		}
	)
end
mod.s.OpticalFlowExecuteInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkOpticalFlowExecuteInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			regionCount = t.regionCount,
			pRegions = t.pRegions,
		}
	)
end
mod.s.PhysicalDeviceLineRasterizationFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceLineRasterizationFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rectangularLines = t.rectangularLines,
			bresenhamLines = t.bresenhamLines,
			smoothLines = t.smoothLines,
			stippledRectangularLines = t.stippledRectangularLines,
			stippledBresenhamLines = t.stippledBresenhamLines,
			stippledSmoothLines = t.stippledSmoothLines,
		}
	)
end
mod.s.PhysicalDeviceLineRasterizationProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceLineRasterizationProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			lineSubPixelPrecisionBits = t.lineSubPixelPrecisionBits,
		}
	)
end
mod.s.PipelineRasterizationLineStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineRasterizationLineStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			lineRasterizationMode = t.lineRasterizationMode and
				mod.e.VkLineRasterizationMode(t.lineRasterizationMode),
			stippledLineEnable = t.stippledLineEnable,
			lineStippleFactor = t.lineStippleFactor,
			lineStipplePattern = t.lineStipplePattern,
		}
	)
end
mod.s.PhysicalDeviceVertexAttributeDivisorProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVertexAttributeDivisorProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxVertexAttribDivisor = t.maxVertexAttribDivisor,
			supportsNonZeroFirstInstance = t.supportsNonZeroFirstInstance,
		}
	)
end
mod.s.PipelineVertexInputDivisorStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineVertexInputDivisorStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vertexBindingDivisorCount = t.vertexBindingDivisorCount,
			pVertexBindingDivisors = t.pVertexBindingDivisors,
		}
	)
end
mod.s.PhysicalDeviceRepresentativeFragmentTestFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			representativeFragmentTest = t.representativeFragmentTest,
		}
	)
end
mod.s.PhysicalDeviceVertexAttributeDivisorFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVertexAttributeDivisorFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vertexAttributeInstanceRateDivisor = t.vertexAttributeInstanceRateDivisor,
			vertexAttributeInstanceRateZeroDivisor = t.vertexAttributeInstanceRateZeroDivisor,
		}
	)
end
mod.s.PhysicalDeviceIndexTypeUint8Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceIndexTypeUint8Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			indexTypeUint8 = t.indexTypeUint8,
		}
	)
end
mod.s.MemoryMapInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryMapInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkMemoryMapFlagBits(t.flags),
			memory = t.memory,
			offset = t.offset,
			size = t.size,
		}
	)
end
mod.s.MemoryUnmapInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryUnmapInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkMemoryUnmapFlagBits(t.flags),
			memory = t.memory,
		}
	)
end
mod.s.PhysicalDeviceMaintenance5Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance5Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maintenance5 = t.maintenance5,
		}
	)
end
mod.s.PhysicalDeviceMaintenance5Properties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance5Properties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			earlyFragmentMultisampleCoverageAfterSampleCounting = t.earlyFragmentMultisampleCoverageAfterSampleCounting,
			earlyFragmentSampleMaskTestBeforeSampleCounting = t.earlyFragmentSampleMaskTestBeforeSampleCounting,
			depthStencilSwizzleOneSupport = t.depthStencilSwizzleOneSupport,
			polygonModePointSize = t.polygonModePointSize,
			nonStrictSinglePixelWideLinesUseParallelogram = t.nonStrictSinglePixelWideLinesUseParallelogram,
			nonStrictWideLinesUseParallelogram = t.nonStrictWideLinesUseParallelogram,
		}
	)
end
mod.s.RenderingAreaInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderingAreaInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			viewMask = t.viewMask,
			colorAttachmentCount = t.colorAttachmentCount,
			pColorAttachmentFormats = t.pColorAttachmentFormats,
			depthAttachmentFormat = t.depthAttachmentFormat and mod.e.VkFormat(t.depthAttachmentFormat),
			stencilAttachmentFormat = t.stencilAttachmentFormat and mod.e.VkFormat(t.stencilAttachmentFormat),
		}
	)
end
mod.s.PhysicalDeviceLegacyDitheringFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceLegacyDitheringFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			legacyDithering = t.legacyDithering,
		}
	)
end
mod.s.DeviceImageSubresourceInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceImageSubresourceInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pCreateInfo = t.pCreateInfo,
			pSubresource = t.pSubresource,
		}
	)
end
mod.s.SubresourceLayout2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubresourceLayout2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			subresourceLayout = t.subresourceLayout,
		}
	)
end
mod.s.PhysicalDevicePipelineExecutablePropertiesFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineExecutableInfo = t.pipelineExecutableInfo,
		}
	)
end
mod.s.BufferUsageFlags2CreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferUsageFlags2CreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			usage = t.usage,
		}
	)
end
mod.s.PipelineInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipeline = t.pipeline,
		}
	)
end
mod.s.PipelineExecutablePropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineExecutablePropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stages = t.stages and mod.e.VkShaderStageFlagBits(t.stages),
			name = t.name,
			description = t.description,
			subgroupSize = t.subgroupSize,
		}
	)
end
mod.s.RenderingAttachmentLocationInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderingAttachmentLocationInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			colorAttachmentCount = t.colorAttachmentCount,
			pColorAttachmentLocations = t.pColorAttachmentLocations,
		}
	)
end
mod.s.PipelineExecutableInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineExecutableInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipeline = t.pipeline,
			executableIndex = t.executableIndex,
		}
	)
end
mod.s.RenderingInputAttachmentIndexInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderingInputAttachmentIndexInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			colorAttachmentCount = t.colorAttachmentCount,
			pColorAttachmentInputIndices = t.pColorAttachmentInputIndices,
			pDepthInputAttachmentIndex = t.pDepthInputAttachmentIndex,
			pStencilInputAttachmentIndex = t.pStencilInputAttachmentIndex,
		}
	)
end
mod.s.PipelineExecutableStatisticKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineExecutableStatisticKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			name = t.name,
			description = t.description,
			format = t.format and mod.e.VkPipelineExecutableStatisticFormatKHR(t.format),
			value = t.value,
		}
	)
end
mod.s.PipelineExecutableInternalRepresentationKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineExecutableInternalRepresentationKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			name = t.name,
			description = t.description,
			isText = t.isText,
			dataSize = t.dataSize,
			pData = t.pData,
		}
	)
end
mod.s.PhysicalDeviceAntiLagFeaturesAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceAntiLagFeaturesAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			antiLag = t.antiLag,
		}
	)
end
mod.s.AntiLagPresentationInfoAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAntiLagPresentationInfoAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stage = t.stage and mod.e.VkAntiLagStageAMD(t.stage),
			frameIndex = t.frameIndex,
		}
	)
end
mod.s.FenceGetFdInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFenceGetFdInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fence = t.fence,
			handleType = t.handleType and mod.e.VkExternalFenceHandleTypeFlagBits(t.handleType),
		}
	)
end
mod.s.AntiLagDataAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAntiLagDataAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			mode = t.mode and mod.e.VkAntiLagModeAMD(t.mode),
			maxFPS = t.maxFPS,
			pPresentationInfo = t.pPresentationInfo,
		}
	)
end
mod.s.PhysicalDeviceShaderObjectFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderObjectFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderObject = t.shaderObject,
		}
	)
end
mod.s.PipelineLibraryCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineLibraryCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			libraryCount = t.libraryCount,
			pLibraries = t.pLibraries,
		}
	)
end
mod.s.PhysicalDeviceShaderObjectPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderObjectPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderBinaryUUID = t.shaderBinaryUUID,
			shaderBinaryVersion = t.shaderBinaryVersion,
		}
	)
end
mod.s.ShaderCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkShaderCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			stage = t.stage and mod.e.VkShaderStageFlagBits(t.stage),
			nextStage = t.nextStage and mod.e.VkShaderStageFlagBits(t.nextStage),
			codeType = t.codeType and mod.e.VkShaderCodeTypeEXT(t.codeType),
			codeSize = t.codeSize,
			pCode = t.pCode,
			pName = t.pName,
			setLayoutCount = t.setLayoutCount,
			pSetLayouts = t.pSetLayouts,
			pushConstantRangeCount = t.pushConstantRangeCount,
			pPushConstantRanges = t.pPushConstantRanges,
			pSpecializationInfo = t.pSpecializationInfo,
		}
	)
end
mod.s.PresentIdKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPresentIdKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchainCount = t.swapchainCount,
			pPresentIds = t.pPresentIds,
		}
	)
end
mod.s.PhysicalDevicePresentIdFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePresentIdFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentId = t.presentId,
		}
	)
end
mod.s.PhysicalDevicePerformanceQueryFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePerformanceQueryFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			performanceCounterQueryPools = t.performanceCounterQueryPools,
			performanceCounterMultipleQueryPools = t.performanceCounterMultipleQueryPools,
		}
	)
end
mod.s.PhysicalDevicePerformanceQueryPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePerformanceQueryPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			allowCommandBufferQueryCopies = t.allowCommandBufferQueryCopies,
		}
	)
end
mod.s.PhysicalDeviceTilePropertiesFeaturesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTilePropertiesFeaturesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tileProperties = t.tileProperties,
		}
	)
end
mod.s.PerformanceCounterKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPerformanceCounterKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			unit = t.unit and mod.e.VkPerformanceCounterUnitKHR(t.unit),
			scope = t.scope and mod.e.VkPerformanceCounterScopeKHR(t.scope),
			storage = t.storage and mod.e.VkPerformanceCounterStorageKHR(t.storage),
			uuid = t.uuid,
		}
	)
end
mod.s.TilePropertiesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTilePropertiesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tileSize = t.tileSize,
			apronSize = t.apronSize,
			origin = t.origin,
		}
	)
end
mod.s.PerformanceCounterDescriptionKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPerformanceCounterDescriptionKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			name = t.name,
			category = t.category,
			description = t.description,
		}
	)
end
mod.s.QueryPoolPerformanceCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueryPoolPerformanceCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			queueFamilyIndex = t.queueFamilyIndex,
			counterIndexCount = t.counterIndexCount,
			pCounterIndices = t.pCounterIndices,
		}
	)
end
mod.s.StdVideoH265ProfileTierLevel = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoH265ProfileTierLevel(
		{
			flags = t.flags,
			general_profile_idc = t.general_profile_idc and mod.e.StdVideoH265ProfileIdc(t.general_profile_idc),
			general_level_idc = t.general_level_idc and mod.e.StdVideoH265LevelIdc(t.general_level_idc),
		}
	)
end
mod.s.PhysicalDeviceAmigoProfilingFeaturesSEC = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceAmigoProfilingFeaturesSEC(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			amigoProfiling = t.amigoProfiling,
		}
	)
end
mod.s.PerformanceQuerySubmitInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPerformanceQuerySubmitInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			counterPassIndex = t.counterPassIndex,
		}
	)
end
mod.s.AmigoProfilingSubmitInfoSEC = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAmigoProfilingSubmitInfoSEC(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			firstDrawTimestamp = t.firstDrawTimestamp,
			swapBufferTimestamp = t.swapBufferTimestamp,
		}
	)
end
mod.s.PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			multiviewPerViewViewports = t.multiviewPerViewViewports,
		}
	)
end
mod.s.PhysicalDeviceRayTracingInvocationReorderPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rayTracingInvocationReorderReorderingHint = t.rayTracingInvocationReorderReorderingHint and
				mod.e.VkRayTracingInvocationReorderModeNV(t.rayTracingInvocationReorderReorderingHint),
		}
	)
end
mod.s.PhysicalDeviceRayTracingInvocationReorderFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rayTracingInvocationReorder = t.rayTracingInvocationReorder,
		}
	)
end
mod.s.StdVideoH265SequenceParameterSetVui = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoH265SequenceParameterSetVui(
		{
			flags = t.flags,
			aspect_ratio_idc = t.aspect_ratio_idc and mod.e.StdVideoH265AspectRatioIdc(t.aspect_ratio_idc),
			sar_width = t.sar_width,
			sar_height = t.sar_height,
			video_format = t.video_format,
			colour_primaries = t.colour_primaries,
			transfer_characteristics = t.transfer_characteristics,
			matrix_coeffs = t.matrix_coeffs,
			chroma_sample_loc_type_top_field = t.chroma_sample_loc_type_top_field,
			chroma_sample_loc_type_bottom_field = t.chroma_sample_loc_type_bottom_field,
			reserved1 = t.reserved1,
			reserved2 = t.reserved2,
			def_disp_win_left_offset = t.def_disp_win_left_offset,
			def_disp_win_right_offset = t.def_disp_win_right_offset,
			def_disp_win_top_offset = t.def_disp_win_top_offset,
			def_disp_win_bottom_offset = t.def_disp_win_bottom_offset,
			vui_num_units_in_tick = t.vui_num_units_in_tick,
			vui_time_scale = t.vui_time_scale,
			vui_num_ticks_poc_diff_one_minus1 = t.vui_num_ticks_poc_diff_one_minus1,
			min_spatial_segmentation_idc = t.min_spatial_segmentation_idc,
			reserved3 = t.reserved3,
			max_bytes_per_pic_denom = t.max_bytes_per_pic_denom,
			max_bits_per_min_cu_denom = t.max_bits_per_min_cu_denom,
			log2_max_mv_length_horizontal = t.log2_max_mv_length_horizontal,
			log2_max_mv_length_vertical = t.log2_max_mv_length_vertical,
			pHrdParameters = t.pHrdParameters,
		}
	)
end
mod.s.CooperativeMatrixPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCooperativeMatrixPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			MSize = t.MSize,
			NSize = t.NSize,
			KSize = t.KSize,
			AType = t.AType and mod.e.VkComponentTypeKHR(t.AType),
			BType = t.BType and mod.e.VkComponentTypeKHR(t.BType),
			CType = t.CType and mod.e.VkComponentTypeKHR(t.CType),
			ResultType = t.ResultType and mod.e.VkComponentTypeKHR(t.ResultType),
			saturatingAccumulation = t.saturatingAccumulation,
			scope = t.scope and mod.e.VkScopeKHR(t.scope),
		}
	)
end
mod.s.PhysicalDeviceFragmentShaderBarycentricPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			triStripVertexOrderIndependentOfProvokingVertex = t.triStripVertexOrderIndependentOfProvokingVertex,
		}
	)
end
mod.s.PhysicalDeviceCooperativeVectorPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCooperativeVectorPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cooperativeVectorSupportedStages = t.cooperativeVectorSupportedStages and
				mod.e.VkShaderStageFlagBits(t.cooperativeVectorSupportedStages),
			cooperativeVectorTrainingFloat16Accumulation = t.cooperativeVectorTrainingFloat16Accumulation,
			cooperativeVectorTrainingFloat32Accumulation = t.cooperativeVectorTrainingFloat32Accumulation,
			maxCooperativeVectorComponents = t.maxCooperativeVectorComponents,
		}
	)
end
mod.s.PhysicalDeviceSurfaceInfo2KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSurfaceInfo2KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			surface = t.surface,
		}
	)
end
mod.s.SurfaceCapabilities2KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfaceCapabilities2KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			surfaceCapabilities = t.surfaceCapabilities,
		}
	)
end
mod.s.PhysicalDeviceCooperativeVectorFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCooperativeVectorFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cooperativeVector = t.cooperativeVector,
			cooperativeVectorTraining = t.cooperativeVectorTraining,
		}
	)
end
mod.s.SurfaceFormat2KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfaceFormat2KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			surfaceFormat = t.surfaceFormat,
		}
	)
end
mod.s.PhysicalDeviceCooperativeMatrixFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCooperativeMatrixFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cooperativeMatrix = t.cooperativeMatrix,
			cooperativeMatrixRobustBufferAccess = t.cooperativeMatrixRobustBufferAccess,
		}
	)
end
mod.s.CooperativeVectorPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCooperativeVectorPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			inputType = t.inputType and mod.e.VkComponentTypeKHR(t.inputType),
			inputInterpretation = t.inputInterpretation and mod.e.VkComponentTypeKHR(t.inputInterpretation),
			matrixInterpretation = t.matrixInterpretation and mod.e.VkComponentTypeKHR(t.matrixInterpretation),
			biasInterpretation = t.biasInterpretation and mod.e.VkComponentTypeKHR(t.biasInterpretation),
			resultType = t.resultType and mod.e.VkComponentTypeKHR(t.resultType),
			transpose = t.transpose,
		}
	)
end
mod.s.PhysicalDeviceCooperativeMatrixPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCooperativeMatrixPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cooperativeMatrixSupportedStages = t.cooperativeMatrixSupportedStages and
				mod.e.VkShaderStageFlagBits(t.cooperativeMatrixSupportedStages),
		}
	)
end
mod.s.PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			workgroupMemoryExplicitLayout = t.workgroupMemoryExplicitLayout,
			workgroupMemoryExplicitLayoutScalarBlockLayout = t.workgroupMemoryExplicitLayoutScalarBlockLayout,
			workgroupMemoryExplicitLayout8BitAccess = t.workgroupMemoryExplicitLayout8BitAccess,
			workgroupMemoryExplicitLayout16BitAccess = t.workgroupMemoryExplicitLayout16BitAccess,
		}
	)
end
mod.s.ConvertCooperativeVectorMatrixInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkConvertCooperativeVectorMatrixInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcSize = t.srcSize,
			srcData = t.srcData,
			pDstSize = t.pDstSize,
			dstData = t.dstData,
			srcComponentType = t.srcComponentType and mod.e.VkComponentTypeKHR(t.srcComponentType),
			dstComponentType = t.dstComponentType and mod.e.VkComponentTypeKHR(t.dstComponentType),
			numRows = t.numRows,
			numColumns = t.numColumns,
			srcLayout = t.srcLayout and mod.e.VkCooperativeVectorMatrixLayoutNV(t.srcLayout),
			srcStride = t.srcStride,
			dstLayout = t.dstLayout and mod.e.VkCooperativeVectorMatrixLayoutNV(t.dstLayout),
			dstStride = t.dstStride,
		}
	)
end
mod.s.PhysicalDeviceComputeShaderDerivativesFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			computeDerivativeGroupQuads = t.computeDerivativeGroupQuads,
			computeDerivativeGroupLinear = t.computeDerivativeGroupLinear,
		}
	)
end
mod.s.PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			perViewPositionAllComponents = t.perViewPositionAllComponents,
		}
	)
end
mod.s.PhysicalDeviceComputeShaderDerivativesPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			meshAndTaskShaderDerivatives = t.meshAndTaskShaderDerivatives,
		}
	)
end
mod.s.DisplayProperties2KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplayProperties2KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			displayProperties = t.displayProperties,
		}
	)
end
mod.s.DisplayPlaneProperties2KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplayPlaneProperties2KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			displayPlaneProperties = t.displayPlaneProperties,
		}
	)
end
mod.s.SurfaceCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfaceCapabilitiesKHR(
		{
			minImageCount = t.minImageCount,
			maxImageCount = t.maxImageCount,
			currentExtent = t.currentExtent,
			minImageExtent = t.minImageExtent,
			maxImageExtent = t.maxImageExtent,
			maxImageArrayLayers = t.maxImageArrayLayers,
			supportedTransforms = t.supportedTransforms,
			currentTransform = t.currentTransform and mod.e.VkSurfaceTransformFlagBitsKHR(t.currentTransform),
			supportedCompositeAlpha = t.supportedCompositeAlpha,
			supportedUsageFlags = t.supportedUsageFlags and mod.e.VkImageUsageFlagBits(t.supportedUsageFlags),
		}
	)
end
mod.s.DisplayModeProperties2KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplayModeProperties2KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			displayModeProperties = t.displayModeProperties,
		}
	)
end
mod.s.PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fragmentDensityOffsetGranularity = t.fragmentDensityOffsetGranularity,
		}
	)
end
mod.s.SurfaceFormatKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfaceFormatKHR(
		{
			format = t.format and mod.e.VkFormat(t.format),
			colorSpace = t.colorSpace and mod.e.VkColorSpaceKHR(t.colorSpace),
		}
	)
end
mod.s.RenderPassFragmentDensityMapOffsetEndInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassFragmentDensityMapOffsetEndInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fragmentDensityOffsetCount = t.fragmentDensityOffsetCount,
			pFragmentDensityOffsets = t.pFragmentDensityOffsets,
		}
	)
end
mod.s.PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			extendedSparseAddressSpace = t.extendedSparseAddressSpace,
		}
	)
end
mod.s.ViewportSwizzleNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkViewportSwizzleNV(
		{
			x = t.x and mod.e.VkViewportCoordinateSwizzleNV(t.x),
			y = t.y and mod.e.VkViewportCoordinateSwizzleNV(t.y),
			z = t.z and mod.e.VkViewportCoordinateSwizzleNV(t.z),
			w = t.w and mod.e.VkViewportCoordinateSwizzleNV(t.w),
		}
	)
end
mod.s.PhysicalDeviceExtendedSparseAddressSpacePropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			extendedSparseAddressSpaceSize = t.extendedSparseAddressSpaceSize,
			extendedSparseImageUsageFlags = t.extendedSparseImageUsageFlags and
				mod.e.VkImageUsageFlagBits(t.extendedSparseImageUsageFlags),
			extendedSparseBufferUsageFlags = t.extendedSparseBufferUsageFlags and
				mod.e.VkBufferUsageFlagBits(t.extendedSparseBufferUsageFlags),
		}
	)
end
mod.s.PhysicalDeviceCopyMemoryIndirectFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			indirectCopy = t.indirectCopy,
		}
	)
end
mod.s.PhysicalDeviceDiscardRectanglePropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDiscardRectanglePropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxDiscardRectangles = t.maxDiscardRectangles,
		}
	)
end
mod.s.PipelineDiscardRectangleStateCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineDiscardRectangleStateCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			discardRectangleMode = t.discardRectangleMode and
				mod.e.VkDiscardRectangleModeEXT(t.discardRectangleMode),
			discardRectangleCount = t.discardRectangleCount,
			pDiscardRectangles = t.pDiscardRectangles,
		}
	)
end
mod.s.PhysicalDeviceRayTracingMaintenance1FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rayTracingMaintenance1 = t.rayTracingMaintenance1,
			rayTracingPipelineTraceRaysIndirect2 = t.rayTracingPipelineTraceRaysIndirect2,
		}
	)
end
mod.s.PhysicalDeviceMemoryDecompressionFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMemoryDecompressionFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memoryDecompression = t.memoryDecompression,
		}
	)
end
mod.s.PhysicalDeviceMemoryDecompressionPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMemoryDecompressionPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			decompressionMethods = t.decompressionMethods,
			maxDecompressionIndirectCount = t.maxDecompressionIndirectCount,
		}
	)
end
mod.s.PhysicalDeviceConservativeRasterizationPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			primitiveOverestimationSize = t.primitiveOverestimationSize,
			maxExtraPrimitiveOverestimationSize = t.maxExtraPrimitiveOverestimationSize,
			extraPrimitiveOverestimationSizeGranularity = t.extraPrimitiveOverestimationSizeGranularity,
			primitiveUnderestimation = t.primitiveUnderestimation,
			conservativePointAndLineRasterization = t.conservativePointAndLineRasterization,
			degenerateTrianglesRasterized = t.degenerateTrianglesRasterized,
			degenerateLinesRasterized = t.degenerateLinesRasterized,
			fullyCoveredFragmentShaderInputVariable = t.fullyCoveredFragmentShaderInputVariable,
			conservativeRasterizationPostDepthCoverage = t.conservativeRasterizationPostDepthCoverage,
		}
	)
end
mod.s.PhysicalDeviceShaderUntypedPointersFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderUntypedPointers = t.shaderUntypedPointers,
		}
	)
end
mod.s.SwapchainCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSwapchainCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			surface = t.surface,
			minImageCount = t.minImageCount,
			imageFormat = t.imageFormat and mod.e.VkFormat(t.imageFormat),
			imageColorSpace = t.imageColorSpace and mod.e.VkColorSpaceKHR(t.imageColorSpace),
			imageExtent = t.imageExtent,
			imageArrayLayers = t.imageArrayLayers,
			imageUsage = t.imageUsage and mod.e.VkImageUsageFlagBits(t.imageUsage),
			imageSharingMode = t.imageSharingMode and mod.e.VkSharingMode(t.imageSharingMode),
			queueFamilyIndexCount = t.queueFamilyIndexCount,
			pQueueFamilyIndices = t.pQueueFamilyIndices,
			preTransform = t.preTransform and mod.e.VkSurfaceTransformFlagBitsKHR(t.preTransform),
			compositeAlpha = t.compositeAlpha and mod.e.VkCompositeAlphaFlagBitsKHR(t.compositeAlpha),
			presentMode = t.presentMode and mod.e.VkPresentModeKHR(t.presentMode),
			clipped = t.clipped,
			oldSwapchain = t.oldSwapchain,
		}
	)
end
mod.s.PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceGeneratedCompute = t.deviceGeneratedCompute,
			deviceGeneratedComputePipelines = t.deviceGeneratedComputePipelines,
			deviceGeneratedComputeCaptureReplay = t.deviceGeneratedComputeCaptureReplay,
		}
	)
end
mod.s.PipelineRasterizationConservativeStateCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineRasterizationConservativeStateCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			conservativeRasterizationMode = t.conservativeRasterizationMode and
				mod.e.VkConservativeRasterizationModeEXT(t.conservativeRasterizationMode),
			extraPrimitiveOverestimationSize = t.extraPrimitiveOverestimationSize,
		}
	)
end
mod.s.ComputePipelineIndirectBufferInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkComputePipelineIndirectBufferInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceAddress = t.deviceAddress,
			size = t.size,
			pipelineDeviceAddressCaptureReplay = t.pipelineDeviceAddressCaptureReplay,
		}
	)
end
mod.s.PipelineIndirectDeviceAddressInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineIndirectDeviceAddressInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineBindPoint = t.pipelineBindPoint and mod.e.VkPipelineBindPoint(t.pipelineBindPoint),
			pipeline = t.pipeline,
		}
	)
end
mod.s.PresentInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPresentInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			waitSemaphoreCount = t.waitSemaphoreCount,
			pWaitSemaphores = t.pWaitSemaphores,
			swapchainCount = t.swapchainCount,
			pSwapchains = t.pSwapchains,
			pImageIndices = t.pImageIndices,
			pResults = t.pResults,
		}
	)
end
mod.s.PhysicalDeviceDepthClipEnableFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDepthClipEnableFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			depthClipEnable = t.depthClipEnable,
		}
	)
end
mod.s.ImageSwapchainCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageSwapchainCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchain = t.swapchain,
		}
	)
end
mod.s.PipelineRasterizationDepthClipStateCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineRasterizationDepthClipStateCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			depthClipEnable = t.depthClipEnable,
		}
	)
end
mod.s.BindImageMemorySwapchainInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindImageMemorySwapchainInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchain = t.swapchain,
			imageIndex = t.imageIndex,
		}
	)
end
mod.s.AcquireNextImageInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAcquireNextImageInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchain = t.swapchain,
			timeout = t.timeout,
			semaphore = t.semaphore,
			fence = t.fence,
			deviceMask = t.deviceMask,
		}
	)
end
mod.s.DeviceGroupPresentCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceGroupPresentCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentMask = t.presentMask,
			modes = t.modes,
		}
	)
end
mod.s.DeviceGroupPresentInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceGroupPresentInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchainCount = t.swapchainCount,
			pDeviceMasks = t.pDeviceMasks,
			mode = t.mode and mod.e.VkDeviceGroupPresentModeFlagBitsKHR(t.mode),
		}
	)
end
mod.s.PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderMaximalReconvergence = t.shaderMaximalReconvergence,
		}
	)
end
mod.s.DeviceGroupSwapchainCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceGroupSwapchainCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			modes = t.modes,
		}
	)
end
mod.s.PhysicalDeviceShaderClockFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderClockFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderSubgroupClock = t.shaderSubgroupClock,
			shaderDeviceClock = t.shaderDeviceClock,
		}
	)
end
mod.s.PhysicalDeviceRelaxedLineRasterizationFeaturesIMG = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			relaxedLineRasterization = t.relaxedLineRasterization,
		}
	)
end
mod.s.StdVideoVP9ColorConfig = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoVP9ColorConfig(
		{
			flags = t.flags,
			BitDepth = t.BitDepth,
			subsampling_x = t.subsampling_x,
			subsampling_y = t.subsampling_y,
			reserved1 = t.reserved1,
			color_space = t.color_space and mod.e.StdVideoVP9ColorSpace(t.color_space),
		}
	)
end
mod.s.BaseInStructure = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBaseInStructure({
		sType = t.sType and mod.e.VkStructureType(t.sType),
		pNext = t.pNext,
	})
end
mod.s.BaseOutStructure = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBaseOutStructure({
		sType = t.sType and mod.e.VkStructureType(t.sType),
		pNext = t.pNext,
	})
end
mod.s.BufferMemoryBarrier = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferMemoryBarrier(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcAccessMask = t.srcAccessMask and mod.e.VkAccessFlagBits(t.srcAccessMask),
			dstAccessMask = t.dstAccessMask and mod.e.VkAccessFlagBits(t.dstAccessMask),
			srcQueueFamilyIndex = t.srcQueueFamilyIndex,
			dstQueueFamilyIndex = t.dstQueueFamilyIndex,
			buffer = t.buffer,
			offset = t.offset,
			size = t.size,
		}
	)
end
mod.s.SurfaceCapabilitiesPresentId2KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfaceCapabilitiesPresentId2KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentId2Supported = t.presentId2Supported,
		}
	)
end
mod.s.PresentId2KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPresentId2KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchainCount = t.swapchainCount,
			pPresentIds = t.pPresentIds,
		}
	)
end
mod.s.PhysicalDevicePresentId2FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePresentId2FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentId2 = t.presentId2,
		}
	)
end
mod.s.SurfaceCapabilitiesPresentWait2KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfaceCapabilitiesPresentWait2KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentWait2Supported = t.presentWait2Supported,
		}
	)
end
mod.s.PhysicalDevicePresentWait2FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePresentWait2FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentWait2 = t.presentWait2,
		}
	)
end
mod.s.VideoDecodeH265ProfileInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH265ProfileInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stdProfileIdc = t.stdProfileIdc and mod.e.StdVideoH265ProfileIdc(t.stdProfileIdc),
		}
	)
end
mod.s.VideoDecodeH265CapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH265CapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxLevelIdc = t.maxLevelIdc and mod.e.StdVideoH265LevelIdc(t.maxLevelIdc),
		}
	)
end
mod.s.VideoDecodeH265SessionParametersAddInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH265SessionParametersAddInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stdVPSCount = t.stdVPSCount,
			pStdVPSs = t.pStdVPSs,
			stdSPSCount = t.stdSPSCount,
			pStdSPSs = t.pStdSPSs,
			stdPPSCount = t.stdPPSCount,
			pStdPPSs = t.pStdPPSs,
		}
	)
end
mod.s.VideoDecodeH265SessionParametersCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH265SessionParametersCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxStdVPSCount = t.maxStdVPSCount,
			maxStdSPSCount = t.maxStdSPSCount,
			maxStdPPSCount = t.maxStdPPSCount,
			pParametersAddInfo = t.pParametersAddInfo,
		}
	)
end
mod.s.VideoDecodeH265PictureInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH265PictureInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdPictureInfo = t.pStdPictureInfo,
			sliceSegmentCount = t.sliceSegmentCount,
			pSliceSegmentOffsets = t.pSliceSegmentOffsets,
		}
	)
end
mod.s.DisplayModeCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplayModeCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			parameters = t.parameters,
		}
	)
end
mod.s.PhysicalDeviceRayTracingPositionFetchFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rayTracingPositionFetch = t.rayTracingPositionFetch,
		}
	)
end
mod.s.ImageMemoryBarrier = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageMemoryBarrier(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcAccessMask = t.srcAccessMask and mod.e.VkAccessFlagBits(t.srcAccessMask),
			dstAccessMask = t.dstAccessMask and mod.e.VkAccessFlagBits(t.dstAccessMask),
			oldLayout = t.oldLayout and mod.e.VkImageLayout(t.oldLayout),
			newLayout = t.newLayout and mod.e.VkImageLayout(t.newLayout),
			srcQueueFamilyIndex = t.srcQueueFamilyIndex,
			dstQueueFamilyIndex = t.dstQueueFamilyIndex,
			image = t.image,
			subresourceRange = t.subresourceRange,
		}
	)
end
mod.s.DebugUtilsObjectNameInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDebugUtilsObjectNameInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			objectType = t.objectType and mod.e.VkObjectType(t.objectType),
			objectHandle = t.objectHandle,
			pObjectName = t.pObjectName,
		}
	)
end
mod.s.DebugUtilsMessengerCallbackDataEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDebugUtilsMessengerCallbackDataEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			pMessageIdName = t.pMessageIdName,
			messageIdNumber = t.messageIdNumber,
			pMessage = t.pMessage,
			queueLabelCount = t.queueLabelCount,
			pQueueLabels = t.pQueueLabels,
			cmdBufLabelCount = t.cmdBufLabelCount,
			pCmdBufLabels = t.pCmdBufLabels,
			objectCount = t.objectCount,
			pObjects = t.pObjects,
		}
	)
end
mod.s.PhysicalDevicePipelineBinaryFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePipelineBinaryFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineBinaries = t.pipelineBinaries,
		}
	)
end
mod.s.MemoryBarrier = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryBarrier(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcAccessMask = t.srcAccessMask and mod.e.VkAccessFlagBits(t.srcAccessMask),
			dstAccessMask = t.dstAccessMask and mod.e.VkAccessFlagBits(t.dstAccessMask),
		}
	)
end
mod.s.PipelineCacheHeaderVersionOne = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineCacheHeaderVersionOne(
		{
			headerSize = t.headerSize,
			headerVersion = t.headerVersion and mod.e.VkPipelineCacheHeaderVersion(t.headerVersion),
			vendorID = t.vendorID,
			deviceID = t.deviceID,
			pipelineCacheUUID = t.pipelineCacheUUID,
		}
	)
end
mod.s.PhysicalDeviceVideoDecodeVP9FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoDecodeVP9 = t.videoDecodeVP9,
		}
	)
end
mod.s.VideoDecodeVP9ProfileInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeVP9ProfileInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stdProfile = t.stdProfile and mod.e.StdVideoVP9Profile(t.stdProfile),
		}
	)
end
mod.s.DevicePipelineBinaryInternalCacheControlKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDevicePipelineBinaryInternalCacheControlKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			disableInternalCache = t.disableInternalCache,
		}
	)
end
mod.s.VideoDecodeVP9PictureInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeVP9PictureInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdPictureInfo = t.pStdPictureInfo,
			referenceNameSlotIndices = t.referenceNameSlotIndices,
			uncompressedHeaderOffset = t.uncompressedHeaderOffset,
			compressedHeaderOffset = t.compressedHeaderOffset,
			tilesOffset = t.tilesOffset,
		}
	)
end
mod.s.PipelineBinaryKeyKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineBinaryKeyKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			keySize = t.keySize,
			key = t.key,
		}
	)
end
mod.s.DebugUtilsObjectTagInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDebugUtilsObjectTagInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			objectType = t.objectType and mod.e.VkObjectType(t.objectType),
			objectHandle = t.objectHandle,
			tagName = t.tagName,
			tagSize = t.tagSize,
			pTag = t.pTag,
		}
	)
end
mod.s.PhysicalDeviceVideoMaintenance1FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVideoMaintenance1FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoMaintenance1 = t.videoMaintenance1,
		}
	)
end
mod.s.PipelineCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineCreateInfoKHR({
		sType = t.sType and mod.e.VkStructureType(t.sType),
		pNext = t.pNext,
	})
end
mod.s.VideoInlineQueryInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoInlineQueryInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			queryPool = t.queryPool,
			firstQuery = t.firstQuery,
			queryCount = t.queryCount,
		}
	)
end
mod.s.PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			graphicsPipelineLibraryFastLinking = t.graphicsPipelineLibraryFastLinking,
			graphicsPipelineLibraryIndependentInterpolationDecoration = t.graphicsPipelineLibraryIndependentInterpolationDecoration,
		}
	)
end
mod.s.PipelineBinaryInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineBinaryInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			binaryCount = t.binaryCount,
			pPipelineBinaries = t.pPipelineBinaries,
		}
	)
end
mod.s.ReleaseCapturedPipelineDataInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkReleaseCapturedPipelineDataInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipeline = t.pipeline,
		}
	)
end
mod.s.PipelineBinaryDataInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineBinaryDataInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineBinary = t.pipelineBinary,
		}
	)
end
mod.s.PipelineBinaryHandlesInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineBinaryHandlesInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineBinaryCount = t.pipelineBinaryCount,
			pPipelineBinaries = t.pPipelineBinaries,
		}
	)
end
mod.s.PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderEarlyAndLateFragmentTests = t.shaderEarlyAndLateFragmentTests,
		}
	)
end
mod.s.PhysicalDeviceUnifiedImageLayoutsFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			unifiedImageLayouts = t.unifiedImageLayouts,
			unifiedImageLayoutsVideo = t.unifiedImageLayoutsVideo,
		}
	)
end
mod.s.ApplicationInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkApplicationInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pApplicationName = t.pApplicationName,
			applicationVersion = t.applicationVersion,
			pEngineName = t.pEngineName,
			engineVersion = t.engineVersion,
			apiVersion = t.apiVersion,
		}
	)
end
mod.s.AttachmentFeedbackLoopInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAttachmentFeedbackLoopInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			feedbackLoopEnable = t.feedbackLoopEnable,
		}
	)
end
mod.s.FormatProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFormatProperties(
		{
			linearTilingFeatures = t.linearTilingFeatures and mod.e.VkFormatFeatureFlagBits(t.linearTilingFeatures),
			optimalTilingFeatures = t.optimalTilingFeatures and
				mod.e.VkFormatFeatureFlagBits(t.optimalTilingFeatures),
			bufferFeatures = t.bufferFeatures and mod.e.VkFormatFeatureFlagBits(t.bufferFeatures),
		}
	)
end
mod.s.StdVideoAV1ColorConfig = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoAV1ColorConfig(
		{
			flags = t.flags,
			BitDepth = t.BitDepth,
			subsampling_x = t.subsampling_x,
			subsampling_y = t.subsampling_y,
			reserved1 = t.reserved1,
			color_primaries = t.color_primaries and mod.e.StdVideoAV1ColorPrimaries(t.color_primaries),
			transfer_characteristics = t.transfer_characteristics and
				mod.e.StdVideoAV1TransferCharacteristics(t.transfer_characteristics),
			matrix_coefficients = t.matrix_coefficients and
				mod.e.StdVideoAV1MatrixCoefficients(t.matrix_coefficients),
			chroma_sample_position = t.chroma_sample_position and
				mod.e.StdVideoAV1ChromaSamplePosition(t.chroma_sample_position),
		}
	)
end
mod.s.ImageFormatProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageFormatProperties(
		{
			maxExtent = t.maxExtent,
			maxMipLevels = t.maxMipLevels,
			maxArrayLayers = t.maxArrayLayers,
			sampleCounts = t.sampleCounts and mod.e.VkSampleCountFlagBits(t.sampleCounts),
			maxResourceSize = t.maxResourceSize,
		}
	)
end
mod.s.ImageFormatListCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageFormatListCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			viewFormatCount = t.viewFormatCount,
			pViewFormats = t.pViewFormats,
		}
	)
end
mod.s.InstanceCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkInstanceCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkInstanceCreateFlagBits(t.flags),
			pApplicationInfo = t.pApplicationInfo,
			enabledLayerCount = t.enabledLayerCount,
			ppEnabledLayerNames = t.ppEnabledLayerNames,
			enabledExtensionCount = t.enabledExtensionCount,
			ppEnabledExtensionNames = t.ppEnabledExtensionNames,
		}
	)
end
mod.s.AttachmentSampleCountInfoAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAttachmentSampleCountInfoAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			colorAttachmentCount = t.colorAttachmentCount,
			pColorAttachmentSamples = t.pColorAttachmentSamples,
			depthStencilAttachmentSamples = t.depthStencilAttachmentSamples and
				mod.e.VkSampleCountFlagBits(t.depthStencilAttachmentSamples),
		}
	)
end
mod.s.AttachmentDescription2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAttachmentDescription2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkAttachmentDescriptionFlagBits(t.flags),
			format = t.format and mod.e.VkFormat(t.format),
			samples = t.samples and mod.e.VkSampleCountFlagBits(t.samples),
			loadOp = t.loadOp and mod.e.VkAttachmentLoadOp(t.loadOp),
			storeOp = t.storeOp and mod.e.VkAttachmentStoreOp(t.storeOp),
			stencilLoadOp = t.stencilLoadOp and mod.e.VkAttachmentLoadOp(t.stencilLoadOp),
			stencilStoreOp = t.stencilStoreOp and mod.e.VkAttachmentStoreOp(t.stencilStoreOp),
			initialLayout = t.initialLayout and mod.e.VkImageLayout(t.initialLayout),
			finalLayout = t.finalLayout and mod.e.VkImageLayout(t.finalLayout),
		}
	)
end
mod.s.AttachmentReference2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAttachmentReference2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			attachment = t.attachment,
			layout = t.layout and mod.e.VkImageLayout(t.layout),
			aspectMask = t.aspectMask and mod.e.VkImageAspectFlagBits(t.aspectMask),
		}
	)
end
mod.s.SubpassDescription2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubpassDescription2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkSubpassDescriptionFlagBits(t.flags),
			pipelineBindPoint = t.pipelineBindPoint and mod.e.VkPipelineBindPoint(t.pipelineBindPoint),
			viewMask = t.viewMask,
			inputAttachmentCount = t.inputAttachmentCount,
			pInputAttachments = t.pInputAttachments,
			colorAttachmentCount = t.colorAttachmentCount,
			pColorAttachments = t.pColorAttachments,
			pResolveAttachments = t.pResolveAttachments,
			pDepthStencilAttachment = t.pDepthStencilAttachment,
			preserveAttachmentCount = t.preserveAttachmentCount,
			pPreserveAttachments = t.pPreserveAttachments,
		}
	)
end
mod.s.SubpassDependency2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubpassDependency2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcSubpass = t.srcSubpass,
			dstSubpass = t.dstSubpass,
			srcStageMask = t.srcStageMask and mod.e.VkPipelineStageFlagBits(t.srcStageMask),
			dstStageMask = t.dstStageMask and mod.e.VkPipelineStageFlagBits(t.dstStageMask),
			srcAccessMask = t.srcAccessMask and mod.e.VkAccessFlagBits(t.srcAccessMask),
			dstAccessMask = t.dstAccessMask and mod.e.VkAccessFlagBits(t.dstAccessMask),
			dependencyFlags = t.dependencyFlags and mod.e.VkDependencyFlagBits(t.dependencyFlags),
			viewOffset = t.viewOffset,
		}
	)
end
mod.s.RenderPassCreateInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassCreateInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkRenderPassCreateFlagBits(t.flags),
			attachmentCount = t.attachmentCount,
			pAttachments = t.pAttachments,
			subpassCount = t.subpassCount,
			pSubpasses = t.pSubpasses,
			dependencyCount = t.dependencyCount,
			pDependencies = t.pDependencies,
			correlatedViewMaskCount = t.correlatedViewMaskCount,
			pCorrelatedViewMasks = t.pCorrelatedViewMasks,
		}
	)
end
mod.s.MemoryType = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryType(
		{
			propertyFlags = t.propertyFlags and mod.e.VkMemoryPropertyFlagBits(t.propertyFlags),
			heapIndex = t.heapIndex,
		}
	)
end
mod.s.SubpassBeginInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubpassBeginInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			contents = t.contents and mod.e.VkSubpassContents(t.contents),
		}
	)
end
mod.s.FragmentShadingRateAttachmentInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFragmentShadingRateAttachmentInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pFragmentShadingRateAttachment = t.pFragmentShadingRateAttachment,
			shadingRateAttachmentTexelSize = t.shadingRateAttachmentTexelSize,
		}
	)
end
mod.s.StdVideoEncodeH265PictureInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoEncodeH265PictureInfo(
		{
			flags = t.flags,
			pic_type = t.pic_type and mod.e.StdVideoH265PictureType(t.pic_type),
			sps_video_parameter_set_id = t.sps_video_parameter_set_id,
			pps_seq_parameter_set_id = t.pps_seq_parameter_set_id,
			pps_pic_parameter_set_id = t.pps_pic_parameter_set_id,
			short_term_ref_pic_set_idx = t.short_term_ref_pic_set_idx,
			PicOrderCntVal = t.PicOrderCntVal,
			TemporalId = t.TemporalId,
			reserved1 = t.reserved1,
			pRefLists = t.pRefLists,
			pShortTermRefPicSet = t.pShortTermRefPicSet,
			pLongTermRefPics = t.pLongTermRefPics,
		}
	)
end
mod.s.PhysicalDeviceDriverProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDriverProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			driverID = t.driverID and mod.e.VkDriverId(t.driverID),
			driverName = t.driverName,
			driverInfo = t.driverInfo,
			conformanceVersion = t.conformanceVersion,
		}
	)
end
mod.s.PipelineFragmentShadingRateStateCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineFragmentShadingRateStateCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fragmentSize = t.fragmentSize,
			combinerOps = t.combinerOps and mod.e.VkFragmentShadingRateCombinerOpKHR(t.combinerOps),
		}
	)
end
mod.s.PhysicalDeviceShaderFloat16Int8Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderFloat16Int8Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderFloat16 = t.shaderFloat16,
			shaderInt8 = t.shaderInt8,
		}
	)
end
mod.s.PhysicalDeviceFloatControlsProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFloatControlsProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			denormBehaviorIndependence = t.denormBehaviorIndependence and
				mod.e.VkShaderFloatControlsIndependence(t.denormBehaviorIndependence),
			roundingModeIndependence = t.roundingModeIndependence and
				mod.e.VkShaderFloatControlsIndependence(t.roundingModeIndependence),
			shaderSignedZeroInfNanPreserveFloat16 = t.shaderSignedZeroInfNanPreserveFloat16,
			shaderSignedZeroInfNanPreserveFloat32 = t.shaderSignedZeroInfNanPreserveFloat32,
			shaderSignedZeroInfNanPreserveFloat64 = t.shaderSignedZeroInfNanPreserveFloat64,
			shaderDenormPreserveFloat16 = t.shaderDenormPreserveFloat16,
			shaderDenormPreserveFloat32 = t.shaderDenormPreserveFloat32,
			shaderDenormPreserveFloat64 = t.shaderDenormPreserveFloat64,
			shaderDenormFlushToZeroFloat16 = t.shaderDenormFlushToZeroFloat16,
			shaderDenormFlushToZeroFloat32 = t.shaderDenormFlushToZeroFloat32,
			shaderDenormFlushToZeroFloat64 = t.shaderDenormFlushToZeroFloat64,
			shaderRoundingModeRTEFloat16 = t.shaderRoundingModeRTEFloat16,
			shaderRoundingModeRTEFloat32 = t.shaderRoundingModeRTEFloat32,
			shaderRoundingModeRTEFloat64 = t.shaderRoundingModeRTEFloat64,
			shaderRoundingModeRTZFloat16 = t.shaderRoundingModeRTZFloat16,
			shaderRoundingModeRTZFloat32 = t.shaderRoundingModeRTZFloat32,
			shaderRoundingModeRTZFloat64 = t.shaderRoundingModeRTZFloat64,
		}
	)
end
mod.s.DescriptorSetLayoutBindingFlagsCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorSetLayoutBindingFlagsCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			bindingCount = t.bindingCount,
			pBindingFlags = t.pBindingFlags,
		}
	)
end
mod.s.SurfacePresentModeCompatibilityKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfacePresentModeCompatibilityKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentModeCount = t.presentModeCount,
			pPresentModes = t.pPresentModes,
		}
	)
end
mod.s.PhysicalDeviceDescriptorIndexingProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDescriptorIndexingProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxUpdateAfterBindDescriptorsInAllPools = t.maxUpdateAfterBindDescriptorsInAllPools,
			shaderUniformBufferArrayNonUniformIndexingNative = t.shaderUniformBufferArrayNonUniformIndexingNative,
			shaderSampledImageArrayNonUniformIndexingNative = t.shaderSampledImageArrayNonUniformIndexingNative,
			shaderStorageBufferArrayNonUniformIndexingNative = t.shaderStorageBufferArrayNonUniformIndexingNative,
			shaderStorageImageArrayNonUniformIndexingNative = t.shaderStorageImageArrayNonUniformIndexingNative,
			shaderInputAttachmentArrayNonUniformIndexingNative = t.shaderInputAttachmentArrayNonUniformIndexingNative,
			robustBufferAccessUpdateAfterBind = t.robustBufferAccessUpdateAfterBind,
			quadDivergentImplicitLod = t.quadDivergentImplicitLod,
			maxPerStageDescriptorUpdateAfterBindSamplers = t.maxPerStageDescriptorUpdateAfterBindSamplers,
			maxPerStageDescriptorUpdateAfterBindUniformBuffers = t.maxPerStageDescriptorUpdateAfterBindUniformBuffers,
			maxPerStageDescriptorUpdateAfterBindStorageBuffers = t.maxPerStageDescriptorUpdateAfterBindStorageBuffers,
			maxPerStageDescriptorUpdateAfterBindSampledImages = t.maxPerStageDescriptorUpdateAfterBindSampledImages,
			maxPerStageDescriptorUpdateAfterBindStorageImages = t.maxPerStageDescriptorUpdateAfterBindStorageImages,
			maxPerStageDescriptorUpdateAfterBindInputAttachments = t.maxPerStageDescriptorUpdateAfterBindInputAttachments,
			maxPerStageUpdateAfterBindResources = t.maxPerStageUpdateAfterBindResources,
			maxDescriptorSetUpdateAfterBindSamplers = t.maxDescriptorSetUpdateAfterBindSamplers,
			maxDescriptorSetUpdateAfterBindUniformBuffers = t.maxDescriptorSetUpdateAfterBindUniformBuffers,
			maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = t.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic,
			maxDescriptorSetUpdateAfterBindStorageBuffers = t.maxDescriptorSetUpdateAfterBindStorageBuffers,
			maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = t.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic,
			maxDescriptorSetUpdateAfterBindSampledImages = t.maxDescriptorSetUpdateAfterBindSampledImages,
			maxDescriptorSetUpdateAfterBindStorageImages = t.maxDescriptorSetUpdateAfterBindStorageImages,
			maxDescriptorSetUpdateAfterBindInputAttachments = t.maxDescriptorSetUpdateAfterBindInputAttachments,
		}
	)
end
mod.s.PhysicalDeviceFragmentShadingRatePropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minFragmentShadingRateAttachmentTexelSize = t.minFragmentShadingRateAttachmentTexelSize,
			maxFragmentShadingRateAttachmentTexelSize = t.maxFragmentShadingRateAttachmentTexelSize,
			maxFragmentShadingRateAttachmentTexelSizeAspectRatio = t.maxFragmentShadingRateAttachmentTexelSizeAspectRatio,
			primitiveFragmentShadingRateWithMultipleViewports = t.primitiveFragmentShadingRateWithMultipleViewports,
			layeredShadingRateAttachments = t.layeredShadingRateAttachments,
			fragmentShadingRateNonTrivialCombinerOps = t.fragmentShadingRateNonTrivialCombinerOps,
			maxFragmentSize = t.maxFragmentSize,
			maxFragmentSizeAspectRatio = t.maxFragmentSizeAspectRatio,
			maxFragmentShadingRateCoverageSamples = t.maxFragmentShadingRateCoverageSamples,
			maxFragmentShadingRateRasterizationSamples = t.maxFragmentShadingRateRasterizationSamples and
				mod.e.VkSampleCountFlagBits(t.maxFragmentShadingRateRasterizationSamples),
			fragmentShadingRateWithShaderDepthStencilWrites = t.fragmentShadingRateWithShaderDepthStencilWrites,
			fragmentShadingRateWithSampleMask = t.fragmentShadingRateWithSampleMask,
			fragmentShadingRateWithShaderSampleMask = t.fragmentShadingRateWithShaderSampleMask,
			fragmentShadingRateWithConservativeRasterization = t.fragmentShadingRateWithConservativeRasterization,
			fragmentShadingRateWithFragmentShaderInterlock = t.fragmentShadingRateWithFragmentShaderInterlock,
			fragmentShadingRateWithCustomSampleLocations = t.fragmentShadingRateWithCustomSampleLocations,
			fragmentShadingRateStrictMultiplyCombiner = t.fragmentShadingRateStrictMultiplyCombiner,
		}
	)
end
mod.s.PhysicalDeviceMaintenance6Properties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance6Properties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			blockTexelViewCompatibleMultipleLayers = t.blockTexelViewCompatibleMultipleLayers,
			maxCombinedImageSamplerDescriptorCount = t.maxCombinedImageSamplerDescriptorCount,
			fragmentShadingRateClampCombinerInputs = t.fragmentShadingRateClampCombinerInputs,
		}
	)
end
mod.s.BindMemoryStatus = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindMemoryStatus(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pResult = t.pResult,
		}
	)
end
mod.s.PhysicalDeviceSwapchainMaintenance1FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchainMaintenance1 = t.swapchainMaintenance1,
		}
	)
end
mod.s.SubpassDescriptionDepthStencilResolve = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubpassDescriptionDepthStencilResolve(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			depthResolveMode = t.depthResolveMode and mod.e.VkResolveModeFlagBits(t.depthResolveMode),
			stencilResolveMode = t.stencilResolveMode and mod.e.VkResolveModeFlagBits(t.stencilResolveMode),
			pDepthStencilResolveAttachment = t.pDepthStencilResolveAttachment,
		}
	)
end
mod.s.PushConstantsInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPushConstantsInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			layout = t.layout,
			stageFlags = t.stageFlags and mod.e.VkShaderStageFlagBits(t.stageFlags),
			offset = t.offset,
			size = t.size,
			pValues = t.pValues,
		}
	)
end
mod.s.PushDescriptorSetInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPushDescriptorSetInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stageFlags = t.stageFlags and mod.e.VkShaderStageFlagBits(t.stageFlags),
			layout = t.layout,
			set = t.set,
			descriptorWriteCount = t.descriptorWriteCount,
			pDescriptorWrites = t.pDescriptorWrites,
		}
	)
end
mod.s.PushDescriptorSetWithTemplateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPushDescriptorSetWithTemplateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			descriptorUpdateTemplate = t.descriptorUpdateTemplate,
			layout = t.layout,
			set = t.set,
			pData = t.pData,
		}
	)
end
mod.s.PhysicalDevicePipelineProtectedAccessFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePipelineProtectedAccessFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineProtectedAccess = t.pipelineProtectedAccess,
		}
	)
end
mod.s.PipelineColorBlendAttachmentState = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineColorBlendAttachmentState(
		{
			blendEnable = t.blendEnable,
			srcColorBlendFactor = t.srcColorBlendFactor and mod.e.VkBlendFactor(t.srcColorBlendFactor),
			dstColorBlendFactor = t.dstColorBlendFactor and mod.e.VkBlendFactor(t.dstColorBlendFactor),
			colorBlendOp = t.colorBlendOp and mod.e.VkBlendOp(t.colorBlendOp),
			srcAlphaBlendFactor = t.srcAlphaBlendFactor and mod.e.VkBlendFactor(t.srcAlphaBlendFactor),
			dstAlphaBlendFactor = t.dstAlphaBlendFactor and mod.e.VkBlendFactor(t.dstAlphaBlendFactor),
			alphaBlendOp = t.alphaBlendOp and mod.e.VkBlendOp(t.alphaBlendOp),
			colorWriteMask = t.colorWriteMask and mod.e.VkColorComponentFlagBits(t.colorWriteMask),
		}
	)
end
mod.s.ImageStencilUsageCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageStencilUsageCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stencilUsage = t.stencilUsage and mod.e.VkImageUsageFlagBits(t.stencilUsage),
		}
	)
end
mod.s.PipelineRobustnessCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineRobustnessCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			storageBuffers = t.storageBuffers and mod.e.VkPipelineRobustnessBufferBehavior(t.storageBuffers),
			uniformBuffers = t.uniformBuffers and mod.e.VkPipelineRobustnessBufferBehavior(t.uniformBuffers),
			vertexInputs = t.vertexInputs and mod.e.VkPipelineRobustnessBufferBehavior(t.vertexInputs),
			images = t.images and mod.e.VkPipelineRobustnessImageBehavior(t.images),
		}
	)
end
mod.s.VideoEncodeQuantizationMapSessionParametersCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			quantizationMapTexelSize = t.quantizationMapTexelSize,
		}
	)
end
mod.s.PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoEncodeQuantizationMap = t.videoEncodeQuantizationMap,
		}
	)
end
mod.s.PhysicalDeviceSamplerFilterMinmaxProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSamplerFilterMinmaxProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			filterMinmaxSingleComponentFormats = t.filterMinmaxSingleComponentFormats,
			filterMinmaxImageComponentMapping = t.filterMinmaxImageComponentMapping,
		}
	)
end
mod.s.VideoEncodeH264QuantizationMapCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264QuantizationMapCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minQpDelta = t.minQpDelta,
			maxQpDelta = t.maxQpDelta,
		}
	)
end
mod.s.PhysicalDeviceImagelessFramebufferFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImagelessFramebufferFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imagelessFramebuffer = t.imagelessFramebuffer,
		}
	)
end
mod.s.PhysicalDeviceHostImageCopyProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceHostImageCopyProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			copySrcLayoutCount = t.copySrcLayoutCount,
			pCopySrcLayouts = t.pCopySrcLayouts,
			copyDstLayoutCount = t.copyDstLayoutCount,
			pCopyDstLayouts = t.pCopyDstLayouts,
			optimalTilingLayoutUUID = t.optimalTilingLayoutUUID,
			identicalMemoryTypeRequirements = t.identicalMemoryTypeRequirements,
		}
	)
end
mod.s.VideoEncodeH265QuantizationMapCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265QuantizationMapCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minQpDelta = t.minQpDelta,
			maxQpDelta = t.maxQpDelta,
		}
	)
end
mod.s.RenderingFragmentShadingRateAttachmentInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderingFragmentShadingRateAttachmentInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageView = t.imageView,
			imageLayout = t.imageLayout and mod.e.VkImageLayout(t.imageLayout),
			shadingRateAttachmentTexelSize = t.shadingRateAttachmentTexelSize,
		}
	)
end
mod.s.VideoEncodeAV1QuantizationMapCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minQIndexDelta = t.minQIndexDelta,
			maxQIndexDelta = t.maxQIndexDelta,
		}
	)
end
mod.s.SetDescriptorBufferOffsetsInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSetDescriptorBufferOffsetsInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stageFlags = t.stageFlags and mod.e.VkShaderStageFlagBits(t.stageFlags),
			layout = t.layout,
			firstSet = t.firstSet,
			setCount = t.setCount,
			pBufferIndices = t.pBufferIndices,
			pOffsets = t.pOffsets,
		}
	)
end
mod.s.CopyMemoryToImageInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyMemoryToImageInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkHostImageCopyFlagBits(t.flags),
			dstImage = t.dstImage,
			dstImageLayout = t.dstImageLayout and mod.e.VkImageLayout(t.dstImageLayout),
			regionCount = t.regionCount,
			pRegions = t.pRegions,
		}
	)
end
mod.s.VideoFormatAV1QuantizationMapPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoFormatAV1QuantizationMapPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			compatibleSuperblockSizes = t.compatibleSuperblockSizes,
		}
	)
end
mod.s.AttachmentReferenceStencilLayout = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAttachmentReferenceStencilLayout(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stencilLayout = t.stencilLayout and mod.e.VkImageLayout(t.stencilLayout),
		}
	)
end
mod.s.HostImageLayoutTransitionInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkHostImageLayoutTransitionInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			image = t.image,
			oldLayout = t.oldLayout and mod.e.VkImageLayout(t.oldLayout),
			newLayout = t.newLayout and mod.e.VkImageLayout(t.newLayout),
			subresourceRange = t.subresourceRange,
		}
	)
end
mod.s.AttachmentDescriptionStencilLayout = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAttachmentDescriptionStencilLayout(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stencilInitialLayout = t.stencilInitialLayout and mod.e.VkImageLayout(t.stencilInitialLayout),
			stencilFinalLayout = t.stencilFinalLayout and mod.e.VkImageLayout(t.stencilFinalLayout),
		}
	)
end
mod.s.HostImageCopyDevicePerformanceQuery = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkHostImageCopyDevicePerformanceQuery(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			optimalDeviceAccess = t.optimalDeviceAccess,
			identicalMemoryLayout = t.identicalMemoryLayout,
		}
	)
end
mod.s.PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderRelaxedExtendedInstruction = t.shaderRelaxedExtendedInstruction,
		}
	)
end
mod.s.PhysicalDeviceHostQueryResetFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceHostQueryResetFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			hostQueryReset = t.hostQueryReset,
		}
	)
end
mod.s.PhysicalDeviceTimelineSemaphoreFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTimelineSemaphoreFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			timelineSemaphore = t.timelineSemaphore,
		}
	)
end
mod.s.PhysicalDeviceTimelineSemaphoreProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTimelineSemaphoreProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxTimelineSemaphoreValueDifference = t.maxTimelineSemaphoreValueDifference,
		}
	)
end
mod.s.SemaphoreTypeCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSemaphoreTypeCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			semaphoreType = t.semaphoreType and mod.e.VkSemaphoreType(t.semaphoreType),
			initialValue = t.initialValue,
		}
	)
end
mod.s.TimelineSemaphoreSubmitInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTimelineSemaphoreSubmitInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			waitSemaphoreValueCount = t.waitSemaphoreValueCount,
			pWaitSemaphoreValues = t.pWaitSemaphoreValues,
			signalSemaphoreValueCount = t.signalSemaphoreValueCount,
			pSignalSemaphoreValues = t.pSignalSemaphoreValues,
		}
	)
end
mod.s.PhysicalDeviceFragmentDensityMap2FeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fragmentDensityMapDeferred = t.fragmentDensityMapDeferred,
		}
	)
end
mod.s.PhysicalDeviceFragmentDensityMap2PropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			subsampledLoads = t.subsampledLoads,
			subsampledCoarseReconstructionEarlyAccess = t.subsampledCoarseReconstructionEarlyAccess,
			maxSubsampledArrayLayers = t.maxSubsampledArrayLayers,
			maxDescriptorSetSubsampledSamplers = t.maxDescriptorSetSubsampledSamplers,
		}
	)
end
mod.s.PhysicalDeviceShaderQuadControlFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderQuadControlFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderQuadControl = t.shaderQuadControl,
		}
	)
end
mod.s.SemaphoreWaitInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSemaphoreWaitInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkSemaphoreWaitFlagBits(t.flags),
			semaphoreCount = t.semaphoreCount,
			pSemaphores = t.pSemaphores,
			pValues = t.pValues,
		}
	)
end
mod.s.PhysicalDeviceMaintenance7PropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance7PropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			robustFragmentShadingRateAttachmentAccess = t.robustFragmentShadingRateAttachmentAccess,
			separateDepthStencilAttachmentAccess = t.separateDepthStencilAttachmentAccess,
			maxDescriptorSetTotalUniformBuffersDynamic = t.maxDescriptorSetTotalUniformBuffersDynamic,
			maxDescriptorSetTotalStorageBuffersDynamic = t.maxDescriptorSetTotalStorageBuffersDynamic,
			maxDescriptorSetTotalBuffersDynamic = t.maxDescriptorSetTotalBuffersDynamic,
			maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic = t.maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic,
			maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic = t.maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic,
			maxDescriptorSetUpdateAfterBindTotalBuffersDynamic = t.maxDescriptorSetUpdateAfterBindTotalBuffersDynamic,
		}
	)
end
mod.s.SemaphoreSignalInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSemaphoreSignalInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			semaphore = t.semaphore,
			value = t.value,
		}
	)
end
mod.s.PhysicalDeviceBufferDeviceAddressFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceBufferDeviceAddressFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			bufferDeviceAddress = t.bufferDeviceAddress,
			bufferDeviceAddressCaptureReplay = t.bufferDeviceAddressCaptureReplay,
			bufferDeviceAddressMultiDevice = t.bufferDeviceAddressMultiDevice,
		}
	)
end
mod.s.PhysicalDeviceLimits = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceLimits(
		{
			maxImageDimension1D = t.maxImageDimension1D,
			maxImageDimension2D = t.maxImageDimension2D,
			maxImageDimension3D = t.maxImageDimension3D,
			maxImageDimensionCube = t.maxImageDimensionCube,
			maxImageArrayLayers = t.maxImageArrayLayers,
			maxTexelBufferElements = t.maxTexelBufferElements,
			maxUniformBufferRange = t.maxUniformBufferRange,
			maxStorageBufferRange = t.maxStorageBufferRange,
			maxPushConstantsSize = t.maxPushConstantsSize,
			maxMemoryAllocationCount = t.maxMemoryAllocationCount,
			maxSamplerAllocationCount = t.maxSamplerAllocationCount,
			bufferImageGranularity = t.bufferImageGranularity,
			sparseAddressSpaceSize = t.sparseAddressSpaceSize,
			maxBoundDescriptorSets = t.maxBoundDescriptorSets,
			maxPerStageDescriptorSamplers = t.maxPerStageDescriptorSamplers,
			maxPerStageDescriptorUniformBuffers = t.maxPerStageDescriptorUniformBuffers,
			maxPerStageDescriptorStorageBuffers = t.maxPerStageDescriptorStorageBuffers,
			maxPerStageDescriptorSampledImages = t.maxPerStageDescriptorSampledImages,
			maxPerStageDescriptorStorageImages = t.maxPerStageDescriptorStorageImages,
			maxPerStageDescriptorInputAttachments = t.maxPerStageDescriptorInputAttachments,
			maxPerStageResources = t.maxPerStageResources,
			maxDescriptorSetSamplers = t.maxDescriptorSetSamplers,
			maxDescriptorSetUniformBuffers = t.maxDescriptorSetUniformBuffers,
			maxDescriptorSetUniformBuffersDynamic = t.maxDescriptorSetUniformBuffersDynamic,
			maxDescriptorSetStorageBuffers = t.maxDescriptorSetStorageBuffers,
			maxDescriptorSetStorageBuffersDynamic = t.maxDescriptorSetStorageBuffersDynamic,
			maxDescriptorSetSampledImages = t.maxDescriptorSetSampledImages,
			maxDescriptorSetStorageImages = t.maxDescriptorSetStorageImages,
			maxDescriptorSetInputAttachments = t.maxDescriptorSetInputAttachments,
			maxVertexInputAttributes = t.maxVertexInputAttributes,
			maxVertexInputBindings = t.maxVertexInputBindings,
			maxVertexInputAttributeOffset = t.maxVertexInputAttributeOffset,
			maxVertexInputBindingStride = t.maxVertexInputBindingStride,
			maxVertexOutputComponents = t.maxVertexOutputComponents,
			maxTessellationGenerationLevel = t.maxTessellationGenerationLevel,
			maxTessellationPatchSize = t.maxTessellationPatchSize,
			maxTessellationControlPerVertexInputComponents = t.maxTessellationControlPerVertexInputComponents,
			maxTessellationControlPerVertexOutputComponents = t.maxTessellationControlPerVertexOutputComponents,
			maxTessellationControlPerPatchOutputComponents = t.maxTessellationControlPerPatchOutputComponents,
			maxTessellationControlTotalOutputComponents = t.maxTessellationControlTotalOutputComponents,
			maxTessellationEvaluationInputComponents = t.maxTessellationEvaluationInputComponents,
			maxTessellationEvaluationOutputComponents = t.maxTessellationEvaluationOutputComponents,
			maxGeometryShaderInvocations = t.maxGeometryShaderInvocations,
			maxGeometryInputComponents = t.maxGeometryInputComponents,
			maxGeometryOutputComponents = t.maxGeometryOutputComponents,
			maxGeometryOutputVertices = t.maxGeometryOutputVertices,
			maxGeometryTotalOutputComponents = t.maxGeometryTotalOutputComponents,
			maxFragmentInputComponents = t.maxFragmentInputComponents,
			maxFragmentOutputAttachments = t.maxFragmentOutputAttachments,
			maxFragmentDualSrcAttachments = t.maxFragmentDualSrcAttachments,
			maxFragmentCombinedOutputResources = t.maxFragmentCombinedOutputResources,
			maxComputeSharedMemorySize = t.maxComputeSharedMemorySize,
			maxComputeWorkGroupCount = t.maxComputeWorkGroupCount,
			maxComputeWorkGroupInvocations = t.maxComputeWorkGroupInvocations,
			maxComputeWorkGroupSize = t.maxComputeWorkGroupSize,
			subPixelPrecisionBits = t.subPixelPrecisionBits,
			subTexelPrecisionBits = t.subTexelPrecisionBits,
			mipmapPrecisionBits = t.mipmapPrecisionBits,
			maxDrawIndexedIndexValue = t.maxDrawIndexedIndexValue,
			maxDrawIndirectCount = t.maxDrawIndirectCount,
			maxSamplerLodBias = t.maxSamplerLodBias,
			maxSamplerAnisotropy = t.maxSamplerAnisotropy,
			maxViewports = t.maxViewports,
			maxViewportDimensions = t.maxViewportDimensions,
			viewportBoundsRange = t.viewportBoundsRange,
			viewportSubPixelBits = t.viewportSubPixelBits,
			minMemoryMapAlignment = t.minMemoryMapAlignment,
			minTexelBufferOffsetAlignment = t.minTexelBufferOffsetAlignment,
			minUniformBufferOffsetAlignment = t.minUniformBufferOffsetAlignment,
			minStorageBufferOffsetAlignment = t.minStorageBufferOffsetAlignment,
			minTexelOffset = t.minTexelOffset,
			maxTexelOffset = t.maxTexelOffset,
			minTexelGatherOffset = t.minTexelGatherOffset,
			maxTexelGatherOffset = t.maxTexelGatherOffset,
			minInterpolationOffset = t.minInterpolationOffset,
			maxInterpolationOffset = t.maxInterpolationOffset,
			subPixelInterpolationOffsetBits = t.subPixelInterpolationOffsetBits,
			maxFramebufferWidth = t.maxFramebufferWidth,
			maxFramebufferHeight = t.maxFramebufferHeight,
			maxFramebufferLayers = t.maxFramebufferLayers,
			framebufferColorSampleCounts = t.framebufferColorSampleCounts and
				mod.e.VkSampleCountFlagBits(t.framebufferColorSampleCounts),
			framebufferDepthSampleCounts = t.framebufferDepthSampleCounts and
				mod.e.VkSampleCountFlagBits(t.framebufferDepthSampleCounts),
			framebufferStencilSampleCounts = t.framebufferStencilSampleCounts and
				mod.e.VkSampleCountFlagBits(t.framebufferStencilSampleCounts),
			framebufferNoAttachmentsSampleCounts = t.framebufferNoAttachmentsSampleCounts and
				mod.e.VkSampleCountFlagBits(t.framebufferNoAttachmentsSampleCounts),
			maxColorAttachments = t.maxColorAttachments,
			sampledImageColorSampleCounts = t.sampledImageColorSampleCounts and
				mod.e.VkSampleCountFlagBits(t.sampledImageColorSampleCounts),
			sampledImageIntegerSampleCounts = t.sampledImageIntegerSampleCounts and
				mod.e.VkSampleCountFlagBits(t.sampledImageIntegerSampleCounts),
			sampledImageDepthSampleCounts = t.sampledImageDepthSampleCounts and
				mod.e.VkSampleCountFlagBits(t.sampledImageDepthSampleCounts),
			sampledImageStencilSampleCounts = t.sampledImageStencilSampleCounts and
				mod.e.VkSampleCountFlagBits(t.sampledImageStencilSampleCounts),
			storageImageSampleCounts = t.storageImageSampleCounts and
				mod.e.VkSampleCountFlagBits(t.storageImageSampleCounts),
			maxSampleMaskWords = t.maxSampleMaskWords,
			timestampComputeAndGraphics = t.timestampComputeAndGraphics,
			timestampPeriod = t.timestampPeriod,
			maxClipDistances = t.maxClipDistances,
			maxCullDistances = t.maxCullDistances,
			maxCombinedClipAndCullDistances = t.maxCombinedClipAndCullDistances,
			discreteQueuePriorities = t.discreteQueuePriorities,
			pointSizeRange = t.pointSizeRange,
			lineWidthRange = t.lineWidthRange,
			pointSizeGranularity = t.pointSizeGranularity,
			lineWidthGranularity = t.lineWidthGranularity,
			strictLines = t.strictLines,
			standardSampleLocations = t.standardSampleLocations,
			optimalBufferCopyOffsetAlignment = t.optimalBufferCopyOffsetAlignment,
			optimalBufferCopyRowPitchAlignment = t.optimalBufferCopyRowPitchAlignment,
			nonCoherentAtomSize = t.nonCoherentAtomSize,
		}
	)
end
mod.s.BufferOpaqueCaptureAddressCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferOpaqueCaptureAddressCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			opaqueCaptureAddress = t.opaqueCaptureAddress,
		}
	)
end
mod.s.MemoryOpaqueCaptureAddressAllocateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryOpaqueCaptureAddressAllocateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			opaqueCaptureAddress = t.opaqueCaptureAddress,
		}
	)
end
mod.s.DeviceMemoryOpaqueCaptureAddressInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceMemoryOpaqueCaptureAddressInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memory = t.memory,
		}
	)
end
mod.s.PhysicalDeviceLayeredApiPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceLayeredApiPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vendorID = t.vendorID,
			deviceID = t.deviceID,
			layeredAPI = t.layeredAPI and mod.e.VkPhysicalDeviceLayeredApiKHR(t.layeredAPI),
			deviceName = t.deviceName,
		}
	)
end
mod.s.CopyMemoryIndirectInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyMemoryIndirectInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcCopyFlags = t.srcCopyFlags,
			dstCopyFlags = t.dstCopyFlags,
			copyCount = t.copyCount,
			copyAddressRange = t.copyAddressRange,
		}
	)
end
mod.s.PhysicalDeviceLayeredApiVulkanPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			properties = t.properties,
		}
	)
end
mod.s.CopyMemoryToImageIndirectInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyMemoryToImageIndirectInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcCopyFlags = t.srcCopyFlags,
			copyCount = t.copyCount,
			copyAddressRange = t.copyAddressRange,
			dstImage = t.dstImage,
			dstImageLayout = t.dstImageLayout and mod.e.VkImageLayout(t.dstImageLayout),
			pImageSubresources = t.pImageSubresources,
		}
	)
end
mod.s.VideoEncodeH265CapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265CapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			maxLevelIdc = t.maxLevelIdc and mod.e.StdVideoH265LevelIdc(t.maxLevelIdc),
			maxSliceSegmentCount = t.maxSliceSegmentCount,
			maxTiles = t.maxTiles,
			ctbSizes = t.ctbSizes,
			transformBlockSizes = t.transformBlockSizes,
			maxPPictureL0ReferenceCount = t.maxPPictureL0ReferenceCount,
			maxBPictureL0ReferenceCount = t.maxBPictureL0ReferenceCount,
			maxL1ReferenceCount = t.maxL1ReferenceCount,
			maxSubLayerCount = t.maxSubLayerCount,
			expectDyadicTemporalSubLayerPattern = t.expectDyadicTemporalSubLayerPattern,
			minQp = t.minQp,
			maxQp = t.maxQp,
			prefersGopRemainingFrames = t.prefersGopRemainingFrames,
			requiresGopRemainingFrames = t.requiresGopRemainingFrames,
			stdSyntaxFlags = t.stdSyntaxFlags,
		}
	)
end
mod.s.MemoryBarrierAccessFlags3KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryBarrierAccessFlags3KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcAccessMask3 = t.srcAccessMask3,
			dstAccessMask3 = t.dstAccessMask3,
		}
	)
end
mod.s.PhysicalDeviceMaintenance8FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance8FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maintenance8 = t.maintenance8,
		}
	)
end
mod.s.VideoEncodeH265SessionCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265SessionCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			useMaxLevelIdc = t.useMaxLevelIdc,
			maxLevelIdc = t.maxLevelIdc and mod.e.StdVideoH265LevelIdc(t.maxLevelIdc),
		}
	)
end
mod.s.VideoEncodeH265QualityLevelPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265QualityLevelPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			preferredRateControlFlags = t.preferredRateControlFlags,
			preferredGopFrameCount = t.preferredGopFrameCount,
			preferredIdrPeriod = t.preferredIdrPeriod,
			preferredConsecutiveBFrameCount = t.preferredConsecutiveBFrameCount,
			preferredSubLayerCount = t.preferredSubLayerCount,
			preferredConstantQp = t.preferredConstantQp,
			preferredMaxL0ReferenceCount = t.preferredMaxL0ReferenceCount,
			preferredMaxL1ReferenceCount = t.preferredMaxL1ReferenceCount,
		}
	)
end
mod.s.VideoEncodeH265SessionParametersAddInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265SessionParametersAddInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stdVPSCount = t.stdVPSCount,
			pStdVPSs = t.pStdVPSs,
			stdSPSCount = t.stdSPSCount,
			pStdSPSs = t.pStdSPSs,
			stdPPSCount = t.stdPPSCount,
			pStdPPSs = t.pStdPPSs,
		}
	)
end
mod.s.VideoEncodeH265SessionParametersCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265SessionParametersCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxStdVPSCount = t.maxStdVPSCount,
			maxStdSPSCount = t.maxStdSPSCount,
			maxStdPPSCount = t.maxStdPPSCount,
			pParametersAddInfo = t.pParametersAddInfo,
		}
	)
end
mod.s.PhysicalDeviceMaintenance9FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance9FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maintenance9 = t.maintenance9,
		}
	)
end
mod.s.VideoEncodeH265SessionParametersGetInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265SessionParametersGetInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			writeStdVPS = t.writeStdVPS,
			writeStdSPS = t.writeStdSPS,
			writeStdPPS = t.writeStdPPS,
			stdVPSId = t.stdVPSId,
			stdSPSId = t.stdSPSId,
			stdPPSId = t.stdPPSId,
		}
	)
end
mod.s.PhysicalDeviceMaintenance9PropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance9PropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			image2DViewOf3DSparse = t.image2DViewOf3DSparse,
			defaultVertexAttributeValue = t.defaultVertexAttributeValue and
				mod.e.VkDefaultVertexAttributeValueKHR(t.defaultVertexAttributeValue),
		}
	)
end
mod.s.VideoEncodeH265SessionParametersFeedbackInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265SessionParametersFeedbackInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			hasStdVPSOverrides = t.hasStdVPSOverrides,
			hasStdSPSOverrides = t.hasStdSPSOverrides,
			hasStdPPSOverrides = t.hasStdPPSOverrides,
		}
	)
end
mod.s.QueueFamilyOwnershipTransferPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueueFamilyOwnershipTransferPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			optimalImageTransferToQueueFamilies = t.optimalImageTransferToQueueFamilies,
		}
	)
end
mod.s.VideoEncodeH265NaluSliceSegmentInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265NaluSliceSegmentInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			constantQp = t.constantQp,
			pStdSliceSegmentHeader = t.pStdSliceSegmentHeader,
		}
	)
end
mod.s.VideoEncodeIntraRefreshCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeIntraRefreshCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			intraRefreshModes = t.intraRefreshModes,
			maxIntraRefreshCycleDuration = t.maxIntraRefreshCycleDuration,
			maxIntraRefreshActiveReferencePictures = t.maxIntraRefreshActiveReferencePictures,
			partitionIndependentIntraRefreshRegions = t.partitionIndependentIntraRefreshRegions,
			nonRectangularIntraRefreshRegions = t.nonRectangularIntraRefreshRegions,
		}
	)
end
mod.s.VideoEncodeH265PictureInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265PictureInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			naluSliceSegmentEntryCount = t.naluSliceSegmentEntryCount,
			pNaluSliceSegmentEntries = t.pNaluSliceSegmentEntries,
			pStdPictureInfo = t.pStdPictureInfo,
		}
	)
end
mod.s.PhysicalDeviceVideoMaintenance2FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVideoMaintenance2FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoMaintenance2 = t.videoMaintenance2,
		}
	)
end
mod.s.VideoEncodeH265DpbSlotInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265DpbSlotInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdReferenceInfo = t.pStdReferenceInfo,
		}
	)
end
mod.s.VideoEncodeH265ProfileInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265ProfileInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stdProfileIdc = t.stdProfileIdc and mod.e.StdVideoH265ProfileIdc(t.stdProfileIdc),
		}
	)
end
mod.s.VideoEncodeH265RateControlInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265RateControlInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			gopFrameCount = t.gopFrameCount,
			idrPeriod = t.idrPeriod,
			consecutiveBFrameCount = t.consecutiveBFrameCount,
			subLayerCount = t.subLayerCount,
		}
	)
end
mod.s.VideoDecodeH265InlineSessionParametersInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH265InlineSessionParametersInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdVPS = t.pStdVPS,
			pStdSPS = t.pStdSPS,
			pStdPPS = t.pStdPPS,
		}
	)
end
mod.s.VideoDecodeAV1InlineSessionParametersInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeAV1InlineSessionParametersInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdSequenceHeader = t.pStdSequenceHeader,
		}
	)
end
mod.s.VideoEncodeH265GopRemainingFrameInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265GopRemainingFrameInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			useGopRemainingFrames = t.useGopRemainingFrames,
			gopRemainingI = t.gopRemainingI,
			gopRemainingP = t.gopRemainingP,
			gopRemainingB = t.gopRemainingB,
		}
	)
end
mod.s.PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoEncodeIntraRefresh = t.videoEncodeIntraRefresh,
		}
	)
end
mod.s.PhysicalDeviceDepthClampZeroOneFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			depthClampZeroOne = t.depthClampZeroOne,
		}
	)
end
mod.s.PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			attachmentFeedbackLoopLayout = t.attachmentFeedbackLoopLayout,
		}
	)
end
mod.s.VideoEncodeQuantizationMapCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeQuantizationMapCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxQuantizationMapExtent = t.maxQuantizationMapExtent,
		}
	)
end
mod.s.PhysicalDeviceRobustness2FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRobustness2FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			robustBufferAccess2 = t.robustBufferAccess2,
			robustImageAccess2 = t.robustImageAccess2,
			nullDescriptor = t.nullDescriptor,
		}
	)
end
mod.s.VideoFormatQuantizationMapPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoFormatQuantizationMapPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			quantizationMapTexelSize = t.quantizationMapTexelSize,
		}
	)
end
mod.s.FilterCubicImageViewImageFormatPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFilterCubicImageViewImageFormatPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			filterCubic = t.filterCubic,
			filterCubicMinmax = t.filterCubicMinmax,
		}
	)
end
mod.s.PhysicalDevice4444FormatsFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevice4444FormatsFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			formatA4R4G4B4 = t.formatA4R4G4B4,
			formatA4B4G4R4 = t.formatA4B4G4R4,
		}
	)
end
mod.s.PhysicalDeviceRobustness2PropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRobustness2PropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			robustStorageBufferAccessSizeAlignment = t.robustStorageBufferAccessSizeAlignment,
			robustUniformBufferAccessSizeAlignment = t.robustUniformBufferAccessSizeAlignment,
		}
	)
end
mod.s.PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentModeFifoLatestReady = t.presentModeFifoLatestReady,
		}
	)
end
mod.s.ImportMemoryHostPointerInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImportMemoryHostPointerInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleType = t.handleType and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType),
			pHostPointer = t.pHostPointer,
		}
	)
end
mod.s.MemoryHostPointerPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryHostPointerPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memoryTypeBits = t.memoryTypeBits,
		}
	)
end
mod.s.PhysicalDeviceExternalMemoryHostPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minImportedHostPointerAlignment = t.minImportedHostPointerAlignment,
		}
	)
end
mod.s.VideoDecodeH264ProfileInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH264ProfileInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stdProfileIdc = t.stdProfileIdc and mod.e.StdVideoH264ProfileIdc(t.stdProfileIdc),
			pictureLayout = t.pictureLayout and
				mod.e.VkVideoDecodeH264PictureLayoutFlagBitsKHR(t.pictureLayout),
		}
	)
end
mod.s.VideoDecodeH264CapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH264CapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxLevelIdc = t.maxLevelIdc and mod.e.StdVideoH264LevelIdc(t.maxLevelIdc),
			fieldOffsetGranularity = t.fieldOffsetGranularity,
		}
	)
end
mod.s.VideoDecodeH264SessionParametersAddInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH264SessionParametersAddInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stdSPSCount = t.stdSPSCount,
			pStdSPSs = t.pStdSPSs,
			stdPPSCount = t.stdPPSCount,
			pStdPPSs = t.pStdPPSs,
		}
	)
end
mod.s.VideoDecodeH264SessionParametersCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH264SessionParametersCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxStdSPSCount = t.maxStdSPSCount,
			maxStdPPSCount = t.maxStdPPSCount,
			pParametersAddInfo = t.pParametersAddInfo,
		}
	)
end
mod.s.VideoDecodeH264PictureInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH264PictureInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdPictureInfo = t.pStdPictureInfo,
			sliceCount = t.sliceCount,
			pSliceOffsets = t.pSliceOffsets,
		}
	)
end
mod.s.VideoDecodeH264DpbSlotInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH264DpbSlotInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdReferenceInfo = t.pStdReferenceInfo,
		}
	)
end
mod.s.PhysicalDeviceShaderCorePropertiesAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderCorePropertiesAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderEngineCount = t.shaderEngineCount,
			shaderArraysPerEngineCount = t.shaderArraysPerEngineCount,
			computeUnitsPerShaderArray = t.computeUnitsPerShaderArray,
			simdPerComputeUnit = t.simdPerComputeUnit,
			wavefrontsPerSimd = t.wavefrontsPerSimd,
			wavefrontSize = t.wavefrontSize,
			sgprsPerSimd = t.sgprsPerSimd,
			minSgprAllocation = t.minSgprAllocation,
			maxSgprAllocation = t.maxSgprAllocation,
			sgprAllocationGranularity = t.sgprAllocationGranularity,
			vgprsPerSimd = t.vgprsPerSimd,
			minVgprAllocation = t.minVgprAllocation,
			maxVgprAllocation = t.maxVgprAllocation,
			vgprAllocationGranularity = t.vgprAllocationGranularity,
		}
	)
end
mod.s.TensorMemoryBarrierARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTensorMemoryBarrierARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcStageMask = t.srcStageMask,
			srcAccessMask = t.srcAccessMask,
			dstStageMask = t.dstStageMask,
			dstAccessMask = t.dstAccessMask,
			srcQueueFamilyIndex = t.srcQueueFamilyIndex,
			dstQueueFamilyIndex = t.dstQueueFamilyIndex,
			tensor = t.tensor,
		}
	)
end
mod.s.TensorDependencyInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTensorDependencyInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tensorMemoryBarrierCount = t.tensorMemoryBarrierCount,
			pTensorMemoryBarriers = t.pTensorMemoryBarriers,
		}
	)
end
mod.s.PhysicalDeviceTensorFeaturesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTensorFeaturesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tensorNonPacked = t.tensorNonPacked,
			shaderTensorAccess = t.shaderTensorAccess,
			shaderStorageTensorArrayDynamicIndexing = t.shaderStorageTensorArrayDynamicIndexing,
			shaderStorageTensorArrayNonUniformIndexing = t.shaderStorageTensorArrayNonUniformIndexing,
			descriptorBindingStorageTensorUpdateAfterBind = t.descriptorBindingStorageTensorUpdateAfterBind,
			tensors = t.tensors,
		}
	)
end
mod.s.DeviceTensorMemoryRequirementsARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceTensorMemoryRequirementsARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pCreateInfo = t.pCreateInfo,
		}
	)
end
mod.s.TensorCopyARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTensorCopyARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dimensionCount = t.dimensionCount,
			pSrcOffset = t.pSrcOffset,
			pDstOffset = t.pDstOffset,
			pExtent = t.pExtent,
		}
	)
end
mod.s.CopyTensorInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyTensorInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcTensor = t.srcTensor,
			dstTensor = t.dstTensor,
			regionCount = t.regionCount,
			pRegions = t.pRegions,
		}
	)
end
mod.s.MemoryDedicatedAllocateInfoTensorARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryDedicatedAllocateInfoTensorARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tensor = t.tensor,
		}
	)
end
mod.s.PhysicalDeviceExternalTensorInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExternalTensorInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			pDescription = t.pDescription,
			handleType = t.handleType and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType),
		}
	)
end
mod.s.PhysicalDeviceVertexAttributeDivisorPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxVertexAttribDivisor = t.maxVertexAttribDivisor,
		}
	)
end
mod.s.ExternalMemoryTensorCreateInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalMemoryTensorCreateInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleTypes = t.handleTypes and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleTypes),
		}
	)
end
mod.s.PhysicalDeviceDescriptorBufferTensorFeaturesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			descriptorBufferTensorDescriptors = t.descriptorBufferTensorDescriptors,
		}
	)
end
mod.s.VideoCodingControlInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoCodingControlInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
		}
	)
end
mod.s.PhysicalDeviceDescriptorBufferTensorPropertiesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tensorCaptureReplayDescriptorDataSize = t.tensorCaptureReplayDescriptorDataSize,
			tensorViewCaptureReplayDescriptorDataSize = t.tensorViewCaptureReplayDescriptorDataSize,
			tensorDescriptorSize = t.tensorDescriptorSize,
		}
	)
end
mod.s.DescriptorGetTensorInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorGetTensorInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tensorView = t.tensorView,
		}
	)
end
mod.s.TensorCaptureDescriptorDataInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTensorCaptureDescriptorDataInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tensor = t.tensor,
		}
	)
end
mod.s.TensorViewCaptureDescriptorDataInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTensorViewCaptureDescriptorDataInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tensorView = t.tensorView,
		}
	)
end
mod.s.PhysicalDeviceMeshShaderFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMeshShaderFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			taskShader = t.taskShader,
			meshShader = t.meshShader,
		}
	)
end
mod.s.PhysicalDeviceMeshShaderPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMeshShaderPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxDrawMeshTasksCount = t.maxDrawMeshTasksCount,
			maxTaskWorkGroupInvocations = t.maxTaskWorkGroupInvocations,
			maxTaskWorkGroupSize = t.maxTaskWorkGroupSize,
			maxTaskTotalMemorySize = t.maxTaskTotalMemorySize,
			maxTaskOutputCount = t.maxTaskOutputCount,
			maxMeshWorkGroupInvocations = t.maxMeshWorkGroupInvocations,
			maxMeshWorkGroupSize = t.maxMeshWorkGroupSize,
			maxMeshTotalMemorySize = t.maxMeshTotalMemorySize,
			maxMeshOutputVertices = t.maxMeshOutputVertices,
			maxMeshOutputPrimitives = t.maxMeshOutputPrimitives,
			maxMeshMultiviewViewCount = t.maxMeshMultiviewViewCount,
			meshOutputPerVertexGranularity = t.meshOutputPerVertexGranularity,
			meshOutputPerPrimitiveGranularity = t.meshOutputPerPrimitiveGranularity,
		}
	)
end
mod.s.PhysicalDeviceShaderImageFootprintFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderImageFootprintFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageFootprint = t.imageFootprint,
		}
	)
end
mod.s.DisplayPlaneInfo2KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplayPlaneInfo2KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			mode = t.mode,
			planeIndex = t.planeIndex,
		}
	)
end
mod.s.PipelineViewportExclusiveScissorStateCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineViewportExclusiveScissorStateCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			exclusiveScissorCount = t.exclusiveScissorCount,
			pExclusiveScissors = t.pExclusiveScissors,
		}
	)
end
mod.s.MicromapBuildInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMicromapBuildInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type and mod.e.VkMicromapTypeEXT(t.type),
			flags = t.flags,
			mode = t.mode and mod.e.VkBuildMicromapModeEXT(t.mode),
			dstMicromap = t.dstMicromap,
			usageCountsCount = t.usageCountsCount,
			pUsageCounts = t.pUsageCounts,
			ppUsageCounts = t.ppUsageCounts,
			data = t.data,
			scratchData = t.scratchData,
			triangleArray = t.triangleArray,
			triangleArrayStride = t.triangleArrayStride,
		}
	)
end
mod.s.PhysicalDeviceExclusiveScissorFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExclusiveScissorFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			exclusiveScissor = t.exclusiveScissor,
		}
	)
end
mod.s.PhysicalDeviceMapMemoryPlacedFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memoryMapPlaced = t.memoryMapPlaced,
			memoryMapRangePlaced = t.memoryMapRangePlaced,
			memoryUnmapReserve = t.memoryUnmapReserve,
		}
	)
end
mod.s.MicromapCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMicromapCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			createFlags = t.createFlags,
			buffer = t.buffer,
			offset = t.offset,
			size = t.size,
			type = t.type and mod.e.VkMicromapTypeEXT(t.type),
			deviceAddress = t.deviceAddress,
		}
	)
end
mod.s.PhysicalDeviceOpacityMicromapFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceOpacityMicromapFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			micromap = t.micromap,
			micromapCaptureReplay = t.micromapCaptureReplay,
			micromapHostCommands = t.micromapHostCommands,
		}
	)
end
mod.s.MemoryMapPlacedInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryMapPlacedInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pPlacedAddress = t.pPlacedAddress,
		}
	)
end
mod.s.QueueFamilyCheckpointPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueueFamilyCheckpointPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			checkpointExecutionStageMask = t.checkpointExecutionStageMask and
				mod.e.VkPipelineStageFlagBits(t.checkpointExecutionStageMask),
		}
	)
end
mod.s.PhysicalDeviceOpacityMicromapPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceOpacityMicromapPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxOpacity2StateSubdivisionLevel = t.maxOpacity2StateSubdivisionLevel,
			maxOpacity4StateSubdivisionLevel = t.maxOpacity4StateSubdivisionLevel,
		}
	)
end
mod.s.CheckpointDataNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCheckpointDataNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stage = t.stage and mod.e.VkPipelineStageFlagBits(t.stage),
			pCheckpointMarker = t.pCheckpointMarker,
		}
	)
end
mod.s.MicromapVersionInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMicromapVersionInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pVersionData = t.pVersionData,
		}
	)
end
mod.s.CheckpointData2NV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCheckpointData2NV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stage = t.stage,
			pCheckpointMarker = t.pCheckpointMarker,
		}
	)
end
mod.s.CopyMicromapToMemoryInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyMicromapToMemoryInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			src = t.src,
			dst = t.dst,
			mode = t.mode and mod.e.VkCopyMicromapModeEXT(t.mode),
		}
	)
end
mod.s.CopyMemoryToMicromapInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyMemoryToMicromapInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			src = t.src,
			dst = t.dst,
			mode = t.mode and mod.e.VkCopyMicromapModeEXT(t.mode),
		}
	)
end
mod.s.CopyMicromapInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyMicromapInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			src = t.src,
			dst = t.dst,
			mode = t.mode and mod.e.VkCopyMicromapModeEXT(t.mode),
		}
	)
end
mod.s.MicromapBuildSizesInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMicromapBuildSizesInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			micromapSize = t.micromapSize,
			buildScratchSize = t.buildScratchSize,
			discardable = t.discardable,
		}
	)
end
mod.s.AccelerationStructureTrianglesOpacityMicromapEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureTrianglesOpacityMicromapEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			indexType = t.indexType and mod.e.VkIndexType(t.indexType),
			indexBuffer = t.indexBuffer,
			indexStride = t.indexStride,
			baseTriangle = t.baseTriangle,
			usageCountsCount = t.usageCountsCount,
			pUsageCounts = t.pUsageCounts,
			ppUsageCounts = t.ppUsageCounts,
			micromap = t.micromap,
		}
	)
end
mod.s.PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderIntegerFunctions2 = t.shaderIntegerFunctions2,
		}
	)
end
mod.s.PerformanceValueINTEL = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPerformanceValueINTEL(
		{
			type = t.type and mod.e.VkPerformanceValueTypeINTEL(t.type),
			data = t.data,
		}
	)
end
mod.s.InitializePerformanceApiInfoINTEL = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkInitializePerformanceApiInfoINTEL(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pUserData = t.pUserData,
		}
	)
end
mod.s.QueryPoolPerformanceQueryCreateInfoINTEL = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueryPoolPerformanceQueryCreateInfoINTEL(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			performanceCountersSampling = t.performanceCountersSampling and
				mod.e.VkQueryPoolSamplingModeINTEL(t.performanceCountersSampling),
		}
	)
end
mod.s.PerformanceMarkerInfoINTEL = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPerformanceMarkerInfoINTEL(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			marker = t.marker,
		}
	)
end
mod.s.PhysicalDeviceVulkan13Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVulkan13Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			robustImageAccess = t.robustImageAccess,
			inlineUniformBlock = t.inlineUniformBlock,
			descriptorBindingInlineUniformBlockUpdateAfterBind = t.descriptorBindingInlineUniformBlockUpdateAfterBind,
			pipelineCreationCacheControl = t.pipelineCreationCacheControl,
			privateData = t.privateData,
			shaderDemoteToHelperInvocation = t.shaderDemoteToHelperInvocation,
			shaderTerminateInvocation = t.shaderTerminateInvocation,
			subgroupSizeControl = t.subgroupSizeControl,
			computeFullSubgroups = t.computeFullSubgroups,
			synchronization2 = t.synchronization2,
			textureCompressionASTC_HDR = t.textureCompressionASTC_HDR,
			shaderZeroInitializeWorkgroupMemory = t.shaderZeroInitializeWorkgroupMemory,
			dynamicRendering = t.dynamicRendering,
			shaderIntegerDotProduct = t.shaderIntegerDotProduct,
			maintenance4 = t.maintenance4,
		}
	)
end
mod.s.PerformanceOverrideInfoINTEL = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPerformanceOverrideInfoINTEL(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type and mod.e.VkPerformanceOverrideTypeINTEL(t.type),
			enable = t.enable,
			parameter = t.parameter,
		}
	)
end
mod.s.PerformanceConfigurationAcquireInfoINTEL = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPerformanceConfigurationAcquireInfoINTEL(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type and mod.e.VkPerformanceConfigurationTypeINTEL(t.type),
		}
	)
end
mod.s.PhysicalDeviceClusterCullingShaderFeaturesHUAWEI = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			clustercullingShader = t.clustercullingShader,
			multiviewClusterCullingShader = t.multiviewClusterCullingShader,
		}
	)
end
mod.s.PhysicalDeviceClusterCullingShaderPropertiesHUAWEI = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxWorkGroupCount = t.maxWorkGroupCount,
			maxWorkGroupSize = t.maxWorkGroupSize,
			maxOutputClusterCount = t.maxOutputClusterCount,
			indirectBufferOffsetAlignment = t.indirectBufferOffsetAlignment,
		}
	)
end
mod.s.PhysicalDeviceDeviceGeneratedCommandsPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxGraphicsShaderGroupCount = t.maxGraphicsShaderGroupCount,
			maxIndirectSequenceCount = t.maxIndirectSequenceCount,
			maxIndirectCommandsTokenCount = t.maxIndirectCommandsTokenCount,
			maxIndirectCommandsStreamCount = t.maxIndirectCommandsStreamCount,
			maxIndirectCommandsTokenOffset = t.maxIndirectCommandsTokenOffset,
			maxIndirectCommandsStreamStride = t.maxIndirectCommandsStreamStride,
			minSequencesCountBufferOffsetAlignment = t.minSequencesCountBufferOffsetAlignment,
			minSequencesIndexBufferOffsetAlignment = t.minSequencesIndexBufferOffsetAlignment,
			minIndirectCommandsBufferOffsetAlignment = t.minIndirectCommandsBufferOffsetAlignment,
		}
	)
end
mod.s.PhysicalDeviceVulkan13Properties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVulkan13Properties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minSubgroupSize = t.minSubgroupSize,
			maxSubgroupSize = t.maxSubgroupSize,
			maxComputeWorkgroupSubgroups = t.maxComputeWorkgroupSubgroups,
			requiredSubgroupSizeStages = t.requiredSubgroupSizeStages and
				mod.e.VkShaderStageFlagBits(t.requiredSubgroupSizeStages),
			maxInlineUniformBlockSize = t.maxInlineUniformBlockSize,
			maxPerStageDescriptorInlineUniformBlocks = t.maxPerStageDescriptorInlineUniformBlocks,
			maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = t.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks,
			maxDescriptorSetInlineUniformBlocks = t.maxDescriptorSetInlineUniformBlocks,
			maxDescriptorSetUpdateAfterBindInlineUniformBlocks = t.maxDescriptorSetUpdateAfterBindInlineUniformBlocks,
			maxInlineUniformTotalSize = t.maxInlineUniformTotalSize,
			integerDotProduct8BitUnsignedAccelerated = t.integerDotProduct8BitUnsignedAccelerated,
			integerDotProduct8BitSignedAccelerated = t.integerDotProduct8BitSignedAccelerated,
			integerDotProduct8BitMixedSignednessAccelerated = t.integerDotProduct8BitMixedSignednessAccelerated,
			integerDotProduct4x8BitPackedUnsignedAccelerated = t.integerDotProduct4x8BitPackedUnsignedAccelerated,
			integerDotProduct4x8BitPackedSignedAccelerated = t.integerDotProduct4x8BitPackedSignedAccelerated,
			integerDotProduct4x8BitPackedMixedSignednessAccelerated = t.integerDotProduct4x8BitPackedMixedSignednessAccelerated,
			integerDotProduct16BitUnsignedAccelerated = t.integerDotProduct16BitUnsignedAccelerated,
			integerDotProduct16BitSignedAccelerated = t.integerDotProduct16BitSignedAccelerated,
			integerDotProduct16BitMixedSignednessAccelerated = t.integerDotProduct16BitMixedSignednessAccelerated,
			integerDotProduct32BitUnsignedAccelerated = t.integerDotProduct32BitUnsignedAccelerated,
			integerDotProduct32BitSignedAccelerated = t.integerDotProduct32BitSignedAccelerated,
			integerDotProduct32BitMixedSignednessAccelerated = t.integerDotProduct32BitMixedSignednessAccelerated,
			integerDotProduct64BitUnsignedAccelerated = t.integerDotProduct64BitUnsignedAccelerated,
			integerDotProduct64BitSignedAccelerated = t.integerDotProduct64BitSignedAccelerated,
			integerDotProduct64BitMixedSignednessAccelerated = t.integerDotProduct64BitMixedSignednessAccelerated,
			integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated,
			integerDotProductAccumulatingSaturating8BitSignedAccelerated = t.integerDotProductAccumulatingSaturating8BitSignedAccelerated,
			integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated,
			integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = t.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated,
			integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = t.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated,
			integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated,
			integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated,
			integerDotProductAccumulatingSaturating16BitSignedAccelerated = t.integerDotProductAccumulatingSaturating16BitSignedAccelerated,
			integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated,
			integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated,
			integerDotProductAccumulatingSaturating32BitSignedAccelerated = t.integerDotProductAccumulatingSaturating32BitSignedAccelerated,
			integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated,
			integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated,
			integerDotProductAccumulatingSaturating64BitSignedAccelerated = t.integerDotProductAccumulatingSaturating64BitSignedAccelerated,
			integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated,
			storageTexelBufferOffsetAlignmentBytes = t.storageTexelBufferOffsetAlignmentBytes,
			storageTexelBufferOffsetSingleTexelAlignment = t.storageTexelBufferOffsetSingleTexelAlignment,
			uniformTexelBufferOffsetAlignmentBytes = t.uniformTexelBufferOffsetAlignmentBytes,
			uniformTexelBufferOffsetSingleTexelAlignment = t.uniformTexelBufferOffsetSingleTexelAlignment,
			maxBufferSize = t.maxBufferSize,
		}
	)
end
mod.s.PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			clusterShadingRate = t.clusterShadingRate,
		}
	)
end
mod.s.PhysicalDeviceDeviceGeneratedCommandsFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceGeneratedCommands = t.deviceGeneratedCommands,
		}
	)
end
mod.s.GraphicsShaderGroupCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGraphicsShaderGroupCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stageCount = t.stageCount,
			pStages = t.pStages,
			pVertexInputState = t.pVertexInputState,
			pTessellationState = t.pTessellationState,
		}
	)
end
mod.s.PhysicalDeviceBorderColorSwizzleFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			borderColorSwizzle = t.borderColorSwizzle,
			borderColorSwizzleFromImage = t.borderColorSwizzleFromImage,
		}
	)
end
mod.s.SamplerBorderColorComponentMappingCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSamplerBorderColorComponentMappingCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			components = t.components,
			srgb = t.srgb,
		}
	)
end
mod.s.BindIndexBufferIndirectCommandNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindIndexBufferIndirectCommandNV(
		{
			bufferAddress = t.bufferAddress,
			size = t.size,
			indexType = t.indexType and mod.e.VkIndexType(t.indexType),
		}
	)
end
mod.s.PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pageableDeviceLocalMemory = t.pageableDeviceLocalMemory,
		}
	)
end
mod.s.IndirectCommandsLayoutTokenNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkIndirectCommandsLayoutTokenNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tokenType = t.tokenType and mod.e.VkIndirectCommandsTokenTypeNV(t.tokenType),
			stream = t.stream,
			offset = t.offset,
			vertexBindingUnit = t.vertexBindingUnit,
			vertexDynamicStride = t.vertexDynamicStride,
			pushconstantPipelineLayout = t.pushconstantPipelineLayout,
			pushconstantShaderStageFlags = t.pushconstantShaderStageFlags and
				mod.e.VkShaderStageFlagBits(t.pushconstantShaderStageFlags),
			pushconstantOffset = t.pushconstantOffset,
			pushconstantSize = t.pushconstantSize,
			indirectStateFlags = t.indirectStateFlags,
			indexTypeCount = t.indexTypeCount,
			pIndexTypes = t.pIndexTypes,
			pIndexTypeValues = t.pIndexTypeValues,
		}
	)
end
mod.s.PhysicalDeviceShaderCorePropertiesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderCorePropertiesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pixelRate = t.pixelRate,
			texelRate = t.texelRate,
			fmaRate = t.fmaRate,
		}
	)
end
mod.s.PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			spheres = t.spheres,
			linearSweptSpheres = t.linearSweptSpheres,
		}
	)
end
mod.s.IndirectCommandsLayoutCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkIndirectCommandsLayoutCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			pipelineBindPoint = t.pipelineBindPoint and mod.e.VkPipelineBindPoint(t.pipelineBindPoint),
			tokenCount = t.tokenCount,
			pTokens = t.pTokens,
			streamCount = t.streamCount,
			pStreamStrides = t.pStreamStrides,
		}
	)
end
mod.s.AccelerationStructureGeometryLinearSweptSpheresDataNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureGeometryLinearSweptSpheresDataNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vertexFormat = t.vertexFormat and mod.e.VkFormat(t.vertexFormat),
			vertexData = t.vertexData,
			vertexStride = t.vertexStride,
			radiusFormat = t.radiusFormat and mod.e.VkFormat(t.radiusFormat),
			radiusData = t.radiusData,
			radiusStride = t.radiusStride,
			indexType = t.indexType and mod.e.VkIndexType(t.indexType),
			indexData = t.indexData,
			indexStride = t.indexStride,
			indexingMode = t.indexingMode and mod.e.VkRayTracingLssIndexingModeNV(t.indexingMode),
			endCapsMode = t.endCapsMode and mod.e.VkRayTracingLssPrimitiveEndCapsModeNV(t.endCapsMode),
		}
	)
end
mod.s.SampleLocationsInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSampleLocationsInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			sampleLocationsPerPixel = t.sampleLocationsPerPixel and
				mod.e.VkSampleCountFlagBits(t.sampleLocationsPerPixel),
			sampleLocationGridSize = t.sampleLocationGridSize,
			sampleLocationsCount = t.sampleLocationsCount,
			pSampleLocations = t.pSampleLocations,
		}
	)
end
mod.s.DeviceQueueShaderCoreControlCreateInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceQueueShaderCoreControlCreateInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderCoreCount = t.shaderCoreCount,
		}
	)
end
mod.s.GeneratedCommandsInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGeneratedCommandsInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineBindPoint = t.pipelineBindPoint and mod.e.VkPipelineBindPoint(t.pipelineBindPoint),
			pipeline = t.pipeline,
			indirectCommandsLayout = t.indirectCommandsLayout,
			streamCount = t.streamCount,
			pStreams = t.pStreams,
			sequencesCount = t.sequencesCount,
			preprocessBuffer = t.preprocessBuffer,
			preprocessOffset = t.preprocessOffset,
			preprocessSize = t.preprocessSize,
			sequencesCountBuffer = t.sequencesCountBuffer,
			sequencesCountOffset = t.sequencesCountOffset,
			sequencesIndexBuffer = t.sequencesIndexBuffer,
			sequencesIndexOffset = t.sequencesIndexOffset,
		}
	)
end
mod.s.PhysicalDeviceSchedulingControlsFeaturesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSchedulingControlsFeaturesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			schedulingControls = t.schedulingControls,
		}
	)
end
mod.s.AccelerationStructureGeometrySpheresDataNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureGeometrySpheresDataNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vertexFormat = t.vertexFormat and mod.e.VkFormat(t.vertexFormat),
			vertexData = t.vertexData,
			vertexStride = t.vertexStride,
			radiusFormat = t.radiusFormat and mod.e.VkFormat(t.radiusFormat),
			radiusData = t.radiusData,
			radiusStride = t.radiusStride,
			indexType = t.indexType and mod.e.VkIndexType(t.indexType),
			indexData = t.indexData,
			indexStride = t.indexStride,
		}
	)
end
mod.s.PhysicalDeviceLinearColorAttachmentFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceLinearColorAttachmentFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			linearColorAttachment = t.linearColorAttachment,
		}
	)
end
mod.s.RenderPassSampleLocationsBeginInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassSampleLocationsBeginInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			attachmentInitialSampleLocationsCount = t.attachmentInitialSampleLocationsCount,
			pAttachmentInitialSampleLocations = t.pAttachmentInitialSampleLocations,
			postSubpassSampleLocationsCount = t.postSubpassSampleLocationsCount,
			pPostSubpassSampleLocations = t.pPostSubpassSampleLocations,
		}
	)
end
mod.s.PhysicalDeviceImageSlicedViewOf3DFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageSlicedViewOf3D = t.imageSlicedViewOf3D,
		}
	)
end
mod.s.ImageViewSlicedCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageViewSlicedCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			sliceOffset = t.sliceOffset,
			sliceCount = t.sliceCount,
		}
	)
end
mod.s.PipelineSampleLocationsStateCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineSampleLocationsStateCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			sampleLocationsEnable = t.sampleLocationsEnable,
			sampleLocationsInfo = t.sampleLocationsInfo,
		}
	)
end
mod.s.PhysicalDeviceSampleLocationsPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSampleLocationsPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			sampleLocationSampleCounts = t.sampleLocationSampleCounts and
				mod.e.VkSampleCountFlagBits(t.sampleLocationSampleCounts),
			maxSampleLocationGridSize = t.maxSampleLocationGridSize,
			sampleLocationCoordinateRange = t.sampleLocationCoordinateRange,
			sampleLocationSubPixelBits = t.sampleLocationSubPixelBits,
			variableSampleLocations = t.variableSampleLocations,
		}
	)
end
mod.s.PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			descriptorSetHostMapping = t.descriptorSetHostMapping,
		}
	)
end
mod.s.DescriptorSetBindingReferenceVALVE = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorSetBindingReferenceVALVE(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			descriptorSetLayout = t.descriptorSetLayout,
			binding = t.binding,
		}
	)
end
mod.s.PhysicalDeviceShaderDemoteToHelperInvocationFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderDemoteToHelperInvocation = t.shaderDemoteToHelperInvocation,
		}
	)
end
mod.s.PhysicalDevicePrivateDataFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePrivateDataFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			privateData = t.privateData,
		}
	)
end
mod.s.ImageViewSampleWeightCreateInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageViewSampleWeightCreateInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			filterCenter = t.filterCenter,
			filterSize = t.filterSize,
			numPhases = t.numPhases,
		}
	)
end
mod.s.PrivateDataSlotCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPrivateDataSlotCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
		}
	)
end
mod.s.PhysicalDevicePipelineCreationCacheControlFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePipelineCreationCacheControlFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineCreationCacheControl = t.pipelineCreationCacheControl,
		}
	)
end
mod.s.MemoryBarrier2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryBarrier2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcStageMask = t.srcStageMask,
			srcAccessMask = t.srcAccessMask,
			dstStageMask = t.dstStageMask,
			dstAccessMask = t.dstAccessMask,
		}
	)
end
mod.s.BufferMemoryBarrier2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferMemoryBarrier2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcStageMask = t.srcStageMask,
			srcAccessMask = t.srcAccessMask,
			dstStageMask = t.dstStageMask,
			dstAccessMask = t.dstAccessMask,
			srcQueueFamilyIndex = t.srcQueueFamilyIndex,
			dstQueueFamilyIndex = t.dstQueueFamilyIndex,
			buffer = t.buffer,
			offset = t.offset,
			size = t.size,
		}
	)
end
mod.s.ImageMemoryBarrier2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageMemoryBarrier2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcStageMask = t.srcStageMask,
			srcAccessMask = t.srcAccessMask,
			dstStageMask = t.dstStageMask,
			dstAccessMask = t.dstAccessMask,
			oldLayout = t.oldLayout and mod.e.VkImageLayout(t.oldLayout),
			newLayout = t.newLayout and mod.e.VkImageLayout(t.newLayout),
			srcQueueFamilyIndex = t.srcQueueFamilyIndex,
			dstQueueFamilyIndex = t.dstQueueFamilyIndex,
			image = t.image,
			subresourceRange = t.subresourceRange,
		}
	)
end
mod.s.DependencyInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDependencyInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dependencyFlags = t.dependencyFlags and mod.e.VkDependencyFlagBits(t.dependencyFlags),
			memoryBarrierCount = t.memoryBarrierCount,
			pMemoryBarriers = t.pMemoryBarriers,
			bufferMemoryBarrierCount = t.bufferMemoryBarrierCount,
			pBufferMemoryBarriers = t.pBufferMemoryBarriers,
			imageMemoryBarrierCount = t.imageMemoryBarrierCount,
			pImageMemoryBarriers = t.pImageMemoryBarriers,
		}
	)
end
mod.s.SemaphoreSubmitInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSemaphoreSubmitInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			semaphore = t.semaphore,
			value = t.value,
			stageMask = t.stageMask,
			deviceIndex = t.deviceIndex,
		}
	)
end
mod.s.PhysicalDeviceInheritedViewportScissorFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceInheritedViewportScissorFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			inheritedViewportScissor2D = t.inheritedViewportScissor2D,
		}
	)
end
mod.s.SubmitInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubmitInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkSubmitFlagBits(t.flags),
			waitSemaphoreInfoCount = t.waitSemaphoreInfoCount,
			pWaitSemaphoreInfos = t.pWaitSemaphoreInfos,
			commandBufferInfoCount = t.commandBufferInfoCount,
			pCommandBufferInfos = t.pCommandBufferInfos,
			signalSemaphoreInfoCount = t.signalSemaphoreInfoCount,
			pSignalSemaphoreInfos = t.pSignalSemaphoreInfos,
		}
	)
end
mod.s.CommandBufferInheritanceViewportScissorInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCommandBufferInheritanceViewportScissorInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			viewportScissor2D = t.viewportScissor2D,
			viewportDepthCount = t.viewportDepthCount,
			pViewportDepths = t.pViewportDepths,
		}
	)
end
mod.s.PhysicalDeviceNonSeamlessCubeMapFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			nonSeamlessCubeMap = t.nonSeamlessCubeMap,
		}
	)
end
mod.s.PhysicalDeviceBlendOperationAdvancedFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			advancedBlendCoherentOperations = t.advancedBlendCoherentOperations,
		}
	)
end
mod.s.PhysicalDeviceNestedCommandBufferFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceNestedCommandBufferFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			nestedCommandBuffer = t.nestedCommandBuffer,
			nestedCommandBufferRendering = t.nestedCommandBufferRendering,
			nestedCommandBufferSimultaneousUse = t.nestedCommandBufferSimultaneousUse,
		}
	)
end
mod.s.PhysicalDeviceBlendOperationAdvancedPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			advancedBlendMaxColorAttachments = t.advancedBlendMaxColorAttachments,
			advancedBlendIndependentBlend = t.advancedBlendIndependentBlend,
			advancedBlendNonPremultipliedSrcColor = t.advancedBlendNonPremultipliedSrcColor,
			advancedBlendNonPremultipliedDstColor = t.advancedBlendNonPremultipliedDstColor,
			advancedBlendCorrelatedOverlap = t.advancedBlendCorrelatedOverlap,
			advancedBlendAllOperations = t.advancedBlendAllOperations,
		}
	)
end
mod.s.PhysicalDeviceSynchronization2Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSynchronization2Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			synchronization2 = t.synchronization2,
		}
	)
end
mod.s.PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderZeroInitializeWorkgroupMemory = t.shaderZeroInitializeWorkgroupMemory,
		}
	)
end
mod.s.PhysicalDeviceImageRobustnessFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageRobustnessFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			robustImageAccess = t.robustImageAccess,
		}
	)
end
mod.s.PhysicalDeviceRenderPassStripedPropertiesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRenderPassStripedPropertiesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			renderPassStripeGranularity = t.renderPassStripeGranularity,
			maxRenderPassStripes = t.maxRenderPassStripes,
		}
	)
end
mod.s.CopyBufferInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyBufferInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcBuffer = t.srcBuffer,
			dstBuffer = t.dstBuffer,
			regionCount = t.regionCount,
			pRegions = t.pRegions,
		}
	)
end
mod.s.ImageCopy2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageCopy2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcSubresource = t.srcSubresource,
			srcOffset = t.srcOffset,
			dstSubresource = t.dstSubresource,
			dstOffset = t.dstOffset,
			extent = t.extent,
		}
	)
end
mod.s.RenderPassStripeInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassStripeInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stripeArea = t.stripeArea,
		}
	)
end
mod.s.ExternalMemoryAcquireUnmodifiedEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalMemoryAcquireUnmodifiedEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			acquireUnmodifiedMemory = t.acquireUnmodifiedMemory,
		}
	)
end
mod.s.RenderPassStripeBeginInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassStripeBeginInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stripeInfoCount = t.stripeInfoCount,
			pStripeInfos = t.pStripeInfos,
		}
	)
end
mod.s.CopyImageToBufferInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyImageToBufferInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcImage = t.srcImage,
			srcImageLayout = t.srcImageLayout and mod.e.VkImageLayout(t.srcImageLayout),
			dstBuffer = t.dstBuffer,
			regionCount = t.regionCount,
			pRegions = t.pRegions,
		}
	)
end
mod.s.ImageBlit2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageBlit2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcSubresource = t.srcSubresource,
			srcOffsets = t.srcOffsets,
			dstSubresource = t.dstSubresource,
			dstOffsets = t.dstOffsets,
		}
	)
end
mod.s.RenderPassStripeSubmitInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassStripeSubmitInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stripeSemaphoreInfoCount = t.stripeSemaphoreInfoCount,
			pStripeSemaphoreInfos = t.pStripeSemaphoreInfos,
		}
	)
end
mod.s.ImageResolve2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageResolve2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcSubresource = t.srcSubresource,
			srcOffset = t.srcOffset,
			dstSubresource = t.dstSubresource,
			dstOffset = t.dstOffset,
			extent = t.extent,
		}
	)
end
mod.s.ResolveImageInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkResolveImageInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcImage = t.srcImage,
			srcImageLayout = t.srcImageLayout and mod.e.VkImageLayout(t.srcImageLayout),
			dstImage = t.dstImage,
			dstImageLayout = t.dstImageLayout and mod.e.VkImageLayout(t.dstImageLayout),
			regionCount = t.regionCount,
			pRegions = t.pRegions,
		}
	)
end
mod.s.PhysicalDeviceSubgroupSizeControlFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSubgroupSizeControlFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			subgroupSizeControl = t.subgroupSizeControl,
			computeFullSubgroups = t.computeFullSubgroups,
		}
	)
end
mod.s.PhysicalDeviceSubgroupSizeControlProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSubgroupSizeControlProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minSubgroupSize = t.minSubgroupSize,
			maxSubgroupSize = t.maxSubgroupSize,
			maxComputeWorkgroupSubgroups = t.maxComputeWorkgroupSubgroups,
			requiredSubgroupSizeStages = t.requiredSubgroupSizeStages and
				mod.e.VkShaderStageFlagBits(t.requiredSubgroupSizeStages),
		}
	)
end
mod.s.PipelineShaderStageRequiredSubgroupSizeCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			requiredSubgroupSize = t.requiredSubgroupSize,
		}
	)
end
mod.s.VideoDecodeCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
		}
	)
end
mod.s.PhysicalDeviceInlineUniformBlockFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceInlineUniformBlockFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			inlineUniformBlock = t.inlineUniformBlock,
			descriptorBindingInlineUniformBlockUpdateAfterBind = t.descriptorBindingInlineUniformBlockUpdateAfterBind,
		}
	)
end
mod.s.PhysicalDeviceInlineUniformBlockProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceInlineUniformBlockProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxInlineUniformBlockSize = t.maxInlineUniformBlockSize,
			maxPerStageDescriptorInlineUniformBlocks = t.maxPerStageDescriptorInlineUniformBlocks,
			maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = t.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks,
			maxDescriptorSetInlineUniformBlocks = t.maxDescriptorSetInlineUniformBlocks,
			maxDescriptorSetUpdateAfterBindInlineUniformBlocks = t.maxDescriptorSetUpdateAfterBindInlineUniformBlocks,
		}
	)
end
mod.s.WriteDescriptorSetInlineUniformBlock = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkWriteDescriptorSetInlineUniformBlock(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dataSize = t.dataSize,
			pData = t.pData,
		}
	)
end
mod.s.DescriptorPoolInlineUniformBlockCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorPoolInlineUniformBlockCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxInlineUniformBlockBindings = t.maxInlineUniformBlockBindings,
		}
	)
end
mod.s.PhysicalDeviceTextureCompressionASTCHDRFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTextureCompressionASTCHDRFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			textureCompressionASTC_HDR = t.textureCompressionASTC_HDR,
		}
	)
end
mod.s.StdVideoEncodeH264RefPicMarkingEntry = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoEncodeH264RefPicMarkingEntry(
		{
			memory_management_control_operation = t.memory_management_control_operation and
				mod.e.StdVideoH264MemMgmtControlOp(t.memory_management_control_operation),
			difference_of_pic_nums_minus1 = t.difference_of_pic_nums_minus1,
			long_term_pic_num = t.long_term_pic_num,
			long_term_frame_idx = t.long_term_frame_idx,
			max_long_term_frame_idx_plus1 = t.max_long_term_frame_idx_plus1,
		}
	)
end
mod.s.PipelineCoverageModulationStateCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineCoverageModulationStateCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			coverageModulationMode = t.coverageModulationMode and
				mod.e.VkCoverageModulationModeNV(t.coverageModulationMode),
			coverageModulationTableEnable = t.coverageModulationTableEnable,
			coverageModulationTableCount = t.coverageModulationTableCount,
			pCoverageModulationTable = t.pCoverageModulationTable,
		}
	)
end
mod.s.RenderingInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderingInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkRenderingFlagBits(t.flags),
			renderArea = t.renderArea,
			layerCount = t.layerCount,
			viewMask = t.viewMask,
			colorAttachmentCount = t.colorAttachmentCount,
			pColorAttachments = t.pColorAttachments,
			pDepthAttachment = t.pDepthAttachment,
			pStencilAttachment = t.pStencilAttachment,
		}
	)
end
mod.s.PipelineRenderingCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineRenderingCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			viewMask = t.viewMask,
			colorAttachmentCount = t.colorAttachmentCount,
			pColorAttachmentFormats = t.pColorAttachmentFormats,
			depthAttachmentFormat = t.depthAttachmentFormat and mod.e.VkFormat(t.depthAttachmentFormat),
			stencilAttachmentFormat = t.stencilAttachmentFormat and mod.e.VkFormat(t.stencilAttachmentFormat),
		}
	)
end
mod.s.PhysicalDeviceDynamicRenderingFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDynamicRenderingFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dynamicRendering = t.dynamicRendering,
		}
	)
end
mod.s.CommandBufferInheritanceRenderingInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCommandBufferInheritanceRenderingInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkRenderingFlagBits(t.flags),
			viewMask = t.viewMask,
			colorAttachmentCount = t.colorAttachmentCount,
			pColorAttachmentFormats = t.pColorAttachmentFormats,
			depthAttachmentFormat = t.depthAttachmentFormat and mod.e.VkFormat(t.depthAttachmentFormat),
			stencilAttachmentFormat = t.stencilAttachmentFormat and mod.e.VkFormat(t.stencilAttachmentFormat),
			rasterizationSamples = t.rasterizationSamples and mod.e.VkSampleCountFlagBits(t.rasterizationSamples),
		}
	)
end
mod.s.PhysicalDeviceShaderIntegerDotProductFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderIntegerDotProductFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderIntegerDotProduct = t.shaderIntegerDotProduct,
		}
	)
end
mod.s.PhysicalDeviceShaderIntegerDotProductProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderIntegerDotProductProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			integerDotProduct8BitUnsignedAccelerated = t.integerDotProduct8BitUnsignedAccelerated,
			integerDotProduct8BitSignedAccelerated = t.integerDotProduct8BitSignedAccelerated,
			integerDotProduct8BitMixedSignednessAccelerated = t.integerDotProduct8BitMixedSignednessAccelerated,
			integerDotProduct4x8BitPackedUnsignedAccelerated = t.integerDotProduct4x8BitPackedUnsignedAccelerated,
			integerDotProduct4x8BitPackedSignedAccelerated = t.integerDotProduct4x8BitPackedSignedAccelerated,
			integerDotProduct4x8BitPackedMixedSignednessAccelerated = t.integerDotProduct4x8BitPackedMixedSignednessAccelerated,
			integerDotProduct16BitUnsignedAccelerated = t.integerDotProduct16BitUnsignedAccelerated,
			integerDotProduct16BitSignedAccelerated = t.integerDotProduct16BitSignedAccelerated,
			integerDotProduct16BitMixedSignednessAccelerated = t.integerDotProduct16BitMixedSignednessAccelerated,
			integerDotProduct32BitUnsignedAccelerated = t.integerDotProduct32BitUnsignedAccelerated,
			integerDotProduct32BitSignedAccelerated = t.integerDotProduct32BitSignedAccelerated,
			integerDotProduct32BitMixedSignednessAccelerated = t.integerDotProduct32BitMixedSignednessAccelerated,
			integerDotProduct64BitUnsignedAccelerated = t.integerDotProduct64BitUnsignedAccelerated,
			integerDotProduct64BitSignedAccelerated = t.integerDotProduct64BitSignedAccelerated,
			integerDotProduct64BitMixedSignednessAccelerated = t.integerDotProduct64BitMixedSignednessAccelerated,
			integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated,
			integerDotProductAccumulatingSaturating8BitSignedAccelerated = t.integerDotProductAccumulatingSaturating8BitSignedAccelerated,
			integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated,
			integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = t.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated,
			integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = t.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated,
			integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated,
			integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated,
			integerDotProductAccumulatingSaturating16BitSignedAccelerated = t.integerDotProductAccumulatingSaturating16BitSignedAccelerated,
			integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated,
			integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated,
			integerDotProductAccumulatingSaturating32BitSignedAccelerated = t.integerDotProductAccumulatingSaturating32BitSignedAccelerated,
			integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated,
			integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated,
			integerDotProductAccumulatingSaturating64BitSignedAccelerated = t.integerDotProductAccumulatingSaturating64BitSignedAccelerated,
			integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated,
		}
	)
end
mod.s.PhysicalDeviceTexelBufferAlignmentProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTexelBufferAlignmentProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			storageTexelBufferOffsetAlignmentBytes = t.storageTexelBufferOffsetAlignmentBytes,
			storageTexelBufferOffsetSingleTexelAlignment = t.storageTexelBufferOffsetSingleTexelAlignment,
			uniformTexelBufferOffsetAlignmentBytes = t.uniformTexelBufferOffsetAlignmentBytes,
			uniformTexelBufferOffsetSingleTexelAlignment = t.uniformTexelBufferOffsetSingleTexelAlignment,
		}
	)
end
mod.s.PhysicalDeviceShaderSMBuiltinsPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderSMCount = t.shaderSMCount,
			shaderWarpsPerSM = t.shaderWarpsPerSM,
		}
	)
end
mod.s.PhysicalDeviceMaintenance4Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance4Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maintenance4 = t.maintenance4,
		}
	)
end
mod.s.PhysicalDeviceMaintenance4Properties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance4Properties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxBufferSize = t.maxBufferSize,
		}
	)
end
mod.s.DeviceBufferMemoryRequirements = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceBufferMemoryRequirements(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pCreateInfo = t.pCreateInfo,
		}
	)
end
mod.s.DeviceImageMemoryRequirements = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceImageMemoryRequirements(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pCreateInfo = t.pCreateInfo,
			planeAspect = t.planeAspect and mod.e.VkImageAspectFlagBits(t.planeAspect),
		}
	)
end
mod.s.ColorBlendEquationEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkColorBlendEquationEXT(
		{
			srcColorBlendFactor = t.srcColorBlendFactor and mod.e.VkBlendFactor(t.srcColorBlendFactor),
			dstColorBlendFactor = t.dstColorBlendFactor and mod.e.VkBlendFactor(t.dstColorBlendFactor),
			colorBlendOp = t.colorBlendOp and mod.e.VkBlendOp(t.colorBlendOp),
			srcAlphaBlendFactor = t.srcAlphaBlendFactor and mod.e.VkBlendFactor(t.srcAlphaBlendFactor),
			dstAlphaBlendFactor = t.dstAlphaBlendFactor and mod.e.VkBlendFactor(t.dstAlphaBlendFactor),
			alphaBlendOp = t.alphaBlendOp and mod.e.VkBlendOp(t.alphaBlendOp),
		}
	)
end
mod.s.ColorBlendAdvancedEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkColorBlendAdvancedEXT(
		{
			advancedBlendOp = t.advancedBlendOp and mod.e.VkBlendOp(t.advancedBlendOp),
			srcPremultiplied = t.srcPremultiplied,
			dstPremultiplied = t.dstPremultiplied,
			blendOverlap = t.blendOverlap and mod.e.VkBlendOverlapEXT(t.blendOverlap),
			clampResults = t.clampResults,
		}
	)
end
mod.s.StdVideoEncodeH264ReferenceInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoEncodeH264ReferenceInfo(
		{
			flags = t.flags,
			primary_pic_type = t.primary_pic_type and mod.e.StdVideoH264PictureType(t.primary_pic_type),
			FrameNum = t.FrameNum,
			PicOrderCnt = t.PicOrderCnt,
			long_term_pic_num = t.long_term_pic_num,
			long_term_frame_idx = t.long_term_frame_idx,
			temporal_id = t.temporal_id,
		}
	)
end
mod.s.StdVideoEncodeH264SliceHeader = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoEncodeH264SliceHeader(
		{
			flags = t.flags,
			first_mb_in_slice = t.first_mb_in_slice,
			slice_type = t.slice_type and mod.e.StdVideoH264SliceType(t.slice_type),
			slice_alpha_c0_offset_div2 = t.slice_alpha_c0_offset_div2,
			slice_beta_offset_div2 = t.slice_beta_offset_div2,
			slice_qp_delta = t.slice_qp_delta,
			reserved1 = t.reserved1,
			cabac_init_idc = t.cabac_init_idc and mod.e.StdVideoH264CabacInitIdc(t.cabac_init_idc),
			disable_deblocking_filter_idc = t.disable_deblocking_filter_idc and
				mod.e.StdVideoH264DisableDeblockingFilterIdc(t.disable_deblocking_filter_idc),
			pWeightTable = t.pWeightTable,
		}
	)
end
mod.s.DrmFormatModifierPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDrmFormatModifierPropertiesEXT(
		{
			drmFormatModifier = t.drmFormatModifier,
			drmFormatModifierPlaneCount = t.drmFormatModifierPlaneCount,
			drmFormatModifierTilingFeatures = t.drmFormatModifierTilingFeatures and
				mod.e.VkFormatFeatureFlagBits(t.drmFormatModifierTilingFeatures),
		}
	)
end
mod.s.DrmFormatModifierPropertiesListEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDrmFormatModifierPropertiesListEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			drmFormatModifierCount = t.drmFormatModifierCount,
			pDrmFormatModifierProperties = t.pDrmFormatModifierProperties,
		}
	)
end
mod.s.PhysicalDeviceImageDrmFormatModifierInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			drmFormatModifier = t.drmFormatModifier,
			sharingMode = t.sharingMode and mod.e.VkSharingMode(t.sharingMode),
			queueFamilyIndexCount = t.queueFamilyIndexCount,
			pQueueFamilyIndices = t.pQueueFamilyIndices,
		}
	)
end
mod.s.ImageDrmFormatModifierListCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageDrmFormatModifierListCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			drmFormatModifierCount = t.drmFormatModifierCount,
			pDrmFormatModifiers = t.pDrmFormatModifiers,
		}
	)
end
mod.s.ImageDrmFormatModifierExplicitCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageDrmFormatModifierExplicitCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			drmFormatModifier = t.drmFormatModifier,
			drmFormatModifierPlaneCount = t.drmFormatModifierPlaneCount,
			pPlaneLayouts = t.pPlaneLayouts,
		}
	)
end
mod.s.ImageDrmFormatModifierPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageDrmFormatModifierPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			drmFormatModifier = t.drmFormatModifier,
		}
	)
end
mod.s.DrmFormatModifierPropertiesList2EXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDrmFormatModifierPropertiesList2EXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			drmFormatModifierCount = t.drmFormatModifierCount,
			pDrmFormatModifierProperties = t.pDrmFormatModifierProperties,
		}
	)
end
mod.s.PhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoEncodeRgbConversion = t.videoEncodeRgbConversion,
		}
	)
end
mod.s.PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineCacheIncrementalMode = t.pipelineCacheIncrementalMode,
		}
	)
end
mod.s.ShaderModuleValidationCacheCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkShaderModuleValidationCacheCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			validationCache = t.validationCache,
		}
	)
end
mod.s.VideoEncodeProfileRgbConversionInfoVALVE = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeProfileRgbConversionInfoVALVE(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			performEncodeRgbConversion = t.performEncodeRgbConversion,
		}
	)
end
mod.s.VideoEncodeSessionRgbConversionCreateInfoVALVE = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeSessionRgbConversionCreateInfoVALVE(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rgbModel = t.rgbModel and mod.e.VkVideoEncodeRgbModelConversionFlagBitsVALVE(t.rgbModel),
			rgbRange = t.rgbRange and mod.e.VkVideoEncodeRgbRangeCompressionFlagBitsVALVE(t.rgbRange),
			xChromaOffset = t.xChromaOffset and
				mod.e.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE(t.xChromaOffset),
			yChromaOffset = t.yChromaOffset and
				mod.e.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE(t.yChromaOffset),
		}
	)
end
mod.s.PhysicalDeviceImageViewMinLodFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageViewMinLodFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minLod = t.minLod,
		}
	)
end
mod.s.ImageViewMinLodCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageViewMinLodCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minLod = t.minLod,
		}
	)
end
mod.s.PhysicalDeviceMultiDrawFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMultiDrawFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			multiDraw = t.multiDraw,
		}
	)
end
mod.s.PhysicalDeviceMultiDrawPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMultiDrawPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxMultiDrawCount = t.maxMultiDrawCount,
		}
	)
end
mod.s.AccelerationStructureGeometryInstancesDataKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureGeometryInstancesDataKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			arrayOfPointers = t.arrayOfPointers,
			data = t.data,
		}
	)
end
mod.s.AccelerationStructureGeometryKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureGeometryKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			geometryType = t.geometryType and mod.e.VkGeometryTypeKHR(t.geometryType),
			geometry = t.geometry,
			flags = t.flags,
		}
	)
end
mod.s.AccelerationStructureBuildGeometryInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureBuildGeometryInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type and mod.e.VkAccelerationStructureTypeKHR(t.type),
			flags = t.flags,
			mode = t.mode and mod.e.VkBuildAccelerationStructureModeKHR(t.mode),
			srcAccelerationStructure = t.srcAccelerationStructure,
			dstAccelerationStructure = t.dstAccelerationStructure,
			geometryCount = t.geometryCount,
			pGeometries = t.pGeometries,
			ppGeometries = t.ppGeometries,
			scratchData = t.scratchData,
		}
	)
end
mod.s.VideoEncodeH264CapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264CapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			maxLevelIdc = t.maxLevelIdc and mod.e.StdVideoH264LevelIdc(t.maxLevelIdc),
			maxSliceCount = t.maxSliceCount,
			maxPPictureL0ReferenceCount = t.maxPPictureL0ReferenceCount,
			maxBPictureL0ReferenceCount = t.maxBPictureL0ReferenceCount,
			maxL1ReferenceCount = t.maxL1ReferenceCount,
			maxTemporalLayerCount = t.maxTemporalLayerCount,
			expectDyadicTemporalLayerPattern = t.expectDyadicTemporalLayerPattern,
			minQp = t.minQp,
			maxQp = t.maxQp,
			prefersGopRemainingFrames = t.prefersGopRemainingFrames,
			requiresGopRemainingFrames = t.requiresGopRemainingFrames,
			stdSyntaxFlags = t.stdSyntaxFlags,
		}
	)
end
mod.s.WriteDescriptorSetAccelerationStructureKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkWriteDescriptorSetAccelerationStructureKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			accelerationStructureCount = t.accelerationStructureCount,
			pAccelerationStructures = t.pAccelerationStructures,
		}
	)
end
mod.s.PhysicalDeviceAccelerationStructureFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceAccelerationStructureFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			accelerationStructure = t.accelerationStructure,
			accelerationStructureCaptureReplay = t.accelerationStructureCaptureReplay,
			accelerationStructureIndirectBuild = t.accelerationStructureIndirectBuild,
			accelerationStructureHostCommands = t.accelerationStructureHostCommands,
			descriptorBindingAccelerationStructureUpdateAfterBind = t.descriptorBindingAccelerationStructureUpdateAfterBind,
		}
	)
end
mod.s.PhysicalDeviceImage2DViewOf3DFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			image2DViewOf3D = t.image2DViewOf3D,
			sampler2DViewOf3D = t.sampler2DViewOf3D,
		}
	)
end
mod.s.PhysicalDeviceAccelerationStructurePropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceAccelerationStructurePropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxGeometryCount = t.maxGeometryCount,
			maxInstanceCount = t.maxInstanceCount,
			maxPrimitiveCount = t.maxPrimitiveCount,
			maxPerStageDescriptorAccelerationStructures = t.maxPerStageDescriptorAccelerationStructures,
			maxPerStageDescriptorUpdateAfterBindAccelerationStructures = t.maxPerStageDescriptorUpdateAfterBindAccelerationStructures,
			maxDescriptorSetAccelerationStructures = t.maxDescriptorSetAccelerationStructures,
			maxDescriptorSetUpdateAfterBindAccelerationStructures = t.maxDescriptorSetUpdateAfterBindAccelerationStructures,
			minAccelerationStructureScratchOffsetAlignment = t.minAccelerationStructureScratchOffsetAlignment,
		}
	)
end
mod.s.PhysicalDeviceShaderTileImageFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderTileImageFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderTileImageColorReadAccess = t.shaderTileImageColorReadAccess,
			shaderTileImageDepthReadAccess = t.shaderTileImageDepthReadAccess,
			shaderTileImageStencilReadAccess = t.shaderTileImageStencilReadAccess,
		}
	)
end
mod.s.AccelerationStructureDeviceAddressInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureDeviceAddressInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			accelerationStructure = t.accelerationStructure,
		}
	)
end
mod.s.AccelerationStructureVersionInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureVersionInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pVersionData = t.pVersionData,
		}
	)
end
mod.s.PhysicalDeviceShaderTileImagePropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderTileImagePropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderTileImageCoherentReadAccelerated = t.shaderTileImageCoherentReadAccelerated,
			shaderTileImageReadSampleFromPixelRateInvocation = t.shaderTileImageReadSampleFromPixelRateInvocation,
			shaderTileImageReadFromHelperInvocation = t.shaderTileImageReadFromHelperInvocation,
		}
	)
end
mod.s.CopyMemoryToAccelerationStructureInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyMemoryToAccelerationStructureInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			src = t.src,
			dst = t.dst,
			mode = t.mode and mod.e.VkCopyAccelerationStructureModeKHR(t.mode),
		}
	)
end
mod.s.CopyAccelerationStructureInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyAccelerationStructureInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			src = t.src,
			dst = t.dst,
			mode = t.mode and mod.e.VkCopyAccelerationStructureModeKHR(t.mode),
		}
	)
end
mod.s.PipelineViewportShadingRateImageStateCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineViewportShadingRateImageStateCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shadingRateImageEnable = t.shadingRateImageEnable,
			viewportCount = t.viewportCount,
			pShadingRatePalettes = t.pShadingRatePalettes,
		}
	)
end
mod.s.PhysicalDeviceShadingRateImageFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShadingRateImageFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shadingRateImage = t.shadingRateImage,
			shadingRateCoarseSampleOrder = t.shadingRateCoarseSampleOrder,
		}
	)
end
mod.s.VideoEncodeH264SessionCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264SessionCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			useMaxLevelIdc = t.useMaxLevelIdc,
			maxLevelIdc = t.maxLevelIdc and mod.e.StdVideoH264LevelIdc(t.maxLevelIdc),
		}
	)
end
mod.s.VideoEncodeH264SessionParametersAddInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264SessionParametersAddInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stdSPSCount = t.stdSPSCount,
			pStdSPSs = t.pStdSPSs,
			stdPPSCount = t.stdPPSCount,
			pStdPPSs = t.pStdPPSs,
		}
	)
end
mod.s.PhysicalDeviceSubpassMergeFeedbackFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			subpassMergeFeedback = t.subpassMergeFeedback,
		}
	)
end
mod.s.RenderPassCreationControlEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassCreationControlEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			disallowMerging = t.disallowMerging,
		}
	)
end
mod.s.TextureLODGatherFormatPropertiesAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTextureLODGatherFormatPropertiesAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			supportsTextureGatherLODBiasAMD = t.supportsTextureGatherLODBiasAMD,
		}
	)
end
mod.s.VideoEncodeH264SessionParametersCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264SessionParametersCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxStdSPSCount = t.maxStdSPSCount,
			maxStdPPSCount = t.maxStdPPSCount,
			pParametersAddInfo = t.pParametersAddInfo,
		}
	)
end
mod.s.RenderPassCreationFeedbackCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassCreationFeedbackCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pRenderPassFeedback = t.pRenderPassFeedback,
		}
	)
end
mod.s.CoarseSampleOrderCustomNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCoarseSampleOrderCustomNV(
		{
			shadingRate = t.shadingRate and mod.e.VkShadingRatePaletteEntryNV(t.shadingRate),
			sampleCount = t.sampleCount,
			sampleLocationCount = t.sampleLocationCount,
			pSampleLocations = t.pSampleLocations,
		}
	)
end
mod.s.RenderPassSubpassFeedbackInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassSubpassFeedbackInfoEXT(
		{
			subpassMergeStatus = t.subpassMergeStatus and mod.e.VkSubpassMergeStatusEXT(t.subpassMergeStatus),
			description = t.description,
			postMergeIndex = t.postMergeIndex,
		}
	)
end
mod.s.VideoEncodeH264SessionParametersGetInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264SessionParametersGetInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			writeStdSPS = t.writeStdSPS,
			writeStdPPS = t.writeStdPPS,
			stdSPSId = t.stdSPSId,
			stdPPSId = t.stdPPSId,
		}
	)
end
mod.s.PipelineViewportCoarseSampleOrderStateCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			sampleOrderType = t.sampleOrderType and mod.e.VkCoarseSampleOrderTypeNV(t.sampleOrderType),
			customSampleOrderCount = t.customSampleOrderCount,
			pCustomSampleOrders = t.pCustomSampleOrders,
		}
	)
end
mod.s.VideoEncodeH264SessionParametersFeedbackInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264SessionParametersFeedbackInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			hasStdSPSOverrides = t.hasStdSPSOverrides,
			hasStdPPSOverrides = t.hasStdPPSOverrides,
		}
	)
end
mod.s.VideoEncodeH264NaluSliceInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264NaluSliceInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			constantQp = t.constantQp,
			pStdSliceHeader = t.pStdSliceHeader,
		}
	)
end
mod.s.ShaderStatisticsInfoAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkShaderStatisticsInfoAMD(
		{
			shaderStageMask = t.shaderStageMask and mod.e.VkShaderStageFlagBits(t.shaderStageMask),
			resourceUsage = t.resourceUsage,
			numPhysicalVgprs = t.numPhysicalVgprs,
			numPhysicalSgprs = t.numPhysicalSgprs,
			numAvailableVgprs = t.numAvailableVgprs,
			numAvailableSgprs = t.numAvailableSgprs,
			computeWorkGroupSize = t.computeWorkGroupSize,
		}
	)
end
mod.s.VideoEncodeH264PictureInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264PictureInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			naluSliceEntryCount = t.naluSliceEntryCount,
			pNaluSliceEntries = t.pNaluSliceEntries,
			pStdPictureInfo = t.pStdPictureInfo,
			generatePrefixNalu = t.generatePrefixNalu,
		}
	)
end
mod.s.VideoEncodeH264DpbSlotInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264DpbSlotInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdReferenceInfo = t.pStdReferenceInfo,
		}
	)
end
mod.s.VideoEncodeH264ProfileInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264ProfileInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stdProfileIdc = t.stdProfileIdc and mod.e.StdVideoH264ProfileIdc(t.stdProfileIdc),
		}
	)
end
mod.s.DescriptorSetVariableDescriptorCountLayoutSupport = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorSetVariableDescriptorCountLayoutSupport(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxVariableDescriptorCount = t.maxVariableDescriptorCount,
		}
	)
end
mod.s.VideoEncodeH264RateControlInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264RateControlInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			gopFrameCount = t.gopFrameCount,
			idrPeriod = t.idrPeriod,
			consecutiveBFrameCount = t.consecutiveBFrameCount,
			temporalLayerCount = t.temporalLayerCount,
		}
	)
end
mod.s.PhysicalDeviceSeparateDepthStencilLayoutsFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			separateDepthStencilLayouts = t.separateDepthStencilLayouts,
		}
	)
end
mod.s.BindDescriptorSetsInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindDescriptorSetsInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stageFlags = t.stageFlags and mod.e.VkShaderStageFlagBits(t.stageFlags),
			layout = t.layout,
			firstSet = t.firstSet,
			descriptorSetCount = t.descriptorSetCount,
			pDescriptorSets = t.pDescriptorSets,
			dynamicOffsetCount = t.dynamicOffsetCount,
			pDynamicOffsets = t.pDynamicOffsets,
		}
	)
end
mod.s.CommandBufferInheritanceRenderPassTransformInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			transform = t.transform and mod.e.VkSurfaceTransformFlagBitsKHR(t.transform),
			renderArea = t.renderArea,
		}
	)
end
mod.s.PhysicalDeviceCopyMemoryIndirectPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			supportedQueues = t.supportedQueues and mod.e.VkQueueFlagBits(t.supportedQueues),
		}
	)
end
mod.s.RayTracingShaderGroupCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRayTracingShaderGroupCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type and mod.e.VkRayTracingShaderGroupTypeKHR(t.type),
			generalShader = t.generalShader,
			closestHitShader = t.closestHitShader,
			anyHitShader = t.anyHitShader,
			intersectionShader = t.intersectionShader,
			pShaderGroupCaptureReplayHandle = t.pShaderGroupCaptureReplayHandle,
		}
	)
end
mod.s.PipelineShaderStageCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineShaderStageCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkPipelineShaderStageCreateFlagBits(t.flags),
			stage = t.stage and mod.e.VkShaderStageFlagBits(t.stage),
			module = t.module,
			pName = t.pName,
			pSpecializationInfo = t.pSpecializationInfo,
		}
	)
end
mod.s.RayTracingPipelineInterfaceCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRayTracingPipelineInterfaceCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxPipelineRayPayloadSize = t.maxPipelineRayPayloadSize,
			maxPipelineRayHitAttributeSize = t.maxPipelineRayHitAttributeSize,
		}
	)
end
mod.s.DirectFBSurfaceCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDirectFBSurfaceCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			dfb = t.dfb,
			surface = t.surface,
		}
	)
end
mod.s.VideoEncodeH264RateControlLayerInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264RateControlLayerInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			useMinQp = t.useMinQp,
			minQp = t.minQp,
			useMaxQp = t.useMaxQp,
			maxQp = t.maxQp,
			useMaxFrameSize = t.useMaxFrameSize,
			maxFrameSize = t.maxFrameSize,
		}
	)
end
mod.s.PhysicalDeviceCornerSampledImageFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCornerSampledImageFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cornerSampledImage = t.cornerSampledImage,
		}
	)
end
mod.s.MemoryRequirements2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryRequirements2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memoryRequirements = t.memoryRequirements,
		}
	)
end
mod.s.SurfacePresentScalingCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfacePresentScalingCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			supportedPresentScaling = t.supportedPresentScaling,
			supportedPresentGravityX = t.supportedPresentGravityX,
			supportedPresentGravityY = t.supportedPresentGravityY,
			minScaledImageExtent = t.minScaledImageExtent,
			maxScaledImageExtent = t.maxScaledImageExtent,
		}
	)
end
mod.s.StdVideoEncodeH265ReferenceInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoEncodeH265ReferenceInfo(
		{
			flags = t.flags,
			pic_type = t.pic_type and mod.e.StdVideoH265PictureType(t.pic_type),
			PicOrderCntVal = t.PicOrderCntVal,
			TemporalId = t.TemporalId,
		}
	)
end
mod.s.VideoEncodeH264GopRemainingFrameInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264GopRemainingFrameInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			useGopRemainingFrames = t.useGopRemainingFrames,
			gopRemainingI = t.gopRemainingI,
			gopRemainingP = t.gopRemainingP,
			gopRemainingB = t.gopRemainingB,
		}
	)
end
mod.s.PhysicalDeviceRayTracingPipelineFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rayTracingPipeline = t.rayTracingPipeline,
			rayTracingPipelineShaderGroupHandleCaptureReplay = t.rayTracingPipelineShaderGroupHandleCaptureReplay,
			rayTracingPipelineShaderGroupHandleCaptureReplayMixed = t.rayTracingPipelineShaderGroupHandleCaptureReplayMixed,
			rayTracingPipelineTraceRaysIndirect = t.rayTracingPipelineTraceRaysIndirect,
			rayTraversalPrimitiveCulling = t.rayTraversalPrimitiveCulling,
		}
	)
end
mod.s.PipelineColorBlendStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineColorBlendStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkPipelineColorBlendStateCreateFlagBits(t.flags),
			logicOpEnable = t.logicOpEnable,
			logicOp = t.logicOp and mod.e.VkLogicOp(t.logicOp),
			attachmentCount = t.attachmentCount,
			pAttachments = t.pAttachments,
			blendConstants = t.blendConstants,
		}
	)
end
mod.s.ImageToMemoryCopy = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageToMemoryCopy(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pHostPointer = t.pHostPointer,
			memoryRowLength = t.memoryRowLength,
			memoryImageHeight = t.memoryImageHeight,
			imageSubresource = t.imageSubresource,
			imageOffset = t.imageOffset,
			imageExtent = t.imageExtent,
		}
	)
end
mod.s.SwapchainPresentScalingCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSwapchainPresentScalingCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			scalingBehavior = t.scalingBehavior,
			presentGravityX = t.presentGravityX,
			presentGravityY = t.presentGravityY,
		}
	)
end
mod.s.MemoryGetMetalHandleInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryGetMetalHandleInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memory = t.memory,
			handleType = t.handleType and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType),
		}
	)
end
mod.s.DisplayPlaneCapabilities2KHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplayPlaneCapabilities2KHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			capabilities = t.capabilities,
		}
	)
end
mod.s.PhysicalDeviceRayTracingPipelinePropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderGroupHandleSize = t.shaderGroupHandleSize,
			maxRayRecursionDepth = t.maxRayRecursionDepth,
			maxShaderGroupStride = t.maxShaderGroupStride,
			shaderGroupBaseAlignment = t.shaderGroupBaseAlignment,
			shaderGroupHandleCaptureReplaySize = t.shaderGroupHandleCaptureReplaySize,
			maxRayDispatchInvocationCount = t.maxRayDispatchInvocationCount,
			shaderGroupHandleAlignment = t.shaderGroupHandleAlignment,
			maxRayHitAttributeSize = t.maxRayHitAttributeSize,
		}
	)
end
mod.s.CopyImageToImageInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyImageToImageInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkHostImageCopyFlagBits(t.flags),
			srcImage = t.srcImage,
			srcImageLayout = t.srcImageLayout and mod.e.VkImageLayout(t.srcImageLayout),
			dstImage = t.dstImage,
			dstImageLayout = t.dstImageLayout and mod.e.VkImageLayout(t.dstImageLayout),
			regionCount = t.regionCount,
			pRegions = t.pRegions,
		}
	)
end
mod.s.PhysicalDeviceMapMemoryPlacedPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minPlacedMemoryMapAlignment = t.minPlacedMemoryMapAlignment,
		}
	)
end
mod.s.ComponentMapping = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkComponentMapping(
		{
			r = t.r and mod.e.VkComponentSwizzle(t.r),
			g = t.g and mod.e.VkComponentSwizzle(t.g),
			b = t.b and mod.e.VkComponentSwizzle(t.b),
			a = t.a and mod.e.VkComponentSwizzle(t.a),
		}
	)
end
mod.s.QueueFamilyCheckpointProperties2NV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueueFamilyCheckpointProperties2NV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			checkpointExecutionStageMask = t.checkpointExecutionStageMask,
		}
	)
end
mod.s.VideoCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			minBitstreamBufferOffsetAlignment = t.minBitstreamBufferOffsetAlignment,
			minBitstreamBufferSizeAlignment = t.minBitstreamBufferSizeAlignment,
			pictureAccessGranularity = t.pictureAccessGranularity,
			minCodedExtent = t.minCodedExtent,
			maxCodedExtent = t.maxCodedExtent,
			maxDpbSlots = t.maxDpbSlots,
			maxActiveReferencePictures = t.maxActiveReferencePictures,
			stdHeaderVersion = t.stdHeaderVersion,
		}
	)
end
mod.s.PhysicalDeviceShaderBfloat16FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderBfloat16FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderBFloat16Type = t.shaderBFloat16Type,
			shaderBFloat16DotProduct = t.shaderBFloat16DotProduct,
			shaderBFloat16CooperativeMatrix = t.shaderBFloat16CooperativeMatrix,
		}
	)
end
mod.s.PhysicalDeviceExternalFormatResolveFeaturesANDROID = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			externalFormatResolve = t.externalFormatResolve,
		}
	)
end
mod.s.AndroidHardwareBufferFormatProperties2ANDROID = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAndroidHardwareBufferFormatProperties2ANDROID(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			format = t.format and mod.e.VkFormat(t.format),
			externalFormat = t.externalFormat,
			formatFeatures = t.formatFeatures,
			samplerYcbcrConversionComponents = t.samplerYcbcrConversionComponents,
			suggestedYcbcrModel = t.suggestedYcbcrModel and
				mod.e.VkSamplerYcbcrModelConversion(t.suggestedYcbcrModel),
			suggestedYcbcrRange = t.suggestedYcbcrRange and mod.e.VkSamplerYcbcrRange(t.suggestedYcbcrRange),
			suggestedXChromaOffset = t.suggestedXChromaOffset and mod.e.VkChromaLocation(t.suggestedXChromaOffset),
			suggestedYChromaOffset = t.suggestedYChromaOffset and mod.e.VkChromaLocation(t.suggestedYChromaOffset),
		}
	)
end
mod.s.ImageCompressionPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageCompressionPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageCompressionFlags = t.imageCompressionFlags,
			imageCompressionFixedRateFlags = t.imageCompressionFixedRateFlags,
		}
	)
end
mod.s.ImageCompressionControlEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageCompressionControlEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			compressionControlPlaneCount = t.compressionControlPlaneCount,
			pFixedRateFlags = t.pFixedRateFlags,
		}
	)
end
mod.s.PhysicalDeviceImageCompressionControlFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageCompressionControlFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageCompressionControl = t.imageCompressionControl,
		}
	)
end
mod.s.CopyCommandTransformInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyCommandTransformInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			transform = t.transform and mod.e.VkSurfaceTransformFlagBitsKHR(t.transform),
		}
	)
end
mod.s.PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			ycbcr2plane444Formats = t.ycbcr2plane444Formats,
		}
	)
end
mod.s.StreamDescriptorSurfaceCreateInfoGGP = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkStreamDescriptorSurfaceCreateInfoGGP(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			streamDescriptor = t.streamDescriptor,
		}
	)
end
mod.s.PhysicalDeviceRayTracingMotionBlurFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rayTracingMotionBlur = t.rayTracingMotionBlur,
			rayTracingMotionBlurPipelineTraceRaysIndirect = t.rayTracingMotionBlurPipelineTraceRaysIndirect,
		}
	)
end
mod.s.AccelerationStructureMotionInstanceNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureMotionInstanceNV(
		{
			type = t.type and mod.e.VkAccelerationStructureMotionInstanceTypeNV(t.type),
			flags = t.flags,
			data = t.data,
		}
	)
end
mod.s.VideoDecodeVP9CapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeVP9CapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxLevel = t.maxLevel and mod.e.StdVideoVP9Level(t.maxLevel),
		}
	)
end
mod.s.VideoFormatH265QuantizationMapPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoFormatH265QuantizationMapPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			compatibleCtbSizes = t.compatibleCtbSizes,
		}
	)
end
mod.s.ExternalMemoryImageCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalMemoryImageCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleTypes = t.handleTypes,
		}
	)
end
mod.s.ExportMemoryAllocateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportMemoryAllocateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleTypes = t.handleTypes,
		}
	)
end
mod.s.PresentFrameTokenGGP = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPresentFrameTokenGGP(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			frameToken = t.frameToken,
		}
	)
end
mod.s.AccelerationStructureGeometryMotionTrianglesDataNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureGeometryMotionTrianglesDataNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vertexData = t.vertexData,
		}
	)
end
mod.s.PipelineFragmentShadingRateEnumStateCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shadingRateType = t.shadingRateType and mod.e.VkFragmentShadingRateTypeNV(t.shadingRateType),
			shadingRate = t.shadingRate and mod.e.VkFragmentShadingRateNV(t.shadingRate),
			combinerOps = t.combinerOps and mod.e.VkFragmentShadingRateCombinerOpKHR(t.combinerOps),
		}
	)
end
mod.s.PhysicalDeviceFragmentShadingRateEnumsPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxFragmentShadingRateInvocationCount = t.maxFragmentShadingRateInvocationCount and
				mod.e.VkSampleCountFlagBits(t.maxFragmentShadingRateInvocationCount),
		}
	)
end
mod.s.RenderingEndInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderingEndInfoEXT({
		sType = t.sType and mod.e.VkStructureType(t.sType),
		pNext = t.pNext,
	})
end
mod.s.GraphicsPipelineLibraryCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGraphicsPipelineLibraryCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
		}
	)
end
mod.s.ImageAlignmentControlCreateInfoMESA = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageAlignmentControlCreateInfoMESA(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maximumRequestedAlignment = t.maximumRequestedAlignment,
		}
	)
end
mod.s.ValidationFlagsEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkValidationFlagsEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			disabledValidationCheckCount = t.disabledValidationCheckCount,
			pDisabledValidationChecks = t.pDisabledValidationChecks,
		}
	)
end
mod.s.PhysicalDeviceRayQueryFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRayQueryFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rayQuery = t.rayQuery,
		}
	)
end
mod.s.PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			graphicsPipelineLibrary = t.graphicsPipelineLibrary,
		}
	)
end
mod.s.VertexInputAttributeDescription = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVertexInputAttributeDescription(
		{
			location = t.location,
			binding = t.binding,
			format = t.format and mod.e.VkFormat(t.format),
			offset = t.offset,
		}
	)
end
mod.s.AccelerationStructureCaptureDescriptorDataInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureCaptureDescriptorDataInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			accelerationStructure = t.accelerationStructure,
			accelerationStructureNV = t.accelerationStructureNV,
		}
	)
end
mod.s.SamplerCaptureDescriptorDataInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSamplerCaptureDescriptorDataInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			sampler = t.sampler,
		}
	)
end
mod.s.PhysicalDeviceProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceProperties(
		{
			apiVersion = t.apiVersion,
			driverVersion = t.driverVersion,
			vendorID = t.vendorID,
			deviceID = t.deviceID,
			deviceType = t.deviceType and mod.e.VkPhysicalDeviceType(t.deviceType),
			deviceName = t.deviceName,
			pipelineCacheUUID = t.pipelineCacheUUID,
			limits = t.limits,
			sparseProperties = t.sparseProperties,
		}
	)
end
mod.s.BufferCaptureDescriptorDataInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferCaptureDescriptorDataInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			buffer = t.buffer,
		}
	)
end
mod.s.DescriptorBufferBindingInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorBufferBindingInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			address = t.address,
			usage = t.usage and mod.e.VkBufferUsageFlagBits(t.usage),
		}
	)
end
mod.s.PhysicalDeviceScalarBlockLayoutFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceScalarBlockLayoutFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			scalarBlockLayout = t.scalarBlockLayout,
		}
	)
end
mod.s.PhysicalDeviceMeshShaderPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMeshShaderPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxTaskWorkGroupTotalCount = t.maxTaskWorkGroupTotalCount,
			maxTaskWorkGroupCount = t.maxTaskWorkGroupCount,
			maxTaskWorkGroupInvocations = t.maxTaskWorkGroupInvocations,
			maxTaskWorkGroupSize = t.maxTaskWorkGroupSize,
			maxTaskPayloadSize = t.maxTaskPayloadSize,
			maxTaskSharedMemorySize = t.maxTaskSharedMemorySize,
			maxTaskPayloadAndSharedMemorySize = t.maxTaskPayloadAndSharedMemorySize,
			maxMeshWorkGroupTotalCount = t.maxMeshWorkGroupTotalCount,
			maxMeshWorkGroupCount = t.maxMeshWorkGroupCount,
			maxMeshWorkGroupInvocations = t.maxMeshWorkGroupInvocations,
			maxMeshWorkGroupSize = t.maxMeshWorkGroupSize,
			maxMeshSharedMemorySize = t.maxMeshSharedMemorySize,
			maxMeshPayloadAndSharedMemorySize = t.maxMeshPayloadAndSharedMemorySize,
			maxMeshOutputMemorySize = t.maxMeshOutputMemorySize,
			maxMeshPayloadAndOutputMemorySize = t.maxMeshPayloadAndOutputMemorySize,
			maxMeshOutputComponents = t.maxMeshOutputComponents,
			maxMeshOutputVertices = t.maxMeshOutputVertices,
			maxMeshOutputPrimitives = t.maxMeshOutputPrimitives,
			maxMeshOutputLayers = t.maxMeshOutputLayers,
			maxMeshMultiviewViewCount = t.maxMeshMultiviewViewCount,
			meshOutputPerVertexGranularity = t.meshOutputPerVertexGranularity,
			meshOutputPerPrimitiveGranularity = t.meshOutputPerPrimitiveGranularity,
			maxPreferredTaskWorkGroupInvocations = t.maxPreferredTaskWorkGroupInvocations,
			maxPreferredMeshWorkGroupInvocations = t.maxPreferredMeshWorkGroupInvocations,
			prefersLocalInvocationVertexOutput = t.prefersLocalInvocationVertexOutput,
			prefersLocalInvocationPrimitiveOutput = t.prefersLocalInvocationPrimitiveOutput,
			prefersCompactVertexOutput = t.prefersCompactVertexOutput,
			prefersCompactPrimitiveOutput = t.prefersCompactPrimitiveOutput,
		}
	)
end
mod.s.DescriptorSetLayoutHostMappingInfoVALVE = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorSetLayoutHostMappingInfoVALVE(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			descriptorOffset = t.descriptorOffset,
			descriptorSize = t.descriptorSize,
		}
	)
end
mod.s.DispatchTileInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDispatchTileInfoQCOM({
		sType = t.sType and mod.e.VkStructureType(t.sType),
		pNext = t.pNext,
	})
end
mod.s.ValidationCacheCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkValidationCacheCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			initialDataSize = t.initialDataSize,
			pInitialData = t.pInitialData,
		}
	)
end
mod.s.ScreenSurfaceCreateInfoQNX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkScreenSurfaceCreateInfoQNX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			context = t.context,
			window = t.window,
		}
	)
end
mod.s.DeviceDiagnosticsConfigCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceDiagnosticsConfigCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
		}
	)
end
mod.s.QueueFamilyProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueueFamilyProperties(
		{
			queueFlags = t.queueFlags and mod.e.VkQueueFlagBits(t.queueFlags),
			queueCount = t.queueCount,
			timestampValidBits = t.timestampValidBits,
			minImageTransferGranularity = t.minImageTransferGranularity,
		}
	)
end
mod.s.PhysicalDevicePresentBarrierFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePresentBarrierFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentBarrier = t.presentBarrier,
		}
	)
end
mod.s.ImageViewASTCDecodeModeEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageViewASTCDecodeModeEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			decodeMode = t.decodeMode and mod.e.VkFormat(t.decodeMode),
		}
	)
end
mod.s.DeviceDeviceMemoryReportCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceDeviceMemoryReportCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			pfnUserCallback = t.pfnUserCallback,
			pUserData = t.pUserData,
		}
	)
end
mod.s.PhysicalDeviceASTCDecodeFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceASTCDecodeFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			decodeModeSharedExponent = t.decodeModeSharedExponent,
		}
	)
end
mod.s.DeviceQueueCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceQueueCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkDeviceQueueCreateFlagBits(t.flags),
			queueFamilyIndex = t.queueFamilyIndex,
			queueCount = t.queueCount,
			pQueuePriorities = t.pQueuePriorities,
		}
	)
end
mod.s.PhysicalDeviceTexelBufferAlignmentFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			texelBufferAlignment = t.texelBufferAlignment,
		}
	)
end
mod.s.PhysicalDeviceClusterAccelerationStructureFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			clusterAccelerationStructure = t.clusterAccelerationStructure,
		}
	)
end
mod.s.DeviceCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			queueCreateInfoCount = t.queueCreateInfoCount,
			pQueueCreateInfos = t.pQueueCreateInfos,
			enabledLayerCount = t.enabledLayerCount,
			ppEnabledLayerNames = t.ppEnabledLayerNames,
			enabledExtensionCount = t.enabledExtensionCount,
			ppEnabledExtensionNames = t.ppEnabledExtensionNames,
			pEnabledFeatures = t.pEnabledFeatures,
		}
	)
end
mod.s.PhysicalDeviceClusterAccelerationStructurePropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxVerticesPerCluster = t.maxVerticesPerCluster,
			maxTrianglesPerCluster = t.maxTrianglesPerCluster,
			clusterScratchByteAlignment = t.clusterScratchByteAlignment,
			clusterByteAlignment = t.clusterByteAlignment,
			clusterTemplateByteAlignment = t.clusterTemplateByteAlignment,
			clusterBottomLevelByteAlignment = t.clusterBottomLevelByteAlignment,
			clusterTemplateBoundsByteAlignment = t.clusterTemplateBoundsByteAlignment,
			maxClusterGeometryIndex = t.maxClusterGeometryIndex,
		}
	)
end
mod.s.ImportScreenBufferInfoQNX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImportScreenBufferInfoQNX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			buffer = t.buffer,
		}
	)
end
mod.s.StdVideoEncodeH265SliceSegmentHeader = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoEncodeH265SliceSegmentHeader(
		{
			flags = t.flags,
			slice_type = t.slice_type and mod.e.StdVideoH265SliceType(t.slice_type),
			slice_segment_address = t.slice_segment_address,
			collocated_ref_idx = t.collocated_ref_idx,
			MaxNumMergeCand = t.MaxNumMergeCand,
			slice_cb_qp_offset = t.slice_cb_qp_offset,
			slice_cr_qp_offset = t.slice_cr_qp_offset,
			slice_beta_offset_div2 = t.slice_beta_offset_div2,
			slice_tc_offset_div2 = t.slice_tc_offset_div2,
			slice_act_y_qp_offset = t.slice_act_y_qp_offset,
			slice_act_cb_qp_offset = t.slice_act_cb_qp_offset,
			slice_act_cr_qp_offset = t.slice_act_cr_qp_offset,
			slice_qp_delta = t.slice_qp_delta,
			reserved1 = t.reserved1,
			pWeightTable = t.pWeightTable,
		}
	)
end
mod.s.ExternalFormatQNX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalFormatQNX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			externalFormat = t.externalFormat,
		}
	)
end
mod.s.PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			screenBufferImport = t.screenBufferImport,
		}
	)
end
mod.s.StdVideoH264PictureParameterSet = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoH264PictureParameterSet(
		{
			flags = t.flags,
			seq_parameter_set_id = t.seq_parameter_set_id,
			pic_parameter_set_id = t.pic_parameter_set_id,
			num_ref_idx_l0_default_active_minus1 = t.num_ref_idx_l0_default_active_minus1,
			num_ref_idx_l1_default_active_minus1 = t.num_ref_idx_l1_default_active_minus1,
			weighted_bipred_idc = t.weighted_bipred_idc and
				mod.e.StdVideoH264WeightedBipredIdc(t.weighted_bipred_idc),
			pic_init_qp_minus26 = t.pic_init_qp_minus26,
			pic_init_qs_minus26 = t.pic_init_qs_minus26,
			chroma_qp_index_offset = t.chroma_qp_index_offset,
			second_chroma_qp_index_offset = t.second_chroma_qp_index_offset,
			pScalingLists = t.pScalingLists,
		}
	)
end
mod.s.BufferDeviceAddressInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferDeviceAddressInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			buffer = t.buffer,
		}
	)
end
mod.s.PhysicalDeviceShaderAtomicFloat2FeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderBufferFloat16Atomics = t.shaderBufferFloat16Atomics,
			shaderBufferFloat16AtomicAdd = t.shaderBufferFloat16AtomicAdd,
			shaderBufferFloat16AtomicMinMax = t.shaderBufferFloat16AtomicMinMax,
			shaderBufferFloat32AtomicMinMax = t.shaderBufferFloat32AtomicMinMax,
			shaderBufferFloat64AtomicMinMax = t.shaderBufferFloat64AtomicMinMax,
			shaderSharedFloat16Atomics = t.shaderSharedFloat16Atomics,
			shaderSharedFloat16AtomicAdd = t.shaderSharedFloat16AtomicAdd,
			shaderSharedFloat16AtomicMinMax = t.shaderSharedFloat16AtomicMinMax,
			shaderSharedFloat32AtomicMinMax = t.shaderSharedFloat32AtomicMinMax,
			shaderSharedFloat64AtomicMinMax = t.shaderSharedFloat64AtomicMinMax,
			shaderImageFloat32AtomicMinMax = t.shaderImageFloat32AtomicMinMax,
			sparseImageFloat32AtomicMinMax = t.sparseImageFloat32AtomicMinMax,
		}
	)
end
mod.s.PipelineCreationFeedback = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineCreationFeedback(
		{
			flags = t.flags and mod.e.VkPipelineCreationFeedbackFlagBits(t.flags),
			duration = t.duration,
		}
	)
end
mod.s.PipelineCreationFeedbackCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineCreationFeedbackCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pPipelineCreationFeedback = t.pPipelineCreationFeedback,
			pipelineStageCreationFeedbackCount = t.pipelineStageCreationFeedbackCount,
			pPipelineStageCreationFeedbacks = t.pPipelineStageCreationFeedbacks,
		}
	)
end
mod.s.PhysicalDeviceShaderTerminateInvocationFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderTerminateInvocationFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderTerminateInvocation = t.shaderTerminateInvocation,
		}
	)
end
mod.s.GraphicsPipelineShaderGroupsCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGraphicsPipelineShaderGroupsCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			groupCount = t.groupCount,
			pGroups = t.pGroups,
			pipelineCount = t.pipelineCount,
			pPipelines = t.pPipelines,
		}
	)
end
mod.s.SubmitInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubmitInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			waitSemaphoreCount = t.waitSemaphoreCount,
			pWaitSemaphores = t.pWaitSemaphores,
			pWaitDstStageMask = t.pWaitDstStageMask,
			commandBufferCount = t.commandBufferCount,
			pCommandBuffers = t.pCommandBuffers,
			signalSemaphoreCount = t.signalSemaphoreCount,
			pSignalSemaphores = t.pSignalSemaphores,
		}
	)
end
mod.s.PhysicalDeviceConditionalRenderingFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceConditionalRenderingFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			conditionalRendering = t.conditionalRendering,
			inheritedConditionalRendering = t.inheritedConditionalRendering,
		}
	)
end
mod.s.ConditionalRenderingBeginInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkConditionalRenderingBeginInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			buffer = t.buffer,
			offset = t.offset,
			flags = t.flags,
		}
	)
end
mod.s.DisplaySurfaceCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplaySurfaceCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			displayMode = t.displayMode,
			planeIndex = t.planeIndex,
			planeStackIndex = t.planeStackIndex,
			transform = t.transform and mod.e.VkSurfaceTransformFlagBitsKHR(t.transform),
			globalAlpha = t.globalAlpha,
			alphaMode = t.alphaMode and mod.e.VkDisplayPlaneAlphaFlagBitsKHR(t.alphaMode),
			imageExtent = t.imageExtent,
		}
	)
end
mod.s.CommandBufferInheritanceConditionalRenderingInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCommandBufferInheritanceConditionalRenderingInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			conditionalRenderingEnable = t.conditionalRenderingEnable,
		}
	)
end
mod.s.CommandBufferSubmitInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCommandBufferSubmitInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			commandBuffer = t.commandBuffer,
			deviceMask = t.deviceMask,
		}
	)
end
mod.s.BufferCopy2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferCopy2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcOffset = t.srcOffset,
			dstOffset = t.dstOffset,
			size = t.size,
		}
	)
end
mod.s.CopyImageInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyImageInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcImage = t.srcImage,
			srcImageLayout = t.srcImageLayout and mod.e.VkImageLayout(t.srcImageLayout),
			dstImage = t.dstImage,
			dstImageLayout = t.dstImageLayout and mod.e.VkImageLayout(t.dstImageLayout),
			regionCount = t.regionCount,
			pRegions = t.pRegions,
		}
	)
end
mod.s.BufferImageCopy2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferImageCopy2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			bufferOffset = t.bufferOffset,
			bufferRowLength = t.bufferRowLength,
			bufferImageHeight = t.bufferImageHeight,
			imageSubresource = t.imageSubresource,
			imageOffset = t.imageOffset,
			imageExtent = t.imageExtent,
		}
	)
end
mod.s.MappedMemoryRange = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMappedMemoryRange(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memory = t.memory,
			offset = t.offset,
			size = t.size,
		}
	)
end
mod.s.PhysicalDeviceDescriptorIndexingFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDescriptorIndexingFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderInputAttachmentArrayDynamicIndexing = t.shaderInputAttachmentArrayDynamicIndexing,
			shaderUniformTexelBufferArrayDynamicIndexing = t.shaderUniformTexelBufferArrayDynamicIndexing,
			shaderStorageTexelBufferArrayDynamicIndexing = t.shaderStorageTexelBufferArrayDynamicIndexing,
			shaderUniformBufferArrayNonUniformIndexing = t.shaderUniformBufferArrayNonUniformIndexing,
			shaderSampledImageArrayNonUniformIndexing = t.shaderSampledImageArrayNonUniformIndexing,
			shaderStorageBufferArrayNonUniformIndexing = t.shaderStorageBufferArrayNonUniformIndexing,
			shaderStorageImageArrayNonUniformIndexing = t.shaderStorageImageArrayNonUniformIndexing,
			shaderInputAttachmentArrayNonUniformIndexing = t.shaderInputAttachmentArrayNonUniformIndexing,
			shaderUniformTexelBufferArrayNonUniformIndexing = t.shaderUniformTexelBufferArrayNonUniformIndexing,
			shaderStorageTexelBufferArrayNonUniformIndexing = t.shaderStorageTexelBufferArrayNonUniformIndexing,
			descriptorBindingUniformBufferUpdateAfterBind = t.descriptorBindingUniformBufferUpdateAfterBind,
			descriptorBindingSampledImageUpdateAfterBind = t.descriptorBindingSampledImageUpdateAfterBind,
			descriptorBindingStorageImageUpdateAfterBind = t.descriptorBindingStorageImageUpdateAfterBind,
			descriptorBindingStorageBufferUpdateAfterBind = t.descriptorBindingStorageBufferUpdateAfterBind,
			descriptorBindingUniformTexelBufferUpdateAfterBind = t.descriptorBindingUniformTexelBufferUpdateAfterBind,
			descriptorBindingStorageTexelBufferUpdateAfterBind = t.descriptorBindingStorageTexelBufferUpdateAfterBind,
			descriptorBindingUpdateUnusedWhilePending = t.descriptorBindingUpdateUnusedWhilePending,
			descriptorBindingPartiallyBound = t.descriptorBindingPartiallyBound,
			descriptorBindingVariableDescriptorCount = t.descriptorBindingVariableDescriptorCount,
			runtimeDescriptorArray = t.runtimeDescriptorArray,
		}
	)
end
mod.s.MemoryAllocateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryAllocateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			allocationSize = t.allocationSize,
			memoryTypeIndex = t.memoryTypeIndex,
		}
	)
end
mod.s.BlitImageInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBlitImageInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcImage = t.srcImage,
			srcImageLayout = t.srcImageLayout and mod.e.VkImageLayout(t.srcImageLayout),
			dstImage = t.dstImage,
			dstImageLayout = t.dstImageLayout and mod.e.VkImageLayout(t.dstImageLayout),
			regionCount = t.regionCount,
			pRegions = t.pRegions,
			filter = t.filter and mod.e.VkFilter(t.filter),
		}
	)
end
mod.s.PipelineColorBlendAdvancedStateCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineColorBlendAdvancedStateCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcPremultiplied = t.srcPremultiplied,
			dstPremultiplied = t.dstPremultiplied,
			blendOverlap = t.blendOverlap and mod.e.VkBlendOverlapEXT(t.blendOverlap),
		}
	)
end
mod.s.BlitImageCubicWeightsInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBlitImageCubicWeightsInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			cubicWeights = t.cubicWeights and mod.e.VkCubicFilterWeightsQCOM(t.cubicWeights),
		}
	)
end
mod.s.MemoryGetRemoteAddressInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryGetRemoteAddressInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memory = t.memory,
			handleType = t.handleType and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType),
		}
	)
end
mod.s.SparseMemoryBind = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSparseMemoryBind(
		{
			resourceOffset = t.resourceOffset,
			size = t.size,
			memory = t.memory,
			memoryOffset = t.memoryOffset,
			flags = t.flags and mod.e.VkSparseMemoryBindFlagBits(t.flags),
		}
	)
end
mod.s.PipelineViewportWScalingStateCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineViewportWScalingStateCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			viewportWScalingEnable = t.viewportWScalingEnable,
			viewportCount = t.viewportCount,
			pViewportWScalings = t.pViewportWScalings,
		}
	)
end
mod.s.PhysicalDeviceCopyMemoryIndirectFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			indirectMemoryCopy = t.indirectMemoryCopy,
			indirectMemoryToImageCopy = t.indirectMemoryToImageCopy,
		}
	)
end
mod.s.PhysicalDeviceShaderAtomicInt64Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderAtomicInt64Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderBufferInt64Atomics = t.shaderBufferInt64Atomics,
			shaderSharedInt64Atomics = t.shaderSharedInt64Atomics,
		}
	)
end
mod.s.PerformanceStreamMarkerInfoINTEL = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPerformanceStreamMarkerInfoINTEL(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			marker = t.marker,
		}
	)
end
mod.s.PhysicalDeviceImageViewImageFormatInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageViewImageFormatInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageViewType = t.imageViewType and mod.e.VkImageViewType(t.imageViewType),
		}
	)
end
mod.s.PhysicalDeviceImageProcessingPropertiesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageProcessingPropertiesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxWeightFilterPhases = t.maxWeightFilterPhases,
			maxWeightFilterDimension = t.maxWeightFilterDimension,
			maxBlockMatchRegion = t.maxBlockMatchRegion,
			maxBoxFilterBlockSize = t.maxBoxFilterBlockSize,
		}
	)
end
mod.s.ImageSubresource = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageSubresource(
		{
			aspectMask = t.aspectMask and mod.e.VkImageAspectFlagBits(t.aspectMask),
			mipLevel = t.mipLevel,
			arrayLayer = t.arrayLayer,
		}
	)
end
mod.s.PipelineRepresentativeFragmentTestStateCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			representativeFragmentTestEnable = t.representativeFragmentTestEnable,
		}
	)
end
mod.s.MemoryToImageCopy = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryToImageCopy(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pHostPointer = t.pHostPointer,
			memoryRowLength = t.memoryRowLength,
			memoryImageHeight = t.memoryImageHeight,
			imageSubresource = t.imageSubresource,
			imageOffset = t.imageOffset,
			imageExtent = t.imageExtent,
		}
	)
end
mod.s.SparseImageMemoryBind = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSparseImageMemoryBind(
		{
			subresource = t.subresource,
			offset = t.offset,
			extent = t.extent,
			memory = t.memory,
			memoryOffset = t.memoryOffset,
			flags = t.flags and mod.e.VkSparseMemoryBindFlagBits(t.flags),
		}
	)
end
mod.s.PhysicalDeviceExtendedDynamicState3PropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dynamicPrimitiveTopologyUnrestricted = t.dynamicPrimitiveTopologyUnrestricted,
		}
	)
end
mod.s.PhysicalDeviceShaderSMBuiltinsFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderSMBuiltins = t.shaderSMBuiltins,
		}
	)
end
mod.s.BindSparseInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindSparseInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			waitSemaphoreCount = t.waitSemaphoreCount,
			pWaitSemaphores = t.pWaitSemaphores,
			bufferBindCount = t.bufferBindCount,
			pBufferBinds = t.pBufferBinds,
			imageOpaqueBindCount = t.imageOpaqueBindCount,
			pImageOpaqueBinds = t.pImageOpaqueBinds,
			imageBindCount = t.imageBindCount,
			pImageBinds = t.pImageBinds,
			signalSemaphoreCount = t.signalSemaphoreCount,
			pSignalSemaphores = t.pSignalSemaphores,
		}
	)
end
mod.s.PipelineCoverageToColorStateCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineCoverageToColorStateCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			coverageToColorEnable = t.coverageToColorEnable,
			coverageToColorLocation = t.coverageToColorLocation,
		}
	)
end
mod.s.MultisamplePropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMultisamplePropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxSampleLocationGridSize = t.maxSampleLocationGridSize,
		}
	)
end
mod.s.DebugUtilsMessengerCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDebugUtilsMessengerCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			messageSeverity = t.messageSeverity,
			messageType = t.messageType,
			pfnUserCallback = t.pfnUserCallback,
			pUserData = t.pUserData,
		}
	)
end
mod.s.LatencySleepModeInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkLatencySleepModeInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			lowLatencyMode = t.lowLatencyMode,
			lowLatencyBoost = t.lowLatencyBoost,
			minimumIntervalUs = t.minimumIntervalUs,
		}
	)
end
mod.s.PhysicalDeviceSubpassShadingFeaturesHUAWEI = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			subpassShading = t.subpassShading,
		}
	)
end
mod.s.SubpassShadingPipelineCreateInfoHUAWEI = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubpassShadingPipelineCreateInfoHUAWEI(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			renderPass = t.renderPass,
			subpass = t.subpass,
		}
	)
end
mod.s.SurfaceCapabilities2EXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfaceCapabilities2EXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minImageCount = t.minImageCount,
			maxImageCount = t.maxImageCount,
			currentExtent = t.currentExtent,
			minImageExtent = t.minImageExtent,
			maxImageExtent = t.maxImageExtent,
			maxImageArrayLayers = t.maxImageArrayLayers,
			supportedTransforms = t.supportedTransforms,
			currentTransform = t.currentTransform and mod.e.VkSurfaceTransformFlagBitsKHR(t.currentTransform),
			supportedCompositeAlpha = t.supportedCompositeAlpha,
			supportedUsageFlags = t.supportedUsageFlags and mod.e.VkImageUsageFlagBits(t.supportedUsageFlags),
			supportedSurfaceCounters = t.supportedSurfaceCounters,
		}
	)
end
mod.s.PhysicalDevicePipelineRobustnessProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePipelineRobustnessProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			defaultRobustnessStorageBuffers = t.defaultRobustnessStorageBuffers and
				mod.e.VkPipelineRobustnessBufferBehavior(t.defaultRobustnessStorageBuffers),
			defaultRobustnessUniformBuffers = t.defaultRobustnessUniformBuffers and
				mod.e.VkPipelineRobustnessBufferBehavior(t.defaultRobustnessUniformBuffers),
			defaultRobustnessVertexInputs = t.defaultRobustnessVertexInputs and
				mod.e.VkPipelineRobustnessBufferBehavior(t.defaultRobustnessVertexInputs),
			defaultRobustnessImages = t.defaultRobustnessImages and
				mod.e.VkPipelineRobustnessImageBehavior(t.defaultRobustnessImages),
		}
	)
end
mod.s.SparseImageFormatProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSparseImageFormatProperties(
		{
			aspectMask = t.aspectMask and mod.e.VkImageAspectFlagBits(t.aspectMask),
			imageGranularity = t.imageGranularity,
			flags = t.flags and mod.e.VkSparseImageFormatFlagBits(t.flags),
		}
	)
end
mod.s.FramebufferAttachmentsCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFramebufferAttachmentsCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			attachmentImageInfoCount = t.attachmentImageInfoCount,
			pAttachmentImageInfos = t.pAttachmentImageInfos,
		}
	)
end
mod.s.DeviceGroupCommandBufferBeginInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceGroupCommandBufferBeginInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceMask = t.deviceMask,
		}
	)
end
mod.s.RenderingAttachmentInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderingAttachmentInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageView = t.imageView,
			imageLayout = t.imageLayout and mod.e.VkImageLayout(t.imageLayout),
			resolveMode = t.resolveMode and mod.e.VkResolveModeFlagBits(t.resolveMode),
			resolveImageView = t.resolveImageView,
			resolveImageLayout = t.resolveImageLayout and mod.e.VkImageLayout(t.resolveImageLayout),
			loadOp = t.loadOp and mod.e.VkAttachmentLoadOp(t.loadOp),
			storeOp = t.storeOp and mod.e.VkAttachmentStoreOp(t.storeOp),
			clearValue = t.clearValue,
		}
	)
end
mod.s.VideoReferenceIntraRefreshInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoReferenceIntraRefreshInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dirtyIntraRefreshRegions = t.dirtyIntraRefreshRegions,
		}
	)
end
mod.s.PipelineDynamicStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineDynamicStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			dynamicStateCount = t.dynamicStateCount,
			pDynamicStates = t.pDynamicStates,
		}
	)
end
mod.s.PhysicalDeviceMaintenance7FeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance7FeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maintenance7 = t.maintenance7,
		}
	)
end
mod.s.VideoProfileListInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoProfileListInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			profileCount = t.profileCount,
			pProfiles = t.pProfiles,
		}
	)
end
mod.s.GraphicsPipelineCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGraphicsPipelineCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkPipelineCreateFlagBits(t.flags),
			stageCount = t.stageCount,
			pStages = t.pStages,
			pVertexInputState = t.pVertexInputState,
			pInputAssemblyState = t.pInputAssemblyState,
			pTessellationState = t.pTessellationState,
			pViewportState = t.pViewportState,
			pRasterizationState = t.pRasterizationState,
			pMultisampleState = t.pMultisampleState,
			pDepthStencilState = t.pDepthStencilState,
			pColorBlendState = t.pColorBlendState,
			pDynamicState = t.pDynamicState,
			layout = t.layout,
			renderPass = t.renderPass,
			subpass = t.subpass,
			basePipelineHandle = t.basePipelineHandle,
			basePipelineIndex = t.basePipelineIndex,
		}
	)
end
mod.s.FenceCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFenceCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkFenceCreateFlagBits(t.flags),
		}
	)
end
mod.s.SemaphoreCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSemaphoreCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
		}
	)
end
mod.s.EventCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkEventCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkEventCreateFlagBits(t.flags),
		}
	)
end
mod.s.QueryPoolCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueryPoolCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkQueryPoolCreateFlagBits(t.flags),
			queryType = t.queryType and mod.e.VkQueryType(t.queryType),
			queryCount = t.queryCount,
			pipelineStatistics = t.pipelineStatistics and
				mod.e.VkQueryPipelineStatisticFlagBits(t.pipelineStatistics),
		}
	)
end
mod.s.BindDescriptorBufferEmbeddedSamplersInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBindDescriptorBufferEmbeddedSamplersInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stageFlags = t.stageFlags and mod.e.VkShaderStageFlagBits(t.stageFlags),
			layout = t.layout,
			set = t.set,
		}
	)
end
mod.s.PipelineCoverageReductionStateCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineCoverageReductionStateCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			coverageReductionMode = t.coverageReductionMode and
				mod.e.VkCoverageReductionModeNV(t.coverageReductionMode),
		}
	)
end
mod.s.PhysicalDevicePipelineBinaryPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePipelineBinaryPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineBinaryInternalCache = t.pipelineBinaryInternalCache,
			pipelineBinaryInternalCacheControl = t.pipelineBinaryInternalCacheControl,
			pipelineBinaryPrefersInternalCache = t.pipelineBinaryPrefersInternalCache,
			pipelineBinaryPrecompiledInternalCache = t.pipelineBinaryPrecompiledInternalCache,
			pipelineBinaryCompressedData = t.pipelineBinaryCompressedData,
		}
	)
end
mod.s.BufferCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkBufferCreateFlagBits(t.flags),
			size = t.size,
			usage = t.usage and mod.e.VkBufferUsageFlagBits(t.usage),
			sharingMode = t.sharingMode and mod.e.VkSharingMode(t.sharingMode),
			queueFamilyIndexCount = t.queueFamilyIndexCount,
			pQueueFamilyIndices = t.pQueueFamilyIndices,
		}
	)
end
mod.s.PhysicalDeviceFragmentShaderInterlockFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fragmentShaderSampleInterlock = t.fragmentShaderSampleInterlock,
			fragmentShaderPixelInterlock = t.fragmentShaderPixelInterlock,
			fragmentShaderShadingRateInterlock = t.fragmentShaderShadingRateInterlock,
		}
	)
end
mod.s.DeviceEventInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceEventInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceEvent = t.deviceEvent and mod.e.VkDeviceEventTypeEXT(t.deviceEvent),
		}
	)
end
mod.s.DebugUtilsLabelEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDebugUtilsLabelEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pLabelName = t.pLabelName,
			color = t.color,
		}
	)
end
mod.s.DisplayEventInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplayEventInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			displayEvent = t.displayEvent and mod.e.VkDisplayEventTypeEXT(t.displayEvent),
		}
	)
end
mod.s.BufferViewCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkBufferViewCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			buffer = t.buffer,
			format = t.format and mod.e.VkFormat(t.format),
			offset = t.offset,
			range = t.range,
		}
	)
end
mod.s.ImageCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkImageCreateFlagBits(t.flags),
			imageType = t.imageType and mod.e.VkImageType(t.imageType),
			format = t.format and mod.e.VkFormat(t.format),
			extent = t.extent,
			mipLevels = t.mipLevels,
			arrayLayers = t.arrayLayers,
			samples = t.samples and mod.e.VkSampleCountFlagBits(t.samples),
			tiling = t.tiling and mod.e.VkImageTiling(t.tiling),
			usage = t.usage and mod.e.VkImageUsageFlagBits(t.usage),
			sharingMode = t.sharingMode and mod.e.VkSharingMode(t.sharingMode),
			queueFamilyIndexCount = t.queueFamilyIndexCount,
			pQueueFamilyIndices = t.pQueueFamilyIndices,
			initialLayout = t.initialLayout and mod.e.VkImageLayout(t.initialLayout),
		}
	)
end
mod.s.PushConstantRange = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPushConstantRange(
		{
			stageFlags = t.stageFlags and mod.e.VkShaderStageFlagBits(t.stageFlags),
			offset = t.offset,
			size = t.size,
		}
	)
end
mod.s.StdVideoDecodeVP9PictureInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoDecodeVP9PictureInfo(
		{
			flags = t.flags,
			profile = t.profile and mod.e.StdVideoVP9Profile(t.profile),
			frame_type = t.frame_type and mod.e.StdVideoVP9FrameType(t.frame_type),
			frame_context_idx = t.frame_context_idx,
			reset_frame_context = t.reset_frame_context,
			refresh_frame_flags = t.refresh_frame_flags,
			ref_frame_sign_bias_mask = t.ref_frame_sign_bias_mask,
			interpolation_filter = t.interpolation_filter and
				mod.e.StdVideoVP9InterpolationFilter(t.interpolation_filter),
			base_q_idx = t.base_q_idx,
			delta_q_y_dc = t.delta_q_y_dc,
			delta_q_uv_dc = t.delta_q_uv_dc,
			delta_q_uv_ac = t.delta_q_uv_ac,
			tile_cols_log2 = t.tile_cols_log2,
			tile_rows_log2 = t.tile_rows_log2,
			reserved1 = t.reserved1,
			pColorConfig = t.pColorConfig,
			pLoopFilter = t.pLoopFilter,
			pSegmentation = t.pSegmentation,
		}
	)
end
mod.s.PipelineLayoutCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineLayoutCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkPipelineLayoutCreateFlagBits(t.flags),
			setLayoutCount = t.setLayoutCount,
			pSetLayouts = t.pSetLayouts,
			pushConstantRangeCount = t.pushConstantRangeCount,
			pPushConstantRanges = t.pPushConstantRanges,
		}
	)
end
mod.s.ImageSubresourceRange = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageSubresourceRange(
		{
			aspectMask = t.aspectMask and mod.e.VkImageAspectFlagBits(t.aspectMask),
			baseMipLevel = t.baseMipLevel,
			levelCount = t.levelCount,
			baseArrayLayer = t.baseArrayLayer,
			layerCount = t.layerCount,
		}
	)
end
mod.s.PresentWait2InfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPresentWait2InfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentId = t.presentId,
			timeout = t.timeout,
		}
	)
end
mod.s.PhysicalDeviceShaderSubgroupExtendedTypesFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderSubgroupExtendedTypes = t.shaderSubgroupExtendedTypes,
		}
	)
end
mod.s.RenderPassAttachmentBeginInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassAttachmentBeginInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			attachmentCount = t.attachmentCount,
			pAttachments = t.pAttachments,
		}
	)
end
mod.s.SamplerCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSamplerCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkSamplerCreateFlagBits(t.flags),
			magFilter = t.magFilter and mod.e.VkFilter(t.magFilter),
			minFilter = t.minFilter and mod.e.VkFilter(t.minFilter),
			mipmapMode = t.mipmapMode and mod.e.VkSamplerMipmapMode(t.mipmapMode),
			addressModeU = t.addressModeU and mod.e.VkSamplerAddressMode(t.addressModeU),
			addressModeV = t.addressModeV and mod.e.VkSamplerAddressMode(t.addressModeV),
			addressModeW = t.addressModeW and mod.e.VkSamplerAddressMode(t.addressModeW),
			mipLodBias = t.mipLodBias,
			anisotropyEnable = t.anisotropyEnable,
			maxAnisotropy = t.maxAnisotropy,
			compareEnable = t.compareEnable,
			compareOp = t.compareOp and mod.e.VkCompareOp(t.compareOp),
			minLod = t.minLod,
			maxLod = t.maxLod,
			borderColor = t.borderColor and mod.e.VkBorderColor(t.borderColor),
			unnormalizedCoordinates = t.unnormalizedCoordinates,
		}
	)
end
mod.s.PhysicalDeviceFragmentShadingRateKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentShadingRateKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			sampleCounts = t.sampleCounts and mod.e.VkSampleCountFlagBits(t.sampleCounts),
			fragmentSize = t.fragmentSize,
		}
	)
end
mod.s.FramebufferAttachmentImageInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFramebufferAttachmentImageInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkImageCreateFlagBits(t.flags),
			usage = t.usage and mod.e.VkImageUsageFlagBits(t.usage),
			width = t.width,
			height = t.height,
			layerCount = t.layerCount,
			viewFormatCount = t.viewFormatCount,
			pViewFormats = t.pViewFormats,
		}
	)
end
mod.s.PipelineDepthStencilStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineDepthStencilStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkPipelineDepthStencilStateCreateFlagBits(t.flags),
			depthTestEnable = t.depthTestEnable,
			depthWriteEnable = t.depthWriteEnable,
			depthCompareOp = t.depthCompareOp and mod.e.VkCompareOp(t.depthCompareOp),
			depthBoundsTestEnable = t.depthBoundsTestEnable,
			stencilTestEnable = t.stencilTestEnable,
			front = t.front,
			back = t.back,
			minDepthBounds = t.minDepthBounds,
			maxDepthBounds = t.maxDepthBounds,
		}
	)
end
mod.s.PhysicalDeviceFragmentShadingRateFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineFragmentShadingRate = t.pipelineFragmentShadingRate,
			primitiveFragmentShadingRate = t.primitiveFragmentShadingRate,
			attachmentFragmentShadingRate = t.attachmentFragmentShadingRate,
		}
	)
end
mod.s.PipelineBinaryCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineBinaryCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pKeysAndDataInfo = t.pKeysAndDataInfo,
			pipeline = t.pipeline,
			pPipelineCreateInfo = t.pPipelineCreateInfo,
		}
	)
end
mod.s.PhysicalDeviceImageProcessing2FeaturesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageProcessing2FeaturesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			textureBlockMatch2 = t.textureBlockMatch2,
		}
	)
end
mod.s.HdrMetadataEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkHdrMetadataEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			displayPrimaryRed = t.displayPrimaryRed,
			displayPrimaryGreen = t.displayPrimaryGreen,
			displayPrimaryBlue = t.displayPrimaryBlue,
			whitePoint = t.whitePoint,
			maxLuminance = t.maxLuminance,
			minLuminance = t.minLuminance,
			maxContentLightLevel = t.maxContentLightLevel,
			maxFrameAverageLightLevel = t.maxFrameAverageLightLevel,
		}
	)
end
mod.s.PhysicalDevice8BitStorageFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevice8BitStorageFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			storageBuffer8BitAccess = t.storageBuffer8BitAccess,
			uniformAndStorageBuffer8BitAccess = t.uniformAndStorageBuffer8BitAccess,
			storagePushConstant8 = t.storagePushConstant8,
		}
	)
end
mod.s.SamplerReductionModeCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSamplerReductionModeCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			reductionMode = t.reductionMode and mod.e.VkSamplerReductionMode(t.reductionMode),
		}
	)
end
mod.s.PhysicalDeviceVulkanMemoryModelFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVulkanMemoryModelFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vulkanMemoryModel = t.vulkanMemoryModel,
			vulkanMemoryModelDeviceScope = t.vulkanMemoryModelDeviceScope,
			vulkanMemoryModelAvailabilityVisibilityChains = t.vulkanMemoryModelAvailabilityVisibilityChains,
		}
	)
end
mod.s.PhysicalDeviceHostImageCopyFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceHostImageCopyFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			hostImageCopy = t.hostImageCopy,
		}
	)
end
mod.s.StdVideoAV1SequenceHeader = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoAV1SequenceHeader(
		{
			flags = t.flags,
			seq_profile = t.seq_profile and mod.e.StdVideoAV1Profile(t.seq_profile),
			frame_width_bits_minus_1 = t.frame_width_bits_minus_1,
			frame_height_bits_minus_1 = t.frame_height_bits_minus_1,
			max_frame_width_minus_1 = t.max_frame_width_minus_1,
			max_frame_height_minus_1 = t.max_frame_height_minus_1,
			delta_frame_id_length_minus_2 = t.delta_frame_id_length_minus_2,
			additional_frame_id_length_minus_1 = t.additional_frame_id_length_minus_1,
			order_hint_bits_minus_1 = t.order_hint_bits_minus_1,
			seq_force_integer_mv = t.seq_force_integer_mv,
			seq_force_screen_content_tools = t.seq_force_screen_content_tools,
			reserved1 = t.reserved1,
			pColorConfig = t.pColorConfig,
			pTimingInfo = t.pTimingInfo,
		}
	)
end
mod.s.DataGraphPipelineIdentifierCreateInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineIdentifierCreateInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			identifierSize = t.identifierSize,
			pIdentifier = t.pIdentifier,
		}
	)
end
mod.s.PhysicalDeviceProvokingVertexPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceProvokingVertexPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			provokingVertexModePerPipeline = t.provokingVertexModePerPipeline,
			transformFeedbackPreservesTriangleFanProvokingVertex = t.transformFeedbackPreservesTriangleFanProvokingVertex,
		}
	)
end
mod.s.CopyDescriptorSet = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyDescriptorSet(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcSet = t.srcSet,
			srcBinding = t.srcBinding,
			srcArrayElement = t.srcArrayElement,
			dstSet = t.dstSet,
			dstBinding = t.dstBinding,
			dstArrayElement = t.dstArrayElement,
			descriptorCount = t.descriptorCount,
		}
	)
end
mod.s.DataGraphPipelineSessionBindPointRequirementsInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineSessionBindPointRequirementsInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			session = t.session,
		}
	)
end
mod.s.PhysicalDeviceYcbcrImageArraysFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			ycbcrImageArrays = t.ycbcrImageArrays,
		}
	)
end
mod.s.PhysicalDeviceImageProcessing2PropertiesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageProcessing2PropertiesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxBlockMatchWindow = t.maxBlockMatchWindow,
		}
	)
end
mod.s.PresentTimesInfoGOOGLE = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPresentTimesInfoGOOGLE(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			swapchainCount = t.swapchainCount,
			pTimes = t.pTimes,
		}
	)
end
mod.s.WriteDescriptorSetTensorARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkWriteDescriptorSetTensorARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tensorViewCount = t.tensorViewCount,
			pTensorViews = t.pTensorViews,
		}
	)
end
mod.s.VideoEncodeIntraRefreshInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeIntraRefreshInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			intraRefreshCycleDuration = t.intraRefreshCycleDuration,
			intraRefreshIndex = t.intraRefreshIndex,
		}
	)
end
mod.s.DataGraphPipelineCreateInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDataGraphPipelineCreateInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			layout = t.layout,
			resourceInfoCount = t.resourceInfoCount,
			pResourceInfos = t.pResourceInfos,
		}
	)
end
mod.s.PhysicalDeviceTileMemoryHeapPropertiesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			queueSubmitBoundary = t.queueSubmitBoundary,
			tileBufferTransfers = t.tileBufferTransfers,
		}
	)
end
mod.s.DescriptorImageInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorImageInfo(
		{
			sampler = t.sampler,
			imageView = t.imageView,
			imageLayout = t.imageLayout and mod.e.VkImageLayout(t.imageLayout),
		}
	)
end
mod.s.TileMemoryRequirementsQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTileMemoryRequirementsQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			size = t.size,
			alignment = t.alignment,
		}
	)
end
mod.s.PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderFloat16VectorAtomics = t.shaderFloat16VectorAtomics,
		}
	)
end
mod.s.PhysicalDeviceShaderExpectAssumeFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderExpectAssumeFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderExpectAssume = t.shaderExpectAssume,
		}
	)
end
mod.s.DescriptorPoolSize = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorPoolSize(
		{
			type = t.type and mod.e.VkDescriptorType(t.type),
			descriptorCount = t.descriptorCount,
		}
	)
end
mod.s.DescriptorPoolCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorPoolCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkDescriptorPoolCreateFlagBits(t.flags),
			maxSets = t.maxSets,
			poolSizeCount = t.poolSizeCount,
			pPoolSizes = t.pPoolSizes,
		}
	)
end
mod.s.CuFunctionCreateInfoNVX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCuFunctionCreateInfoNVX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			module = t.module,
			pName = t.pName,
		}
	)
end
mod.s.DeviceMemoryOverallocationCreateInfoAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceMemoryOverallocationCreateInfoAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			overallocationBehavior = t.overallocationBehavior and
				mod.e.VkMemoryOverallocationBehaviorAMD(t.overallocationBehavior),
		}
	)
end
mod.s.PipelineViewportSwizzleStateCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineViewportSwizzleStateCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			viewportCount = t.viewportCount,
			pViewportSwizzles = t.pViewportSwizzles,
		}
	)
end
mod.s.DescriptorSetAllocateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorSetAllocateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			descriptorPool = t.descriptorPool,
			descriptorSetCount = t.descriptorSetCount,
			pSetLayouts = t.pSetLayouts,
		}
	)
end
mod.s.PhysicalDevicePushDescriptorProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePushDescriptorProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxPushDescriptors = t.maxPushDescriptors,
		}
	)
end
mod.s.PhysicalDevicePartitionedAccelerationStructureFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			partitionedAccelerationStructure = t.partitionedAccelerationStructure,
		}
	)
end
mod.s.DescriptorSetLayoutBinding = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorSetLayoutBinding(
		{
			binding = t.binding,
			descriptorType = t.descriptorType and mod.e.VkDescriptorType(t.descriptorType),
			descriptorCount = t.descriptorCount,
			stageFlags = t.stageFlags and mod.e.VkShaderStageFlagBits(t.stageFlags),
			pImmutableSamplers = t.pImmutableSamplers,
		}
	)
end
mod.s.PhysicalDevicePartitionedAccelerationStructurePropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxPartitionCount = t.maxPartitionCount,
		}
	)
end
mod.s.VideoEndCodingInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEndCodingInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
		}
	)
end
mod.s.DescriptorSetLayoutCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorSetLayoutCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkDescriptorSetLayoutCreateFlagBits(t.flags),
			bindingCount = t.bindingCount,
			pBindings = t.pBindings,
		}
	)
end
mod.s.VideoEncodeRgbConversionCapabilitiesVALVE = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeRgbConversionCapabilitiesVALVE(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rgbModels = t.rgbModels,
			rgbRanges = t.rgbRanges,
			xChromaOffsets = t.xChromaOffsets,
			yChromaOffsets = t.yChromaOffsets,
		}
	)
end
mod.s.PhysicalDeviceExtendedDynamicStateFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			extendedDynamicState = t.extendedDynamicState,
		}
	)
end
mod.s.WriteDescriptorSet = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkWriteDescriptorSet(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dstSet = t.dstSet,
			dstBinding = t.dstBinding,
			dstArrayElement = t.dstArrayElement,
			descriptorCount = t.descriptorCount,
			descriptorType = t.descriptorType and mod.e.VkDescriptorType(t.descriptorType),
			pImageInfo = t.pImageInfo,
			pBufferInfo = t.pBufferInfo,
			pTexelBufferView = t.pTexelBufferView,
		}
	)
end
mod.s.MultiviewPerViewAttributesInfoNVX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMultiviewPerViewAttributesInfoNVX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			perViewAttributes = t.perViewAttributes,
			perViewAttributesPositionXOnly = t.perViewAttributesPositionXOnly,
		}
	)
end
mod.s.PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderSubgroupUniformControlFlow = t.shaderSubgroupUniformControlFlow,
		}
	)
end
mod.s.PhysicalDeviceFragmentShaderBarycentricFeaturesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fragmentShaderBarycentric = t.fragmentShaderBarycentric,
		}
	)
end
mod.s.AttachmentDescription = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAttachmentDescription(
		{
			flags = t.flags and mod.e.VkAttachmentDescriptionFlagBits(t.flags),
			format = t.format and mod.e.VkFormat(t.format),
			samples = t.samples and mod.e.VkSampleCountFlagBits(t.samples),
			loadOp = t.loadOp and mod.e.VkAttachmentLoadOp(t.loadOp),
			storeOp = t.storeOp and mod.e.VkAttachmentStoreOp(t.storeOp),
			stencilLoadOp = t.stencilLoadOp and mod.e.VkAttachmentLoadOp(t.stencilLoadOp),
			stencilStoreOp = t.stencilStoreOp and mod.e.VkAttachmentStoreOp(t.stencilStoreOp),
			initialLayout = t.initialLayout and mod.e.VkImageLayout(t.initialLayout),
			finalLayout = t.finalLayout and mod.e.VkImageLayout(t.finalLayout),
		}
	)
end
mod.s.MemoryGetAndroidHardwareBufferInfoANDROID = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryGetAndroidHardwareBufferInfoANDROID(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memory = t.memory,
		}
	)
end
mod.s.ExportMetalBufferInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportMetalBufferInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memory = t.memory,
			mtlBuffer = t.mtlBuffer,
		}
	)
end
mod.s.ExternalSemaphoreProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalSemaphoreProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			exportFromImportedHandleTypes = t.exportFromImportedHandleTypes and
				mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.exportFromImportedHandleTypes),
			compatibleHandleTypes = t.compatibleHandleTypes and
				mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.compatibleHandleTypes),
			externalSemaphoreFeatures = t.externalSemaphoreFeatures and
				mod.e.VkExternalSemaphoreFeatureFlagBits(t.externalSemaphoreFeatures),
		}
	)
end
mod.s.PhysicalDeviceTileShadingFeaturesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceTileShadingFeaturesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			tileShading = t.tileShading,
			tileShadingFragmentStage = t.tileShadingFragmentStage,
			tileShadingColorAttachments = t.tileShadingColorAttachments,
			tileShadingDepthAttachments = t.tileShadingDepthAttachments,
			tileShadingStencilAttachments = t.tileShadingStencilAttachments,
			tileShadingInputAttachments = t.tileShadingInputAttachments,
			tileShadingSampledAttachments = t.tileShadingSampledAttachments,
			tileShadingPerTileDraw = t.tileShadingPerTileDraw,
			tileShadingPerTileDispatch = t.tileShadingPerTileDispatch,
			tileShadingDispatchTile = t.tileShadingDispatchTile,
			tileShadingApron = t.tileShadingApron,
			tileShadingAnisotropicApron = t.tileShadingAnisotropicApron,
			tileShadingAtomicOps = t.tileShadingAtomicOps,
			tileShadingImageProcessing = t.tileShadingImageProcessing,
		}
	)
end
mod.s.ExportFenceCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportFenceCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleTypes = t.handleTypes and mod.e.VkExternalFenceHandleTypeFlagBits(t.handleTypes),
		}
	)
end
mod.s.AttachmentReference = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAttachmentReference(
		{
			attachment = t.attachment,
			layout = t.layout and mod.e.VkImageLayout(t.layout),
		}
	)
end
mod.s.PhysicalDeviceFragmentShadingRateEnumsFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fragmentShadingRateEnums = t.fragmentShadingRateEnums,
			supersampleFragmentShadingRates = t.supersampleFragmentShadingRates,
			noInvocationFragmentShadingRates = t.noInvocationFragmentShadingRates,
		}
	)
end
mod.s.FramebufferCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFramebufferCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkFramebufferCreateFlagBits(t.flags),
			renderPass = t.renderPass,
			attachmentCount = t.attachmentCount,
			pAttachments = t.pAttachments,
			width = t.width,
			height = t.height,
			layers = t.layers,
		}
	)
end
mod.s.VideoDecodeH265DpbSlotInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH265DpbSlotInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdReferenceInfo = t.pStdReferenceInfo,
		}
	)
end
mod.s.SubpassDescription = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubpassDescription(
		{
			flags = t.flags and mod.e.VkSubpassDescriptionFlagBits(t.flags),
			pipelineBindPoint = t.pipelineBindPoint and mod.e.VkPipelineBindPoint(t.pipelineBindPoint),
			inputAttachmentCount = t.inputAttachmentCount,
			pInputAttachments = t.pInputAttachments,
			colorAttachmentCount = t.colorAttachmentCount,
			pColorAttachments = t.pColorAttachments,
			pResolveAttachments = t.pResolveAttachments,
			pDepthStencilAttachment = t.pDepthStencilAttachment,
			preserveAttachmentCount = t.preserveAttachmentCount,
			pPreserveAttachments = t.pPreserveAttachments,
		}
	)
end
mod.s.PhysicalDeviceDepthStencilResolveProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDepthStencilResolveProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			supportedDepthResolveModes = t.supportedDepthResolveModes and
				mod.e.VkResolveModeFlagBits(t.supportedDepthResolveModes),
			supportedStencilResolveModes = t.supportedStencilResolveModes and
				mod.e.VkResolveModeFlagBits(t.supportedStencilResolveModes),
			independentResolveNone = t.independentResolveNone,
			independentResolve = t.independentResolve,
		}
	)
end
mod.s.XlibSurfaceCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkXlibSurfaceCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			dpy = t.dpy,
			window = t.window,
		}
	)
end
mod.s.MemoryMetalHandlePropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryMetalHandlePropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memoryTypeBits = t.memoryTypeBits,
		}
	)
end
mod.s.ImportMemoryMetalHandleInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImportMemoryMetalHandleInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			handleType = t.handleType and mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType),
			handle = t.handle,
		}
	)
end
mod.s.ImportMetalIOSurfaceInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImportMetalIOSurfaceInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			ioSurface = t.ioSurface,
		}
	)
end
mod.s.ExportMetalIOSurfaceInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportMetalIOSurfaceInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			image = t.image,
			ioSurface = t.ioSurface,
		}
	)
end
mod.s.ExportMetalTextureInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportMetalTextureInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			image = t.image,
			imageView = t.imageView,
			bufferView = t.bufferView,
			plane = t.plane and mod.e.VkImageAspectFlagBits(t.plane),
			mtlTexture = t.mtlTexture,
		}
	)
end
mod.s.AcquireProfilingLockInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAcquireProfilingLockInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			timeout = t.timeout,
		}
	)
end
mod.s.ImportMetalBufferInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImportMetalBufferInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			mtlBuffer = t.mtlBuffer,
		}
	)
end
mod.s.SubpassDependency = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubpassDependency(
		{
			srcSubpass = t.srcSubpass,
			dstSubpass = t.dstSubpass,
			srcStageMask = t.srcStageMask and mod.e.VkPipelineStageFlagBits(t.srcStageMask),
			dstStageMask = t.dstStageMask and mod.e.VkPipelineStageFlagBits(t.dstStageMask),
			srcAccessMask = t.srcAccessMask and mod.e.VkAccessFlagBits(t.srcAccessMask),
			dstAccessMask = t.dstAccessMask and mod.e.VkAccessFlagBits(t.dstAccessMask),
			dependencyFlags = t.dependencyFlags and mod.e.VkDependencyFlagBits(t.dependencyFlags),
		}
	)
end
mod.s.ExportMetalDeviceInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportMetalDeviceInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			mtlDevice = t.mtlDevice,
		}
	)
end
mod.s.ExportMetalObjectCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportMetalObjectCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			exportObjectType = t.exportObjectType and
				mod.e.VkExportMetalObjectTypeFlagBitsEXT(t.exportObjectType),
		}
	)
end
mod.s.PhysicalDeviceExternalFormatResolvePropertiesANDROID = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			nullColorAttachmentWithExternalFormatResolve = t.nullColorAttachmentWithExternalFormatResolve,
			externalFormatResolveChromaOffsetX = t.externalFormatResolveChromaOffsetX and
				mod.e.VkChromaLocation(t.externalFormatResolveChromaOffsetX),
			externalFormatResolveChromaOffsetY = t.externalFormatResolveChromaOffsetY and
				mod.e.VkChromaLocation(t.externalFormatResolveChromaOffsetY),
		}
	)
end
mod.s.StdVideoDecodeAV1PictureInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoDecodeAV1PictureInfo(
		{
			flags = t.flags,
			frame_type = t.frame_type and mod.e.StdVideoAV1FrameType(t.frame_type),
			current_frame_id = t.current_frame_id,
			OrderHint = t.OrderHint,
			primary_ref_frame = t.primary_ref_frame,
			refresh_frame_flags = t.refresh_frame_flags,
			reserved1 = t.reserved1,
			interpolation_filter = t.interpolation_filter and
				mod.e.StdVideoAV1InterpolationFilter(t.interpolation_filter),
			TxMode = t.TxMode and mod.e.StdVideoAV1TxMode(t.TxMode),
			delta_q_res = t.delta_q_res,
			delta_lf_res = t.delta_lf_res,
			SkipModeFrame = t.SkipModeFrame,
			coded_denom = t.coded_denom,
			reserved2 = t.reserved2,
			OrderHints = t.OrderHints,
			expectedFrameId = t.expectedFrameId,
			pTileInfo = t.pTileInfo,
			pQuantization = t.pQuantization,
			pSegmentation = t.pSegmentation,
			pLoopFilter = t.pLoopFilter,
			pCDEF = t.pCDEF,
			pLoopRestoration = t.pLoopRestoration,
			pGlobalMotion = t.pGlobalMotion,
			pFilmGrain = t.pFilmGrain,
		}
	)
end
mod.s.ImportAndroidHardwareBufferInfoANDROID = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImportAndroidHardwareBufferInfoANDROID(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			buffer = t.buffer,
		}
	)
end
mod.s.RenderPassCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkRenderPassCreateFlagBits(t.flags),
			attachmentCount = t.attachmentCount,
			pAttachments = t.pAttachments,
			subpassCount = t.subpassCount,
			pSubpasses = t.pSubpasses,
			dependencyCount = t.dependencyCount,
			pDependencies = t.pDependencies,
		}
	)
end
mod.s.AndroidHardwareBufferPropertiesANDROID = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAndroidHardwareBufferPropertiesANDROID(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			allocationSize = t.allocationSize,
			memoryTypeBits = t.memoryTypeBits,
		}
	)
end
mod.s.AndroidHardwareBufferUsageANDROID = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAndroidHardwareBufferUsageANDROID(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			androidHardwareBufferUsage = t.androidHardwareBufferUsage,
		}
	)
end
mod.s.AndroidSurfaceCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAndroidSurfaceCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			window = t.window,
		}
	)
end
mod.s.TensorCreateInfoARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTensorCreateInfoARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			pDescription = t.pDescription,
			sharingMode = t.sharingMode and mod.e.VkSharingMode(t.sharingMode),
			queueFamilyIndexCount = t.queueFamilyIndexCount,
			pQueueFamilyIndices = t.pQueueFamilyIndices,
		}
	)
end
mod.s.CommandPoolCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCommandPoolCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkCommandPoolCreateFlagBits(t.flags),
			queueFamilyIndex = t.queueFamilyIndex,
		}
	)
end
mod.s.CommandBufferAllocateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCommandBufferAllocateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			commandPool = t.commandPool,
			level = t.level and mod.e.VkCommandBufferLevel(t.level),
			commandBufferCount = t.commandBufferCount,
		}
	)
end
mod.s.PhysicalDeviceSchedulingControlsPropertiesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSchedulingControlsPropertiesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			schedulingControlsFlags = t.schedulingControlsFlags,
		}
	)
end
mod.s.CommandBufferInheritanceInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCommandBufferInheritanceInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			renderPass = t.renderPass,
			subpass = t.subpass,
			framebuffer = t.framebuffer,
			occlusionQueryEnable = t.occlusionQueryEnable,
			queryFlags = t.queryFlags and mod.e.VkQueryControlFlagBits(t.queryFlags),
			pipelineStatistics = t.pipelineStatistics and
				mod.e.VkQueryPipelineStatisticFlagBits(t.pipelineStatistics),
		}
	)
end
mod.s.PhysicalDeviceShaderFloat8FeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderFloat8FeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderFloat8 = t.shaderFloat8,
			shaderFloat8CooperativeMatrix = t.shaderFloat8CooperativeMatrix,
		}
	)
end
mod.s.DevicePrivateDataCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDevicePrivateDataCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			privateDataSlotRequestCount = t.privateDataSlotRequestCount,
		}
	)
end
mod.s.ClusterAccelerationStructureClustersBottomLevelInputNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkClusterAccelerationStructureClustersBottomLevelInputNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxTotalClusterCount = t.maxTotalClusterCount,
			maxClusterCountPerAccelerationStructure = t.maxClusterCountPerAccelerationStructure,
		}
	)
end
mod.s.CommandBufferBeginInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCommandBufferBeginInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkCommandBufferUsageFlagBits(t.flags),
			pInheritanceInfo = t.pInheritanceInfo,
		}
	)
end
mod.s.ClusterAccelerationStructureTriangleClusterInputNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkClusterAccelerationStructureTriangleClusterInputNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vertexFormat = t.vertexFormat and mod.e.VkFormat(t.vertexFormat),
			maxGeometryIndexValue = t.maxGeometryIndexValue,
			maxClusterUniqueGeometryCount = t.maxClusterUniqueGeometryCount,
			maxClusterTriangleCount = t.maxClusterTriangleCount,
			maxClusterVertexCount = t.maxClusterVertexCount,
			maxTotalTriangleCount = t.maxTotalTriangleCount,
			maxTotalVertexCount = t.maxTotalVertexCount,
			minPositionTruncateBitCount = t.minPositionTruncateBitCount,
		}
	)
end
mod.s.AccelerationStructureCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			createFlags = t.createFlags,
			buffer = t.buffer,
			offset = t.offset,
			size = t.size,
			type = t.type and mod.e.VkAccelerationStructureTypeKHR(t.type),
			deviceAddress = t.deviceAddress,
		}
	)
end
mod.s.RenderPassTransformBeginInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassTransformBeginInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			transform = t.transform and mod.e.VkSurfaceTransformFlagBitsKHR(t.transform),
		}
	)
end
mod.s.ClusterAccelerationStructureInputInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkClusterAccelerationStructureInputInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxAccelerationStructureCount = t.maxAccelerationStructureCount,
			flags = t.flags,
			opType = t.opType and mod.e.VkClusterAccelerationStructureOpTypeNV(t.opType),
			opMode = t.opMode and mod.e.VkClusterAccelerationStructureOpModeNV(t.opMode),
			opInput = t.opInput,
		}
	)
end
mod.s.ImageSubresourceLayers = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageSubresourceLayers(
		{
			aspectMask = t.aspectMask and mod.e.VkImageAspectFlagBits(t.aspectMask),
			mipLevel = t.mipLevel,
			baseArrayLayer = t.baseArrayLayer,
			layerCount = t.layerCount,
		}
	)
end
mod.s.AccelerationStructureGeometryAabbsDataKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureGeometryAabbsDataKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			data = t.data,
			stride = t.stride,
		}
	)
end
mod.s.SwapchainCounterCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSwapchainCounterCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			surfaceCounters = t.surfaceCounters,
		}
	)
end
mod.s.PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			zeroInitializeDeviceMemory = t.zeroInitializeDeviceMemory,
		}
	)
end
mod.s.DisplayPowerInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplayPowerInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			powerState = t.powerState and mod.e.VkDisplayPowerStateEXT(t.powerState),
		}
	)
end
mod.s.SetPresentConfigNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSetPresentConfigNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			numFramesPerBatch = t.numFramesPerBatch,
			presentConfigFeedback = t.presentConfigFeedback,
		}
	)
end
mod.s.PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fragmentDensityMapLayered = t.fragmentDensityMapLayered,
		}
	)
end
mod.s.WriteIndirectExecutionSetShaderEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkWriteIndirectExecutionSetShaderEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			index = t.index,
			shader = t.shader,
		}
	)
end
mod.s.GeneratedCommandsPipelineInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGeneratedCommandsPipelineInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipeline = t.pipeline,
		}
	)
end
mod.s.ImportFenceFdInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImportFenceFdInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fence = t.fence,
			flags = t.flags and mod.e.VkFenceImportFlagBits(t.flags),
			handleType = t.handleType and mod.e.VkExternalFenceHandleTypeFlagBits(t.handleType),
			fd = t.fd,
		}
	)
end
mod.s.VideoDecodeAV1ProfileInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeAV1ProfileInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stdProfile = t.stdProfile and mod.e.StdVideoAV1Profile(t.stdProfile),
			filmGrainSupport = t.filmGrainSupport,
		}
	)
end
mod.s.GeneratedCommandsMemoryRequirementsInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkGeneratedCommandsMemoryRequirementsInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineBindPoint = t.pipelineBindPoint and mod.e.VkPipelineBindPoint(t.pipelineBindPoint),
			pipeline = t.pipeline,
			indirectCommandsLayout = t.indirectCommandsLayout,
			maxSequencesCount = t.maxSequencesCount,
		}
	)
end
mod.s.PartitionedAccelerationStructureInstancesInputNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPartitionedAccelerationStructureInstancesInputNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			instanceCount = t.instanceCount,
			maxInstancePerPartitionCount = t.maxInstancePerPartitionCount,
			partitionCount = t.partitionCount,
			maxInstanceInGlobalPartitionCount = t.maxInstanceInGlobalPartitionCount,
		}
	)
end
mod.s.VideoDecodeAV1CapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeAV1CapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxLevel = t.maxLevel and mod.e.StdVideoAV1Level(t.maxLevel),
		}
	)
end
mod.s.PartitionedAccelerationStructureFlagsNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPartitionedAccelerationStructureFlagsNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			enablePartitionTranslation = t.enablePartitionTranslation,
		}
	)
end
mod.s.VideoDecodeAV1SessionParametersCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeAV1SessionParametersCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdSequenceHeader = t.pStdSequenceHeader,
		}
	)
end
mod.s.VideoEncodeInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			dstBuffer = t.dstBuffer,
			dstBufferOffset = t.dstBufferOffset,
			dstBufferRange = t.dstBufferRange,
			srcPictureResource = t.srcPictureResource,
			pSetupReferenceSlot = t.pSetupReferenceSlot,
			referenceSlotCount = t.referenceSlotCount,
			pReferenceSlots = t.pReferenceSlots,
			precedingExternallyEncodedBytes = t.precedingExternallyEncodedBytes,
		}
	)
end
mod.s.VideoDecodeAV1PictureInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeAV1PictureInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdPictureInfo = t.pStdPictureInfo,
			referenceNameSlotIndices = t.referenceNameSlotIndices,
			frameHeaderOffset = t.frameHeaderOffset,
			tileCount = t.tileCount,
			pTileOffsets = t.pTileOffsets,
			pTileSizes = t.pTileSizes,
		}
	)
end
mod.s.ImageViewAddressPropertiesNVX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageViewAddressPropertiesNVX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceAddress = t.deviceAddress,
			size = t.size,
		}
	)
end
mod.s.ImageViewHandleInfoNVX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageViewHandleInfoNVX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageView = t.imageView,
			descriptorType = t.descriptorType and mod.e.VkDescriptorType(t.descriptorType),
			sampler = t.sampler,
		}
	)
end
mod.s.PhysicalDeviceDynamicRenderingLocalReadFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDynamicRenderingLocalReadFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dynamicRenderingLocalRead = t.dynamicRenderingLocalRead,
		}
	)
end
mod.s.VideoEncodeCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			rateControlModes = t.rateControlModes,
			maxRateControlLayers = t.maxRateControlLayers,
			maxBitrate = t.maxBitrate,
			maxQualityLevels = t.maxQualityLevels,
			encodeInputPictureGranularity = t.encodeInputPictureGranularity,
			supportedEncodeFeedbackFlags = t.supportedEncodeFeedbackFlags,
		}
	)
end
mod.s.PipelineCreateFlags2CreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineCreateFlags2CreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
		}
	)
end
mod.s.VideoDecodeAV1DpbSlotInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeAV1DpbSlotInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdReferenceInfo = t.pStdReferenceInfo,
		}
	)
end
mod.s.ImageSubresource2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkImageSubresource2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageSubresource = t.imageSubresource,
		}
	)
end
mod.s.SharedPresentSurfaceCapabilitiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSharedPresentSurfaceCapabilitiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			sharedPresentSupportedUsageFlags = t.sharedPresentSupportedUsageFlags and
				mod.e.VkImageUsageFlagBits(t.sharedPresentSupportedUsageFlags),
		}
	)
end
mod.s.StdVideoH265SequenceParameterSet = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoH265SequenceParameterSet(
		{
			flags = t.flags,
			chroma_format_idc = t.chroma_format_idc and mod.e.StdVideoH265ChromaFormatIdc(t.chroma_format_idc),
			pic_width_in_luma_samples = t.pic_width_in_luma_samples,
			pic_height_in_luma_samples = t.pic_height_in_luma_samples,
			sps_video_parameter_set_id = t.sps_video_parameter_set_id,
			sps_max_sub_layers_minus1 = t.sps_max_sub_layers_minus1,
			sps_seq_parameter_set_id = t.sps_seq_parameter_set_id,
			bit_depth_luma_minus8 = t.bit_depth_luma_minus8,
			bit_depth_chroma_minus8 = t.bit_depth_chroma_minus8,
			log2_max_pic_order_cnt_lsb_minus4 = t.log2_max_pic_order_cnt_lsb_minus4,
			log2_min_luma_coding_block_size_minus3 = t.log2_min_luma_coding_block_size_minus3,
			log2_diff_max_min_luma_coding_block_size = t.log2_diff_max_min_luma_coding_block_size,
			log2_min_luma_transform_block_size_minus2 = t.log2_min_luma_transform_block_size_minus2,
			log2_diff_max_min_luma_transform_block_size = t.log2_diff_max_min_luma_transform_block_size,
			max_transform_hierarchy_depth_inter = t.max_transform_hierarchy_depth_inter,
			max_transform_hierarchy_depth_intra = t.max_transform_hierarchy_depth_intra,
			num_short_term_ref_pic_sets = t.num_short_term_ref_pic_sets,
			num_long_term_ref_pics_sps = t.num_long_term_ref_pics_sps,
			pcm_sample_bit_depth_luma_minus1 = t.pcm_sample_bit_depth_luma_minus1,
			pcm_sample_bit_depth_chroma_minus1 = t.pcm_sample_bit_depth_chroma_minus1,
			log2_min_pcm_luma_coding_block_size_minus3 = t.log2_min_pcm_luma_coding_block_size_minus3,
			log2_diff_max_min_pcm_luma_coding_block_size = t.log2_diff_max_min_pcm_luma_coding_block_size,
			reserved1 = t.reserved1,
			reserved2 = t.reserved2,
			palette_max_size = t.palette_max_size,
			delta_palette_max_predictor_size = t.delta_palette_max_predictor_size,
			motion_vector_resolution_control_idc = t.motion_vector_resolution_control_idc,
			sps_num_palette_predictor_initializers_minus1 = t.sps_num_palette_predictor_initializers_minus1,
			conf_win_left_offset = t.conf_win_left_offset,
			conf_win_right_offset = t.conf_win_right_offset,
			conf_win_top_offset = t.conf_win_top_offset,
			conf_win_bottom_offset = t.conf_win_bottom_offset,
			pProfileTierLevel = t.pProfileTierLevel,
			pDecPicBufMgr = t.pDecPicBufMgr,
			pScalingLists = t.pScalingLists,
			pShortTermRefPicSet = t.pShortTermRefPicSet,
			pLongTermRefPicsSps = t.pLongTermRefPicsSps,
			pSequenceParameterSetVui = t.pSequenceParameterSetVui,
			pPredictorPaletteEntries = t.pPredictorPaletteEntries,
		}
	)
end
mod.s.CuLaunchInfoNVX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCuLaunchInfoNVX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			["function"] = t["function"],
			gridDimX = t.gridDimX,
			gridDimY = t.gridDimY,
			gridDimZ = t.gridDimZ,
			blockDimX = t.blockDimX,
			blockDimY = t.blockDimY,
			blockDimZ = t.blockDimZ,
			sharedMemBytes = t.sharedMemBytes,
			paramCount = t.paramCount,
			pParams = t.pParams,
			extraCount = t.extraCount,
			pExtras = t.pExtras,
		}
	)
end
mod.s.QueryPoolVideoEncodeFeedbackCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			encodeFeedbackFlags = t.encodeFeedbackFlags,
		}
	)
end
mod.s.RenderPassBeginInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassBeginInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			renderPass = t.renderPass,
			framebuffer = t.framebuffer,
			renderArea = t.renderArea,
			clearValueCount = t.clearValueCount,
			pClearValues = t.pClearValues,
		}
	)
end
mod.s.VideoEncodeUsageInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeUsageInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoUsageHints = t.videoUsageHints,
			videoContentHints = t.videoContentHints,
			tuningMode = t.tuningMode and mod.e.VkVideoEncodeTuningModeKHR(t.tuningMode),
		}
	)
end
mod.s.CuModuleTexturingModeCreateInfoNVX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCuModuleTexturingModeCreateInfoNVX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			use64bitTexturing = t.use64bitTexturing,
		}
	)
end
mod.s.CuModuleCreateInfoNVX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCuModuleCreateInfoNVX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			dataSize = t.dataSize,
			pData = t.pData,
		}
	)
end
mod.s.VideoEncodeRateControlLayerInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeRateControlLayerInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			averageBitrate = t.averageBitrate,
			maxBitrate = t.maxBitrate,
			frameRateNumerator = t.frameRateNumerator,
			frameRateDenominator = t.frameRateDenominator,
		}
	)
end
mod.s.ScreenBufferFormatPropertiesQNX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkScreenBufferFormatPropertiesQNX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			format = t.format and mod.e.VkFormat(t.format),
			externalFormat = t.externalFormat,
			screenUsage = t.screenUsage,
			formatFeatures = t.formatFeatures and mod.e.VkFormatFeatureFlagBits(t.formatFeatures),
			samplerYcbcrConversionComponents = t.samplerYcbcrConversionComponents,
			suggestedYcbcrModel = t.suggestedYcbcrModel and
				mod.e.VkSamplerYcbcrModelConversion(t.suggestedYcbcrModel),
			suggestedYcbcrRange = t.suggestedYcbcrRange and mod.e.VkSamplerYcbcrRange(t.suggestedYcbcrRange),
			suggestedXChromaOffset = t.suggestedXChromaOffset and mod.e.VkChromaLocation(t.suggestedXChromaOffset),
			suggestedYChromaOffset = t.suggestedYChromaOffset and mod.e.VkChromaLocation(t.suggestedYChromaOffset),
		}
	)
end
mod.s.ScreenBufferPropertiesQNX = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkScreenBufferPropertiesQNX(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			allocationSize = t.allocationSize,
			memoryTypeBits = t.memoryTypeBits,
		}
	)
end
mod.s.PhysicalDeviceRayTracingValidationFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRayTracingValidationFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			rayTracingValidation = t.rayTracingValidation,
		}
	)
end
mod.s.VideoEncodeRateControlInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeRateControlInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			rateControlMode = t.rateControlMode and
				mod.e.VkVideoEncodeRateControlModeFlagBitsKHR(t.rateControlMode),
			layerCount = t.layerCount,
			pLayers = t.pLayers,
			virtualBufferSizeInMs = t.virtualBufferSizeInMs,
			initialVirtualBufferSizeInMs = t.initialVirtualBufferSizeInMs,
		}
	)
end
mod.s.PhysicalDeviceExternalComputeQueuePropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExternalComputeQueuePropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			externalDataSize = t.externalDataSize,
			maxExternalQueues = t.maxExternalQueues,
		}
	)
end
mod.s.VideoEncodeH264QualityLevelPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH264QualityLevelPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			preferredRateControlFlags = t.preferredRateControlFlags,
			preferredGopFrameCount = t.preferredGopFrameCount,
			preferredIdrPeriod = t.preferredIdrPeriod,
			preferredConsecutiveBFrameCount = t.preferredConsecutiveBFrameCount,
			preferredTemporalLayerCount = t.preferredTemporalLayerCount,
			preferredConstantQp = t.preferredConstantQp,
			preferredMaxL0ReferenceCount = t.preferredMaxL0ReferenceCount,
			preferredMaxL1ReferenceCount = t.preferredMaxL1ReferenceCount,
			preferredStdEntropyCodingModeFlag = t.preferredStdEntropyCodingModeFlag,
		}
	)
end
mod.s.TileMemorySizeInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTileMemorySizeInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			size = t.size,
		}
	)
end
mod.s.TileMemoryBindInfoQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTileMemoryBindInfoQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memory = t.memory,
		}
	)
end
mod.s.PhysicalDeviceVideoEncodeQualityLevelInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pVideoProfile = t.pVideoProfile,
			qualityLevel = t.qualityLevel,
		}
	)
end
mod.s.PhysicalDeviceMeshShaderFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMeshShaderFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			taskShader = t.taskShader,
			meshShader = t.meshShader,
			multiviewMeshShader = t.multiviewMeshShader,
			primitiveFragmentShadingRateMeshShader = t.primitiveFragmentShadingRateMeshShader,
			meshShaderQueries = t.meshShaderQueries,
		}
	)
end
mod.s.VideoEncodeQualityLevelPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeQualityLevelPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			preferredRateControlMode = t.preferredRateControlMode and
				mod.e.VkVideoEncodeRateControlModeFlagBitsKHR(t.preferredRateControlMode),
			preferredRateControlLayerCount = t.preferredRateControlLayerCount,
		}
	)
end
mod.s.PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			multiviewPerViewRenderAreas = t.multiviewPerViewRenderAreas,
		}
	)
end
mod.s.PhysicalDeviceDataGraphProcessingEngineARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDataGraphProcessingEngineARM(
		{
			type = t.type and mod.e.VkPhysicalDeviceDataGraphProcessingEngineTypeARM(t.type),
			isForeign = t.isForeign,
		}
	)
end
mod.s.VideoEncodeQualityLevelInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeQualityLevelInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			qualityLevel = t.qualityLevel,
		}
	)
end
mod.s.VideoEncodeSessionParametersGetInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeSessionParametersGetInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoSessionParameters = t.videoSessionParameters,
		}
	)
end
mod.s.VideoEncodeSessionParametersFeedbackInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeSessionParametersFeedbackInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			hasOverrides = t.hasOverrides,
		}
	)
end
mod.s.PhysicalDeviceSubpassShadingPropertiesHUAWEI = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxSubpassShadingWorkgroupSizeAspectRatio = t.maxSubpassShadingWorkgroupSizeAspectRatio,
		}
	)
end
mod.s.SurfacePresentModeKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSurfacePresentModeKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			presentMode = t.presentMode and mod.e.VkPresentModeKHR(t.presentMode),
		}
	)
end
mod.s.ShaderModuleIdentifierEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkShaderModuleIdentifierEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			identifierSize = t.identifierSize,
			identifier = t.identifier,
		}
	)
end
mod.s.ExternalTensorPropertiesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExternalTensorPropertiesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			externalMemoryProperties = t.externalMemoryProperties,
		}
	)
end
mod.s.AccelerationStructureInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			type = t.type,
			flags = t.flags,
			instanceCount = t.instanceCount,
			geometryCount = t.geometryCount,
			pGeometries = t.pGeometries,
		}
	)
end
mod.s.RayTracingPipelineCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRayTracingPipelineCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkPipelineCreateFlagBits(t.flags),
			stageCount = t.stageCount,
			pStages = t.pStages,
			groupCount = t.groupCount,
			pGroups = t.pGroups,
			maxPipelineRayRecursionDepth = t.maxPipelineRayRecursionDepth,
			pLibraryInfo = t.pLibraryInfo,
			pLibraryInterface = t.pLibraryInterface,
			pDynamicState = t.pDynamicState,
			layout = t.layout,
			basePipelineHandle = t.basePipelineHandle,
			basePipelineIndex = t.basePipelineIndex,
		}
	)
end
mod.s.TensorFormatPropertiesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkTensorFormatPropertiesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			optimalTilingTensorFeatures = t.optimalTilingTensorFeatures,
			linearTilingTensorFeatures = t.linearTilingTensorFeatures,
		}
	)
end
mod.s.RenderPassSubpassFeedbackCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassSubpassFeedbackCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pSubpassFeedback = t.pSubpassFeedback,
		}
	)
end
mod.s.StdVideoEncodeAV1PictureInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoEncodeAV1PictureInfo(
		{
			flags = t.flags,
			frame_type = t.frame_type and mod.e.StdVideoAV1FrameType(t.frame_type),
			frame_presentation_time = t.frame_presentation_time,
			current_frame_id = t.current_frame_id,
			order_hint = t.order_hint,
			primary_ref_frame = t.primary_ref_frame,
			refresh_frame_flags = t.refresh_frame_flags,
			coded_denom = t.coded_denom,
			render_width_minus_1 = t.render_width_minus_1,
			render_height_minus_1 = t.render_height_minus_1,
			interpolation_filter = t.interpolation_filter and
				mod.e.StdVideoAV1InterpolationFilter(t.interpolation_filter),
			TxMode = t.TxMode and mod.e.StdVideoAV1TxMode(t.TxMode),
			delta_q_res = t.delta_q_res,
			delta_lf_res = t.delta_lf_res,
			ref_order_hint = t.ref_order_hint,
			ref_frame_idx = t.ref_frame_idx,
			reserved1 = t.reserved1,
			delta_frame_id_minus_1 = t.delta_frame_id_minus_1,
			pTileInfo = t.pTileInfo,
			pQuantization = t.pQuantization,
			pSegmentation = t.pSegmentation,
			pLoopFilter = t.pLoopFilter,
			pCDEF = t.pCDEF,
			pLoopRestoration = t.pLoopRestoration,
			pGlobalMotion = t.pGlobalMotion,
			pExtensionHeader = t.pExtensionHeader,
			pBufferRemovalTimes = t.pBufferRemovalTimes,
		}
	)
end
mod.s.PhysicalDeviceExtendedDynamicState3FeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			extendedDynamicState3TessellationDomainOrigin = t.extendedDynamicState3TessellationDomainOrigin,
			extendedDynamicState3DepthClampEnable = t.extendedDynamicState3DepthClampEnable,
			extendedDynamicState3PolygonMode = t.extendedDynamicState3PolygonMode,
			extendedDynamicState3RasterizationSamples = t.extendedDynamicState3RasterizationSamples,
			extendedDynamicState3SampleMask = t.extendedDynamicState3SampleMask,
			extendedDynamicState3AlphaToCoverageEnable = t.extendedDynamicState3AlphaToCoverageEnable,
			extendedDynamicState3AlphaToOneEnable = t.extendedDynamicState3AlphaToOneEnable,
			extendedDynamicState3LogicOpEnable = t.extendedDynamicState3LogicOpEnable,
			extendedDynamicState3ColorBlendEnable = t.extendedDynamicState3ColorBlendEnable,
			extendedDynamicState3ColorBlendEquation = t.extendedDynamicState3ColorBlendEquation,
			extendedDynamicState3ColorWriteMask = t.extendedDynamicState3ColorWriteMask,
			extendedDynamicState3RasterizationStream = t.extendedDynamicState3RasterizationStream,
			extendedDynamicState3ConservativeRasterizationMode = t.extendedDynamicState3ConservativeRasterizationMode,
			extendedDynamicState3ExtraPrimitiveOverestimationSize = t.extendedDynamicState3ExtraPrimitiveOverestimationSize,
			extendedDynamicState3DepthClipEnable = t.extendedDynamicState3DepthClipEnable,
			extendedDynamicState3SampleLocationsEnable = t.extendedDynamicState3SampleLocationsEnable,
			extendedDynamicState3ColorBlendAdvanced = t.extendedDynamicState3ColorBlendAdvanced,
			extendedDynamicState3ProvokingVertexMode = t.extendedDynamicState3ProvokingVertexMode,
			extendedDynamicState3LineRasterizationMode = t.extendedDynamicState3LineRasterizationMode,
			extendedDynamicState3LineStippleEnable = t.extendedDynamicState3LineStippleEnable,
			extendedDynamicState3DepthClipNegativeOneToOne = t.extendedDynamicState3DepthClipNegativeOneToOne,
			extendedDynamicState3ViewportWScalingEnable = t.extendedDynamicState3ViewportWScalingEnable,
			extendedDynamicState3ViewportSwizzle = t.extendedDynamicState3ViewportSwizzle,
			extendedDynamicState3CoverageToColorEnable = t.extendedDynamicState3CoverageToColorEnable,
			extendedDynamicState3CoverageToColorLocation = t.extendedDynamicState3CoverageToColorLocation,
			extendedDynamicState3CoverageModulationMode = t.extendedDynamicState3CoverageModulationMode,
			extendedDynamicState3CoverageModulationTableEnable = t.extendedDynamicState3CoverageModulationTableEnable,
			extendedDynamicState3CoverageModulationTable = t.extendedDynamicState3CoverageModulationTable,
			extendedDynamicState3CoverageReductionMode = t.extendedDynamicState3CoverageReductionMode,
			extendedDynamicState3RepresentativeFragmentTestEnable = t.extendedDynamicState3RepresentativeFragmentTestEnable,
			extendedDynamicState3ShadingRateImageEnable = t.extendedDynamicState3ShadingRateImageEnable,
		}
	)
end
mod.s.PhysicalDeviceNestedCommandBufferPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceNestedCommandBufferPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxCommandBufferNestingLevel = t.maxCommandBufferNestingLevel,
		}
	)
end
mod.s.PhysicalDeviceInvocationMaskFeaturesHUAWEI = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			invocationMask = t.invocationMask,
		}
	)
end
mod.s.PhysicalDeviceImageProcessingFeaturesQCOM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageProcessingFeaturesQCOM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			textureSampleWeighted = t.textureSampleWeighted,
			textureBoxFilter = t.textureBoxFilter,
			textureBlockMatch = t.textureBlockMatch,
		}
	)
end
mod.s.PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageCompressionControlSwapchain = t.imageCompressionControlSwapchain,
		}
	)
end
mod.s.PhysicalDeviceShadingRateImagePropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShadingRateImagePropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shadingRateTexelSize = t.shadingRateTexelSize,
			shadingRatePaletteSize = t.shadingRatePaletteSize,
			shadingRateMaxCoarseSamples = t.shadingRateMaxCoarseSamples,
		}
	)
end
mod.s.DescriptorAddressInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorAddressInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			address = t.address,
			range = t.range,
			format = t.format and mod.e.VkFormat(t.format),
		}
	)
end
mod.s.DepthBiasRepresentationInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDepthBiasRepresentationInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			depthBiasRepresentation = t.depthBiasRepresentation and
				mod.e.VkDepthBiasRepresentationEXT(t.depthBiasRepresentation),
			depthBiasExact = t.depthBiasExact,
		}
	)
end
mod.s.PipelineCompilerControlCreateInfoAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineCompilerControlCreateInfoAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			compilerControlFlags = t.compilerControlFlags,
		}
	)
end
mod.s.CopyAccelerationStructureToMemoryInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyAccelerationStructureToMemoryInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			src = t.src,
			dst = t.dst,
			mode = t.mode and mod.e.VkCopyAccelerationStructureModeKHR(t.mode),
		}
	)
end
mod.s.StdVideoEncodeAV1ReferenceInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoEncodeAV1ReferenceInfo(
		{
			flags = t.flags,
			RefFrameId = t.RefFrameId,
			frame_type = t.frame_type and mod.e.StdVideoAV1FrameType(t.frame_type),
			OrderHint = t.OrderHint,
			reserved1 = t.reserved1,
			pExtensionHeader = t.pExtensionHeader,
		}
	)
end
mod.s.PhysicalDeviceExternalMemoryRDMAFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			externalMemoryRDMA = t.externalMemoryRDMA,
		}
	)
end
mod.s.PhysicalDeviceLayeredDriverPropertiesMSFT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceLayeredDriverPropertiesMSFT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			underlyingAPI = t.underlyingAPI and mod.e.VkLayeredDriverUnderlyingApiMSFT(t.underlyingAPI),
		}
	)
end
mod.s.PhysicalDeviceVulkan12Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceVulkan12Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			samplerMirrorClampToEdge = t.samplerMirrorClampToEdge,
			drawIndirectCount = t.drawIndirectCount,
			storageBuffer8BitAccess = t.storageBuffer8BitAccess,
			uniformAndStorageBuffer8BitAccess = t.uniformAndStorageBuffer8BitAccess,
			storagePushConstant8 = t.storagePushConstant8,
			shaderBufferInt64Atomics = t.shaderBufferInt64Atomics,
			shaderSharedInt64Atomics = t.shaderSharedInt64Atomics,
			shaderFloat16 = t.shaderFloat16,
			shaderInt8 = t.shaderInt8,
			descriptorIndexing = t.descriptorIndexing,
			shaderInputAttachmentArrayDynamicIndexing = t.shaderInputAttachmentArrayDynamicIndexing,
			shaderUniformTexelBufferArrayDynamicIndexing = t.shaderUniformTexelBufferArrayDynamicIndexing,
			shaderStorageTexelBufferArrayDynamicIndexing = t.shaderStorageTexelBufferArrayDynamicIndexing,
			shaderUniformBufferArrayNonUniformIndexing = t.shaderUniformBufferArrayNonUniformIndexing,
			shaderSampledImageArrayNonUniformIndexing = t.shaderSampledImageArrayNonUniformIndexing,
			shaderStorageBufferArrayNonUniformIndexing = t.shaderStorageBufferArrayNonUniformIndexing,
			shaderStorageImageArrayNonUniformIndexing = t.shaderStorageImageArrayNonUniformIndexing,
			shaderInputAttachmentArrayNonUniformIndexing = t.shaderInputAttachmentArrayNonUniformIndexing,
			shaderUniformTexelBufferArrayNonUniformIndexing = t.shaderUniformTexelBufferArrayNonUniformIndexing,
			shaderStorageTexelBufferArrayNonUniformIndexing = t.shaderStorageTexelBufferArrayNonUniformIndexing,
			descriptorBindingUniformBufferUpdateAfterBind = t.descriptorBindingUniformBufferUpdateAfterBind,
			descriptorBindingSampledImageUpdateAfterBind = t.descriptorBindingSampledImageUpdateAfterBind,
			descriptorBindingStorageImageUpdateAfterBind = t.descriptorBindingStorageImageUpdateAfterBind,
			descriptorBindingStorageBufferUpdateAfterBind = t.descriptorBindingStorageBufferUpdateAfterBind,
			descriptorBindingUniformTexelBufferUpdateAfterBind = t.descriptorBindingUniformTexelBufferUpdateAfterBind,
			descriptorBindingStorageTexelBufferUpdateAfterBind = t.descriptorBindingStorageTexelBufferUpdateAfterBind,
			descriptorBindingUpdateUnusedWhilePending = t.descriptorBindingUpdateUnusedWhilePending,
			descriptorBindingPartiallyBound = t.descriptorBindingPartiallyBound,
			descriptorBindingVariableDescriptorCount = t.descriptorBindingVariableDescriptorCount,
			runtimeDescriptorArray = t.runtimeDescriptorArray,
			samplerFilterMinmax = t.samplerFilterMinmax,
			scalarBlockLayout = t.scalarBlockLayout,
			imagelessFramebuffer = t.imagelessFramebuffer,
			uniformBufferStandardLayout = t.uniformBufferStandardLayout,
			shaderSubgroupExtendedTypes = t.shaderSubgroupExtendedTypes,
			separateDepthStencilLayouts = t.separateDepthStencilLayouts,
			hostQueryReset = t.hostQueryReset,
			timelineSemaphore = t.timelineSemaphore,
			bufferDeviceAddress = t.bufferDeviceAddress,
			bufferDeviceAddressCaptureReplay = t.bufferDeviceAddressCaptureReplay,
			bufferDeviceAddressMultiDevice = t.bufferDeviceAddressMultiDevice,
			vulkanMemoryModel = t.vulkanMemoryModel,
			vulkanMemoryModelDeviceScope = t.vulkanMemoryModelDeviceScope,
			vulkanMemoryModelAvailabilityVisibilityChains = t.vulkanMemoryModelAvailabilityVisibilityChains,
			shaderOutputViewportIndex = t.shaderOutputViewportIndex,
			shaderOutputLayer = t.shaderOutputLayer,
			subgroupBroadcastDynamicId = t.subgroupBroadcastDynamicId,
		}
	)
end
mod.s.AccelerationStructureGeometryTrianglesDataKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureGeometryTrianglesDataKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			vertexFormat = t.vertexFormat and mod.e.VkFormat(t.vertexFormat),
			vertexData = t.vertexData,
			vertexStride = t.vertexStride,
			maxVertex = t.maxVertex,
			indexType = t.indexType and mod.e.VkIndexType(t.indexType),
			indexData = t.indexData,
			transformData = t.transformData,
		}
	)
end
mod.s.PipelineTessellationStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineTessellationStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			patchControlPoints = t.patchControlPoints,
		}
	)
end
mod.s.MemoryHeap = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryHeap({
		size = t.size,
		flags = t.flags and mod.e.VkMemoryHeapFlagBits(t.flags),
	})
end
mod.s.PhysicalDeviceCommandBufferInheritanceFeaturesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			commandBufferInheritance = t.commandBufferInheritance,
		}
	)
end
mod.s.PhysicalDeviceShaderReplicatedCompositesFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderReplicatedComposites = t.shaderReplicatedComposites,
		}
	)
end
mod.s.VideoProfileInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoProfileInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoCodecOperation = t.videoCodecOperation and
				mod.e.VkVideoCodecOperationFlagBitsKHR(t.videoCodecOperation),
			chromaSubsampling = t.chromaSubsampling,
			lumaBitDepth = t.lumaBitDepth,
			chromaBitDepth = t.chromaBitDepth,
		}
	)
end
mod.s.PhysicalDeviceShaderDrawParametersFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceShaderDrawParametersFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			shaderDrawParameters = t.shaderDrawParameters,
		}
	)
end
mod.s.PipelinePropertiesIdentifierEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelinePropertiesIdentifierEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineIdentifier = t.pipelineIdentifier,
		}
	)
end
mod.s.PipelineViewportStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineViewportStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			viewportCount = t.viewportCount,
			pViewports = t.pViewports,
			scissorCount = t.scissorCount,
			pScissors = t.pScissors,
		}
	)
end
mod.s.PhysicalDevicePipelinePropertiesFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePipelinePropertiesFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelinePropertiesIdentifier = t.pipelinePropertiesIdentifier,
		}
	)
end
mod.s.PhysicalDeviceToolProperties = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceToolProperties(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			name = t.name,
			version = t.version,
			purposes = t.purposes and mod.e.VkToolPurposeFlagBits(t.purposes),
			description = t.description,
			layer = t.layer,
		}
	)
end
mod.s.CopyBufferToImageInfo2 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyBufferToImageInfo2(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcBuffer = t.srcBuffer,
			dstImage = t.dstImage,
			dstImageLayout = t.dstImageLayout and mod.e.VkImageLayout(t.dstImageLayout),
			regionCount = t.regionCount,
			pRegions = t.pRegions,
		}
	)
end
mod.s.FormatProperties3 = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFormatProperties3(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			linearTilingFeatures = t.linearTilingFeatures,
			optimalTilingFeatures = t.optimalTilingFeatures,
			bufferFeatures = t.bufferFeatures,
		}
	)
end
mod.s.CopyImageToMemoryInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCopyImageToMemoryInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkHostImageCopyFlagBits(t.flags),
			srcImage = t.srcImage,
			srcImageLayout = t.srcImageLayout and mod.e.VkImageLayout(t.srcImageLayout),
			regionCount = t.regionCount,
			pRegions = t.pRegions,
		}
	)
end
mod.s.PipelineRasterizationStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineRasterizationStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			depthClampEnable = t.depthClampEnable,
			rasterizerDiscardEnable = t.rasterizerDiscardEnable,
			polygonMode = t.polygonMode and mod.e.VkPolygonMode(t.polygonMode),
			cullMode = t.cullMode and mod.e.VkCullModeFlagBits(t.cullMode),
			frontFace = t.frontFace and mod.e.VkFrontFace(t.frontFace),
			depthBiasEnable = t.depthBiasEnable,
			depthBiasConstantFactor = t.depthBiasConstantFactor,
			depthBiasClamp = t.depthBiasClamp,
			depthBiasSlopeFactor = t.depthBiasSlopeFactor,
			lineWidth = t.lineWidth,
		}
	)
end
mod.s.StdVideoEncodeH264RefListModEntry = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoEncodeH264RefListModEntry(
		{
			modification_of_pic_nums_idc = t.modification_of_pic_nums_idc and
				mod.e.StdVideoH264ModificationOfPicNumsIdc(t.modification_of_pic_nums_idc),
			abs_diff_pic_num_minus1 = t.abs_diff_pic_num_minus1,
			long_term_pic_num = t.long_term_pic_num,
		}
	)
end
mod.s.VideoDecodeUsageInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeUsageInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			videoUsageHints = t.videoUsageHints,
		}
	)
end
mod.s.PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fragmentDensityMapOffset = t.fragmentDensityMapOffset,
		}
	)
end
mod.s.PhysicalDeviceMaintenance6Features = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMaintenance6Features(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maintenance6 = t.maintenance6,
		}
	)
end
mod.s.PhysicalDeviceRenderPassStripedFeaturesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceRenderPassStripedFeaturesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			renderPassStriped = t.renderPassStriped,
		}
	)
end
mod.s.AccelerationStructureBuildSizesInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureBuildSizesInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			accelerationStructureSize = t.accelerationStructureSize,
			updateScratchSize = t.updateScratchSize,
			buildScratchSize = t.buildScratchSize,
		}
	)
end
mod.s.PhysicalDeviceFrameBoundaryFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFrameBoundaryFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			frameBoundary = t.frameBoundary,
		}
	)
end
mod.s.PhysicalDeviceLayeredApiPropertiesListKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceLayeredApiPropertiesListKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			layeredApiCount = t.layeredApiCount,
			pLayeredApis = t.pLayeredApis,
		}
	)
end
mod.s.FrameBoundaryEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkFrameBoundaryEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			frameID = t.frameID,
			imageCount = t.imageCount,
			pImages = t.pImages,
			bufferCount = t.bufferCount,
			pBuffers = t.pBuffers,
			tagName = t.tagName,
			tagSize = t.tagSize,
			pTag = t.pTag,
		}
	)
end
mod.s.PipelineMultisampleStateCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineMultisampleStateCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			rasterizationSamples = t.rasterizationSamples and mod.e.VkSampleCountFlagBits(t.rasterizationSamples),
			sampleShadingEnable = t.sampleShadingEnable,
			minSampleShading = t.minSampleShading,
			pSampleMask = t.pSampleMask,
			alphaToCoverageEnable = t.alphaToCoverageEnable,
			alphaToOneEnable = t.alphaToOneEnable,
		}
	)
end
mod.s.VideoDecodeInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			srcBuffer = t.srcBuffer,
			srcBufferOffset = t.srcBufferOffset,
			srcBufferRange = t.srcBufferRange,
			dstPictureResource = t.dstPictureResource,
			pSetupReferenceSlot = t.pSetupReferenceSlot,
			referenceSlotCount = t.referenceSlotCount,
			pReferenceSlots = t.pReferenceSlots,
		}
	)
end
mod.s.PhysicalDevicePipelineRobustnessFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePipelineRobustnessFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pipelineRobustness = t.pipelineRobustness,
		}
	)
end
mod.s.VideoSessionParametersCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoSessionParametersCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			videoSessionParametersTemplate = t.videoSessionParametersTemplate,
			videoSession = t.videoSession,
		}
	)
end
mod.s.VideoEncodeH265RateControlLayerInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeH265RateControlLayerInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			useMinQp = t.useMinQp,
			minQp = t.minQp,
			useMaxQp = t.useMaxQp,
			maxQp = t.maxQp,
			useMaxFrameSize = t.useMaxFrameSize,
			maxFrameSize = t.maxFrameSize,
		}
	)
end
mod.s.IndirectCommandsLayoutCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkIndirectCommandsLayoutCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			shaderStages = t.shaderStages and mod.e.VkShaderStageFlagBits(t.shaderStages),
			indirectStride = t.indirectStride,
			pipelineLayout = t.pipelineLayout,
			tokenCount = t.tokenCount,
			pTokens = t.pTokens,
		}
	)
end
mod.s.PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			multisampledRenderToSingleSampled = t.multisampledRenderToSingleSampled,
		}
	)
end
mod.s.PhysicalDeviceImageAlignmentControlFeaturesMESA = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceImageAlignmentControlFeaturesMESA(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageAlignmentControl = t.imageAlignmentControl,
		}
	)
end
mod.s.SubpassResolvePerformanceQueryEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubpassResolvePerformanceQueryEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			optimal = t.optimal,
		}
	)
end
mod.s.PhysicalDeviceFormatPackFeaturesARM = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFormatPackFeaturesARM(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			formatPack = t.formatPack,
		}
	)
end
mod.s.MultisampledRenderToSingleSampledInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMultisampledRenderToSingleSampledInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			multisampledRenderToSingleSampledEnable = t.multisampledRenderToSingleSampledEnable,
			rasterizationSamples = t.rasterizationSamples and mod.e.VkSampleCountFlagBits(t.rasterizationSamples),
		}
	)
end
mod.s.StdVideoEncodeH264PictureInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.StdVideoEncodeH264PictureInfo(
		{
			flags = t.flags,
			seq_parameter_set_id = t.seq_parameter_set_id,
			pic_parameter_set_id = t.pic_parameter_set_id,
			idr_pic_id = t.idr_pic_id,
			primary_pic_type = t.primary_pic_type and mod.e.StdVideoH264PictureType(t.primary_pic_type),
			frame_num = t.frame_num,
			PicOrderCnt = t.PicOrderCnt,
			temporal_id = t.temporal_id,
			reserved1 = t.reserved1,
			pRefLists = t.pRefLists,
		}
	)
end
mod.s.DeviceGroupRenderPassBeginInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceGroupRenderPassBeginInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceMask = t.deviceMask,
			deviceRenderAreaCount = t.deviceRenderAreaCount,
			pDeviceRenderAreas = t.pDeviceRenderAreas,
		}
	)
end
mod.s.DisplayPresentInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplayPresentInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			srcRect = t.srcRect,
			dstRect = t.dstRect,
			persistent = t.persistent,
		}
	)
end
mod.s.VideoDecodeH264InlineSessionParametersInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoDecodeH264InlineSessionParametersInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pStdSPS = t.pStdSPS,
			pStdPPS = t.pStdPPS,
		}
	)
end
mod.s.PhysicalDeviceExtendedDynamicState2FeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			extendedDynamicState2 = t.extendedDynamicState2,
			extendedDynamicState2LogicOp = t.extendedDynamicState2LogicOp,
			extendedDynamicState2PatchControlPoints = t.extendedDynamicState2PatchControlPoints,
		}
	)
end
mod.s.VideoEncodeQuantizationMapInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeQuantizationMapInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			quantizationMap = t.quantizationMap,
			quantizationMapExtent = t.quantizationMapExtent,
		}
	)
end
mod.s.ClearAttachment = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkClearAttachment(
		{
			aspectMask = t.aspectMask and mod.e.VkImageAspectFlagBits(t.aspectMask),
			colorAttachment = t.colorAttachment,
			clearValue = t.clearValue,
		}
	)
end
mod.s.PhysicalDevicePCIBusInfoPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePCIBusInfoPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			pciDomain = t.pciDomain,
			pciBus = t.pciBus,
			pciDevice = t.pciDevice,
			pciFunction = t.pciFunction,
		}
	)
end
mod.s.StencilOpState = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkStencilOpState(
		{
			failOp = t.failOp and mod.e.VkStencilOp(t.failOp),
			passOp = t.passOp and mod.e.VkStencilOp(t.passOp),
			depthFailOp = t.depthFailOp and mod.e.VkStencilOp(t.depthFailOp),
			compareOp = t.compareOp and mod.e.VkCompareOp(t.compareOp),
			compareMask = t.compareMask,
			writeMask = t.writeMask,
			reference = t.reference,
		}
	)
end
mod.s.SubresourceHostMemcpySize = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubresourceHostMemcpySize(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			size = t.size,
		}
	)
end
mod.s.AccelerationStructureMotionInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAccelerationStructureMotionInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			maxInstances = t.maxInstances,
			flags = t.flags,
		}
	)
end
mod.s.AndroidHardwareBufferFormatPropertiesANDROID = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkAndroidHardwareBufferFormatPropertiesANDROID(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			format = t.format and mod.e.VkFormat(t.format),
			externalFormat = t.externalFormat,
			formatFeatures = t.formatFeatures and mod.e.VkFormatFeatureFlagBits(t.formatFeatures),
			samplerYcbcrConversionComponents = t.samplerYcbcrConversionComponents,
			suggestedYcbcrModel = t.suggestedYcbcrModel and
				mod.e.VkSamplerYcbcrModelConversion(t.suggestedYcbcrModel),
			suggestedYcbcrRange = t.suggestedYcbcrRange and mod.e.VkSamplerYcbcrRange(t.suggestedYcbcrRange),
			suggestedXChromaOffset = t.suggestedXChromaOffset and mod.e.VkChromaLocation(t.suggestedXChromaOffset),
			suggestedYChromaOffset = t.suggestedYChromaOffset and mod.e.VkChromaLocation(t.suggestedYChromaOffset),
		}
	)
end
mod.s.SubpassEndInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSubpassEndInfo({
		sType = t.sType and mod.e.VkStructureType(t.sType),
		pNext = t.pNext,
	})
end
mod.s.VideoEncodeSessionIntraRefreshCreateInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVideoEncodeSessionIntraRefreshCreateInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			intraRefreshMode = t.intraRefreshMode and
				mod.e.VkVideoEncodeIntraRefreshModeFlagBitsKHR(t.intraRefreshMode),
		}
	)
end
mod.s.CalibratedTimestampInfoKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkCalibratedTimestampInfoKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			timeDomain = t.timeDomain and mod.e.VkTimeDomainKHR(t.timeDomain),
		}
	)
end
mod.s.DisplayNativeHdrSurfaceCapabilitiesAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplayNativeHdrSurfaceCapabilitiesAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			localDimmingSupport = t.localDimmingSupport,
		}
	)
end
mod.s.DescriptorSetVariableDescriptorCountAllocateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDescriptorSetVariableDescriptorCountAllocateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			descriptorSetCount = t.descriptorSetCount,
			pDescriptorCounts = t.pDescriptorCounts,
		}
	)
end
mod.s.SwapchainDisplayNativeHdrCreateInfoAMD = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkSwapchainDisplayNativeHdrCreateInfoAMD(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			localDimmingEnable = t.localDimmingEnable,
		}
	)
end
mod.s.MacOSSurfaceCreateInfoMVK = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMacOSSurfaceCreateInfoMVK(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags,
			pView = t.pView,
		}
	)
end
mod.s.MemoryFdPropertiesKHR = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkMemoryFdPropertiesKHR(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			memoryTypeBits = t.memoryTypeBits,
		}
	)
end
mod.s.ExportMetalObjectsInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkExportMetalObjectsInfoEXT({
		sType = t.sType and mod.e.VkStructureType(t.sType),
		pNext = t.pNext,
	})
end
mod.s.PhysicalDeviceColorWriteEnableFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceColorWriteEnableFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			colorWriteEnable = t.colorWriteEnable,
		}
	)
end
mod.s.DisplayModeStereoPropertiesNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplayModeStereoPropertiesNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			hdmi3DSupported = t.hdmi3DSupported,
		}
	)
end
mod.s.PipelineColorWriteCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPipelineColorWriteCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			attachmentCount = t.attachmentCount,
			pColorWriteEnables = t.pColorWriteEnables,
		}
	)
end
mod.s.DeviceGroupSubmitInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceGroupSubmitInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			waitSemaphoreCount = t.waitSemaphoreCount,
			pWaitSemaphoreDeviceIndices = t.pWaitSemaphoreDeviceIndices,
			commandBufferCount = t.commandBufferCount,
			pCommandBufferDeviceMasks = t.pCommandBufferDeviceMasks,
			signalSemaphoreCount = t.signalSemaphoreCount,
			pSignalSemaphoreDeviceIndices = t.pSignalSemaphoreDeviceIndices,
		}
	)
end
mod.s.PhysicalDeviceFragmentDensityMapFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentDensityMapFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fragmentDensityMap = t.fragmentDensityMap,
			fragmentDensityMapDynamic = t.fragmentDensityMapDynamic,
			fragmentDensityMapNonSubsampledImages = t.fragmentDensityMapNonSubsampledImages,
		}
	)
end
mod.s.DisplaySurfaceStereoCreateInfoNV = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDisplaySurfaceStereoCreateInfoNV(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			stereoType = t.stereoType and mod.e.VkDisplaySurfaceStereoTypeNV(t.stereoType),
		}
	)
end
mod.s.ComputePipelineCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkComputePipelineCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			flags = t.flags and mod.e.VkPipelineCreateFlagBits(t.flags),
			stage = t.stage,
			layout = t.layout,
			basePipelineHandle = t.basePipelineHandle,
			basePipelineIndex = t.basePipelineIndex,
		}
	)
end
mod.s.VertexInputBindingDescription = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkVertexInputBindingDescription(
		{
			binding = t.binding,
			stride = t.stride,
			inputRate = t.inputRate and mod.e.VkVertexInputRate(t.inputRate),
		}
	)
end
mod.s.PhysicalDeviceFragmentDensityMapPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceFragmentDensityMapPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			minFragmentDensityTexelSize = t.minFragmentDensityTexelSize,
			maxFragmentDensityTexelSize = t.maxFragmentDensityTexelSize,
			fragmentDensityInvocations = t.fragmentDensityInvocations,
		}
	)
end
mod.s.PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			primitivesGeneratedQuery = t.primitivesGeneratedQuery,
			primitivesGeneratedQueryWithRasterizerDiscard = t.primitivesGeneratedQueryWithRasterizerDiscard,
			primitivesGeneratedQueryWithNonZeroStreams = t.primitivesGeneratedQueryWithNonZeroStreams,
		}
	)
end
mod.s.DeviceGroupDeviceCreateInfo = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkDeviceGroupDeviceCreateInfo(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			physicalDeviceCount = t.physicalDeviceCount,
			pPhysicalDevices = t.pPhysicalDevices,
		}
	)
end
mod.s.PhysicalDeviceLegacyVertexAttributesFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			legacyVertexAttributes = t.legacyVertexAttributes,
		}
	)
end
mod.s.RenderPassFragmentDensityMapCreateInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderPassFragmentDensityMapCreateInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			fragmentDensityMapAttachment = t.fragmentDensityMapAttachment,
		}
	)
end
mod.s.PhysicalDeviceLegacyVertexAttributesPropertiesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			nativeUnalignedPerformance = t.nativeUnalignedPerformance,
		}
	)
end
mod.s.RenderingFragmentDensityMapAttachmentInfoEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkRenderingFragmentDensityMapAttachmentInfoEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			imageView = t.imageView,
			imageLayout = t.imageLayout and mod.e.VkImageLayout(t.imageLayout),
		}
	)
end
mod.s.PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			deviceGeneratedCommands = t.deviceGeneratedCommands,
			dynamicGeneratedPipelineLayout = t.dynamicGeneratedPipelineLayout,
		}
	)
end
mod.s.PhysicalDeviceUniformBufferStandardLayoutFeatures = function(t)
	if type(t) ~= "table" then return t end

	return mod.VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
		{
			sType = t.sType and mod.e.VkStructureType(t.sType),
			pNext = t.pNext,
			uniformBufferStandardLayout = t.uniformBufferStandardLayout,
		}
	)
end
-- Info struct builders with automatic sType and enum translation
mod.infos = {}

do
	local _pool

	function mod.infos.PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxIndirectPipelineCount = t.maxIndirectPipelineCount or 0
		_pool.maxIndirectShaderObjectCount = t.maxIndirectShaderObjectCount or 0
		_pool.maxIndirectSequenceCount = t.maxIndirectSequenceCount or 0
		_pool.maxIndirectCommandsTokenCount = t.maxIndirectCommandsTokenCount or 0
		_pool.maxIndirectCommandsTokenOffset = t.maxIndirectCommandsTokenOffset or 0
		_pool.maxIndirectCommandsIndirectStride = t.maxIndirectCommandsIndirectStride or 0
		_pool.supportedIndirectCommandsInputModes = t.supportedIndirectCommandsInputModes or 0
		_pool.supportedIndirectCommandsShaderStages = t.supportedIndirectCommandsShaderStages ~= nil and
			mod.e.VkShaderStageFlagBits(t.supportedIndirectCommandsShaderStages) or
			0
		_pool.supportedIndirectCommandsShaderStagesPipelineBinding = t.supportedIndirectCommandsShaderStagesPipelineBinding ~= nil and
			mod.e.VkShaderStageFlagBits(t.supportedIndirectCommandsShaderStagesPipelineBinding) or
			0
		_pool.supportedIndirectCommandsShaderStagesShaderBinding = t.supportedIndirectCommandsShaderStagesShaderBinding ~= nil and
			mod.e.VkShaderStageFlagBits(t.supportedIndirectCommandsShaderStagesShaderBinding) or
			0
		_pool.deviceGeneratedCommandsTransformFeedback = t.deviceGeneratedCommandsTransformFeedback or 0
		_pool.deviceGeneratedCommandsMultiDrawIndirectCount = t.deviceGeneratedCommandsMultiDrawIndirectCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DevicePipelineBinaryInternalCacheControlKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDevicePipelineBinaryInternalCacheControlKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.disableInternalCache = t.disableInternalCache or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DebugUtilsMessengerCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDebugUtilsMessengerCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.messageSeverity = t.messageSeverity or 0
		_pool.messageType = t.messageType or 0
		_pool.pfnUserCallback = t.pfnUserCallback or 0
		_pool.pUserData = t.pUserData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineBinaryKeyKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineBinaryKeyKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.keySize = t.keySize or 0
		_pool.key = t.key or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DebugUtilsObjectTagInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDebugUtilsObjectTagInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.objectType = t.objectType ~= nil and mod.e.VkObjectType(t.objectType) or 0
		_pool.objectHandle = t.objectHandle or 0
		_pool.tagName = t.tagName or 0
		_pool.tagSize = t.tagSize or 0
		_pool.pTag = t.pTag or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineBinaryCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineBinaryCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pKeysAndDataInfo = t.pKeysAndDataInfo or 0
		_pool.pipeline = t.pipeline or 0
		_pool.pPipelineCreateInfo = t.pPipelineCreateInfo or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.graphicsPipelineLibraryFastLinking = t.graphicsPipelineLibraryFastLinking or 0
		_pool.graphicsPipelineLibraryIndependentInterpolationDecoration = t.graphicsPipelineLibraryIndependentInterpolationDecoration or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.LayerSettingsCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkLayerSettingsCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.settingCount = t.settingCount or 0
		_pool.pSettings = t.pSettings or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.IndirectExecutionSetShaderLayoutInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkIndirectExecutionSetShaderLayoutInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.setLayoutCount = t.setLayoutCount or 0
		_pool.pSetLayouts = t.pSetLayouts or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.IndirectExecutionSetShaderInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkIndirectExecutionSetShaderInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderCount = t.shaderCount or 0
		_pool.pInitialShaders = t.pInitialShaders or 0
		_pool.pSetLayoutInfos = t.pSetLayoutInfos or 0
		_pool.maxShaderCount = t.maxShaderCount or 0
		_pool.pushConstantRangeCount = t.pushConstantRangeCount or 0
		_pool.pPushConstantRanges = t.pPushConstantRanges or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineBinaryHandlesInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineBinaryHandlesInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineBinaryCount = t.pipelineBinaryCount or 0
		_pool.pPipelineBinaries = t.pPipelineBinaries or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderCoreBuiltinsFeaturesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderCoreBuiltins = t.shaderCoreBuiltins or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderCoreBuiltinsPropertiesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderCoreMask = t.shaderCoreMask or 0
		_pool.shaderCoreCount = t.shaderCoreCount or 0
		_pool.shaderWarpsPerCore = t.shaderWarpsPerCore or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.IndirectExecutionSetCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkIndirectExecutionSetCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type ~= nil and mod.e.VkIndirectExecutionSetInfoTypeEXT(t.type) or 0

		if t.info ~= nil then
			if type(t.info) == "table" then
				_pool.info = mod.VkIndirectExecutionSetInfoEXT(t.info)
			else
				_pool.info = t.info
			end
		else
			_pool.info = mod.VkIndirectExecutionSetInfoEXT()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.GeneratedCommandsInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGeneratedCommandsInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderStages = t.shaderStages ~= nil and mod.e.VkShaderStageFlagBits(t.shaderStages) or 0
		_pool.indirectExecutionSet = t.indirectExecutionSet or 0
		_pool.indirectCommandsLayout = t.indirectCommandsLayout or 0
		_pool.indirectAddress = t.indirectAddress or 0
		_pool.indirectAddressSize = t.indirectAddressSize or 0
		_pool.preprocessAddress = t.preprocessAddress or 0
		_pool.preprocessSize = t.preprocessSize or 0
		_pool.maxSequenceCount = t.maxSequenceCount or 0
		_pool.sequenceCountAddress = t.sequenceCountAddress or 0
		_pool.maxDrawCount = t.maxDrawCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceUnifiedImageLayoutsFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.unifiedImageLayouts = t.unifiedImageLayouts or 0
		_pool.unifiedImageLayoutsVideo = t.unifiedImageLayoutsVideo or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Application(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkApplicationInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_APPLICATION_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.pApplicationName = t.pApplicationName or 0
		_pool.applicationVersion = t.applicationVersion or 0
		_pool.pEngineName = t.pEngineName or 0
		_pool.engineVersion = t.engineVersion or 0
		_pool.apiVersion = t.apiVersion or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineLibraryGroupHandles = t.pipelineLibraryGroupHandles or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AttachmentFeedbackLoopInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAttachmentFeedbackLoopInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.feedbackLoopEnable = t.feedbackLoopEnable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.WriteIndirectExecutionSetPipelineEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkWriteIndirectExecutionSetPipelineEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.index = t.index or 0
		_pool.pipeline = t.pipeline or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCoherentMemoryFeaturesAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCoherentMemoryFeaturesAMD)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceCoherentMemory = t.deviceCoherentMemory or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.dynamicRenderingUnusedAttachments = t.dynamicRenderingUnusedAttachments or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageFormatList(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageFormatListCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.viewFormatCount = t.viewFormatCount or 0
		_pool.pViewFormats = t.pViewFormats or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMemoryBudgetPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMemoryBudgetPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.heapBudget = t.heapBudget or 0
		_pool.heapUsage = t.heapUsage or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AttachmentSampleCountInfoAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAttachmentSampleCountInfoAMD)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD")
		end

		_pool.pNext = t.pNext or nil
		_pool.colorAttachmentCount = t.colorAttachmentCount or 0
		_pool.pColorAttachmentSamples = t.pColorAttachmentSamples or 0
		_pool.depthStencilAttachmentSamples = t.depthStencilAttachmentSamples ~= nil and
			mod.e.VkSampleCountFlagBits(t.depthStencilAttachmentSamples) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentShadingRateEnumsPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxFragmentShadingRateInvocationCount = t.maxFragmentShadingRateInvocationCount ~= nil and
			mod.e.VkSampleCountFlagBits(t.maxFragmentShadingRateInvocationCount) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMemoryPriorityFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMemoryPriorityFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.memoryPriority = t.memoryPriority or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GeneratedCommandsShaderInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGeneratedCommandsShaderInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderCount = t.shaderCount or 0
		_pool.pShaders = t.pShaders or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryPriorityAllocateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryPriorityAllocateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.priority = t.priority or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SubpassBegin(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSubpassBeginInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.contents = t.contents ~= nil and mod.e.VkSubpassContents(t.contents) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.FragmentShadingRateAttachmentInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkFragmentShadingRateAttachmentInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pFragmentShadingRateAttachment = t.pFragmentShadingRateAttachment or 0

		if t.shadingRateAttachmentTexelSize ~= nil then
			if type(t.shadingRateAttachmentTexelSize) == "table" then
				_pool.shadingRateAttachmentTexelSize = mod.VkExtent2D(t.shadingRateAttachmentTexelSize)
			else
				_pool.shadingRateAttachmentTexelSize = t.shadingRateAttachmentTexelSize
			end
		else
			_pool.shadingRateAttachmentTexelSize = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.dedicatedAllocationImageAliasing = t.dedicatedAllocationImageAliasing or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDriverProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDriverProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.driverID = t.driverID ~= nil and mod.e.VkDriverId(t.driverID) or 0
		_pool.driverName = t.driverName or 0
		_pool.driverInfo = t.driverInfo or 0

		if t.conformanceVersion ~= nil then
			if type(t.conformanceVersion) == "table" then
				_pool.conformanceVersion = mod.VkConformanceVersion(t.conformanceVersion)
			else
				_pool.conformanceVersion = t.conformanceVersion
			end
		else
			_pool.conformanceVersion = mod.VkConformanceVersion()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineFragmentShadingRateStateCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineFragmentShadingRateStateCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil

		if t.fragmentSize ~= nil then
			if type(t.fragmentSize) == "table" then
				_pool.fragmentSize = mod.VkExtent2D(t.fragmentSize)
			else
				_pool.fragmentSize = t.fragmentSize
			end
		else
			_pool.fragmentSize = mod.VkExtent2D()
		end

		_pool.combinerOps = t.combinerOps ~= nil and
			mod.e.VkFragmentShadingRateCombinerOpKHR(t.combinerOps) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFloatControlsProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFloatControlsProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.denormBehaviorIndependence = t.denormBehaviorIndependence ~= nil and
			mod.e.VkShaderFloatControlsIndependence(t.denormBehaviorIndependence) or
			0
		_pool.roundingModeIndependence = t.roundingModeIndependence ~= nil and
			mod.e.VkShaderFloatControlsIndependence(t.roundingModeIndependence) or
			0
		_pool.shaderSignedZeroInfNanPreserveFloat16 = t.shaderSignedZeroInfNanPreserveFloat16 or 0
		_pool.shaderSignedZeroInfNanPreserveFloat32 = t.shaderSignedZeroInfNanPreserveFloat32 or 0
		_pool.shaderSignedZeroInfNanPreserveFloat64 = t.shaderSignedZeroInfNanPreserveFloat64 or 0
		_pool.shaderDenormPreserveFloat16 = t.shaderDenormPreserveFloat16 or 0
		_pool.shaderDenormPreserveFloat32 = t.shaderDenormPreserveFloat32 or 0
		_pool.shaderDenormPreserveFloat64 = t.shaderDenormPreserveFloat64 or 0
		_pool.shaderDenormFlushToZeroFloat16 = t.shaderDenormFlushToZeroFloat16 or 0
		_pool.shaderDenormFlushToZeroFloat32 = t.shaderDenormFlushToZeroFloat32 or 0
		_pool.shaderDenormFlushToZeroFloat64 = t.shaderDenormFlushToZeroFloat64 or 0
		_pool.shaderRoundingModeRTEFloat16 = t.shaderRoundingModeRTEFloat16 or 0
		_pool.shaderRoundingModeRTEFloat32 = t.shaderRoundingModeRTEFloat32 or 0
		_pool.shaderRoundingModeRTEFloat64 = t.shaderRoundingModeRTEFloat64 or 0
		_pool.shaderRoundingModeRTZFloat16 = t.shaderRoundingModeRTZFloat16 or 0
		_pool.shaderRoundingModeRTZFloat32 = t.shaderRoundingModeRTZFloat32 or 0
		_pool.shaderRoundingModeRTZFloat64 = t.shaderRoundingModeRTZFloat64 or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceBufferDeviceAddressFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.bufferDeviceAddress = t.bufferDeviceAddress or 0
		_pool.bufferDeviceAddressCaptureReplay = t.bufferDeviceAddressCaptureReplay or 0
		_pool.bufferDeviceAddressMultiDevice = t.bufferDeviceAddressMultiDevice or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SetLatencyMarkerInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSetLatencyMarkerInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentID = t.presentID or 0
		_pool.marker = t.marker ~= nil and mod.e.VkLatencyMarkerNV(t.marker) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.LatencyTimingsFrameReportNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkLatencyTimingsFrameReportNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentID = t.presentID or 0
		_pool.inputSampleTimeUs = t.inputSampleTimeUs or 0
		_pool.simStartTimeUs = t.simStartTimeUs or 0
		_pool.simEndTimeUs = t.simEndTimeUs or 0
		_pool.renderSubmitStartTimeUs = t.renderSubmitStartTimeUs or 0
		_pool.renderSubmitEndTimeUs = t.renderSubmitEndTimeUs or 0
		_pool.presentStartTimeUs = t.presentStartTimeUs or 0
		_pool.presentEndTimeUs = t.presentEndTimeUs or 0
		_pool.driverStartTimeUs = t.driverStartTimeUs or 0
		_pool.driverEndTimeUs = t.driverEndTimeUs or 0
		_pool.osRenderQueueStartTimeUs = t.osRenderQueueStartTimeUs or 0
		_pool.osRenderQueueEndTimeUs = t.osRenderQueueEndTimeUs or 0
		_pool.gpuRenderStartTimeUs = t.gpuRenderStartTimeUs or 0
		_pool.gpuRenderEndTimeUs = t.gpuRenderEndTimeUs or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BufferDeviceAddressCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBufferDeviceAddressCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceAddress = t.deviceAddress or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentShadingRatePropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentShadingRatePropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil

		if t.minFragmentShadingRateAttachmentTexelSize ~= nil then
			if type(t.minFragmentShadingRateAttachmentTexelSize) == "table" then
				_pool.minFragmentShadingRateAttachmentTexelSize = mod.VkExtent2D(t.minFragmentShadingRateAttachmentTexelSize)
			else
				_pool.minFragmentShadingRateAttachmentTexelSize = t.minFragmentShadingRateAttachmentTexelSize
			end
		else
			_pool.minFragmentShadingRateAttachmentTexelSize = mod.VkExtent2D()
		end

		if t.maxFragmentShadingRateAttachmentTexelSize ~= nil then
			if type(t.maxFragmentShadingRateAttachmentTexelSize) == "table" then
				_pool.maxFragmentShadingRateAttachmentTexelSize = mod.VkExtent2D(t.maxFragmentShadingRateAttachmentTexelSize)
			else
				_pool.maxFragmentShadingRateAttachmentTexelSize = t.maxFragmentShadingRateAttachmentTexelSize
			end
		else
			_pool.maxFragmentShadingRateAttachmentTexelSize = mod.VkExtent2D()
		end

		_pool.maxFragmentShadingRateAttachmentTexelSizeAspectRatio = t.maxFragmentShadingRateAttachmentTexelSizeAspectRatio or 0
		_pool.primitiveFragmentShadingRateWithMultipleViewports = t.primitiveFragmentShadingRateWithMultipleViewports or 0
		_pool.layeredShadingRateAttachments = t.layeredShadingRateAttachments or 0
		_pool.fragmentShadingRateNonTrivialCombinerOps = t.fragmentShadingRateNonTrivialCombinerOps or 0

		if t.maxFragmentSize ~= nil then
			if type(t.maxFragmentSize) == "table" then
				_pool.maxFragmentSize = mod.VkExtent2D(t.maxFragmentSize)
			else
				_pool.maxFragmentSize = t.maxFragmentSize
			end
		else
			_pool.maxFragmentSize = mod.VkExtent2D()
		end

		_pool.maxFragmentSizeAspectRatio = t.maxFragmentSizeAspectRatio or 0
		_pool.maxFragmentShadingRateCoverageSamples = t.maxFragmentShadingRateCoverageSamples or 0
		_pool.maxFragmentShadingRateRasterizationSamples = t.maxFragmentShadingRateRasterizationSamples ~= nil and
			mod.e.VkSampleCountFlagBits(t.maxFragmentShadingRateRasterizationSamples) or
			0
		_pool.fragmentShadingRateWithShaderDepthStencilWrites = t.fragmentShadingRateWithShaderDepthStencilWrites or 0
		_pool.fragmentShadingRateWithSampleMask = t.fragmentShadingRateWithSampleMask or 0
		_pool.fragmentShadingRateWithShaderSampleMask = t.fragmentShadingRateWithShaderSampleMask or 0
		_pool.fragmentShadingRateWithConservativeRasterization = t.fragmentShadingRateWithConservativeRasterization or 0
		_pool.fragmentShadingRateWithFragmentShaderInterlock = t.fragmentShadingRateWithFragmentShaderInterlock or 0
		_pool.fragmentShadingRateWithCustomSampleLocations = t.fragmentShadingRateWithCustomSampleLocations or 0
		_pool.fragmentShadingRateStrictMultiplyCombiner = t.fragmentShadingRateStrictMultiplyCombiner or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureMotionInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureMotionInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxInstances = t.maxInstances or 0
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindMemoryStatus(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindMemoryStatus)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS")
		end

		_pool.pNext = t.pNext or nil
		_pool.pResult = t.pResult or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SubpassDescriptionDepthStencilResolve(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSubpassDescriptionDepthStencilResolve)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE")
		end

		_pool.pNext = t.pNext or nil
		_pool.depthResolveMode = t.depthResolveMode ~= nil and
			mod.e.VkResolveModeFlagBits(t.depthResolveMode) or
			0
		_pool.stencilResolveMode = t.stencilResolveMode ~= nil and
			mod.e.VkResolveModeFlagBits(t.stencilResolveMode) or
			0
		_pool.pDepthStencilResolveAttachment = t.pDepthStencilResolveAttachment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PushConstants(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPushConstantsInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.layout = t.layout or 0
		_pool.stageFlags = t.stageFlags ~= nil and mod.e.VkShaderStageFlagBits(t.stageFlags) or 0
		_pool.offset = t.offset or 0
		_pool.size = t.size or 0
		_pool.pValues = t.pValues or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PushDescriptorSet(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPushDescriptorSetInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.stageFlags = t.stageFlags ~= nil and mod.e.VkShaderStageFlagBits(t.stageFlags) or 0
		_pool.layout = t.layout or 0
		_pool.set = t.set or 0
		_pool.descriptorWriteCount = t.descriptorWriteCount or 0
		_pool.pDescriptorWrites = t.pDescriptorWrites or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PushDescriptorSetWithTemplate(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPushDescriptorSetWithTemplateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.descriptorUpdateTemplate = t.descriptorUpdateTemplate or 0
		_pool.layout = t.layout or 0
		_pool.set = t.set or 0
		_pool.pData = t.pData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePipelineProtectedAccessFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePipelineProtectedAccessFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineProtectedAccess = t.pipelineProtectedAccess or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceScalarBlockLayoutFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceScalarBlockLayoutFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.scalarBlockLayout = t.scalarBlockLayout or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageStencilUsage(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageStencilUsageCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.stencilUsage = t.stencilUsage ~= nil and mod.e.VkImageUsageFlagBits(t.stencilUsage) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineRobustness(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineRobustnessCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.storageBuffers = t.storageBuffers ~= nil and
			mod.e.VkPipelineRobustnessBufferBehavior(t.storageBuffers) or
			0
		_pool.uniformBuffers = t.uniformBuffers ~= nil and
			mod.e.VkPipelineRobustnessBufferBehavior(t.uniformBuffers) or
			0
		_pool.vertexInputs = t.vertexInputs ~= nil and
			mod.e.VkPipelineRobustnessBufferBehavior(t.vertexInputs) or
			0
		_pool.images = t.images ~= nil and mod.e.VkPipelineRobustnessImageBehavior(t.images) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GetLatencyMarkerInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGetLatencyMarkerInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.timingCount = t.timingCount or 0
		_pool.pTimings = t.pTimings or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.videoEncodeQuantizationMap = t.videoEncodeQuantizationMap or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceImageAlignmentControlPropertiesMESA(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceImageAlignmentControlPropertiesMESA)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA")
		end

		_pool.pNext = t.pNext or nil
		_pool.supportedImageAlignmentMask = t.supportedImageAlignmentMask or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.LatencySubmissionPresentIdNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkLatencySubmissionPresentIdNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentID = t.presentID or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SwapchainLatencyCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSwapchainLatencyCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.latencyModeEnable = t.latencyModeEnable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePerStageDescriptorSetFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePerStageDescriptorSetFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.perStageDescriptorSet = t.perStageDescriptorSet or 0
		_pool.dynamicPipelineLayout = t.dynamicPipelineLayout or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.OutOfBandQueueTypeInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkOutOfBandQueueTypeInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.queueType = t.queueType ~= nil and mod.e.VkOutOfBandQueueTypeNV(t.queueType) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderingFragmentShadingRateAttachmentInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderingFragmentShadingRateAttachmentInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.imageView = t.imageView or 0
		_pool.imageLayout = t.imageLayout ~= nil and mod.e.VkImageLayout(t.imageLayout) or 0

		if t.shadingRateAttachmentTexelSize ~= nil then
			if type(t.shadingRateAttachmentTexelSize) == "table" then
				_pool.shadingRateAttachmentTexelSize = mod.VkExtent2D(t.shadingRateAttachmentTexelSize)
			else
				_pool.shadingRateAttachmentTexelSize = t.shadingRateAttachmentTexelSize
			end
		else
			_pool.shadingRateAttachmentTexelSize = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.LatencySurfaceCapabilitiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkLatencySurfaceCapabilitiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentModeCount = t.presentModeCount or 0
		_pool.pPresentModes = t.pPresentModes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDepthClampControlFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDepthClampControlFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.depthClampControl = t.depthClampControl or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceUniformBufferStandardLayoutFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceUniformBufferStandardLayoutFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.uniformBufferStandardLayout = t.uniformBufferStandardLayout or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineViewportDepthClampControlCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineViewportDepthClampControlCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.depthClampMode = t.depthClampMode ~= nil and mod.e.VkDepthClampModeEXT(t.depthClampMode) or 0
		_pool.pDepthClampRange = t.pDepthClampRange or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSeparateDepthStencilLayoutsFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.separateDepthStencilLayouts = t.separateDepthStencilLayouts or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AttachmentReferenceStencilLayout(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAttachmentReferenceStencilLayout)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT")
		end

		_pool.pNext = t.pNext or nil
		_pool.stencilLayout = t.stencilLayout ~= nil and mod.e.VkImageLayout(t.stencilLayout) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.HostImageLayoutTransition(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkHostImageLayoutTransitionInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.image = t.image or 0
		_pool.oldLayout = t.oldLayout ~= nil and mod.e.VkImageLayout(t.oldLayout) or 0
		_pool.newLayout = t.newLayout ~= nil and mod.e.VkImageLayout(t.newLayout) or 0

		if t.subresourceRange ~= nil then
			if type(t.subresourceRange) == "table" then
				_pool.subresourceRange = mod.s.ImageSubresourceRange(t.subresourceRange)
			else
				_pool.subresourceRange = t.subresourceRange
			end
		else
			_pool.subresourceRange = mod.VkImageSubresourceRange()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.AttachmentDescriptionStencilLayout(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAttachmentDescriptionStencilLayout)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT")
		end

		_pool.pNext = t.pNext or nil
		_pool.stencilInitialLayout = t.stencilInitialLayout ~= nil and
			mod.e.VkImageLayout(t.stencilInitialLayout) or
			0
		_pool.stencilFinalLayout = t.stencilFinalLayout ~= nil and mod.e.VkImageLayout(t.stencilFinalLayout) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DirectDriverLoadingInfoLUNARG(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDirectDriverLoadingInfoLUNARG)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.pfnGetInstanceProcAddr = t.pfnGetInstanceProcAddr or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderRelaxedExtendedInstruction = t.shaderRelaxedExtendedInstruction or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DirectDriverLoadingListLUNARG(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDirectDriverLoadingListLUNARG)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG")
		end

		_pool.pNext = t.pNext or nil
		_pool.mode = t.mode ~= nil and mod.e.VkDirectDriverLoadingModeLUNARG(t.mode) or 0
		_pool.driverCount = t.driverCount or 0
		_pool.pDrivers = t.pDrivers or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SamplerBlockMatchWindowCreateInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSamplerBlockMatchWindowCreateInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil

		if t.windowExtent ~= nil then
			if type(t.windowExtent) == "table" then
				_pool.windowExtent = mod.VkExtent2D(t.windowExtent)
			else
				_pool.windowExtent = t.windowExtent
			end
		else
			_pool.windowExtent = mod.VkExtent2D()
		end

		_pool.windowCompareMode = t.windowCompareMode ~= nil and
			mod.e.VkBlockMatchWindowCompareModeQCOM(t.windowCompareMode) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTimelineSemaphoreProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTimelineSemaphoreProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxTimelineSemaphoreValueDifference = t.maxTimelineSemaphoreValueDifference or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SemaphoreType(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSemaphoreTypeCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.semaphoreType = t.semaphoreType ~= nil and mod.e.VkSemaphoreType(t.semaphoreType) or 0
		_pool.initialValue = t.initialValue or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ValidationFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkValidationFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.enabledValidationFeatureCount = t.enabledValidationFeatureCount or 0
		_pool.pEnabledValidationFeatures = t.pEnabledValidationFeatures or 0
		_pool.disabledValidationFeatureCount = t.disabledValidationFeatureCount or 0
		_pool.pDisabledValidationFeatures = t.pDisabledValidationFeatures or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CooperativeMatrixFlexibleDimensionsPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCooperativeMatrixFlexibleDimensionsPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.MGranularity = t.MGranularity or 0
		_pool.NGranularity = t.NGranularity or 0
		_pool.KGranularity = t.KGranularity or 0
		_pool.AType = t.AType ~= nil and mod.e.VkComponentTypeKHR(t.AType) or 0
		_pool.BType = t.BType ~= nil and mod.e.VkComponentTypeKHR(t.BType) or 0
		_pool.CType = t.CType ~= nil and mod.e.VkComponentTypeKHR(t.CType) or 0
		_pool.ResultType = t.ResultType ~= nil and mod.e.VkComponentTypeKHR(t.ResultType) or 0
		_pool.saturatingAccumulation = t.saturatingAccumulation or 0
		_pool.scope = t.scope ~= nil and mod.e.VkScopeKHR(t.scope) or 0
		_pool.workgroupInvocations = t.workgroupInvocations or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TimelineSemaphoreSubmit(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTimelineSemaphoreSubmitInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.waitSemaphoreValueCount = t.waitSemaphoreValueCount or 0
		_pool.pWaitSemaphoreValues = t.pWaitSemaphoreValues or 0
		_pool.signalSemaphoreValueCount = t.signalSemaphoreValueCount or 0
		_pool.pSignalSemaphoreValues = t.pSignalSemaphoreValues or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderQuadControlFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderQuadControlFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderQuadControl = t.shaderQuadControl or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SemaphoreWait(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSemaphoreWaitInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkSemaphoreWaitFlagBits(t.flags) or 0
		_pool.semaphoreCount = t.semaphoreCount or 0
		_pool.pSemaphores = t.pSemaphores or 0
		_pool.pValues = t.pValues or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCubicWeightsFeaturesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCubicWeightsFeaturesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.selectableCubicWeights = t.selectableCubicWeights or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CooperativeMatrixPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCooperativeMatrixPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.MSize = t.MSize or 0
		_pool.NSize = t.NSize or 0
		_pool.KSize = t.KSize or 0
		_pool.AType = t.AType or 0
		_pool.BType = t.BType or 0
		_pool.CType = t.CType or 0
		_pool.DType = t.DType or 0
		_pool.scope = t.scope or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SamplerCubicWeightsCreateInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSamplerCubicWeightsCreateInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.cubicWeights = t.cubicWeights ~= nil and mod.e.VkCubicFilterWeightsQCOM(t.cubicWeights) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCooperativeMatrixFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCooperativeMatrixFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.cooperativeMatrix = t.cooperativeMatrix or 0
		_pool.cooperativeMatrixRobustBufferAccess = t.cooperativeMatrixRobustBufferAccess or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCooperativeMatrixPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCooperativeMatrixPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.cooperativeMatrixSupportedStages = t.cooperativeMatrixSupportedStages ~= nil and
			mod.e.VkShaderStageFlagBits(t.cooperativeMatrixSupportedStages) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryOpaqueCaptureAddressAllocate(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryOpaqueCaptureAddressAllocateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.opaqueCaptureAddress = t.opaqueCaptureAddress or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceMemoryOpaqueCaptureAddress(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceMemoryOpaqueCaptureAddressInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.memory = t.memory or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceYcbcrDegammaFeaturesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.ycbcrDegamma = t.ycbcrDegamma or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceLayeredApiPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceLayeredApiPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.vendorID = t.vendorID or 0
		_pool.deviceID = t.deviceID or 0
		_pool.layeredAPI = t.layeredAPI ~= nil and mod.e.VkPhysicalDeviceLayeredApiKHR(t.layeredAPI) or 0
		_pool.deviceName = t.deviceName or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.enableYDegamma = t.enableYDegamma or 0
		_pool.enableCbCrDegamma = t.enableCbCrDegamma or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyMemoryIndirectInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyMemoryIndirectInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.srcCopyFlags = t.srcCopyFlags or 0
		_pool.dstCopyFlags = t.dstCopyFlags or 0
		_pool.copyCount = t.copyCount or 0

		if t.copyAddressRange ~= nil then
			if type(t.copyAddressRange) == "table" then
				_pool.copyAddressRange = mod.VkStridedDeviceAddressRangeKHR(t.copyAddressRange)
			else
				_pool.copyAddressRange = t.copyAddressRange
			end
		else
			_pool.copyAddressRange = mod.VkStridedDeviceAddressRangeKHR()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePipelineOpacityMicromapFeaturesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineOpacityMicromap = t.pipelineOpacityMicromap or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCoverageReductionModeFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCoverageReductionModeFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.coverageReductionMode = t.coverageReductionMode or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCubicClampFeaturesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCubicClampFeaturesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.cubicRangeClamp = t.cubicRangeClamp or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineCoverageReductionStateCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineCoverageReductionStateCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.coverageReductionMode = t.coverageReductionMode ~= nil and
			mod.e.VkCoverageReductionModeNV(t.coverageReductionMode) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.FramebufferMixedSamplesCombinationNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkFramebufferMixedSamplesCombinationNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.coverageReductionMode = t.coverageReductionMode ~= nil and
			mod.e.VkCoverageReductionModeNV(t.coverageReductionMode) or
			0
		_pool.rasterizationSamples = t.rasterizationSamples ~= nil and
			mod.e.VkSampleCountFlagBits(t.rasterizationSamples) or
			0
		_pool.depthStencilSamples = t.depthStencilSamples ~= nil and
			mod.e.VkSampleCountFlagBits(t.depthStencilSamples) or
			0
		_pool.colorSamples = t.colorSamples ~= nil and mod.e.VkSampleCountFlagBits(t.colorSamples) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVertexAttributeRobustnessFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.vertexAttributeRobustness = t.vertexAttributeRobustness or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TensorCreateInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTensorCreateInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.pDescription = t.pDescription or 0
		_pool.sharingMode = t.sharingMode ~= nil and mod.e.VkSharingMode(t.sharingMode) or 0
		_pool.queueFamilyIndexCount = t.queueFamilyIndexCount or 0
		_pool.pQueueFamilyIndices = t.pQueueFamilyIndices or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.attachmentFeedbackLoopDynamicState = t.attachmentFeedbackLoopDynamicState or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TensorViewCreateInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTensorViewCreateInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.tensor = t.tensor or 0
		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TensorMemoryRequirementsInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTensorMemoryRequirementsInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tensor = t.tensor or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindTensorMemoryInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindTensorMemoryInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tensor = t.tensor or 0
		_pool.memory = t.memory or 0
		_pool.memoryOffset = t.memoryOffset or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.WriteDescriptorSetTensorARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkWriteDescriptorSetTensorARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tensorViewCount = t.tensorViewCount or 0
		_pool.pTensorViews = t.pTensorViews or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentShaderInterlockFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.fragmentShaderSampleInterlock = t.fragmentShaderSampleInterlock or 0
		_pool.fragmentShaderPixelInterlock = t.fragmentShaderPixelInterlock or 0
		_pool.fragmentShaderShadingRateInterlock = t.fragmentShaderShadingRateInterlock or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDepthBiasControlFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDepthBiasControlFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.depthBiasControl = t.depthBiasControl or 0
		_pool.leastRepresentableValueForceUnormRepresentation = t.leastRepresentableValueForceUnormRepresentation or 0
		_pool.floatRepresentation = t.floatRepresentation or 0
		_pool.depthBiasExact = t.depthBiasExact or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineCompilerControlCreateInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineCompilerControlCreateInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.pVendorOptions = t.pVendorOptions or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxFragmentDensityMapLayers = t.maxFragmentDensityMapLayers or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTensorPropertiesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTensorPropertiesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxTensorDimensionCount = t.maxTensorDimensionCount or 0
		_pool.maxTensorElements = t.maxTensorElements or 0
		_pool.maxPerDimensionTensorElements = t.maxPerDimensionTensorElements or 0
		_pool.maxTensorStride = t.maxTensorStride or 0
		_pool.maxTensorSize = t.maxTensorSize or 0
		_pool.maxTensorShaderAccessArrayLength = t.maxTensorShaderAccessArrayLength or 0
		_pool.maxTensorShaderAccessSize = t.maxTensorShaderAccessSize or 0
		_pool.maxDescriptorSetStorageTensors = t.maxDescriptorSetStorageTensors or 0
		_pool.maxPerStageDescriptorSetStorageTensors = t.maxPerStageDescriptorSetStorageTensors or 0
		_pool.maxDescriptorSetUpdateAfterBindStorageTensors = t.maxDescriptorSetUpdateAfterBindStorageTensors or 0
		_pool.maxPerStageDescriptorUpdateAfterBindStorageTensors = t.maxPerStageDescriptorUpdateAfterBindStorageTensors or 0
		_pool.shaderStorageTensorArrayNonUniformIndexingNative = t.shaderStorageTensorArrayNonUniformIndexingNative or 0
		_pool.shaderTensorSupportedStages = t.shaderTensorSupportedStages ~= nil and
			mod.e.VkShaderStageFlagBits(t.shaderTensorSupportedStages) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineFragmentDensityMapLayeredCreateInfoVALVE(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxFragmentDensityMapLayers = t.maxFragmentDensityMapLayers or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DepthBiasInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDepthBiasInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.depthBiasConstantFactor = t.depthBiasConstantFactor or 0
		_pool.depthBiasClamp = t.depthBiasClamp or 0
		_pool.depthBiasSlopeFactor = t.depthBiasSlopeFactor or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceYcbcrImageArraysFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.ycbcrImageArrays = t.ycbcrImageArrays or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDescriptorPoolOverallocationFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.descriptorPoolOverallocation = t.descriptorPoolOverallocation or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineSessionCreateInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineSessionCreateInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.dataGraphPipeline = t.dataGraphPipeline or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueueFamilyOwnershipTransferPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueueFamilyOwnershipTransferPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.optimalImageTransferToQueueFamilies = t.optimalImageTransferToQueueFamilies or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineSessionBindPointRequirementsInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineSessionBindPointRequirementsInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.session = t.session or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineSessionBindPointRequirementARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineSessionBindPointRequirementARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.bindPoint = t.bindPoint ~= nil and
			mod.e.VkDataGraphPipelineSessionBindPointARM(t.bindPoint) or
			0
		_pool.bindPointType = t.bindPointType ~= nil and
			mod.e.VkDataGraphPipelineSessionBindPointTypeARM(t.bindPointType) or
			0
		_pool.numObjects = t.numObjects or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTileMemoryHeapFeaturesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tileMemoryHeap = t.tileMemoryHeap or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceProvokingVertexFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceProvokingVertexFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.provokingVertexLast = t.provokingVertexLast or 0
		_pool.transformFeedbackPreservesProvokingVertex = t.transformFeedbackPreservesProvokingVertex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineSessionMemoryRequirementsInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineSessionMemoryRequirementsInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.session = t.session or 0
		_pool.bindPoint = t.bindPoint ~= nil and
			mod.e.VkDataGraphPipelineSessionBindPointARM(t.bindPoint) or
			0
		_pool.objectIndex = t.objectIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceProvokingVertexPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceProvokingVertexPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.provokingVertexModePerPipeline = t.provokingVertexModePerPipeline or 0
		_pool.transformFeedbackPreservesTriangleFanProvokingVertex = t.transformFeedbackPreservesTriangleFanProvokingVertex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.dataGraphPipeline = t.dataGraphPipeline or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelinePropertyQueryResultARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelinePropertyQueryResultARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.property = t.property ~= nil and mod.e.VkDataGraphPipelinePropertyARM(t.property) or 0
		_pool.isText = t.isText or 0
		_pool.dataSize = t.dataSize or 0
		_pool.pData = t.pData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineRasterizationProvokingVertexStateCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.provokingVertexMode = t.provokingVertexMode ~= nil and
			mod.e.VkProvokingVertexModeEXT(t.provokingVertexMode) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDeviceMemoryReportFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceMemoryReport = t.deviceMemoryReport or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineDispatchInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineDispatchInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceMemoryReportCallbackDataEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceMemoryReportCallbackDataEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.type = t.type ~= nil and mod.e.VkDeviceMemoryReportEventTypeEXT(t.type) or 0
		_pool.memoryObjectId = t.memoryObjectId or 0
		_pool.size = t.size or 0
		_pool.objectType = t.objectType ~= nil and mod.e.VkObjectType(t.objectType) or 0
		_pool.objectHandle = t.objectHandle or 0
		_pool.heapIndex = t.heapIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.videoEncodeIntraRefresh = t.videoEncodeIntraRefresh or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDepthClampZeroOneFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.depthClampZeroOne = t.depthClampZeroOne or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.HeadlessSurfaceCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkHeadlessSurfaceCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueueFamilyDataGraphPropertiesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueueFamilyDataGraphPropertiesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM")
		end

		_pool.pNext = t.pNext or nil

		if t.engine ~= nil then
			if type(t.engine) == "table" then
				_pool.engine = mod.s.PhysicalDeviceDataGraphProcessingEngineARM(t.engine)
			else
				_pool.engine = t.engine
			end
		else
			_pool.engine = mod.VkPhysicalDeviceDataGraphProcessingEngineARM()
		end

		if t.operation ~= nil then
			if type(t.operation) == "table" then
				_pool.operation = mod.s.PhysicalDeviceDataGraphOperationSupportARM(t.operation)
			else
				_pool.operation = t.operation
			end
		else
			_pool.operation = mod.VkPhysicalDeviceDataGraphOperationSupportARM()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.attachmentFeedbackLoopLayout = t.attachmentFeedbackLoopLayout or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphProcessingEngineCreateInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphProcessingEngineCreateInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.processingEngineCount = t.processingEngineCount or 0
		_pool.pProcessingEngines = t.pProcessingEngines or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceImageViewImageFormatInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceImageViewImageFormatInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.imageViewType = t.imageViewType ~= nil and mod.e.VkImageViewType(t.imageViewType) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoFormatQuantizationMapPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoFormatQuantizationMapPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil

		if t.quantizationMapTexelSize ~= nil then
			if type(t.quantizationMapTexelSize) == "table" then
				_pool.quantizationMapTexelSize = mod.VkExtent2D(t.quantizationMapTexelSize)
			else
				_pool.quantizationMapTexelSize = t.quantizationMapTexelSize
			end
		else
			_pool.quantizationMapTexelSize = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.DisplaySurfaceStereoCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDisplaySurfaceStereoCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.stereoType = t.stereoType ~= nil and mod.e.VkDisplaySurfaceStereoTypeNV(t.stereoType) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DisplayModeStereoPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDisplayModeStereoPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.hdmi3DSupported = t.hdmi3DSupported or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.dimension = t.dimension or 0
		_pool.zeroCount = t.zeroCount or 0
		_pool.groupSize = t.groupSize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRawAccessChainsFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRawAccessChainsFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderRawAccessChains = t.shaderRawAccessChains or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentModeFifoLatestReady = t.presentModeFifoLatestReady or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderAtomicFloatFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderBufferFloat32Atomics = t.shaderBufferFloat32Atomics or 0
		_pool.shaderBufferFloat32AtomicAdd = t.shaderBufferFloat32AtomicAdd or 0
		_pool.shaderBufferFloat64Atomics = t.shaderBufferFloat64Atomics or 0
		_pool.shaderBufferFloat64AtomicAdd = t.shaderBufferFloat64AtomicAdd or 0
		_pool.shaderSharedFloat32Atomics = t.shaderSharedFloat32Atomics or 0
		_pool.shaderSharedFloat32AtomicAdd = t.shaderSharedFloat32AtomicAdd or 0
		_pool.shaderSharedFloat64Atomics = t.shaderSharedFloat64Atomics or 0
		_pool.shaderSharedFloat64AtomicAdd = t.shaderSharedFloat64AtomicAdd or 0
		_pool.shaderImageFloat32Atomics = t.shaderImageFloat32Atomics or 0
		_pool.shaderImageFloat32AtomicAdd = t.shaderImageFloat32AtomicAdd or 0
		_pool.sparseImageFloat32Atomics = t.sparseImageFloat32Atomics or 0
		_pool.sparseImageFloat32AtomicAdd = t.sparseImageFloat32AtomicAdd or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SamplerCustomBorderColorCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSamplerCustomBorderColorCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil

		if t.customBorderColor ~= nil then
			if type(t.customBorderColor) == "table" then
				_pool.customBorderColor = mod.VkClearColorValue(t.customBorderColor)
			else
				_pool.customBorderColor = t.customBorderColor
			end
		else
			_pool.customBorderColor = mod.VkClearColorValue()
		end

		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalComputeQueueDeviceCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalComputeQueueDeviceCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.reservedExternalQueues = t.reservedExternalQueues or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCustomBorderColorPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCustomBorderColorPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxCustomBorderColorSamplers = t.maxCustomBorderColorSamplers or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImportMemoryHostPointerInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImportMemoryHostPointerInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType) or
			0
		_pool.pHostPointer = t.pHostPointer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryHostPointerPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryHostPointerPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.memoryTypeBits = t.memoryTypeBits or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalComputeQueueDataParamsNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalComputeQueueDataParamsNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceIndex = t.deviceIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.combinedImageSamplerDensityMapDescriptorSize = t.combinedImageSamplerDensityMapDescriptorSize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSubgroupProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSubgroupProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.subgroupSize = t.subgroupSize or 0
		_pool.supportedStages = t.supportedStages ~= nil and mod.e.VkShaderStageFlagBits(t.supportedStages) or 0
		_pool.supportedOperations = t.supportedOperations ~= nil and
			mod.e.VkSubgroupFeatureFlagBits(t.supportedOperations) or
			0
		_pool.quadOperationsInAllStages = t.quadOperationsInAllStages or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDescriptorBufferFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDescriptorBufferFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.descriptorBuffer = t.descriptorBuffer or 0
		_pool.descriptorBufferCaptureReplay = t.descriptorBufferCaptureReplay or 0
		_pool.descriptorBufferImageLayoutIgnored = t.descriptorBufferImageLayoutIgnored or 0
		_pool.descriptorBufferPushDescriptors = t.descriptorBufferPushDescriptors or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindBufferMemory(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindBufferMemoryInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.buffer = t.buffer or 0
		_pool.memory = t.memory or 0
		_pool.memoryOffset = t.memoryOffset or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ClusterAccelerationStructureClustersBottomLevelInputNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkClusterAccelerationStructureClustersBottomLevelInputNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxTotalClusterCount = t.maxTotalClusterCount or 0
		_pool.maxClusterCountPerAccelerationStructure = t.maxClusterCountPerAccelerationStructure or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePresentBarrierFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePresentBarrierFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentBarrier = t.presentBarrier or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorBufferBindingPushDescriptorBufferHandleEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.buffer = t.buffer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SurfaceCapabilitiesPresentBarrierNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSurfaceCapabilitiesPresentBarrierNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentBarrierSupported = t.presentBarrierSupported or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SwapchainPresentBarrierCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSwapchainPresentBarrierCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentBarrierEnable = t.presentBarrierEnable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryDedicatedRequirements(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryDedicatedRequirements)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS")
		end

		_pool.pNext = t.pNext or nil
		_pool.prefersDedicatedAllocation = t.prefersDedicatedAllocation or 0
		_pool.requiresDedicatedAllocation = t.requiresDedicatedAllocation or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExportMetalObjectCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExportMetalObjectCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.exportObjectType = t.exportObjectType ~= nil and
			mod.e.VkExportMetalObjectTypeFlagBitsEXT(t.exportObjectType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryDedicatedAllocate(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryDedicatedAllocateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.image = t.image or 0
		_pool.buffer = t.buffer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExportMetalObjectsInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExportMetalObjectsInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExportMetalDeviceInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExportMetalDeviceInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.mtlDevice = t.mtlDevice or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorGetInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorGetInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type ~= nil and mod.e.VkDescriptorType(t.type) or 0

		if t.data ~= nil then
			if type(t.data) == "table" then
				_pool.data = mod.VkDescriptorDataEXT(t.data)
			else
				_pool.data = t.data
			end
		else
			_pool.data = mod.VkDescriptorDataEXT()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.ExportMetalCommandQueueInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExportMetalCommandQueueInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.queue = t.queue or 0
		_pool.mtlCommandQueue = t.mtlCommandQueue or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageCaptureDescriptorDataInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageCaptureDescriptorDataInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.image = t.image or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExportMetalBufferInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExportMetalBufferInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.memory = t.memory or 0
		_pool.mtlBuffer = t.mtlBuffer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageView(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageViewCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkImageViewCreateFlagBits(t.flags) or 0
		_pool.image = t.image or 0
		_pool.viewType = t.viewType ~= nil and mod.e.VkImageViewType(t.viewType) or 0
		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0

		if t.components ~= nil then
			if type(t.components) == "table" then
				_pool.components = mod.s.ComponentMapping(t.components)
			else
				_pool.components = t.components
			end
		else
			_pool.components = mod.VkComponentMapping()
		end

		if t.subresourceRange ~= nil then
			if type(t.subresourceRange) == "table" then
				_pool.subresourceRange = mod.s.ImageSubresourceRange(t.subresourceRange)
			else
				_pool.subresourceRange = t.subresourceRange
			end
		else
			_pool.subresourceRange = mod.VkImageSubresourceRange()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.OpaqueCaptureDescriptorDataCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkOpaqueCaptureDescriptorDataCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.opaqueCaptureDescriptorData = t.opaqueCaptureDescriptorData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.perViewRenderAreaCount = t.perViewRenderAreaCount or 0
		_pool.pPerViewRenderAreas = t.pPerViewRenderAreas or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ShaderModule(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkShaderModuleCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.codeSize = t.codeSize or 0
		_pool.pCode = t.pCode or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceGroupBindSparse(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceGroupBindSparseInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.resourceDeviceIndex = t.resourceDeviceIndex or 0
		_pool.memoryDeviceIndex = t.memoryDeviceIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImportMetalTextureInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImportMetalTextureInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.plane = t.plane ~= nil and mod.e.VkImageAspectFlagBits(t.plane) or 0
		_pool.mtlTexture = t.mtlTexture or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineCache(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineCacheCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkPipelineCacheCreateFlagBits(t.flags) or 0
		_pool.initialDataSize = t.initialDataSize or 0
		_pool.pInitialData = t.pInitialData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindBufferMemoryDeviceGroup(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindBufferMemoryDeviceGroupInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceIndexCount = t.deviceIndexCount or 0
		_pool.pDeviceIndices = t.pDeviceIndices or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ClusterAccelerationStructureCommandsInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkClusterAccelerationStructureCommandsInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV")
		end

		_pool.pNext = t.pNext or nil

		if t.input ~= nil then
			if type(t.input) == "table" then
				_pool.input = mod.s.ClusterAccelerationStructureInputInfoNV(t.input)
			else
				_pool.input = t.input
			end
		else
			_pool.input = mod.VkClusterAccelerationStructureInputInfoNV()
		end

		_pool.dstImplicitData = t.dstImplicitData or 0
		_pool.scratchData = t.scratchData or 0

		if t.dstAddressesArray ~= nil then
			if type(t.dstAddressesArray) == "table" then
				_pool.dstAddressesArray = mod.VkStridedDeviceAddressRegionKHR(t.dstAddressesArray)
			else
				_pool.dstAddressesArray = t.dstAddressesArray
			end
		else
			_pool.dstAddressesArray = mod.VkStridedDeviceAddressRegionKHR()
		end

		if t.dstSizesArray ~= nil then
			if type(t.dstSizesArray) == "table" then
				_pool.dstSizesArray = mod.VkStridedDeviceAddressRegionKHR(t.dstSizesArray)
			else
				_pool.dstSizesArray = t.dstSizesArray
			end
		else
			_pool.dstSizesArray = mod.VkStridedDeviceAddressRegionKHR()
		end

		if t.srcInfosArray ~= nil then
			if type(t.srcInfosArray) == "table" then
				_pool.srcInfosArray = mod.VkStridedDeviceAddressRegionKHR(t.srcInfosArray)
			else
				_pool.srcInfosArray = t.srcInfosArray
			end
		else
			_pool.srcInfosArray = mod.VkStridedDeviceAddressRegionKHR()
		end

		_pool.srcInfosCount = t.srcInfosCount or 0
		_pool.addressResolutionFlags = t.addressResolutionFlags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderCorePropertiesAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderCorePropertiesAMD)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderEngineCount = t.shaderEngineCount or 0
		_pool.shaderArraysPerEngineCount = t.shaderArraysPerEngineCount or 0
		_pool.computeUnitsPerShaderArray = t.computeUnitsPerShaderArray or 0
		_pool.simdPerComputeUnit = t.simdPerComputeUnit or 0
		_pool.wavefrontsPerSimd = t.wavefrontsPerSimd or 0
		_pool.wavefrontSize = t.wavefrontSize or 0
		_pool.sgprsPerSimd = t.sgprsPerSimd or 0
		_pool.minSgprAllocation = t.minSgprAllocation or 0
		_pool.maxSgprAllocation = t.maxSgprAllocation or 0
		_pool.sgprAllocationGranularity = t.sgprAllocationGranularity or 0
		_pool.vgprsPerSimd = t.vgprsPerSimd or 0
		_pool.minVgprAllocation = t.minVgprAllocation or 0
		_pool.maxVgprAllocation = t.maxVgprAllocation or 0
		_pool.vgprAllocationGranularity = t.vgprAllocationGranularity or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindImageMemoryDeviceGroup(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindImageMemoryDeviceGroupInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceIndexCount = t.deviceIndexCount or 0
		_pool.pDeviceIndices = t.pDeviceIndices or 0
		_pool.splitInstanceBindRegionCount = t.splitInstanceBindRegionCount or 0
		_pool.pSplitInstanceBindRegions = t.pSplitInstanceBindRegions or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImportMetalSharedEventInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImportMetalSharedEventInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.mtlSharedEvent = t.mtlSharedEvent or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceGroupProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceGroupProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.physicalDeviceCount = t.physicalDeviceCount or 0
		_pool.physicalDevices = t.physicalDevices or 0
		_pool.subsetAllocation = t.subsetAllocation or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SwapchainPresentFenceInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSwapchainPresentFenceInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.swapchainCount = t.swapchainCount or 0
		_pool.pFences = t.pFences or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineShaderStage(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineShaderStageCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkPipelineShaderStageCreateFlagBits(t.flags) or 0
		_pool.stage = t.stage ~= nil and mod.e.VkShaderStageFlagBits(t.stage) or 0
		_pool.module = t.module or 0
		_pool.pName = t.pName or 0
		_pool.pSpecializationInfo = t.pSpecializationInfo or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TensorDependencyInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTensorDependencyInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tensorMemoryBarrierCount = t.tensorMemoryBarrierCount or 0
		_pool.pTensorMemoryBarriers = t.pTensorMemoryBarriers or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImportMemoryMetalHandleInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImportMemoryMetalHandleInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType) or
			0
		_pool.handle = t.handle or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTensorFeaturesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTensorFeaturesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tensorNonPacked = t.tensorNonPacked or 0
		_pool.shaderTensorAccess = t.shaderTensorAccess or 0
		_pool.shaderStorageTensorArrayDynamicIndexing = t.shaderStorageTensorArrayDynamicIndexing or 0
		_pool.shaderStorageTensorArrayNonUniformIndexing = t.shaderStorageTensorArrayNonUniformIndexing or 0
		_pool.descriptorBindingStorageTensorUpdateAfterBind = t.descriptorBindingStorageTensorUpdateAfterBind or 0
		_pool.tensors = t.tensors or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDiagnosticsConfigFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDiagnosticsConfigFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.diagnosticsConfig = t.diagnosticsConfig or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ReleaseSwapchainImagesInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkReleaseSwapchainImagesInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.swapchain = t.swapchain or 0
		_pool.imageIndexCount = t.imageIndexCount or 0
		_pool.pImageIndices = t.pImageIndices or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceDiagnosticsConfigCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceDiagnosticsConfigCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AndroidSurfaceCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAndroidSurfaceCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.window = t.window or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceTensorMemoryRequirementsARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceTensorMemoryRequirementsARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.pCreateInfo = t.pCreateInfo or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TensorCopyARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTensorCopyARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_COPY_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.dimensionCount = t.dimensionCount or 0
		_pool.pSrcOffset = t.pSrcOffset or 0
		_pool.pDstOffset = t.pDstOffset or 0
		_pool.pExtent = t.pExtent or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineVertexInputState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineVertexInputStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.vertexBindingDescriptionCount = t.vertexBindingDescriptionCount or 0
		_pool.pVertexBindingDescriptions = t.pVertexBindingDescriptions or 0
		_pool.vertexAttributeDescriptionCount = t.vertexAttributeDescriptionCount or 0
		_pool.pVertexAttributeDescriptions = t.pVertexAttributeDescriptions or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceMemoryOverallocationCreateInfoAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceMemoryOverallocationCreateInfoAMD)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD")
		end

		_pool.pNext = t.pNext or nil
		_pool.overallocationBehavior = t.overallocationBehavior ~= nil and
			mod.e.VkMemoryOverallocationBehaviorAMD(t.overallocationBehavior) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AndroidHardwareBufferUsageANDROID(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAndroidHardwareBufferUsageANDROID)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID")
		end

		_pool.pNext = t.pNext or nil
		_pool.androidHardwareBufferUsage = t.androidHardwareBufferUsage or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryDedicatedAllocateInfoTensorARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryDedicatedAllocateInfoTensorARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tensor = t.tensor or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AndroidHardwareBufferPropertiesANDROID(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAndroidHardwareBufferPropertiesANDROID)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID")
		end

		_pool.pNext = t.pNext or nil
		_pool.allocationSize = t.allocationSize or 0
		_pool.memoryTypeBits = t.memoryTypeBits or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AndroidHardwareBufferFormatPropertiesANDROID(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAndroidHardwareBufferFormatPropertiesANDROID)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID")
		end

		_pool.pNext = t.pNext or nil
		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0
		_pool.externalFormat = t.externalFormat or 0
		_pool.formatFeatures = t.formatFeatures ~= nil and mod.e.VkFormatFeatureFlagBits(t.formatFeatures) or 0

		if t.samplerYcbcrConversionComponents ~= nil then
			if type(t.samplerYcbcrConversionComponents) == "table" then
				_pool.samplerYcbcrConversionComponents = mod.s.ComponentMapping(t.samplerYcbcrConversionComponents)
			else
				_pool.samplerYcbcrConversionComponents = t.samplerYcbcrConversionComponents
			end
		else
			_pool.samplerYcbcrConversionComponents = mod.VkComponentMapping()
		end

		_pool.suggestedYcbcrModel = t.suggestedYcbcrModel ~= nil and
			mod.e.VkSamplerYcbcrModelConversion(t.suggestedYcbcrModel) or
			0
		_pool.suggestedYcbcrRange = t.suggestedYcbcrRange ~= nil and
			mod.e.VkSamplerYcbcrRange(t.suggestedYcbcrRange) or
			0
		_pool.suggestedXChromaOffset = t.suggestedXChromaOffset ~= nil and
			mod.e.VkChromaLocation(t.suggestedXChromaOffset) or
			0
		_pool.suggestedYChromaOffset = t.suggestedYChromaOffset ~= nil and
			mod.e.VkChromaLocation(t.suggestedYChromaOffset) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePointClippingProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePointClippingProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.pointClippingBehavior = t.pointClippingBehavior ~= nil and
			mod.e.VkPointClippingBehavior(t.pointClippingBehavior) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEndCodingInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEndCodingInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoCodingControlInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoCodingControlInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDescriptorBufferTensorPropertiesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tensorCaptureReplayDescriptorDataSize = t.tensorCaptureReplayDescriptorDataSize or 0
		_pool.tensorViewCaptureReplayDescriptorDataSize = t.tensorViewCaptureReplayDescriptorDataSize or 0
		_pool.tensorDescriptorSize = t.tensorDescriptorSize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassInputAttachmentAspect(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassInputAttachmentAspectCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.aspectReferenceCount = t.aspectReferenceCount or 0
		_pool.pAspectReferences = t.pAspectReferences or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImportAndroidHardwareBufferInfoANDROID(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImportAndroidHardwareBufferInfoANDROID)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID")
		end

		_pool.pNext = t.pNext or nil
		_pool.buffer = t.buffer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryGetAndroidHardwareBufferInfoANDROID(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryGetAndroidHardwareBufferInfoANDROID)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID")
		end

		_pool.pNext = t.pNext or nil
		_pool.memory = t.memory or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalFormatANDROID(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalFormatANDROID)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID")
		end

		_pool.pNext = t.pNext or nil
		_pool.externalFormat = t.externalFormat or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TensorViewCaptureDescriptorDataInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTensorViewCaptureDescriptorDataInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tensorView = t.tensorView or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTileShadingPropertiesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTileShadingPropertiesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxApronSize = t.maxApronSize or 0
		_pool.preferNonCoherent = t.preferNonCoherent or 0

		if t.tileGranularity ~= nil then
			if type(t.tileGranularity) == "table" then
				_pool.tileGranularity = mod.VkExtent2D(t.tileGranularity)
			else
				_pool.tileGranularity = t.tileGranularity
			end
		else
			_pool.tileGranularity = mod.VkExtent2D()
		end

		if t.maxTileShadingRate ~= nil then
			if type(t.maxTileShadingRate) == "table" then
				_pool.maxTileShadingRate = mod.VkExtent2D(t.maxTileShadingRate)
			else
				_pool.maxTileShadingRate = t.maxTileShadingRate
			end
		else
			_pool.maxTileShadingRate = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.WaylandSurfaceCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkWaylandSurfaceCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.display = t.display or 0
		_pool.surface = t.surface or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMultiviewFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMultiviewFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.multiview = t.multiview or 0
		_pool.multiviewGeometryShader = t.multiviewGeometryShader or 0
		_pool.multiviewTessellationShader = t.multiviewTessellationShader or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RayTracingPipelineClusterAccelerationStructureCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.allowClusterAccelerationStructure = t.allowClusterAccelerationStructure or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExternalFormatResolveFeaturesANDROID(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID")
		end

		_pool.pNext = t.pNext or nil
		_pool.externalFormatResolve = t.externalFormatResolve or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMultiviewProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMultiviewProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxMultiviewViewCount = t.maxMultiviewViewCount or 0
		_pool.maxMultiviewInstanceIndex = t.maxMultiviewInstanceIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExternalFormatResolvePropertiesANDROID(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID")
		end

		_pool.pNext = t.pNext or nil
		_pool.nullColorAttachmentWithExternalFormatResolve = t.nullColorAttachmentWithExternalFormatResolve or 0
		_pool.externalFormatResolveChromaOffsetX = t.externalFormatResolveChromaOffsetX ~= nil and
			mod.e.VkChromaLocation(t.externalFormatResolveChromaOffsetX) or
			0
		_pool.externalFormatResolveChromaOffsetY = t.externalFormatResolveChromaOffsetY ~= nil and
			mod.e.VkChromaLocation(t.externalFormatResolveChromaOffsetY) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PerTileEndInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPerTileEndInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVariablePointersFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVariablePointersFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.variablePointersStorageBuffer = t.variablePointersStorageBuffer or 0
		_pool.variablePointers = t.variablePointers or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AndroidHardwareBufferFormatResolvePropertiesANDROID(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAndroidHardwareBufferFormatResolvePropertiesANDROID)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID")
		end

		_pool.pNext = t.pNext or nil
		_pool.colorAttachmentFormat = t.colorAttachmentFormat ~= nil and mod.e.VkFormat(t.colorAttachmentFormat) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceProtectedMemoryFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceProtectedMemoryFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.protectedMemory = t.protectedMemory or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceProtectedMemoryProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceProtectedMemoryProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.protectedNoFault = t.protectedNoFault or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ProtectedSubmit(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkProtectedSubmitInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.protectedSubmit = t.protectedSubmit or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SamplerYcbcrConversion(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSamplerYcbcrConversionCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0
		_pool.ycbcrModel = t.ycbcrModel ~= nil and mod.e.VkSamplerYcbcrModelConversion(t.ycbcrModel) or 0
		_pool.ycbcrRange = t.ycbcrRange ~= nil and mod.e.VkSamplerYcbcrRange(t.ycbcrRange) or 0

		if t.components ~= nil then
			if type(t.components) == "table" then
				_pool.components = mod.s.ComponentMapping(t.components)
			else
				_pool.components = t.components
			end
		else
			_pool.components = mod.VkComponentMapping()
		end

		_pool.xChromaOffset = t.xChromaOffset ~= nil and mod.e.VkChromaLocation(t.xChromaOffset) or 0
		_pool.yChromaOffset = t.yChromaOffset ~= nil and mod.e.VkChromaLocation(t.yChromaOffset) or 0
		_pool.chromaFilter = t.chromaFilter ~= nil and mod.e.VkFilter(t.chromaFilter) or 0
		_pool.forceExplicitReconstruction = t.forceExplicitReconstruction or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueryLowLatencySupportNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueryLowLatencySupportNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.pQueriedLowLatencyData = t.pQueriedLowLatencyData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SamplerYcbcrConversion(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSamplerYcbcrConversionInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.conversion = t.conversion or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDescriptorBufferPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDescriptorBufferPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.combinedImageSamplerDescriptorSingleArray = t.combinedImageSamplerDescriptorSingleArray or 0
		_pool.bufferlessPushDescriptors = t.bufferlessPushDescriptors or 0
		_pool.allowSamplerImageViewPostSubmitCreation = t.allowSamplerImageViewPostSubmitCreation or 0
		_pool.descriptorBufferOffsetAlignment = t.descriptorBufferOffsetAlignment or 0
		_pool.maxDescriptorBufferBindings = t.maxDescriptorBufferBindings or 0
		_pool.maxResourceDescriptorBufferBindings = t.maxResourceDescriptorBufferBindings or 0
		_pool.maxSamplerDescriptorBufferBindings = t.maxSamplerDescriptorBufferBindings or 0
		_pool.maxEmbeddedImmutableSamplerBindings = t.maxEmbeddedImmutableSamplerBindings or 0
		_pool.maxEmbeddedImmutableSamplers = t.maxEmbeddedImmutableSamplers or 0
		_pool.bufferCaptureReplayDescriptorDataSize = t.bufferCaptureReplayDescriptorDataSize or 0
		_pool.imageCaptureReplayDescriptorDataSize = t.imageCaptureReplayDescriptorDataSize or 0
		_pool.imageViewCaptureReplayDescriptorDataSize = t.imageViewCaptureReplayDescriptorDataSize or 0
		_pool.samplerCaptureReplayDescriptorDataSize = t.samplerCaptureReplayDescriptorDataSize or 0
		_pool.accelerationStructureCaptureReplayDescriptorDataSize = t.accelerationStructureCaptureReplayDescriptorDataSize or 0
		_pool.samplerDescriptorSize = t.samplerDescriptorSize or 0
		_pool.combinedImageSamplerDescriptorSize = t.combinedImageSamplerDescriptorSize or 0
		_pool.sampledImageDescriptorSize = t.sampledImageDescriptorSize or 0
		_pool.storageImageDescriptorSize = t.storageImageDescriptorSize or 0
		_pool.uniformTexelBufferDescriptorSize = t.uniformTexelBufferDescriptorSize or 0
		_pool.robustUniformTexelBufferDescriptorSize = t.robustUniformTexelBufferDescriptorSize or 0
		_pool.storageTexelBufferDescriptorSize = t.storageTexelBufferDescriptorSize or 0
		_pool.robustStorageTexelBufferDescriptorSize = t.robustStorageTexelBufferDescriptorSize or 0
		_pool.uniformBufferDescriptorSize = t.uniformBufferDescriptorSize or 0
		_pool.robustUniformBufferDescriptorSize = t.robustUniformBufferDescriptorSize or 0
		_pool.storageBufferDescriptorSize = t.storageBufferDescriptorSize or 0
		_pool.robustStorageBufferDescriptorSize = t.robustStorageBufferDescriptorSize or 0
		_pool.inputAttachmentDescriptorSize = t.inputAttachmentDescriptorSize or 0
		_pool.accelerationStructureDescriptorSize = t.accelerationStructureDescriptorSize or 0
		_pool.maxSamplerDescriptorBufferRange = t.maxSamplerDescriptorBufferRange or 0
		_pool.maxResourceDescriptorBufferRange = t.maxResourceDescriptorBufferRange or 0
		_pool.samplerDescriptorBufferAddressSpaceSize = t.samplerDescriptorBufferAddressSpaceSize or 0
		_pool.resourceDescriptorBufferAddressSpaceSize = t.resourceDescriptorBufferAddressSpaceSize or 0
		_pool.descriptorBufferAddressSpaceSize = t.descriptorBufferAddressSpaceSize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindImagePlaneMemory(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindImagePlaneMemoryInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.planeAspect = t.planeAspect ~= nil and mod.e.VkImageAspectFlagBits(t.planeAspect) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImagePlaneMemoryRequirements(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImagePlaneMemoryRequirementsInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.planeAspect = t.planeAspect ~= nil and mod.e.VkImageAspectFlagBits(t.planeAspect) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSamplerYcbcrConversionFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSamplerYcbcrConversionFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.samplerYcbcrConversion = t.samplerYcbcrConversion or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SamplerYcbcrConversionImageFormatProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSamplerYcbcrConversionImageFormatProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.combinedImageSamplerDescriptorCount = t.combinedImageSamplerDescriptorCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorUpdateTemplate(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorUpdateTemplateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.descriptorUpdateEntryCount = t.descriptorUpdateEntryCount or 0
		_pool.pDescriptorUpdateEntries = t.pDescriptorUpdateEntries or 0
		_pool.templateType = t.templateType ~= nil and
			mod.e.VkDescriptorUpdateTemplateType(t.templateType) or
			0
		_pool.descriptorSetLayout = t.descriptorSetLayout or 0
		_pool.pipelineBindPoint = t.pipelineBindPoint ~= nil and
			mod.e.VkPipelineBindPoint(t.pipelineBindPoint) or
			0
		_pool.pipelineLayout = t.pipelineLayout or 0
		_pool.set = t.set or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderImageFootprintFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderImageFootprintFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.imageFootprint = t.imageFootprint or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExternalImageFormat(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExternalImageFormatInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineViewportExclusiveScissorStateCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineViewportExclusiveScissorStateCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.exclusiveScissorCount = t.exclusiveScissorCount or 0
		_pool.pExclusiveScissors = t.pExclusiveScissors or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalImageFormatProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalImageFormatProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil

		if t.externalMemoryProperties ~= nil then
			if type(t.externalMemoryProperties) == "table" then
				_pool.externalMemoryProperties = mod.s.ExternalMemoryProperties(t.externalMemoryProperties)
			else
				_pool.externalMemoryProperties = t.externalMemoryProperties
			end
		else
			_pool.externalMemoryProperties = mod.VkExternalMemoryProperties()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.WriteDescriptorSetPartitionedAccelerationStructureNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkWriteDescriptorSetPartitionedAccelerationStructureNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.accelerationStructureCount = t.accelerationStructureCount or 0
		_pool.pAccelerationStructures = t.pAccelerationStructures or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExternalBuffer(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExternalBufferInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkBufferCreateFlagBits(t.flags) or 0
		_pool.usage = t.usage ~= nil and mod.e.VkBufferUsageFlagBits(t.usage) or 0
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalBufferProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalBufferProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil

		if t.externalMemoryProperties ~= nil then
			if type(t.externalMemoryProperties) == "table" then
				_pool.externalMemoryProperties = mod.s.ExternalMemoryProperties(t.externalMemoryProperties)
			else
				_pool.externalMemoryProperties = t.externalMemoryProperties
			end
		else
			_pool.externalMemoryProperties = mod.VkExternalMemoryProperties()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.MetalSurfaceCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMetalSurfaceCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.pLayer = t.pLayer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BuildPartitionedAccelerationStructureInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBuildPartitionedAccelerationStructureInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil

		if t.input ~= nil then
			if type(t.input) == "table" then
				_pool.input = mod.s.PartitionedAccelerationStructureInstancesInputNV(t.input)
			else
				_pool.input = t.input
			end
		else
			_pool.input = mod.VkPartitionedAccelerationStructureInstancesInputNV()
		end

		_pool.srcAccelerationStructureData = t.srcAccelerationStructureData or 0
		_pool.dstAccelerationStructureData = t.dstAccelerationStructureData or 0
		_pool.scratchData = t.scratchData or 0
		_pool.srcInfos = t.srcInfos or 0
		_pool.srcInfosCount = t.srcInfosCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueueFamilyQueryResultStatusPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueueFamilyQueryResultStatusPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.queryResultStatusSupport = t.queryResultStatusSupport or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MicromapCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMicromapCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.createFlags = t.createFlags or 0
		_pool.buffer = t.buffer or 0
		_pool.offset = t.offset or 0
		_pool.size = t.size or 0
		_pool.type = t.type ~= nil and mod.e.VkMicromapTypeEXT(t.type) or 0
		_pool.deviceAddress = t.deviceAddress or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueueFamilyVideoPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueueFamilyVideoPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.videoCodecOperations = t.videoCodecOperations or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceOpacityMicromapFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceOpacityMicromapFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.micromap = t.micromap or 0
		_pool.micromapCaptureReplay = t.micromapCaptureReplay or 0
		_pool.micromapHostCommands = t.micromapHostCommands or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalMemoryImage(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalMemoryImageCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleTypes = t.handleTypes ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleTypes) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryMapPlacedInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryMapPlacedInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.pPlacedAddress = t.pPlacedAddress or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalMemoryBuffer(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalMemoryBufferCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleTypes = t.handleTypes ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleTypes) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExportMemoryAllocate(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExportMemoryAllocateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleTypes = t.handleTypes ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleTypes) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExternalFence(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExternalFenceInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalFenceHandleTypeFlagBits(t.handleType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalFenceProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalFenceProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.exportFromImportedHandleTypes = t.exportFromImportedHandleTypes ~= nil and
			mod.e.VkExternalFenceHandleTypeFlagBits(t.exportFromImportedHandleTypes) or
			0
		_pool.compatibleHandleTypes = t.compatibleHandleTypes ~= nil and
			mod.e.VkExternalFenceHandleTypeFlagBits(t.compatibleHandleTypes) or
			0
		_pool.externalFenceFeatures = t.externalFenceFeatures ~= nil and
			mod.e.VkExternalFenceFeatureFlagBits(t.externalFenceFeatures) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MicromapVersionInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMicromapVersionInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.pVersionData = t.pVersionData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExportFence(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExportFenceCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleTypes = t.handleTypes ~= nil and
			mod.e.VkExternalFenceHandleTypeFlagBits(t.handleTypes) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExportSemaphore(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExportSemaphoreCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleTypes = t.handleTypes ~= nil and
			mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.handleTypes) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryFdPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryFdPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.memoryTypeBits = t.memoryTypeBits or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalSemaphoreProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalSemaphoreProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.exportFromImportedHandleTypes = t.exportFromImportedHandleTypes ~= nil and
			mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.exportFromImportedHandleTypes) or
			0
		_pool.compatibleHandleTypes = t.compatibleHandleTypes ~= nil and
			mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.compatibleHandleTypes) or
			0
		_pool.externalSemaphoreFeatures = t.externalSemaphoreFeatures ~= nil and
			mod.e.VkExternalSemaphoreFeatureFlagBits(t.externalSemaphoreFeatures) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MicromapBuildSizesInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMicromapBuildSizesInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.micromapSize = t.micromapSize or 0
		_pool.buildScratchSize = t.buildScratchSize or 0
		_pool.discardable = t.discardable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureTrianglesOpacityMicromapEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureTrianglesOpacityMicromapEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.indexType = t.indexType ~= nil and mod.e.VkIndexType(t.indexType) or 0

		if t.indexBuffer ~= nil then
			if type(t.indexBuffer) == "table" then
				_pool.indexBuffer = mod.VkDeviceOrHostAddressConstKHR(t.indexBuffer)
			else
				_pool.indexBuffer = t.indexBuffer
			end
		else
			_pool.indexBuffer = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.indexStride = t.indexStride or 0
		_pool.baseTriangle = t.baseTriangle or 0
		_pool.usageCountsCount = t.usageCountsCount or 0
		_pool.pUsageCounts = t.pUsageCounts or 0
		_pool.ppUsageCounts = t.ppUsageCounts or 0
		_pool.micromap = t.micromap or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVideoFormatInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVideoFormatInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.imageUsage = t.imageUsage ~= nil and mod.e.VkImageUsageFlagBits(t.imageUsage) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoFormatPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoFormatPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0

		if t.componentMapping ~= nil then
			if type(t.componentMapping) == "table" then
				_pool.componentMapping = mod.s.ComponentMapping(t.componentMapping)
			else
				_pool.componentMapping = t.componentMapping
			end
		else
			_pool.componentMapping = mod.VkComponentMapping()
		end

		_pool.imageCreateFlags = t.imageCreateFlags ~= nil and
			mod.e.VkImageCreateFlagBits(t.imageCreateFlags) or
			0
		_pool.imageType = t.imageType ~= nil and mod.e.VkImageType(t.imageType) or 0
		_pool.imageTiling = t.imageTiling ~= nil and mod.e.VkImageTiling(t.imageTiling) or 0
		_pool.imageUsageFlags = t.imageUsageFlags ~= nil and mod.e.VkImageUsageFlagBits(t.imageUsageFlags) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoPictureResourceInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoPictureResourceInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil

		if t.codedOffset ~= nil then
			if type(t.codedOffset) == "table" then
				_pool.codedOffset = mod.VkOffset2D(t.codedOffset)
			else
				_pool.codedOffset = t.codedOffset
			end
		else
			_pool.codedOffset = mod.VkOffset2D()
		end

		if t.codedExtent ~= nil then
			if type(t.codedExtent) == "table" then
				_pool.codedExtent = mod.VkExtent2D(t.codedExtent)
			else
				_pool.codedExtent = t.codedExtent
			end
		else
			_pool.codedExtent = mod.VkExtent2D()
		end

		_pool.baseArrayLayer = t.baseArrayLayer or 0
		_pool.imageViewBinding = t.imageViewBinding or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoReferenceSlotInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoReferenceSlotInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.slotIndex = t.slotIndex or 0
		_pool.pPictureResource = t.pPictureResource or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoSessionMemoryRequirementsKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoSessionMemoryRequirementsKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.memoryBindIndex = t.memoryBindIndex or 0

		if t.memoryRequirements ~= nil then
			if type(t.memoryRequirements) == "table" then
				_pool.memoryRequirements = mod.VkMemoryRequirements(t.memoryRequirements)
			else
				_pool.memoryRequirements = t.memoryRequirements
			end
		else
			_pool.memoryRequirements = mod.VkMemoryRequirements()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.BindVideoSessionMemoryInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindVideoSessionMemoryInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.memoryBindIndex = t.memoryBindIndex or 0
		_pool.memory = t.memory or 0
		_pool.memoryOffset = t.memoryOffset or 0
		_pool.memorySize = t.memorySize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoSessionCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoSessionCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.queueFamilyIndex = t.queueFamilyIndex or 0
		_pool.flags = t.flags or 0
		_pool.pVideoProfile = t.pVideoProfile or 0
		_pool.pictureFormat = t.pictureFormat ~= nil and mod.e.VkFormat(t.pictureFormat) or 0

		if t.maxCodedExtent ~= nil then
			if type(t.maxCodedExtent) == "table" then
				_pool.maxCodedExtent = mod.VkExtent2D(t.maxCodedExtent)
			else
				_pool.maxCodedExtent = t.maxCodedExtent
			end
		else
			_pool.maxCodedExtent = mod.VkExtent2D()
		end

		_pool.referencePictureFormat = t.referencePictureFormat ~= nil and mod.e.VkFormat(t.referencePictureFormat) or 0
		_pool.maxDpbSlots = t.maxDpbSlots or 0
		_pool.maxActiveReferencePictures = t.maxActiveReferencePictures or 0
		_pool.pStdHeaderVersion = t.pStdHeaderVersion or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImportSemaphoreFdInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImportSemaphoreFdInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.semaphore = t.semaphore or 0
		_pool.flags = t.flags ~= nil and mod.e.VkSemaphoreImportFlagBits(t.flags) or 0
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.handleType) or
			0
		_pool.fd = t.fd or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SemaphoreGetFdInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSemaphoreGetFdInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.semaphore = t.semaphore or 0
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.handleType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoSessionParametersUpdateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoSessionParametersUpdateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.updateSequenceCount = t.updateSequenceCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoBeginCodingInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoBeginCodingInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.videoSession = t.videoSession or 0
		_pool.videoSessionParameters = t.videoSessionParameters or 0
		_pool.referenceSlotCount = t.referenceSlotCount or 0
		_pool.pReferenceSlots = t.pReferenceSlots or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.InitializePerformanceApiInfoINTEL(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkInitializePerformanceApiInfoINTEL)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL")
		end

		_pool.pNext = t.pNext or nil
		_pool.pUserData = t.pUserData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueryPoolPerformanceQueryCreateInfoINTEL(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueryPoolPerformanceQueryCreateInfoINTEL)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL")
		end

		_pool.pNext = t.pNext or nil
		_pool.performanceCountersSampling = t.performanceCountersSampling ~= nil and
			mod.e.VkQueryPoolSamplingModeINTEL(t.performanceCountersSampling) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PerformanceMarkerInfoINTEL(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPerformanceMarkerInfoINTEL)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL")
		end

		_pool.pNext = t.pNext or nil
		_pool.marker = t.marker or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PerformanceStreamMarkerInfoINTEL(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPerformanceStreamMarkerInfoINTEL)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL")
		end

		_pool.pNext = t.pNext or nil
		_pool.marker = t.marker or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PerformanceOverrideInfoINTEL(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPerformanceOverrideInfoINTEL)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type ~= nil and mod.e.VkPerformanceOverrideTypeINTEL(t.type) or 0
		_pool.enable = t.enable or 0
		_pool.parameter = t.parameter or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PerformanceConfigurationAcquireInfoINTEL(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPerformanceConfigurationAcquireInfoINTEL)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type ~= nil and mod.e.VkPerformanceConfigurationTypeINTEL(t.type) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceClusterCullingShaderFeaturesHUAWEI(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI")
		end

		_pool.pNext = t.pNext or nil
		_pool.clustercullingShader = t.clustercullingShader or 0
		_pool.multiviewClusterCullingShader = t.multiviewClusterCullingShader or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceClusterCullingShaderPropertiesHUAWEI(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxWorkGroupCount = t.maxWorkGroupCount or 0
		_pool.maxWorkGroupSize = t.maxWorkGroupSize or 0
		_pool.maxOutputClusterCount = t.maxOutputClusterCount or 0
		_pool.indirectBufferOffsetAlignment = t.indirectBufferOffsetAlignment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDeviceGeneratedCommandsPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxGraphicsShaderGroupCount = t.maxGraphicsShaderGroupCount or 0
		_pool.maxIndirectSequenceCount = t.maxIndirectSequenceCount or 0
		_pool.maxIndirectCommandsTokenCount = t.maxIndirectCommandsTokenCount or 0
		_pool.maxIndirectCommandsStreamCount = t.maxIndirectCommandsStreamCount or 0
		_pool.maxIndirectCommandsTokenOffset = t.maxIndirectCommandsTokenOffset or 0
		_pool.maxIndirectCommandsStreamStride = t.maxIndirectCommandsStreamStride or 0
		_pool.minSequencesCountBufferOffsetAlignment = t.minSequencesCountBufferOffsetAlignment or 0
		_pool.minSequencesIndexBufferOffsetAlignment = t.minSequencesIndexBufferOffsetAlignment or 0
		_pool.minIndirectCommandsBufferOffsetAlignment = t.minIndirectCommandsBufferOffsetAlignment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI")
		end

		_pool.pNext = t.pNext or nil
		_pool.clusterShadingRate = t.clusterShadingRate or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDeviceGeneratedCommandsFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceGeneratedCommands = t.deviceGeneratedCommands or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GraphicsShaderGroupCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGraphicsShaderGroupCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.stageCount = t.stageCount or 0
		_pool.pStages = t.pStages or 0
		_pool.pVertexInputState = t.pVertexInputState or 0
		_pool.pTessellationState = t.pTessellationState or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceBorderColorSwizzleFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.borderColorSwizzle = t.borderColorSwizzle or 0
		_pool.borderColorSwizzleFromImage = t.borderColorSwizzleFromImage or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SamplerBorderColorComponentMappingCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSamplerBorderColorComponentMappingCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil

		if t.components ~= nil then
			if type(t.components) == "table" then
				_pool.components = mod.s.ComponentMapping(t.components)
			else
				_pool.components = t.components
			end
		else
			_pool.components = mod.VkComponentMapping()
		end

		_pool.srgb = t.srgb or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.pageableDeviceLocalMemory = t.pageableDeviceLocalMemory or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.IndirectCommandsLayoutTokenNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkIndirectCommandsLayoutTokenNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.tokenType = t.tokenType ~= nil and mod.e.VkIndirectCommandsTokenTypeNV(t.tokenType) or 0
		_pool.stream = t.stream or 0
		_pool.offset = t.offset or 0
		_pool.vertexBindingUnit = t.vertexBindingUnit or 0
		_pool.vertexDynamicStride = t.vertexDynamicStride or 0
		_pool.pushconstantPipelineLayout = t.pushconstantPipelineLayout or 0
		_pool.pushconstantShaderStageFlags = t.pushconstantShaderStageFlags ~= nil and
			mod.e.VkShaderStageFlagBits(t.pushconstantShaderStageFlags) or
			0
		_pool.pushconstantOffset = t.pushconstantOffset or 0
		_pool.pushconstantSize = t.pushconstantSize or 0
		_pool.indirectStateFlags = t.indirectStateFlags or 0
		_pool.indexTypeCount = t.indexTypeCount or 0
		_pool.pIndexTypes = t.pIndexTypes or 0
		_pool.pIndexTypeValues = t.pIndexTypeValues or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderCorePropertiesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderCorePropertiesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.pixelRate = t.pixelRate or 0
		_pool.texelRate = t.texelRate or 0
		_pool.fmaRate = t.fmaRate or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.spheres = t.spheres or 0
		_pool.linearSweptSpheres = t.linearSweptSpheres or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.IndirectCommandsLayoutCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkIndirectCommandsLayoutCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.pipelineBindPoint = t.pipelineBindPoint ~= nil and
			mod.e.VkPipelineBindPoint(t.pipelineBindPoint) or
			0
		_pool.tokenCount = t.tokenCount or 0
		_pool.pTokens = t.pTokens or 0
		_pool.streamCount = t.streamCount or 0
		_pool.pStreamStrides = t.pStreamStrides or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureGeometryLinearSweptSpheresDataNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureGeometryLinearSweptSpheresDataNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.vertexFormat = t.vertexFormat ~= nil and mod.e.VkFormat(t.vertexFormat) or 0

		if t.vertexData ~= nil then
			if type(t.vertexData) == "table" then
				_pool.vertexData = mod.VkDeviceOrHostAddressConstKHR(t.vertexData)
			else
				_pool.vertexData = t.vertexData
			end
		else
			_pool.vertexData = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.vertexStride = t.vertexStride or 0
		_pool.radiusFormat = t.radiusFormat ~= nil and mod.e.VkFormat(t.radiusFormat) or 0

		if t.radiusData ~= nil then
			if type(t.radiusData) == "table" then
				_pool.radiusData = mod.VkDeviceOrHostAddressConstKHR(t.radiusData)
			else
				_pool.radiusData = t.radiusData
			end
		else
			_pool.radiusData = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.radiusStride = t.radiusStride or 0
		_pool.indexType = t.indexType ~= nil and mod.e.VkIndexType(t.indexType) or 0

		if t.indexData ~= nil then
			if type(t.indexData) == "table" then
				_pool.indexData = mod.VkDeviceOrHostAddressConstKHR(t.indexData)
			else
				_pool.indexData = t.indexData
			end
		else
			_pool.indexData = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.indexStride = t.indexStride or 0
		_pool.indexingMode = t.indexingMode ~= nil and
			mod.e.VkRayTracingLssIndexingModeNV(t.indexingMode) or
			0
		_pool.endCapsMode = t.endCapsMode ~= nil and
			mod.e.VkRayTracingLssPrimitiveEndCapsModeNV(t.endCapsMode) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SampleLocationsInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSampleLocationsInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.sampleLocationsPerPixel = t.sampleLocationsPerPixel ~= nil and
			mod.e.VkSampleCountFlagBits(t.sampleLocationsPerPixel) or
			0

		if t.sampleLocationGridSize ~= nil then
			if type(t.sampleLocationGridSize) == "table" then
				_pool.sampleLocationGridSize = mod.VkExtent2D(t.sampleLocationGridSize)
			else
				_pool.sampleLocationGridSize = t.sampleLocationGridSize
			end
		else
			_pool.sampleLocationGridSize = mod.VkExtent2D()
		end

		_pool.sampleLocationsCount = t.sampleLocationsCount or 0
		_pool.pSampleLocations = t.pSampleLocations or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceQueueShaderCoreControlCreateInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceQueueShaderCoreControlCreateInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderCoreCount = t.shaderCoreCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GeneratedCommandsInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGeneratedCommandsInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineBindPoint = t.pipelineBindPoint ~= nil and
			mod.e.VkPipelineBindPoint(t.pipelineBindPoint) or
			0
		_pool.pipeline = t.pipeline or 0
		_pool.indirectCommandsLayout = t.indirectCommandsLayout or 0
		_pool.streamCount = t.streamCount or 0
		_pool.pStreams = t.pStreams or 0
		_pool.sequencesCount = t.sequencesCount or 0
		_pool.preprocessBuffer = t.preprocessBuffer or 0
		_pool.preprocessOffset = t.preprocessOffset or 0
		_pool.preprocessSize = t.preprocessSize or 0
		_pool.sequencesCountBuffer = t.sequencesCountBuffer or 0
		_pool.sequencesCountOffset = t.sequencesCountOffset or 0
		_pool.sequencesIndexBuffer = t.sequencesIndexBuffer or 0
		_pool.sequencesIndexOffset = t.sequencesIndexOffset or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSchedulingControlsFeaturesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSchedulingControlsFeaturesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.schedulingControls = t.schedulingControls or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSchedulingControlsPropertiesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSchedulingControlsPropertiesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.schedulingControlsFlags = t.schedulingControlsFlags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceLinearColorAttachmentFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceLinearColorAttachmentFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.linearColorAttachment = t.linearColorAttachment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassSampleLocationsBeginInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassSampleLocationsBeginInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.attachmentInitialSampleLocationsCount = t.attachmentInitialSampleLocationsCount or 0
		_pool.pAttachmentInitialSampleLocations = t.pAttachmentInitialSampleLocations or 0
		_pool.postSubpassSampleLocationsCount = t.postSubpassSampleLocationsCount or 0
		_pool.pPostSubpassSampleLocations = t.pPostSubpassSampleLocations or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageViewSlicedCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageViewSlicedCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.sliceOffset = t.sliceOffset or 0
		_pool.sliceCount = t.sliceCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineSampleLocationsStateCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineSampleLocationsStateCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.sampleLocationsEnable = t.sampleLocationsEnable or 0

		if t.sampleLocationsInfo ~= nil then
			if type(t.sampleLocationsInfo) == "table" then
				_pool.sampleLocationsInfo = mod.s.SampleLocationsInfoEXT(t.sampleLocationsInfo)
			else
				_pool.sampleLocationsInfo = t.sampleLocationsInfo
			end
		else
			_pool.sampleLocationsInfo = mod.VkSampleLocationsInfoEXT()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSampleLocationsPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSampleLocationsPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.sampleLocationSampleCounts = t.sampleLocationSampleCounts ~= nil and
			mod.e.VkSampleCountFlagBits(t.sampleLocationSampleCounts) or
			0

		if t.maxSampleLocationGridSize ~= nil then
			if type(t.maxSampleLocationGridSize) == "table" then
				_pool.maxSampleLocationGridSize = mod.VkExtent2D(t.maxSampleLocationGridSize)
			else
				_pool.maxSampleLocationGridSize = t.maxSampleLocationGridSize
			end
		else
			_pool.maxSampleLocationGridSize = mod.VkExtent2D()
		end

		_pool.sampleLocationCoordinateRange = t.sampleLocationCoordinateRange or 0
		_pool.sampleLocationSubPixelBits = t.sampleLocationSubPixelBits or 0
		_pool.variableSampleLocations = t.variableSampleLocations or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE")
		end

		_pool.pNext = t.pNext or nil
		_pool.descriptorSetHostMapping = t.descriptorSetHostMapping or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorSetBindingReferenceVALVE(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorSetBindingReferenceVALVE)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE")
		end

		_pool.pNext = t.pNext or nil
		_pool.descriptorSetLayout = t.descriptorSetLayout or 0
		_pool.binding = t.binding or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorSetLayoutHostMappingInfoVALVE(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorSetLayoutHostMappingInfoVALVE)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE")
		end

		_pool.pNext = t.pNext or nil
		_pool.descriptorOffset = t.descriptorOffset or 0
		_pool.descriptorSize = t.descriptorSize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePrivateDataFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePrivateDataFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.privateData = t.privateData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DevicePrivateData(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDevicePrivateDataCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.privateDataSlotRequestCount = t.privateDataSlotRequestCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PrivateDataSlot(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPrivateDataSlotCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePipelineCreationCacheControlFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePipelineCreationCacheControlFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineCreationCacheControl = t.pipelineCreationCacheControl or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceImageProcessingFeaturesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceImageProcessingFeaturesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.textureSampleWeighted = t.textureSampleWeighted or 0
		_pool.textureBoxFilter = t.textureBoxFilter or 0
		_pool.textureBlockMatch = t.textureBlockMatch or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Dependency(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDependencyInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEPENDENCY_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.dependencyFlags = t.dependencyFlags ~= nil and mod.e.VkDependencyFlagBits(t.dependencyFlags) or 0
		_pool.memoryBarrierCount = t.memoryBarrierCount or 0
		_pool.pMemoryBarriers = t.pMemoryBarriers or 0
		_pool.bufferMemoryBarrierCount = t.bufferMemoryBarrierCount or 0
		_pool.pBufferMemoryBarriers = t.pBufferMemoryBarriers or 0
		_pool.imageMemoryBarrierCount = t.imageMemoryBarrierCount or 0
		_pool.pImageMemoryBarriers = t.pImageMemoryBarriers or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SemaphoreSubmit(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSemaphoreSubmitInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.semaphore = t.semaphore or 0
		_pool.value = t.value or 0
		_pool.stageMask = t.stageMask or 0
		_pool.deviceIndex = t.deviceIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceInheritedViewportScissorFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceInheritedViewportScissorFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.inheritedViewportScissor2D = t.inheritedViewportScissor2D or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CommandBufferInheritanceViewportScissorInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCommandBufferInheritanceViewportScissorInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.viewportScissor2D = t.viewportScissor2D or 0
		_pool.viewportDepthCount = t.viewportDepthCount or 0
		_pool.pViewportDepths = t.pViewportDepths or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceNonSeamlessCubeMapFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.nonSeamlessCubeMap = t.nonSeamlessCubeMap or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceBlendOperationAdvancedFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.advancedBlendCoherentOperations = t.advancedBlendCoherentOperations or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceNestedCommandBufferFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceNestedCommandBufferFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.nestedCommandBuffer = t.nestedCommandBuffer or 0
		_pool.nestedCommandBufferRendering = t.nestedCommandBufferRendering or 0
		_pool.nestedCommandBufferSimultaneousUse = t.nestedCommandBufferSimultaneousUse or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceBlendOperationAdvancedPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.advancedBlendMaxColorAttachments = t.advancedBlendMaxColorAttachments or 0
		_pool.advancedBlendIndependentBlend = t.advancedBlendIndependentBlend or 0
		_pool.advancedBlendNonPremultipliedSrcColor = t.advancedBlendNonPremultipliedSrcColor or 0
		_pool.advancedBlendNonPremultipliedDstColor = t.advancedBlendNonPremultipliedDstColor or 0
		_pool.advancedBlendCorrelatedOverlap = t.advancedBlendCorrelatedOverlap or 0
		_pool.advancedBlendAllOperations = t.advancedBlendAllOperations or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRenderPassStripedFeaturesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRenderPassStripedFeaturesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.renderPassStriped = t.renderPassStriped or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceImageRobustnessFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceImageRobustnessFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.robustImageAccess = t.robustImageAccess or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRenderPassStripedPropertiesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRenderPassStripedPropertiesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM")
		end

		_pool.pNext = t.pNext or nil

		if t.renderPassStripeGranularity ~= nil then
			if type(t.renderPassStripeGranularity) == "table" then
				_pool.renderPassStripeGranularity = mod.VkExtent2D(t.renderPassStripeGranularity)
			else
				_pool.renderPassStripeGranularity = t.renderPassStripeGranularity
			end
		else
			_pool.renderPassStripeGranularity = mod.VkExtent2D()
		end

		_pool.maxRenderPassStripes = t.maxRenderPassStripes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassStripeInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassStripeInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil

		if t.stripeArea ~= nil then
			if type(t.stripeArea) == "table" then
				_pool.stripeArea = mod.VkRect2D(t.stripeArea)
			else
				_pool.stripeArea = t.stripeArea
			end
		else
			_pool.stripeArea = mod.VkRect2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalMemoryAcquireUnmodifiedEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalMemoryAcquireUnmodifiedEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.acquireUnmodifiedMemory = t.acquireUnmodifiedMemory or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassStripeBeginInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassStripeBeginInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.stripeInfoCount = t.stripeInfoCount or 0
		_pool.pStripeInfos = t.pStripeInfos or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassStripeSubmitInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassStripeSubmitInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.stripeSemaphoreInfoCount = t.stripeSemaphoreInfoCount or 0
		_pool.pStripeSemaphoreInfos = t.pStripeSemaphoreInfos or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSubgroupSizeControlFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSubgroupSizeControlFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.subgroupSizeControl = t.subgroupSizeControl or 0
		_pool.computeFullSubgroups = t.computeFullSubgroups or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSubgroupSizeControlProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSubgroupSizeControlProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.minSubgroupSize = t.minSubgroupSize or 0
		_pool.maxSubgroupSize = t.maxSubgroupSize or 0
		_pool.maxComputeWorkgroupSubgroups = t.maxComputeWorkgroupSubgroups or 0
		_pool.requiredSubgroupSizeStages = t.requiredSubgroupSizeStages ~= nil and
			mod.e.VkShaderStageFlagBits(t.requiredSubgroupSizeStages) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineShaderStageRequiredSubgroupSize(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.requiredSubgroupSize = t.requiredSubgroupSize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.fragmentDensityMapOffset = t.fragmentDensityMapOffset or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoDecodeUsageInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoDecodeUsageInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.videoUsageHints = t.videoUsageHints or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceInlineUniformBlockProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceInlineUniformBlockProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxInlineUniformBlockSize = t.maxInlineUniformBlockSize or 0
		_pool.maxPerStageDescriptorInlineUniformBlocks = t.maxPerStageDescriptorInlineUniformBlocks or 0
		_pool.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = t.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks or 0
		_pool.maxDescriptorSetInlineUniformBlocks = t.maxDescriptorSetInlineUniformBlocks or 0
		_pool.maxDescriptorSetUpdateAfterBindInlineUniformBlocks = t.maxDescriptorSetUpdateAfterBindInlineUniformBlocks or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoDecodeInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoDecodeInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.srcBuffer = t.srcBuffer or 0
		_pool.srcBufferOffset = t.srcBufferOffset or 0
		_pool.srcBufferRange = t.srcBufferRange or 0

		if t.dstPictureResource ~= nil then
			if type(t.dstPictureResource) == "table" then
				_pool.dstPictureResource = mod.s.VideoPictureResourceInfoKHR(t.dstPictureResource)
			else
				_pool.dstPictureResource = t.dstPictureResource
			end
		else
			_pool.dstPictureResource = mod.VkVideoPictureResourceInfoKHR()
		end

		_pool.pSetupReferenceSlot = t.pSetupReferenceSlot or 0
		_pool.referenceSlotCount = t.referenceSlotCount or 0
		_pool.pReferenceSlots = t.pReferenceSlots or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorPoolInlineUniformBlock(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorPoolInlineUniformBlockCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxInlineUniformBlockBindings = t.maxInlineUniformBlockBindings or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderingAttachment(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderingAttachmentInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.imageView = t.imageView or 0
		_pool.imageLayout = t.imageLayout ~= nil and mod.e.VkImageLayout(t.imageLayout) or 0
		_pool.resolveMode = t.resolveMode ~= nil and mod.e.VkResolveModeFlagBits(t.resolveMode) or 0
		_pool.resolveImageView = t.resolveImageView or 0
		_pool.resolveImageLayout = t.resolveImageLayout ~= nil and mod.e.VkImageLayout(t.resolveImageLayout) or 0
		_pool.loadOp = t.loadOp ~= nil and mod.e.VkAttachmentLoadOp(t.loadOp) or 0
		_pool.storeOp = t.storeOp ~= nil and mod.e.VkAttachmentStoreOp(t.storeOp) or 0

		if t.clearValue ~= nil then
			if type(t.clearValue) == "table" then
				_pool.clearValue = mod.VkClearValue(t.clearValue)
			else
				_pool.clearValue = t.clearValue
			end
		else
			_pool.clearValue = mod.VkClearValue()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineCoverageModulationStateCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineCoverageModulationStateCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.coverageModulationMode = t.coverageModulationMode ~= nil and
			mod.e.VkCoverageModulationModeNV(t.coverageModulationMode) or
			0
		_pool.coverageModulationTableEnable = t.coverageModulationTableEnable or 0
		_pool.coverageModulationTableCount = t.coverageModulationTableCount or 0
		_pool.pCoverageModulationTable = t.pCoverageModulationTable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Rendering(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderingInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkRenderingFlagBits(t.flags) or 0

		if t.renderArea ~= nil then
			if type(t.renderArea) == "table" then
				_pool.renderArea = mod.VkRect2D(t.renderArea)
			else
				_pool.renderArea = t.renderArea
			end
		else
			_pool.renderArea = mod.VkRect2D()
		end

		_pool.layerCount = t.layerCount or 0
		_pool.viewMask = t.viewMask or 0
		_pool.colorAttachmentCount = t.colorAttachmentCount or 0
		_pool.pColorAttachments = t.pColorAttachments or 0
		_pool.pDepthAttachment = t.pDepthAttachment or 0
		_pool.pStencilAttachment = t.pStencilAttachment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineRendering(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineRenderingCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.viewMask = t.viewMask or 0
		_pool.colorAttachmentCount = t.colorAttachmentCount or 0
		_pool.pColorAttachmentFormats = t.pColorAttachmentFormats or 0
		_pool.depthAttachmentFormat = t.depthAttachmentFormat ~= nil and mod.e.VkFormat(t.depthAttachmentFormat) or 0
		_pool.stencilAttachmentFormat = t.stencilAttachmentFormat ~= nil and
			mod.e.VkFormat(t.stencilAttachmentFormat) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDynamicRenderingFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDynamicRenderingFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.dynamicRendering = t.dynamicRendering or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CommandBufferInheritanceRendering(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCommandBufferInheritanceRenderingInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkRenderingFlagBits(t.flags) or 0
		_pool.viewMask = t.viewMask or 0
		_pool.colorAttachmentCount = t.colorAttachmentCount or 0
		_pool.pColorAttachmentFormats = t.pColorAttachmentFormats or 0
		_pool.depthAttachmentFormat = t.depthAttachmentFormat ~= nil and mod.e.VkFormat(t.depthAttachmentFormat) or 0
		_pool.stencilAttachmentFormat = t.stencilAttachmentFormat ~= nil and
			mod.e.VkFormat(t.stencilAttachmentFormat) or
			0
		_pool.rasterizationSamples = t.rasterizationSamples ~= nil and
			mod.e.VkSampleCountFlagBits(t.rasterizationSamples) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderIntegerDotProductFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderIntegerDotProductFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderIntegerDotProduct = t.shaderIntegerDotProduct or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderIntegerDotProductProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderIntegerDotProductProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.integerDotProduct8BitUnsignedAccelerated = t.integerDotProduct8BitUnsignedAccelerated or 0
		_pool.integerDotProduct8BitSignedAccelerated = t.integerDotProduct8BitSignedAccelerated or 0
		_pool.integerDotProduct8BitMixedSignednessAccelerated = t.integerDotProduct8BitMixedSignednessAccelerated or 0
		_pool.integerDotProduct4x8BitPackedUnsignedAccelerated = t.integerDotProduct4x8BitPackedUnsignedAccelerated or 0
		_pool.integerDotProduct4x8BitPackedSignedAccelerated = t.integerDotProduct4x8BitPackedSignedAccelerated or 0
		_pool.integerDotProduct4x8BitPackedMixedSignednessAccelerated = t.integerDotProduct4x8BitPackedMixedSignednessAccelerated or 0
		_pool.integerDotProduct16BitUnsignedAccelerated = t.integerDotProduct16BitUnsignedAccelerated or 0
		_pool.integerDotProduct16BitSignedAccelerated = t.integerDotProduct16BitSignedAccelerated or 0
		_pool.integerDotProduct16BitMixedSignednessAccelerated = t.integerDotProduct16BitMixedSignednessAccelerated or 0
		_pool.integerDotProduct32BitUnsignedAccelerated = t.integerDotProduct32BitUnsignedAccelerated or 0
		_pool.integerDotProduct32BitSignedAccelerated = t.integerDotProduct32BitSignedAccelerated or 0
		_pool.integerDotProduct32BitMixedSignednessAccelerated = t.integerDotProduct32BitMixedSignednessAccelerated or 0
		_pool.integerDotProduct64BitUnsignedAccelerated = t.integerDotProduct64BitUnsignedAccelerated or 0
		_pool.integerDotProduct64BitSignedAccelerated = t.integerDotProduct64BitSignedAccelerated or 0
		_pool.integerDotProduct64BitMixedSignednessAccelerated = t.integerDotProduct64BitMixedSignednessAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating8BitSignedAccelerated = t.integerDotProductAccumulatingSaturating8BitSignedAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = t.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = t.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated or
			0
		_pool.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating16BitSignedAccelerated = t.integerDotProductAccumulatingSaturating16BitSignedAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating32BitSignedAccelerated = t.integerDotProductAccumulatingSaturating32BitSignedAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = t.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating64BitSignedAccelerated = t.integerDotProductAccumulatingSaturating64BitSignedAccelerated or 0
		_pool.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = t.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTexelBufferAlignmentProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTexelBufferAlignmentProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.storageTexelBufferOffsetAlignmentBytes = t.storageTexelBufferOffsetAlignmentBytes or 0
		_pool.storageTexelBufferOffsetSingleTexelAlignment = t.storageTexelBufferOffsetSingleTexelAlignment or 0
		_pool.uniformTexelBufferOffsetAlignmentBytes = t.uniformTexelBufferOffsetAlignmentBytes or 0
		_pool.uniformTexelBufferOffsetSingleTexelAlignment = t.uniformTexelBufferOffsetSingleTexelAlignment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorSetVariableDescriptorCountLayoutSupport(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorSetVariableDescriptorCountLayoutSupport)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxVariableDescriptorCount = t.maxVariableDescriptorCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.IndirectExecutionSetPipelineInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkIndirectExecutionSetPipelineInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.initialPipeline = t.initialPipeline or 0
		_pool.maxPipelineCount = t.maxPipelineCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderEarlyAndLateFragmentTests = t.shaderEarlyAndLateFragmentTests or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceBufferMemoryRequirements(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceBufferMemoryRequirements)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS")
		end

		_pool.pNext = t.pNext or nil
		_pool.pCreateInfo = t.pCreateInfo or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceImageMemoryRequirements(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceImageMemoryRequirements)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS")
		end

		_pool.pNext = t.pNext or nil
		_pool.pCreateInfo = t.pCreateInfo or 0
		_pool.planeAspect = t.planeAspect ~= nil and mod.e.VkImageAspectFlagBits(t.planeAspect) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.IndirectCommandsLayoutTokenEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkIndirectCommandsLayoutTokenEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type ~= nil and mod.e.VkIndirectCommandsTokenTypeEXT(t.type) or 0

		if t.data ~= nil then
			if type(t.data) == "table" then
				_pool.data = mod.VkIndirectCommandsTokenDataEXT(t.data)
			else
				_pool.data = t.data
			end
		else
			_pool.data = mod.VkIndirectCommandsTokenDataEXT()
		end

		_pool.offset = t.offset or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassFragmentDensityMapCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassFragmentDensityMapCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil

		if t.fragmentDensityMapAttachment ~= nil then
			if type(t.fragmentDensityMapAttachment) == "table" then
				_pool.fragmentDensityMapAttachment = mod.s.AttachmentReference(t.fragmentDensityMapAttachment)
			else
				_pool.fragmentDensityMapAttachment = t.fragmentDensityMapAttachment
			end
		else
			_pool.fragmentDensityMapAttachment = mod.VkAttachmentReference()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureGeometrySpheresDataNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureGeometrySpheresDataNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.vertexFormat = t.vertexFormat ~= nil and mod.e.VkFormat(t.vertexFormat) or 0

		if t.vertexData ~= nil then
			if type(t.vertexData) == "table" then
				_pool.vertexData = mod.VkDeviceOrHostAddressConstKHR(t.vertexData)
			else
				_pool.vertexData = t.vertexData
			end
		else
			_pool.vertexData = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.vertexStride = t.vertexStride or 0
		_pool.radiusFormat = t.radiusFormat ~= nil and mod.e.VkFormat(t.radiusFormat) or 0

		if t.radiusData ~= nil then
			if type(t.radiusData) == "table" then
				_pool.radiusData = mod.VkDeviceOrHostAddressConstKHR(t.radiusData)
			else
				_pool.radiusData = t.radiusData
			end
		else
			_pool.radiusData = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.radiusStride = t.radiusStride or 0
		_pool.indexType = t.indexType ~= nil and mod.e.VkIndexType(t.indexType) or 0

		if t.indexData ~= nil then
			if type(t.indexData) == "table" then
				_pool.indexData = mod.VkDeviceOrHostAddressConstKHR(t.indexData)
			else
				_pool.indexData = t.indexData
			end
		else
			_pool.indexData = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.indexStride = t.indexStride or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CommandBufferInheritanceRenderPassTransformInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCommandBufferInheritanceRenderPassTransformInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.transform = t.transform ~= nil and mod.e.VkSurfaceTransformFlagBitsKHR(t.transform) or 0

		if t.renderArea ~= nil then
			if type(t.renderArea) == "table" then
				_pool.renderArea = mod.VkRect2D(t.renderArea)
			else
				_pool.renderArea = t.renderArea
			end
		else
			_pool.renderArea = mod.VkRect2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFaultFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFaultFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceFault = t.deviceFault or 0
		_pool.deviceFaultVendorBinary = t.deviceFaultVendorBinary or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassAttachmentBegin(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassAttachmentBeginInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.attachmentCount = t.attachmentCount or 0
		_pool.pAttachments = t.pAttachments or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineColorBlendState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineColorBlendStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkPipelineColorBlendStateCreateFlagBits(t.flags) or 0
		_pool.logicOpEnable = t.logicOpEnable or 0
		_pool.logicOp = t.logicOp ~= nil and mod.e.VkLogicOp(t.logicOp) or 0
		_pool.attachmentCount = t.attachmentCount or 0
		_pool.pAttachments = t.pAttachments or 0
		_pool.blendConstants = t.blendConstants or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceFaultCountsEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceFaultCountsEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.addressInfoCount = t.addressInfoCount or 0
		_pool.vendorInfoCount = t.vendorInfoCount or 0
		_pool.vendorBinarySize = t.vendorBinarySize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageToMemoryCopy(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageToMemoryCopy)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY")
		end

		_pool.pNext = t.pNext or nil
		_pool.pHostPointer = t.pHostPointer or 0
		_pool.memoryRowLength = t.memoryRowLength or 0
		_pool.memoryImageHeight = t.memoryImageHeight or 0

		if t.imageSubresource ~= nil then
			if type(t.imageSubresource) == "table" then
				_pool.imageSubresource = mod.s.ImageSubresourceLayers(t.imageSubresource)
			else
				_pool.imageSubresource = t.imageSubresource
			end
		else
			_pool.imageSubresource = mod.VkImageSubresourceLayers()
		end

		if t.imageOffset ~= nil then
			if type(t.imageOffset) == "table" then
				_pool.imageOffset = mod.VkOffset3D(t.imageOffset)
			else
				_pool.imageOffset = t.imageOffset
			end
		else
			_pool.imageOffset = mod.VkOffset3D()
		end

		if t.imageExtent ~= nil then
			if type(t.imageExtent) == "table" then
				_pool.imageExtent = mod.VkExtent3D(t.imageExtent)
			else
				_pool.imageExtent = t.imageExtent
			end
		else
			_pool.imageExtent = mod.VkExtent3D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.SwapchainPresentScalingCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSwapchainPresentScalingCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.scalingBehavior = t.scalingBehavior or 0
		_pool.presentGravityX = t.presentGravityX or 0
		_pool.presentGravityY = t.presentGravityY or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentDensityMapFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentDensityMapFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.fragmentDensityMap = t.fragmentDensityMap or 0
		_pool.fragmentDensityMapDynamic = t.fragmentDensityMapDynamic or 0
		_pool.fragmentDensityMapNonSubsampledImages = t.fragmentDensityMapNonSubsampledImages or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DrmFormatModifierPropertiesListEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDrmFormatModifierPropertiesListEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.drmFormatModifierCount = t.drmFormatModifierCount or 0
		_pool.pDrmFormatModifierProperties = t.pDrmFormatModifierProperties or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineColorWriteCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineColorWriteCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.attachmentCount = t.attachmentCount or 0
		_pool.pColorWriteEnables = t.pColorWriteEnables or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMapMemoryPlacedPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.minPlacedMemoryMapAlignment = t.minPlacedMemoryMapAlignment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceImageDrmFormatModifierInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceImageDrmFormatModifierInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.drmFormatModifier = t.drmFormatModifier or 0
		_pool.sharingMode = t.sharingMode ~= nil and mod.e.VkSharingMode(t.sharingMode) or 0
		_pool.queueFamilyIndexCount = t.queueFamilyIndexCount or 0
		_pool.pQueueFamilyIndices = t.pQueueFamilyIndices or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageDrmFormatModifierListCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageDrmFormatModifierListCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.drmFormatModifierCount = t.drmFormatModifierCount or 0
		_pool.pDrmFormatModifiers = t.pDrmFormatModifiers or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVertexAttributeDivisorPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxVertexAttribDivisor = t.maxVertexAttribDivisor or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageDrmFormatModifierExplicitCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageDrmFormatModifierExplicitCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.drmFormatModifier = t.drmFormatModifier or 0
		_pool.drmFormatModifierPlaneCount = t.drmFormatModifierPlaneCount or 0
		_pool.pPlaneLayouts = t.pPlaneLayouts or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceFaultInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceFaultInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.description = t.description or 0
		_pool.pAddressInfos = t.pAddressInfos or 0
		_pool.pVendorInfos = t.pVendorInfos or 0
		_pool.pVendorBinaryData = t.pVendorBinaryData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageDrmFormatModifierPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageDrmFormatModifierPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.drmFormatModifier = t.drmFormatModifier or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoCapabilitiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoCapabilitiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.minBitstreamBufferOffsetAlignment = t.minBitstreamBufferOffsetAlignment or 0
		_pool.minBitstreamBufferSizeAlignment = t.minBitstreamBufferSizeAlignment or 0

		if t.pictureAccessGranularity ~= nil then
			if type(t.pictureAccessGranularity) == "table" then
				_pool.pictureAccessGranularity = mod.VkExtent2D(t.pictureAccessGranularity)
			else
				_pool.pictureAccessGranularity = t.pictureAccessGranularity
			end
		else
			_pool.pictureAccessGranularity = mod.VkExtent2D()
		end

		if t.minCodedExtent ~= nil then
			if type(t.minCodedExtent) == "table" then
				_pool.minCodedExtent = mod.VkExtent2D(t.minCodedExtent)
			else
				_pool.minCodedExtent = t.minCodedExtent
			end
		else
			_pool.minCodedExtent = mod.VkExtent2D()
		end

		if t.maxCodedExtent ~= nil then
			if type(t.maxCodedExtent) == "table" then
				_pool.maxCodedExtent = mod.VkExtent2D(t.maxCodedExtent)
			else
				_pool.maxCodedExtent = t.maxCodedExtent
			end
		else
			_pool.maxCodedExtent = mod.VkExtent2D()
		end

		_pool.maxDpbSlots = t.maxDpbSlots or 0
		_pool.maxActiveReferencePictures = t.maxActiveReferencePictures or 0

		if t.stdHeaderVersion ~= nil then
			if type(t.stdHeaderVersion) == "table" then
				_pool.stdHeaderVersion = mod.VkExtensionProperties(t.stdHeaderVersion)
			else
				_pool.stdHeaderVersion = t.stdHeaderVersion
			end
		else
			_pool.stdHeaderVersion = mod.VkExtensionProperties()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeQuantizationMapCapabilitiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeQuantizationMapCapabilitiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR")
		end

		_pool.pNext = t.pNext or nil

		if t.maxQuantizationMapExtent ~= nil then
			if type(t.maxQuantizationMapExtent) == "table" then
				_pool.maxQuantizationMapExtent = mod.VkExtent2D(t.maxQuantizationMapExtent)
			else
				_pool.maxQuantizationMapExtent = t.maxQuantizationMapExtent
			end
		else
			_pool.maxQuantizationMapExtent = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassTileShadingCreateInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassTileShadingCreateInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0

		if t.tileApronSize ~= nil then
			if type(t.tileApronSize) == "table" then
				_pool.tileApronSize = mod.VkExtent2D(t.tileApronSize)
			else
				_pool.tileApronSize = t.tileApronSize
			end
		else
			_pool.tileApronSize = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageCompressionPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageCompressionPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.imageCompressionFlags = t.imageCompressionFlags or 0
		_pool.imageCompressionFixedRateFlags = t.imageCompressionFixedRateFlags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageCompressionControlEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageCompressionControlEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.compressionControlPlaneCount = t.compressionControlPlaneCount or 0
		_pool.pFixedRateFlags = t.pFixedRateFlags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceImageCompressionControlFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceImageCompressionControlFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.imageCompressionControl = t.imageCompressionControl or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyCommandTransformInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyCommandTransformInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.transform = t.transform ~= nil and mod.e.VkSurfaceTransformFlagBitsKHR(t.transform) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRayTracingMotionBlurFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.rayTracingMotionBlur = t.rayTracingMotionBlur or 0
		_pool.rayTracingMotionBlurPipelineTraceRaysIndirect = t.rayTracingMotionBlurPipelineTraceRaysIndirect or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureGeometryMotionTrianglesDataNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureGeometryMotionTrianglesDataNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV")
		end

		_pool.pNext = t.pNext or nil

		if t.vertexData ~= nil then
			if type(t.vertexData) == "table" then
				_pool.vertexData = mod.VkDeviceOrHostAddressConstKHR(t.vertexData)
			else
				_pool.vertexData = t.vertexData
			end
		else
			_pool.vertexData = mod.VkDeviceOrHostAddressConstKHR()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineFragmentShadingRateEnumStateCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineFragmentShadingRateEnumStateCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.shadingRateType = t.shadingRateType ~= nil and
			mod.e.VkFragmentShadingRateTypeNV(t.shadingRateType) or
			0
		_pool.shadingRate = t.shadingRate ~= nil and mod.e.VkFragmentShadingRateNV(t.shadingRate) or 0
		_pool.combinerOps = t.combinerOps ~= nil and
			mod.e.VkFragmentShadingRateCombinerOpKHR(t.combinerOps) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE")
		end

		_pool.pNext = t.pNext or nil
		_pool.videoEncodeRgbConversion = t.videoEncodeRgbConversion or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorSetLayoutSupport(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorSetLayoutSupport)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT")
		end

		_pool.pNext = t.pNext or nil
		_pool.supported = t.supported or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.rasterizationOrderColorAttachmentAccess = t.rasterizationOrderColorAttachmentAccess or 0
		_pool.rasterizationOrderDepthAttachmentAccess = t.rasterizationOrderDepthAttachmentAccess or 0
		_pool.rasterizationOrderStencilAttachmentAccess = t.rasterizationOrderStencilAttachmentAccess or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ShaderModuleValidationCacheCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkShaderModuleValidationCacheCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.validationCache = t.validationCache or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GraphicsPipelineLibraryCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGraphicsPipelineLibraryCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CheckpointDataNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCheckpointDataNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.stage = t.stage ~= nil and mod.e.VkPipelineStageFlagBits(t.stage) or 0
		_pool.pCheckpointMarker = t.pCheckpointMarker or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.graphicsPipelineLibrary = t.graphicsPipelineLibrary or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeProfileRgbConversionInfoVALVE(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeProfileRgbConversionInfoVALVE)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE")
		end

		_pool.pNext = t.pNext or nil
		_pool.performEncodeRgbConversion = t.performEncodeRgbConversion or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueueFamilyCheckpointPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueueFamilyCheckpointPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.checkpointExecutionStageMask = t.checkpointExecutionStageMask ~= nil and
			mod.e.VkPipelineStageFlagBits(t.checkpointExecutionStageMask) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeSessionRgbConversionCreateInfoVALVE(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeSessionRgbConversionCreateInfoVALVE)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE")
		end

		_pool.pNext = t.pNext or nil
		_pool.rgbModel = t.rgbModel ~= nil and
			mod.e.VkVideoEncodeRgbModelConversionFlagBitsVALVE(t.rgbModel) or
			0
		_pool.rgbRange = t.rgbRange ~= nil and
			mod.e.VkVideoEncodeRgbRangeCompressionFlagBitsVALVE(t.rgbRange) or
			0
		_pool.xChromaOffset = t.xChromaOffset ~= nil and
			mod.e.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE(t.xChromaOffset) or
			0
		_pool.yChromaOffset = t.yChromaOffset ~= nil and
			mod.e.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE(t.yChromaOffset) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureCaptureDescriptorDataInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureCaptureDescriptorDataInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.accelerationStructure = t.accelerationStructure or 0
		_pool.accelerationStructureNV = t.accelerationStructureNV or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SamplerCaptureDescriptorDataInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSamplerCaptureDescriptorDataInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.sampler = t.sampler or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BufferCaptureDescriptorDataInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBufferCaptureDescriptorDataInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.buffer = t.buffer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorBufferBindingInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorBufferBindingInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.address = t.address or 0
		_pool.usage = t.usage ~= nil and mod.e.VkBufferUsageFlagBits(t.usage) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExtendedDynamicStateFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.extendedDynamicState = t.extendedDynamicState or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMutableDescriptorTypeFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.mutableDescriptorType = t.mutableDescriptorType or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageViewMinLodCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageViewMinLodCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.minLod = t.minLod or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.FrameBoundaryEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkFrameBoundaryEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.frameID = t.frameID or 0
		_pool.imageCount = t.imageCount or 0
		_pool.pImages = t.pImages or 0
		_pool.bufferCount = t.bufferCount or 0
		_pool.pBuffers = t.pBuffers or 0
		_pool.tagName = t.tagName or 0
		_pool.tagSize = t.tagSize or 0
		_pool.pTag = t.pTag or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DispatchTileInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDispatchTileInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExternalTensorInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExternalTensorInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.pDescription = t.pDescription or 0
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureGeometryTrianglesDataKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureGeometryTrianglesDataKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.vertexFormat = t.vertexFormat ~= nil and mod.e.VkFormat(t.vertexFormat) or 0

		if t.vertexData ~= nil then
			if type(t.vertexData) == "table" then
				_pool.vertexData = mod.VkDeviceOrHostAddressConstKHR(t.vertexData)
			else
				_pool.vertexData = t.vertexData
			end
		else
			_pool.vertexData = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.vertexStride = t.vertexStride or 0
		_pool.maxVertex = t.maxVertex or 0
		_pool.indexType = t.indexType ~= nil and mod.e.VkIndexType(t.indexType) or 0

		if t.indexData ~= nil then
			if type(t.indexData) == "table" then
				_pool.indexData = mod.VkDeviceOrHostAddressConstKHR(t.indexData)
			else
				_pool.indexData = t.indexData
			end
		else
			_pool.indexData = mod.VkDeviceOrHostAddressConstKHR()
		end

		if t.transformData ~= nil then
			if type(t.transformData) == "table" then
				_pool.transformData = mod.VkDeviceOrHostAddressConstKHR(t.transformData)
			else
				_pool.transformData = t.transformData
			end
		else
			_pool.transformData = mod.VkDeviceOrHostAddressConstKHR()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceDeviceMemoryReportCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceDeviceMemoryReportCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.pfnUserCallback = t.pfnUserCallback or 0
		_pool.pUserData = t.pUserData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MutableDescriptorTypeCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMutableDescriptorTypeCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.mutableDescriptorTypeListCount = t.mutableDescriptorTypeListCount or 0
		_pool.pMutableDescriptorTypeLists = t.pMutableDescriptorTypeLists or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureGeometryInstancesDataKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureGeometryInstancesDataKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.arrayOfPointers = t.arrayOfPointers or 0

		if t.data ~= nil then
			if type(t.data) == "table" then
				_pool.data = mod.VkDeviceOrHostAddressConstKHR(t.data)
			else
				_pool.data = t.data
			end
		else
			_pool.data = mod.VkDeviceOrHostAddressConstKHR()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTexelBufferAlignmentFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.texelBufferAlignment = t.texelBufferAlignment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.FrameBoundaryTensorsARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkFrameBoundaryTensorsARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tensorCount = t.tensorCount or 0
		_pool.pTensors = t.pTensors or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceLayeredApiVulkanPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil

		if t.properties ~= nil then
			if type(t.properties) == "table" then
				_pool.properties = mod.s.PhysicalDeviceProperties2(t.properties)
			else
				_pool.properties = t.properties
			end
		else
			_pool.properties = mod.VkPhysicalDeviceProperties2()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureGeometryKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureGeometryKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.geometryType = t.geometryType ~= nil and mod.e.VkGeometryTypeKHR(t.geometryType) or 0

		if t.geometry ~= nil then
			if type(t.geometry) == "table" then
				_pool.geometry = mod.VkAccelerationStructureGeometryDataKHR(t.geometry)
			else
				_pool.geometry = t.geometry
			end
		else
			_pool.geometry = mod.VkAccelerationStructureGeometryDataKHR()
		end

		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureBuildGeometryInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureBuildGeometryInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type ~= nil and mod.e.VkAccelerationStructureTypeKHR(t.type) or 0
		_pool.flags = t.flags or 0
		_pool.mode = t.mode ~= nil and mod.e.VkBuildAccelerationStructureModeKHR(t.mode) or 0
		_pool.srcAccelerationStructure = t.srcAccelerationStructure or 0
		_pool.dstAccelerationStructure = t.dstAccelerationStructure or 0
		_pool.geometryCount = t.geometryCount or 0
		_pool.pGeometries = t.pGeometries or 0
		_pool.ppGeometries = t.ppGeometries or 0

		if t.scratchData ~= nil then
			if type(t.scratchData) == "table" then
				_pool.scratchData = mod.VkDeviceOrHostAddressKHR(t.scratchData)
			else
				_pool.scratchData = t.scratchData
			end
		else
			_pool.scratchData = mod.VkDeviceOrHostAddressKHR()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVertexInputDynamicStateFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.vertexInputDynamicState = t.vertexInputDynamicState or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineCreationFeedback(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineCreationFeedbackCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.pPipelineCreationFeedback = t.pPipelineCreationFeedback or 0
		_pool.pipelineStageCreationFeedbackCount = t.pipelineStageCreationFeedbackCount or 0
		_pool.pPipelineStageCreationFeedbacks = t.pPipelineStageCreationFeedbacks or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.createFlags = t.createFlags or 0
		_pool.buffer = t.buffer or 0
		_pool.offset = t.offset or 0
		_pool.size = t.size or 0
		_pool.type = t.type ~= nil and mod.e.VkAccelerationStructureTypeKHR(t.type) or 0
		_pool.deviceAddress = t.deviceAddress or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.WriteDescriptorSetAccelerationStructureKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkWriteDescriptorSetAccelerationStructureKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.accelerationStructureCount = t.accelerationStructureCount or 0
		_pool.pAccelerationStructures = t.pAccelerationStructures or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceAccelerationStructureFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceAccelerationStructureFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.accelerationStructure = t.accelerationStructure or 0
		_pool.accelerationStructureCaptureReplay = t.accelerationStructureCaptureReplay or 0
		_pool.accelerationStructureIndirectBuild = t.accelerationStructureIndirectBuild or 0
		_pool.accelerationStructureHostCommands = t.accelerationStructureHostCommands or 0
		_pool.descriptorBindingAccelerationStructureUpdateAfterBind = t.descriptorBindingAccelerationStructureUpdateAfterBind or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderTerminateInvocationFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderTerminateInvocationFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderTerminateInvocation = t.shaderTerminateInvocation or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentShadingRateKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentShadingRateKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.sampleCounts = t.sampleCounts ~= nil and mod.e.VkSampleCountFlagBits(t.sampleCounts) or 0

		if t.fragmentSize ~= nil then
			if type(t.fragmentSize) == "table" then
				_pool.fragmentSize = mod.VkExtent2D(t.fragmentSize)
			else
				_pool.fragmentSize = t.fragmentSize
			end
		else
			_pool.fragmentSize = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineViewportState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineViewportStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.viewportCount = t.viewportCount or 0
		_pool.pViewports = t.pViewports or 0
		_pool.scissorCount = t.scissorCount or 0
		_pool.pScissors = t.pScissors or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelinePropertiesIdentifierEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelinePropertiesIdentifierEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineIdentifier = t.pipelineIdentifier or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDrmPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDrmPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.hasPrimary = t.hasPrimary or 0
		_pool.hasRender = t.hasRender or 0
		_pool.primaryMajor = t.primaryMajor or 0
		_pool.primaryMinor = t.primaryMinor or 0
		_pool.renderMajor = t.renderMajor or 0
		_pool.renderMinor = t.renderMinor or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CommandBufferSubmit(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCommandBufferSubmitInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.commandBuffer = t.commandBuffer or 0
		_pool.deviceMask = t.deviceMask or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Instance(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkInstanceCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkInstanceCreateFlagBits(t.flags) or 0
		_pool.pApplicationInfo = t.pApplicationInfo or 0
		_pool.enabledLayerCount = t.enabledLayerCount or 0
		_pool.ppEnabledLayerNames = t.ppEnabledLayerNames or 0
		_pool.enabledExtensionCount = t.enabledExtensionCount or 0
		_pool.ppEnabledExtensionNames = t.ppEnabledExtensionNames or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineColorBlendAdvancedStateCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineColorBlendAdvancedStateCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.srcPremultiplied = t.srcPremultiplied or 0
		_pool.dstPremultiplied = t.dstPremultiplied or 0
		_pool.blendOverlap = t.blendOverlap ~= nil and mod.e.VkBlendOverlapEXT(t.blendOverlap) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderTileImageFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderTileImageFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderTileImageColorReadAccess = t.shaderTileImageColorReadAccess or 0
		_pool.shaderTileImageDepthReadAccess = t.shaderTileImageDepthReadAccess or 0
		_pool.shaderTileImageStencilReadAccess = t.shaderTileImageStencilReadAccess or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineDepthStencilState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineDepthStencilStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkPipelineDepthStencilStateCreateFlagBits(t.flags) or 0
		_pool.depthTestEnable = t.depthTestEnable or 0
		_pool.depthWriteEnable = t.depthWriteEnable or 0
		_pool.depthCompareOp = t.depthCompareOp ~= nil and mod.e.VkCompareOp(t.depthCompareOp) or 0
		_pool.depthBoundsTestEnable = t.depthBoundsTestEnable or 0
		_pool.stencilTestEnable = t.stencilTestEnable or 0

		if t.front ~= nil then
			if type(t.front) == "table" then
				_pool.front = mod.s.StencilOpState(t.front)
			else
				_pool.front = t.front
			end
		else
			_pool.front = mod.VkStencilOpState()
		end

		if t.back ~= nil then
			if type(t.back) == "table" then
				_pool.back = mod.s.StencilOpState(t.back)
			else
				_pool.back = t.back
			end
		else
			_pool.back = mod.VkStencilOpState()
		end

		_pool.minDepthBounds = t.minDepthBounds or 0
		_pool.maxDepthBounds = t.maxDepthBounds or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureDeviceAddressInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureDeviceAddressInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.accelerationStructure = t.accelerationStructure or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureVersionInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureVersionInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pVersionData = t.pVersionData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyAccelerationStructureToMemoryInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyAccelerationStructureToMemoryInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.src = t.src or 0

		if t.dst ~= nil then
			if type(t.dst) == "table" then
				_pool.dst = mod.VkDeviceOrHostAddressKHR(t.dst)
			else
				_pool.dst = t.dst
			end
		else
			_pool.dst = mod.VkDeviceOrHostAddressKHR()
		end

		_pool.mode = t.mode ~= nil and mod.e.VkCopyAccelerationStructureModeKHR(t.mode) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyMemoryToAccelerationStructureInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyMemoryToAccelerationStructureInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil

		if t.src ~= nil then
			if type(t.src) == "table" then
				_pool.src = mod.VkDeviceOrHostAddressConstKHR(t.src)
			else
				_pool.src = t.src
			end
		else
			_pool.src = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.dst = t.dst or 0
		_pool.mode = t.mode ~= nil and mod.e.VkCopyAccelerationStructureModeKHR(t.mode) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyAccelerationStructureInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyAccelerationStructureInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.src = t.src or 0
		_pool.dst = t.dst or 0
		_pool.mode = t.mode ~= nil and mod.e.VkCopyAccelerationStructureModeKHR(t.mode) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCopyMemoryIndirectFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.indirectMemoryCopy = t.indirectMemoryCopy or 0
		_pool.indirectMemoryToImageCopy = t.indirectMemoryToImageCopy or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.FramebufferAttachmentImage(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkFramebufferAttachmentImageInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkImageCreateFlagBits(t.flags) or 0
		_pool.usage = t.usage ~= nil and mod.e.VkImageUsageFlagBits(t.usage) or 0
		_pool.width = t.width or 0
		_pool.height = t.height or 0
		_pool.layerCount = t.layerCount or 0
		_pool.viewFormatCount = t.viewFormatCount or 0
		_pool.pViewFormats = t.pViewFormats or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DisplayPresentInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDisplayPresentInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil

		if t.srcRect ~= nil then
			if type(t.srcRect) == "table" then
				_pool.srcRect = mod.VkRect2D(t.srcRect)
			else
				_pool.srcRect = t.srcRect
			end
		else
			_pool.srcRect = mod.VkRect2D()
		end

		if t.dstRect ~= nil then
			if type(t.dstRect) == "table" then
				_pool.dstRect = mod.VkRect2D(t.dstRect)
			else
				_pool.dstRect = t.dstRect
			end
		else
			_pool.dstRect = mod.VkRect2D()
		end

		_pool.persistent = t.persistent or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryToImageCopy(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryToImageCopy)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY")
		end

		_pool.pNext = t.pNext or nil
		_pool.pHostPointer = t.pHostPointer or 0
		_pool.memoryRowLength = t.memoryRowLength or 0
		_pool.memoryImageHeight = t.memoryImageHeight or 0

		if t.imageSubresource ~= nil then
			if type(t.imageSubresource) == "table" then
				_pool.imageSubresource = mod.s.ImageSubresourceLayers(t.imageSubresource)
			else
				_pool.imageSubresource = t.imageSubresource
			end
		else
			_pool.imageSubresource = mod.VkImageSubresourceLayers()
		end

		if t.imageOffset ~= nil then
			if type(t.imageOffset) == "table" then
				_pool.imageOffset = mod.VkOffset3D(t.imageOffset)
			else
				_pool.imageOffset = t.imageOffset
			end
		else
			_pool.imageOffset = mod.VkOffset3D()
		end

		if t.imageExtent ~= nil then
			if type(t.imageExtent) == "table" then
				_pool.imageExtent = mod.VkExtent3D(t.imageExtent)
			else
				_pool.imageExtent = t.imageExtent
			end
		else
			_pool.imageExtent = mod.VkExtent3D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineCoverageToColorStateCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineCoverageToColorStateCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.coverageToColorEnable = t.coverageToColorEnable or 0
		_pool.coverageToColorLocation = t.coverageToColorLocation or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DebugReportCallbackCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDebugReportCallbackCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.pfnCallback = t.pfnCallback or 0
		_pool.pUserData = t.pUserData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MultisamplePropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMultisamplePropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil

		if t.maxSampleLocationGridSize ~= nil then
			if type(t.maxSampleLocationGridSize) == "table" then
				_pool.maxSampleLocationGridSize = mod.VkExtent2D(t.maxSampleLocationGridSize)
			else
				_pool.maxSampleLocationGridSize = t.maxSampleLocationGridSize
			end
		else
			_pool.maxSampleLocationGridSize = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceAddressBindingReportFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceAddressBindingReportFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.reportAddressBinding = t.reportAddressBinding or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShadingRateImageFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShadingRateImageFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.shadingRateImage = t.shadingRateImage or 0
		_pool.shadingRateCoarseSampleOrder = t.shadingRateCoarseSampleOrder or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceAddressBindingCallbackDataEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceAddressBindingCallbackDataEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.baseAddress = t.baseAddress or 0
		_pool.size = t.size or 0
		_pool.bindingType = t.bindingType ~= nil and mod.e.VkDeviceAddressBindingTypeEXT(t.bindingType) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderModuleIdentifierFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderModuleIdentifier = t.shaderModuleIdentifier or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShadingRateImagePropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShadingRateImagePropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil

		if t.shadingRateTexelSize ~= nil then
			if type(t.shadingRateTexelSize) == "table" then
				_pool.shadingRateTexelSize = mod.VkExtent2D(t.shadingRateTexelSize)
			else
				_pool.shadingRateTexelSize = t.shadingRateTexelSize
			end
		else
			_pool.shadingRateTexelSize = mod.VkExtent2D()
		end

		_pool.shadingRatePaletteSize = t.shadingRatePaletteSize or 0
		_pool.shadingRateMaxCoarseSamples = t.shadingRateMaxCoarseSamples or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderModuleIdentifierPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderModuleIdentifierAlgorithmUUID = t.shaderModuleIdentifierAlgorithmUUID or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSubpassShadingPropertiesHUAWEI(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxSubpassShadingWorkgroupSizeAspectRatio = t.maxSubpassShadingWorkgroupSizeAspectRatio or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineShaderStageModuleIdentifierCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineShaderStageModuleIdentifierCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.identifierSize = t.identifierSize or 0
		_pool.pIdentifier = t.pIdentifier or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDepthClipControlFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDepthClipControlFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.depthClipControl = t.depthClipControl or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ViSurfaceCreateInfoNN(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkViSurfaceCreateInfoNN)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.window = t.window or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineViewportDepthClipControlCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineViewportDepthClipControlCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.negativeOneToOne = t.negativeOneToOne or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassCreationFeedbackCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassCreationFeedbackCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.pRenderPassFeedback = t.pRenderPassFeedback or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSubpassShadingFeaturesHUAWEI(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI")
		end

		_pool.pNext = t.pNext or nil
		_pool.subpassShading = t.subpassShading or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SubpassShadingPipelineCreateInfoHUAWEI(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSubpassShadingPipelineCreateInfoHUAWEI)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI")
		end

		_pool.pNext = t.pNext or nil
		_pool.renderPass = t.renderPass or 0
		_pool.subpass = t.subpass or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePipelineRobustnessProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePipelineRobustnessProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.defaultRobustnessStorageBuffers = t.defaultRobustnessStorageBuffers ~= nil and
			mod.e.VkPipelineRobustnessBufferBehavior(t.defaultRobustnessStorageBuffers) or
			0
		_pool.defaultRobustnessUniformBuffers = t.defaultRobustnessUniformBuffers ~= nil and
			mod.e.VkPipelineRobustnessBufferBehavior(t.defaultRobustnessUniformBuffers) or
			0
		_pool.defaultRobustnessVertexInputs = t.defaultRobustnessVertexInputs ~= nil and
			mod.e.VkPipelineRobustnessBufferBehavior(t.defaultRobustnessVertexInputs) or
			0
		_pool.defaultRobustnessImages = t.defaultRobustnessImages ~= nil and
			mod.e.VkPipelineRobustnessImageBehavior(t.defaultRobustnessImages) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.primitiveTopologyListRestart = t.primitiveTopologyListRestart or 0
		_pool.primitiveTopologyPatchListRestart = t.primitiveTopologyPatchListRestart or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineViewportCoarseSampleOrderStateCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.sampleOrderType = t.sampleOrderType ~= nil and
			mod.e.VkCoarseSampleOrderTypeNV(t.sampleOrderType) or
			0
		_pool.customSampleOrderCount = t.customSampleOrderCount or 0
		_pool.pCustomSampleOrders = t.pCustomSampleOrders or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.FramebufferAttachments(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkFramebufferAttachmentsCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.attachmentImageInfoCount = t.attachmentImageInfoCount or 0
		_pool.pAttachmentImageInfos = t.pAttachmentImageInfos or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceGroupCommandBufferBegin(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceGroupCommandBufferBeginInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceMask = t.deviceMask or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderReplicatedCompositesFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderReplicatedComposites = t.shaderReplicatedComposites or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoReferenceIntraRefreshInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoReferenceIntraRefreshInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.dirtyIntraRefreshRegions = t.dirtyIntraRefreshRegions or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RayTracingShaderGroupCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRayTracingShaderGroupCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type ~= nil and mod.e.VkRayTracingShaderGroupTypeKHR(t.type) or 0
		_pool.generalShader = t.generalShader or 0
		_pool.closestHitShader = t.closestHitShader or 0
		_pool.anyHitShader = t.anyHitShader or 0
		_pool.intersectionShader = t.intersectionShader or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassTransformBeginInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassTransformBeginInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.transform = t.transform ~= nil and mod.e.VkSurfaceTransformFlagBitsKHR(t.transform) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindDescriptorBufferEmbeddedSamplersInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindDescriptorBufferEmbeddedSamplersInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.stageFlags = t.stageFlags ~= nil and mod.e.VkShaderStageFlagBits(t.stageFlags) or 0
		_pool.layout = t.layout or 0
		_pool.set = t.set or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineCacheIncrementalMode = t.pipelineCacheIncrementalMode or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassBegin(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassBeginInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.renderPass = t.renderPass or 0
		_pool.framebuffer = t.framebuffer or 0

		if t.renderArea ~= nil then
			if type(t.renderArea) == "table" then
				_pool.renderArea = mod.VkRect2D(t.renderArea)
			else
				_pool.renderArea = t.renderArea
			end
		else
			_pool.renderArea = mod.VkRect2D()
		end

		_pool.clearValueCount = t.clearValueCount or 0
		_pool.pClearValues = t.pClearValues or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RayTracingPipelineCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRayTracingPipelineCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkPipelineCreateFlagBits(t.flags) or 0
		_pool.stageCount = t.stageCount or 0
		_pool.pStages = t.pStages or 0
		_pool.groupCount = t.groupCount or 0
		_pool.pGroups = t.pGroups or 0
		_pool.maxRecursionDepth = t.maxRecursionDepth or 0
		_pool.layout = t.layout or 0
		_pool.basePipelineHandle = t.basePipelineHandle or 0
		_pool.basePipelineIndex = t.basePipelineIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineRasterizationStateRasterizationOrderAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineRasterizationStateRasterizationOrderAMD)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD")
		end

		_pool.pNext = t.pNext or nil
		_pool.rasterizationOrder = t.rasterizationOrder ~= nil and
			mod.e.VkRasterizationOrderAMD(t.rasterizationOrder) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.zeroInitializeDeviceMemory = t.zeroInitializeDeviceMemory or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineResourceInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineResourceInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.descriptorSet = t.descriptorSet or 0
		_pool.binding = t.binding or 0
		_pool.arrayElement = t.arrayElement or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GeometryTrianglesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGeometryTrianglesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.vertexData = t.vertexData or 0
		_pool.vertexOffset = t.vertexOffset or 0
		_pool.vertexCount = t.vertexCount or 0
		_pool.vertexStride = t.vertexStride or 0
		_pool.vertexFormat = t.vertexFormat ~= nil and mod.e.VkFormat(t.vertexFormat) or 0
		_pool.indexData = t.indexData or 0
		_pool.indexOffset = t.indexOffset or 0
		_pool.indexCount = t.indexCount or 0
		_pool.indexType = t.indexType ~= nil and mod.e.VkIndexType(t.indexType) or 0
		_pool.transformData = t.transformData or 0
		_pool.transformOffset = t.transformOffset or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceHdrVividFeaturesHUAWEI(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceHdrVividFeaturesHUAWEI)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI")
		end

		_pool.pNext = t.pNext or nil
		_pool.hdrVivid = t.hdrVivid or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SetDescriptorBufferOffsetsInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSetDescriptorBufferOffsetsInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.stageFlags = t.stageFlags ~= nil and mod.e.VkShaderStageFlagBits(t.stageFlags) or 0
		_pool.layout = t.layout or 0
		_pool.firstSet = t.firstSet or 0
		_pool.setCount = t.setCount or 0
		_pool.pBufferIndices = t.pBufferIndices or 0
		_pool.pOffsets = t.pOffsets or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.WriteIndirectExecutionSetShaderEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkWriteIndirectExecutionSetShaderEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.index = t.index or 0
		_pool.shader = t.shader or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceHostImageCopyProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceHostImageCopyProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.copySrcLayoutCount = t.copySrcLayoutCount or 0
		_pool.pCopySrcLayouts = t.pCopySrcLayouts or 0
		_pool.copyDstLayoutCount = t.copyDstLayoutCount or 0
		_pool.pCopyDstLayouts = t.pCopyDstLayouts or 0
		_pool.optimalTilingLayoutUUID = t.optimalTilingLayoutUUID or 0
		_pool.identicalMemoryTypeRequirements = t.identicalMemoryTypeRequirements or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CommandBufferBegin(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCommandBufferBeginInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkCommandBufferUsageFlagBits(t.flags) or 0
		_pool.pInheritanceInfo = t.pInheritanceInfo or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoDecodeCapabilitiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoDecodeCapabilitiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceInlineUniformBlockFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceInlineUniformBlockFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.inlineUniformBlock = t.inlineUniformBlock or 0
		_pool.descriptorBindingInlineUniformBlockUpdateAfterBind = t.descriptorBindingInlineUniformBlockUpdateAfterBind or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Buffer(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBufferCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkBufferCreateFlagBits(t.flags) or 0
		_pool.size = t.size or 0
		_pool.usage = t.usage ~= nil and mod.e.VkBufferUsageFlagBits(t.usage) or 0
		_pool.sharingMode = t.sharingMode ~= nil and mod.e.VkSharingMode(t.sharingMode) or 0
		_pool.queueFamilyIndexCount = t.queueFamilyIndexCount or 0
		_pool.pQueueFamilyIndices = t.pQueueFamilyIndices or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RayTracingShaderGroupCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRayTracingShaderGroupCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type ~= nil and mod.e.VkRayTracingShaderGroupTypeKHR(t.type) or 0
		_pool.generalShader = t.generalShader or 0
		_pool.closestHitShader = t.closestHitShader or 0
		_pool.anyHitShader = t.anyHitShader or 0
		_pool.intersectionShader = t.intersectionShader or 0
		_pool.pShaderGroupCaptureReplayHandle = t.pShaderGroupCaptureReplayHandle or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DebugMarkerObjectNameInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDebugMarkerObjectNameInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.objectType = t.objectType ~= nil and mod.e.VkDebugReportObjectTypeEXT(t.objectType) or 0
		_pool.object = t.object or 0
		_pool.pObjectName = t.pObjectName or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RayTracingPipelineInterfaceCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRayTracingPipelineInterfaceCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxPipelineRayPayloadSize = t.maxPipelineRayPayloadSize or 0
		_pool.maxPipelineRayHitAttributeSize = t.maxPipelineRayHitAttributeSize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DebugMarkerObjectTagInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDebugMarkerObjectTagInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.objectType = t.objectType ~= nil and mod.e.VkDebugReportObjectTypeEXT(t.objectType) or 0
		_pool.object = t.object or 0
		_pool.tagName = t.tagName or 0
		_pool.tagSize = t.tagSize or 0
		_pool.pTag = t.pTag or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GeometryNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGeometryNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GEOMETRY_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.geometryType = t.geometryType ~= nil and mod.e.VkGeometryTypeKHR(t.geometryType) or 0

		if t.geometry ~= nil then
			if type(t.geometry) == "table" then
				_pool.geometry = mod.VkGeometryDataNV(t.geometry)
			else
				_pool.geometry = t.geometry
			end
		else
			_pool.geometry = mod.VkGeometryDataNV()
		end

		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RayTracingPipelineCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRayTracingPipelineCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkPipelineCreateFlagBits(t.flags) or 0
		_pool.stageCount = t.stageCount or 0
		_pool.pStages = t.pStages or 0
		_pool.groupCount = t.groupCount or 0
		_pool.pGroups = t.pGroups or 0
		_pool.maxPipelineRayRecursionDepth = t.maxPipelineRayRecursionDepth or 0
		_pool.pLibraryInfo = t.pLibraryInfo or 0
		_pool.pLibraryInterface = t.pLibraryInterface or 0
		_pool.pDynamicState = t.pDynamicState or 0
		_pool.layout = t.layout or 0
		_pool.basePipelineHandle = t.basePipelineHandle or 0
		_pool.basePipelineIndex = t.basePipelineIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderSubgroupRotateFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderSubgroupRotateFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderSubgroupRotate = t.shaderSubgroupRotate or 0
		_pool.shaderSubgroupRotateClustered = t.shaderSubgroupRotateClustered or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type or 0
		_pool.flags = t.flags or 0
		_pool.instanceCount = t.instanceCount or 0
		_pool.geometryCount = t.geometryCount or 0
		_pool.pGeometries = t.pGeometries or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CommandBufferAllocate(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCommandBufferAllocateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.commandPool = t.commandPool or 0
		_pool.level = t.level ~= nil and mod.e.VkCommandBufferLevel(t.level) or 0
		_pool.commandBufferCount = t.commandBufferCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCommandBufferInheritanceFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.commandBufferInheritance = t.commandBufferInheritance or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.compactedSize = t.compactedSize or 0

		if t.info ~= nil then
			if type(t.info) == "table" then
				_pool.info = mod.s.AccelerationStructureInfoNV(t.info)
			else
				_pool.info = t.info
			end
		else
			_pool.info = mod.VkAccelerationStructureInfoNV()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.Image(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkImageCreateFlagBits(t.flags) or 0
		_pool.imageType = t.imageType ~= nil and mod.e.VkImageType(t.imageType) or 0
		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0

		if t.extent ~= nil then
			if type(t.extent) == "table" then
				_pool.extent = mod.VkExtent3D(t.extent)
			else
				_pool.extent = t.extent
			end
		else
			_pool.extent = mod.VkExtent3D()
		end

		_pool.mipLevels = t.mipLevels or 0
		_pool.arrayLayers = t.arrayLayers or 0
		_pool.samples = t.samples ~= nil and mod.e.VkSampleCountFlagBits(t.samples) or 0
		_pool.tiling = t.tiling ~= nil and mod.e.VkImageTiling(t.tiling) or 0
		_pool.usage = t.usage ~= nil and mod.e.VkImageUsageFlagBits(t.usage) or 0
		_pool.sharingMode = t.sharingMode ~= nil and mod.e.VkSharingMode(t.sharingMode) or 0
		_pool.queueFamilyIndexCount = t.queueFamilyIndexCount or 0
		_pool.pQueueFamilyIndices = t.pQueueFamilyIndices or 0
		_pool.initialLayout = t.initialLayout ~= nil and mod.e.VkImageLayout(t.initialLayout) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindAccelerationStructureMemoryInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindAccelerationStructureMemoryInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.accelerationStructure = t.accelerationStructure or 0
		_pool.memory = t.memory or 0
		_pool.memoryOffset = t.memoryOffset or 0
		_pool.deviceIndexCount = t.deviceIndexCount or 0
		_pool.pDeviceIndices = t.pDeviceIndices or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SwapchainPresentModesCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSwapchainPresentModesCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentModeCount = t.presentModeCount or 0
		_pool.pPresentModes = t.pPresentModes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.WriteDescriptorSetAccelerationStructureNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkWriteDescriptorSetAccelerationStructureNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.accelerationStructureCount = t.accelerationStructureCount or 0
		_pool.pAccelerationStructures = t.pAccelerationStructures or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPass(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkRenderPassCreateFlagBits(t.flags) or 0
		_pool.attachmentCount = t.attachmentCount or 0
		_pool.pAttachments = t.pAttachments or 0
		_pool.subpassCount = t.subpassCount or 0
		_pool.pSubpasses = t.pSubpasses or 0
		_pool.dependencyCount = t.dependencyCount or 0
		_pool.pDependencies = t.pDependencies or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRayTracingPipelinePropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRayTracingPipelinePropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderGroupHandleSize = t.shaderGroupHandleSize or 0
		_pool.maxRayRecursionDepth = t.maxRayRecursionDepth or 0
		_pool.maxShaderGroupStride = t.maxShaderGroupStride or 0
		_pool.shaderGroupBaseAlignment = t.shaderGroupBaseAlignment or 0
		_pool.shaderGroupHandleCaptureReplaySize = t.shaderGroupHandleCaptureReplaySize or 0
		_pool.maxRayDispatchInvocationCount = t.maxRayDispatchInvocationCount or 0
		_pool.shaderGroupHandleAlignment = t.shaderGroupHandleAlignment or 0
		_pool.maxRayHitAttributeSize = t.maxRayHitAttributeSize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureMemoryRequirementsInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureMemoryRequirementsInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type ~= nil and
			mod.e.VkAccelerationStructureMemoryRequirementsTypeNV(t.type) or
			0
		_pool.accelerationStructure = t.accelerationStructure or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRayTracingPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRayTracingPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderGroupHandleSize = t.shaderGroupHandleSize or 0
		_pool.maxRecursionDepth = t.maxRecursionDepth or 0
		_pool.maxShaderGroupStride = t.maxShaderGroupStride or 0
		_pool.shaderGroupBaseAlignment = t.shaderGroupBaseAlignment or 0
		_pool.maxGeometryCount = t.maxGeometryCount or 0
		_pool.maxInstanceCount = t.maxInstanceCount or 0
		_pool.maxTriangleCount = t.maxTriangleCount or 0
		_pool.maxDescriptorSetAccelerationStructures = t.maxDescriptorSetAccelerationStructures or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorSetLayoutBindingFlags(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorSetLayoutBindingFlagsCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.bindingCount = t.bindingCount or 0
		_pool.pBindingFlags = t.pBindingFlags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SwapchainPresentModeInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSwapchainPresentModeInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.swapchainCount = t.swapchainCount or 0
		_pool.pPresentModes = t.pPresentModes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SurfacePresentModeCompatibilityKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSurfacePresentModeCompatibilityKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentModeCount = t.presentModeCount or 0
		_pool.pPresentModes = t.pPresentModes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SurfacePresentScalingCapabilitiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSurfacePresentScalingCapabilitiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.supportedPresentScaling = t.supportedPresentScaling or 0
		_pool.supportedPresentGravityX = t.supportedPresentGravityX or 0
		_pool.supportedPresentGravityY = t.supportedPresentGravityY or 0

		if t.minScaledImageExtent ~= nil then
			if type(t.minScaledImageExtent) == "table" then
				_pool.minScaledImageExtent = mod.VkExtent2D(t.minScaledImageExtent)
			else
				_pool.minScaledImageExtent = t.minScaledImageExtent
			end
		else
			_pool.minScaledImageExtent = mod.VkExtent2D()
		end

		if t.maxScaledImageExtent ~= nil then
			if type(t.maxScaledImageExtent) == "table" then
				_pool.maxScaledImageExtent = mod.VkExtent2D(t.maxScaledImageExtent)
			else
				_pool.maxScaledImageExtent = t.maxScaledImageExtent
			end
		else
			_pool.maxScaledImageExtent = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceImagelessFramebufferFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceImagelessFramebufferFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.imagelessFramebuffer = t.imagelessFramebuffer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRayTracingPositionFetchFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.rayTracingPositionFetch = t.rayTracingPositionFetch or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceLineRasterizationFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceLineRasterizationFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.rectangularLines = t.rectangularLines or 0
		_pool.bresenhamLines = t.bresenhamLines or 0
		_pool.smoothLines = t.smoothLines or 0
		_pool.stippledRectangularLines = t.stippledRectangularLines or 0
		_pool.stippledBresenhamLines = t.stippledBresenhamLines or 0
		_pool.stippledSmoothLines = t.stippledSmoothLines or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ComputePipeline(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkComputePipelineCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkPipelineCreateFlagBits(t.flags) or 0

		if t.stage ~= nil then
			if type(t.stage) == "table" then
				_pool.stage = mod.s.PipelineShaderStageCreateInfo(t.stage)
			else
				_pool.stage = t.stage
			end
		else
			_pool.stage = mod.VkPipelineShaderStageCreateInfo()
		end

		_pool.layout = t.layout or 0
		_pool.basePipelineHandle = t.basePipelineHandle or 0
		_pool.basePipelineIndex = t.basePipelineIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExternalSemaphore(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExternalSemaphoreInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.handleType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ScreenSurfaceCreateInfoQNX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkScreenSurfaceCreateInfoQNX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.context = t.context or 0
		_pool.window = t.window or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DedicatedAllocationImageCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDedicatedAllocationImageCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.dedicatedAllocation = t.dedicatedAllocation or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.StreamDescriptorSurfaceCreateInfoGGP(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkStreamDescriptorSurfaceCreateInfoGGP)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.streamDescriptor = t.streamDescriptor or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DedicatedAllocationBufferCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDedicatedAllocationBufferCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.dedicatedAllocation = t.dedicatedAllocation or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DedicatedAllocationMemoryAllocateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDedicatedAllocationMemoryAllocateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.image = t.image or 0
		_pool.buffer = t.buffer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceGroupSubmit(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceGroupSubmitInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.waitSemaphoreCount = t.waitSemaphoreCount or 0
		_pool.pWaitSemaphoreDeviceIndices = t.pWaitSemaphoreDeviceIndices or 0
		_pool.commandBufferCount = t.commandBufferCount or 0
		_pool.pCommandBufferDeviceMasks = t.pCommandBufferDeviceMasks or 0
		_pool.signalSemaphoreCount = t.signalSemaphoreCount or 0
		_pool.pSignalSemaphoreDeviceIndices = t.pSignalSemaphoreDeviceIndices or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyImageToImage(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyImageToImageInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkHostImageCopyFlagBits(t.flags) or 0
		_pool.srcImage = t.srcImage or 0
		_pool.srcImageLayout = t.srcImageLayout ~= nil and mod.e.VkImageLayout(t.srcImageLayout) or 0
		_pool.dstImage = t.dstImage or 0
		_pool.dstImageLayout = t.dstImageLayout ~= nil and mod.e.VkImageLayout(t.dstImageLayout) or 0
		_pool.regionCount = t.regionCount or 0
		_pool.pRegions = t.pRegions or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalMemoryImageCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalMemoryImageCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleTypes = t.handleTypes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExportMemoryAllocateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExportMemoryAllocateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleTypes = t.handleTypes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PresentFrameTokenGGP(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPresentFrameTokenGGP)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP")
		end

		_pool.pNext = t.pNext or nil
		_pool.frameToken = t.frameToken or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyMemoryToImage(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyMemoryToImageInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkHostImageCopyFlagBits(t.flags) or 0
		_pool.dstImage = t.dstImage or 0
		_pool.dstImageLayout = t.dstImageLayout ~= nil and mod.e.VkImageLayout(t.dstImageLayout) or 0
		_pool.regionCount = t.regionCount or 0
		_pool.pRegions = t.pRegions or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AntiLagPresentationInfoAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAntiLagPresentationInfoAMD)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD")
		end

		_pool.pNext = t.pNext or nil
		_pool.stage = t.stage ~= nil and mod.e.VkAntiLagStageAMD(t.stage) or 0
		_pool.frameIndex = t.frameIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTransformFeedbackPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTransformFeedbackPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxTransformFeedbackStreams = t.maxTransformFeedbackStreams or 0
		_pool.maxTransformFeedbackBuffers = t.maxTransformFeedbackBuffers or 0
		_pool.maxTransformFeedbackBufferSize = t.maxTransformFeedbackBufferSize or 0
		_pool.maxTransformFeedbackStreamDataSize = t.maxTransformFeedbackStreamDataSize or 0
		_pool.maxTransformFeedbackBufferDataSize = t.maxTransformFeedbackBufferDataSize or 0
		_pool.maxTransformFeedbackBufferDataStride = t.maxTransformFeedbackBufferDataStride or 0
		_pool.transformFeedbackQueries = t.transformFeedbackQueries or 0
		_pool.transformFeedbackStreamsLinesTriangles = t.transformFeedbackStreamsLinesTriangles or 0
		_pool.transformFeedbackRasterizationStreamSelect = t.transformFeedbackRasterizationStreamSelect or 0
		_pool.transformFeedbackDraw = t.transformFeedbackDraw or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCornerSampledImageFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCornerSampledImageFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.cornerSampledImage = t.cornerSampledImage or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineExecutableInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineExecutableInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipeline = t.pipeline or 0
		_pool.executableIndex = t.executableIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineExecutablePropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineExecutablePropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.stages = t.stages ~= nil and mod.e.VkShaderStageFlagBits(t.stages) or 0
		_pool.name = t.name or 0
		_pool.description = t.description or 0
		_pool.subgroupSize = t.subgroupSize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ValidationFlagsEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkValidationFlagsEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.disabledValidationCheckCount = t.disabledValidationCheckCount or 0
		_pool.pDisabledValidationChecks = t.pDisabledValidationChecks or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRayQueryFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRayQueryFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.rayQuery = t.rayQuery or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipeline = t.pipeline or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SurfaceProtectedCapabilitiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSurfaceProtectedCapabilitiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.supportsProtected = t.supportsProtected or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRayTracingPipelineFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRayTracingPipelineFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.rayTracingPipeline = t.rayTracingPipeline or 0
		_pool.rayTracingPipelineShaderGroupHandleCaptureReplay = t.rayTracingPipelineShaderGroupHandleCaptureReplay or 0
		_pool.rayTracingPipelineShaderGroupHandleCaptureReplayMixed = t.rayTracingPipelineShaderGroupHandleCaptureReplayMixed or 0
		_pool.rayTracingPipelineTraceRaysIndirect = t.rayTracingPipelineTraceRaysIndirect or 0
		_pool.rayTraversalPrimitiveCulling = t.rayTraversalPrimitiveCulling or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorSetVariableDescriptorCountAllocate(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorSetVariableDescriptorCountAllocateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.descriptorSetCount = t.descriptorSetCount or 0
		_pool.pDescriptorCounts = t.pDescriptorCounts or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMeshShaderFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMeshShaderFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.taskShader = t.taskShader or 0
		_pool.meshShader = t.meshShader or 0
		_pool.multiviewMeshShader = t.multiviewMeshShader or 0
		_pool.primitiveFragmentShadingRateMeshShader = t.primitiveFragmentShadingRateMeshShader or 0
		_pool.meshShaderQueries = t.meshShaderQueries or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineRasterizationStateStreamCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineRasterizationStateStreamCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.rasterizationStream = t.rasterizationStream or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorPool(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorPoolCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkDescriptorPoolCreateFlagBits(t.flags) or 0
		_pool.maxSets = t.maxSets or 0
		_pool.poolSizeCount = t.poolSizeCount or 0
		_pool.pPoolSizes = t.pPoolSizes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CalibratedTimestampInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCalibratedTimestampInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.timeDomain = t.timeDomain ~= nil and mod.e.VkTimeDomainKHR(t.timeDomain) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PresentRegionsKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPresentRegionsKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.swapchainCount = t.swapchainCount or 0
		_pool.pRegions = t.pRegions or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceOpticalFlowFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceOpticalFlowFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.opticalFlow = t.opticalFlow or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeSessionIntraRefreshCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeSessionIntraRefreshCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.intraRefreshMode = t.intraRefreshMode ~= nil and
			mod.e.VkVideoEncodeIntraRefreshModeFlagBitsKHR(t.intraRefreshMode) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceOpticalFlowPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceOpticalFlowPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.supportedOutputGridSizes = t.supportedOutputGridSizes or 0
		_pool.supportedHintGridSizes = t.supportedHintGridSizes or 0
		_pool.hintSupported = t.hintSupported or 0
		_pool.costSupported = t.costSupported or 0
		_pool.bidirectionalFlowSupported = t.bidirectionalFlowSupported or 0
		_pool.globalFlowSupported = t.globalFlowSupported or 0
		_pool.minWidth = t.minWidth or 0
		_pool.minHeight = t.minHeight or 0
		_pool.maxWidth = t.maxWidth or 0
		_pool.maxHeight = t.maxHeight or 0
		_pool.maxNumRegionsOfInterest = t.maxNumRegionsOfInterest or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePresentWaitFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePresentWaitFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentWait = t.presentWait or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SubpassEnd(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSubpassEndInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_END_INFO")
		end

		_pool.pNext = t.pNext or nil
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderingInputAttachmentIndex(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderingInputAttachmentIndexInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.colorAttachmentCount = t.colorAttachmentCount or 0
		_pool.pColorAttachmentInputIndices = t.pColorAttachmentInputIndices or 0
		_pool.pDepthInputAttachmentIndex = t.pDepthInputAttachmentIndex or 0
		_pool.pStencilInputAttachmentIndex = t.pStencilInputAttachmentIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryUnmap(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryUnmapInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkMemoryUnmapFlagBits(t.flags) or 0
		_pool.memory = t.memory or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryBarrier(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryBarrier)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_BARRIER")
		end

		_pool.pNext = t.pNext or nil
		_pool.srcAccessMask = t.srcAccessMask ~= nil and mod.e.VkAccessFlagBits(t.srcAccessMask) or 0
		_pool.dstAccessMask = t.dstAccessMask ~= nil and mod.e.VkAccessFlagBits(t.dstAccessMask) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SubresourceHostMemcpySize(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSubresourceHostMemcpySize)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE")
		end

		_pool.pNext = t.pNext or nil
		_pool.size = t.size or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyDescriptorSet(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyDescriptorSet)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET")
		end

		_pool.pNext = t.pNext or nil
		_pool.srcSet = t.srcSet or 0
		_pool.srcBinding = t.srcBinding or 0
		_pool.srcArrayElement = t.srcArrayElement or 0
		_pool.dstSet = t.dstSet or 0
		_pool.dstBinding = t.dstBinding or 0
		_pool.dstArrayElement = t.dstArrayElement or 0
		_pool.descriptorCount = t.descriptorCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceQueue(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceQueueCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkDeviceQueueCreateFlagBits(t.flags) or 0
		_pool.queueFamilyIndex = t.queueFamilyIndex or 0
		_pool.queueCount = t.queueCount or 0
		_pool.pQueuePriorities = t.pQueuePriorities or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoInlineQueryInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoInlineQueryInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.queryPool = t.queryPool or 0
		_pool.firstQuery = t.firstQuery or 0
		_pool.queryCount = t.queryCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ScreenBufferPropertiesQNX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkScreenBufferPropertiesQNX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX")
		end

		_pool.pNext = t.pNext or nil
		_pool.allocationSize = t.allocationSize or 0
		_pool.memoryTypeBits = t.memoryTypeBits or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ScreenBufferFormatPropertiesQNX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkScreenBufferFormatPropertiesQNX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX")
		end

		_pool.pNext = t.pNext or nil
		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0
		_pool.externalFormat = t.externalFormat or 0
		_pool.screenUsage = t.screenUsage or 0
		_pool.formatFeatures = t.formatFeatures ~= nil and mod.e.VkFormatFeatureFlagBits(t.formatFeatures) or 0

		if t.samplerYcbcrConversionComponents ~= nil then
			if type(t.samplerYcbcrConversionComponents) == "table" then
				_pool.samplerYcbcrConversionComponents = mod.s.ComponentMapping(t.samplerYcbcrConversionComponents)
			else
				_pool.samplerYcbcrConversionComponents = t.samplerYcbcrConversionComponents
			end
		else
			_pool.samplerYcbcrConversionComponents = mod.VkComponentMapping()
		end

		_pool.suggestedYcbcrModel = t.suggestedYcbcrModel ~= nil and
			mod.e.VkSamplerYcbcrModelConversion(t.suggestedYcbcrModel) or
			0
		_pool.suggestedYcbcrRange = t.suggestedYcbcrRange ~= nil and
			mod.e.VkSamplerYcbcrRange(t.suggestedYcbcrRange) or
			0
		_pool.suggestedXChromaOffset = t.suggestedXChromaOffset ~= nil and
			mod.e.VkChromaLocation(t.suggestedXChromaOffset) or
			0
		_pool.suggestedYChromaOffset = t.suggestedYChromaOffset ~= nil and
			mod.e.VkChromaLocation(t.suggestedYChromaOffset) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.OpticalFlowImageFormatInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkOpticalFlowImageFormatInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.usage = t.usage or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.OpticalFlowImageFormatPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkOpticalFlowImageFormatPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.OpticalFlowSessionCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkOpticalFlowSessionCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.width = t.width or 0
		_pool.height = t.height or 0
		_pool.imageFormat = t.imageFormat ~= nil and mod.e.VkFormat(t.imageFormat) or 0
		_pool.flowVectorFormat = t.flowVectorFormat ~= nil and mod.e.VkFormat(t.flowVectorFormat) or 0
		_pool.costFormat = t.costFormat ~= nil and mod.e.VkFormat(t.costFormat) or 0
		_pool.outputGridSize = t.outputGridSize or 0
		_pool.hintGridSize = t.hintGridSize or 0
		_pool.performanceLevel = t.performanceLevel ~= nil and
			mod.e.VkOpticalFlowPerformanceLevelNV(t.performanceLevel) or
			0
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceQueueGlobalPriority(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceQueueGlobalPriorityCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.globalPriority = t.globalPriority ~= nil and mod.e.VkQueueGlobalPriority(t.globalPriority) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX")
		end

		_pool.pNext = t.pNext or nil
		_pool.screenBufferImport = t.screenBufferImport or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceGlobalPriorityQueryFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceGlobalPriorityQueryFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.globalPriorityQuery = t.globalPriorityQuery or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueueFamilyGlobalPriorityProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueueFamilyGlobalPriorityProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.priorityCount = t.priorityCount or 0
		_pool.priorities = t.priorities ~= nil and mod.e.VkQueueGlobalPriority(t.priorities) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Submit(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSubmitInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBMIT_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.waitSemaphoreCount = t.waitSemaphoreCount or 0
		_pool.pWaitSemaphores = t.pWaitSemaphores or 0
		_pool.pWaitDstStageMask = t.pWaitDstStageMask or 0
		_pool.commandBufferCount = t.commandBufferCount or 0
		_pool.pCommandBuffers = t.pCommandBuffers or 0
		_pool.signalSemaphoreCount = t.signalSemaphoreCount or 0
		_pool.pSignalSemaphores = t.pSignalSemaphores or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.OpticalFlowSessionCreatePrivateDataInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkOpticalFlowSessionCreatePrivateDataInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.id = t.id or 0
		_pool.size = t.size or 0
		_pool.pPrivateData = t.pPrivateData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CuModuleCreateInfoNVX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCuModuleCreateInfoNVX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX")
		end

		_pool.pNext = t.pNext or nil
		_pool.dataSize = t.dataSize or 0
		_pool.pData = t.pData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CuModuleTexturingModeCreateInfoNVX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCuModuleTexturingModeCreateInfoNVX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX")
		end

		_pool.pNext = t.pNext or nil
		_pool.use64bitTexturing = t.use64bitTexturing or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderExpectAssumeFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderExpectAssumeFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderExpectAssume = t.shaderExpectAssume or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CuFunctionCreateInfoNVX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCuFunctionCreateInfoNVX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX")
		end

		_pool.pNext = t.pNext or nil
		_pool.module = t.module or 0
		_pool.pName = t.pName or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CuLaunchInfoNVX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCuLaunchInfoNVX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX")
		end

		_pool.pNext = t.pNext or nil
		_pool["function"] = t["function"] or 0
		_pool.gridDimX = t.gridDimX or 0
		_pool.gridDimY = t.gridDimY or 0
		_pool.gridDimZ = t.gridDimZ or 0
		_pool.blockDimX = t.blockDimX or 0
		_pool.blockDimY = t.blockDimY or 0
		_pool.blockDimZ = t.blockDimZ or 0
		_pool.sharedMemBytes = t.sharedMemBytes or 0
		_pool.paramCount = t.paramCount or 0
		_pool.pParams = t.pParams or 0
		_pool.extraCount = t.extraCount or 0
		_pool.pExtras = t.pExtras or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineRasterizationLineState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineRasterizationLineStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.lineRasterizationMode = t.lineRasterizationMode ~= nil and
			mod.e.VkLineRasterizationMode(t.lineRasterizationMode) or
			0
		_pool.stippledLineEnable = t.stippledLineEnable or 0
		_pool.lineStippleFactor = t.lineStippleFactor or 0
		_pool.lineStipplePattern = t.lineStipplePattern or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTransformFeedbackFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTransformFeedbackFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.transformFeedback = t.transformFeedback or 0
		_pool.geometryStreams = t.geometryStreams or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CommandBufferInheritanceConditionalRenderingInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCommandBufferInheritanceConditionalRenderingInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.conditionalRenderingEnable = t.conditionalRenderingEnable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeQuantizationMapInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeQuantizationMapInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.quantizationMap = t.quantizationMap or 0

		if t.quantizationMapExtent ~= nil then
			if type(t.quantizationMapExtent) == "table" then
				_pool.quantizationMapExtent = mod.VkExtent2D(t.quantizationMapExtent)
			else
				_pool.quantizationMapExtent = t.quantizationMapExtent
			end
		else
			_pool.quantizationMapExtent = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeQuantizationMapSessionParametersCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR"
			)
		end

		_pool.pNext = t.pNext or nil

		if t.quantizationMapTexelSize ~= nil then
			if type(t.quantizationMapTexelSize) == "table" then
				_pool.quantizationMapTexelSize = mod.VkExtent2D(t.quantizationMapTexelSize)
			else
				_pool.quantizationMapTexelSize = t.quantizationMapTexelSize
			end
		else
			_pool.quantizationMapTexelSize = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVertexAttributeDivisorProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVertexAttributeDivisorProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxVertexAttribDivisor = t.maxVertexAttribDivisor or 0
		_pool.supportsNonZeroFirstInstance = t.supportsNonZeroFirstInstance or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DisplaySurfaceCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDisplaySurfaceCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.displayMode = t.displayMode or 0
		_pool.planeIndex = t.planeIndex or 0
		_pool.planeStackIndex = t.planeStackIndex or 0
		_pool.transform = t.transform ~= nil and mod.e.VkSurfaceTransformFlagBitsKHR(t.transform) or 0
		_pool.globalAlpha = t.globalAlpha or 0
		_pool.alphaMode = t.alphaMode ~= nil and mod.e.VkDisplayPlaneAlphaFlagBitsKHR(t.alphaMode) or 0

		if t.imageExtent ~= nil then
			if type(t.imageExtent) == "table" then
				_pool.imageExtent = mod.VkExtent2D(t.imageExtent)
			else
				_pool.imageExtent = t.imageExtent
			end
		else
			_pool.imageExtent = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.MappedMemoryRange(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMappedMemoryRange)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE")
		end

		_pool.pNext = t.pNext or nil
		_pool.memory = t.memory or 0
		_pool.offset = t.offset or 0
		_pool.size = t.size or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineVertexInputDivisorState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineVertexInputDivisorStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.vertexBindingDivisorCount = t.vertexBindingDivisorCount or 0
		_pool.pVertexBindingDivisors = t.pVertexBindingDivisors or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryAllocate(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryAllocateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.allocationSize = t.allocationSize or 0
		_pool.memoryTypeIndex = t.memoryTypeIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRepresentativeFragmentTestFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.representativeFragmentTest = t.representativeFragmentTest or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVertexAttributeDivisorFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVertexAttributeDivisorFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.vertexAttributeInstanceRateDivisor = t.vertexAttributeInstanceRateDivisor or 0
		_pool.vertexAttributeInstanceRateZeroDivisor = t.vertexAttributeInstanceRateZeroDivisor or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineRepresentativeFragmentTestStateCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineRepresentativeFragmentTestStateCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.representativeFragmentTestEnable = t.representativeFragmentTestEnable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryMap(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryMapInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_MAP_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkMemoryMapFlagBits(t.flags) or 0
		_pool.memory = t.memory or 0
		_pool.offset = t.offset or 0
		_pool.size = t.size or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SharedPresentSurfaceCapabilitiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSharedPresentSurfaceCapabilitiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.sharedPresentSupportedUsageFlags = t.sharedPresentSupportedUsageFlags ~= nil and
			mod.e.VkImageUsageFlagBits(t.sharedPresentSupportedUsageFlags) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceBufferDeviceAddressFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceBufferDeviceAddressFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.bufferDeviceAddress = t.bufferDeviceAddress or 0
		_pool.bufferDeviceAddressCaptureReplay = t.bufferDeviceAddressCaptureReplay or 0
		_pool.bufferDeviceAddressMultiDevice = t.bufferDeviceAddressMultiDevice or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceGroupRenderPassBegin(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceGroupRenderPassBeginInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceMask = t.deviceMask or 0
		_pool.deviceRenderAreaCount = t.deviceRenderAreaCount or 0
		_pool.pDeviceRenderAreas = t.pDeviceRenderAreas or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderingArea(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderingAreaInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_AREA_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.viewMask = t.viewMask or 0
		_pool.colorAttachmentCount = t.colorAttachmentCount or 0
		_pool.pColorAttachmentFormats = t.pColorAttachmentFormats or 0
		_pool.depthAttachmentFormat = t.depthAttachmentFormat ~= nil and mod.e.VkFormat(t.depthAttachmentFormat) or 0
		_pool.stencilAttachmentFormat = t.stencilAttachmentFormat ~= nil and
			mod.e.VkFormat(t.stencilAttachmentFormat) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceLegacyDitheringFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceLegacyDitheringFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.legacyDithering = t.legacyDithering or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceImageSubresource(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceImageSubresourceInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.pCreateInfo = t.pCreateInfo or 0
		_pool.pSubresource = t.pSubresource or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BufferDeviceAddress(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBufferDeviceAddressInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.buffer = t.buffer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindDescriptorSets(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindDescriptorSetsInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.stageFlags = t.stageFlags ~= nil and mod.e.VkShaderStageFlagBits(t.stageFlags) or 0
		_pool.layout = t.layout or 0
		_pool.firstSet = t.firstSet or 0
		_pool.descriptorSetCount = t.descriptorSetCount or 0
		_pool.pDescriptorSets = t.pDescriptorSets or 0
		_pool.dynamicOffsetCount = t.dynamicOffsetCount or 0
		_pool.pDynamicOffsets = t.pDynamicOffsets or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePipelineExecutablePropertiesFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineExecutableInfo = t.pipelineExecutableInfo or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DebugMarkerMarkerInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDebugMarkerMarkerInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.pMarkerName = t.pMarkerName or 0
		_pool.color = t.color or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePushDescriptorProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePushDescriptorProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxPushDescriptors = t.maxPushDescriptors or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDynamicRenderingLocalReadFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDynamicRenderingLocalReadFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.dynamicRenderingLocalRead = t.dynamicRenderingLocalRead or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderingAttachmentLocation(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderingAttachmentLocationInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.colorAttachmentCount = t.colorAttachmentCount or 0
		_pool.pColorAttachmentLocations = t.pColorAttachmentLocations or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageViewHandleInfoNVX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageViewHandleInfoNVX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX")
		end

		_pool.pNext = t.pNext or nil
		_pool.imageView = t.imageView or 0
		_pool.descriptorType = t.descriptorType ~= nil and mod.e.VkDescriptorType(t.descriptorType) or 0
		_pool.sampler = t.sampler or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageViewAddressPropertiesNVX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageViewAddressPropertiesNVX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceAddress = t.deviceAddress or 0
		_pool.size = t.size or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceLayeredApiPropertiesListKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceLayeredApiPropertiesListKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.layeredApiCount = t.layeredApiCount or 0
		_pool.pLayeredApis = t.pLayeredApis or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePipelineRobustnessFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePipelineRobustnessFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineRobustness = t.pipelineRobustness or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.LatencySleepInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkLatencySleepInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.signalSemaphore = t.signalSemaphore or 0
		_pool.value = t.value or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderDemoteToHelperInvocationFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderDemoteToHelperInvocation = t.shaderDemoteToHelperInvocation or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderZeroInitializeWorkgroupMemory = t.shaderZeroInitializeWorkgroupMemory or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineExecutableStatisticKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineExecutableStatisticKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.name = t.name or 0
		_pool.description = t.description or 0
		_pool.format = t.format ~= nil and mod.e.VkPipelineExecutableStatisticFormatKHR(t.format) or 0

		if t.value ~= nil then
			if type(t.value) == "table" then
				_pool.value = mod.VkPipelineExecutableStatisticValueKHR(t.value)
			else
				_pool.value = t.value
			end
		else
			_pool.value = mod.VkPipelineExecutableStatisticValueKHR()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineExecutableInternalRepresentationKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineExecutableInternalRepresentationKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.name = t.name or 0
		_pool.description = t.description or 0
		_pool.isText = t.isText or 0
		_pool.dataSize = t.dataSize or 0
		_pool.pData = t.pData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceAntiLagFeaturesAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceAntiLagFeaturesAMD)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD")
		end

		_pool.pNext = t.pNext or nil
		_pool.antiLag = t.antiLag or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineInputAssemblyState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineInputAssemblyStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.topology = t.topology ~= nil and mod.e.VkPrimitiveTopology(t.topology) or 0
		_pool.primitiveRestartEnable = t.primitiveRestartEnable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImportFenceFdInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImportFenceFdInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.fence = t.fence or 0
		_pool.flags = t.flags ~= nil and mod.e.VkFenceImportFlagBits(t.flags) or 0
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalFenceHandleTypeFlagBits(t.handleType) or
			0
		_pool.fd = t.fd or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.FenceGetFdInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkFenceGetFdInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.fence = t.fence or 0
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalFenceHandleTypeFlagBits(t.handleType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AntiLagDataAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAntiLagDataAMD)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD")
		end

		_pool.pNext = t.pNext or nil
		_pool.mode = t.mode ~= nil and mod.e.VkAntiLagModeAMD(t.mode) or 0
		_pool.maxFPS = t.maxFPS or 0
		_pool.pPresentationInfo = t.pPresentationInfo or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineDynamicState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineDynamicStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.dynamicStateCount = t.dynamicStateCount or 0
		_pool.pDynamicStates = t.pDynamicStates or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryAllocateFlags(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryAllocateFlagsInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkMemoryAllocateFlagBits(t.flags) or 0
		_pool.deviceMask = t.deviceMask or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SemaphoreSignal(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSemaphoreSignalInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.semaphore = t.semaphore or 0
		_pool.value = t.value or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GraphicsPipeline(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGraphicsPipelineCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkPipelineCreateFlagBits(t.flags) or 0
		_pool.stageCount = t.stageCount or 0
		_pool.pStages = t.pStages or 0
		_pool.pVertexInputState = t.pVertexInputState or 0
		_pool.pInputAssemblyState = t.pInputAssemblyState or 0
		_pool.pTessellationState = t.pTessellationState or 0
		_pool.pViewportState = t.pViewportState or 0
		_pool.pRasterizationState = t.pRasterizationState or 0
		_pool.pMultisampleState = t.pMultisampleState or 0
		_pool.pDepthStencilState = t.pDepthStencilState or 0
		_pool.pColorBlendState = t.pColorBlendState or 0
		_pool.pDynamicState = t.pDynamicState or 0
		_pool.layout = t.layout or 0
		_pool.renderPass = t.renderPass or 0
		_pool.subpass = t.subpass or 0
		_pool.basePipelineHandle = t.basePipelineHandle or 0
		_pool.basePipelineIndex = t.basePipelineIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Fence(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkFenceCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_FENCE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkFenceCreateFlagBits(t.flags) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Semaphore(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSemaphoreCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Event(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkEventCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EVENT_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkEventCreateFlagBits(t.flags) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueryPool(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueryPoolCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkQueryPoolCreateFlagBits(t.flags) or 0
		_pool.queryType = t.queryType ~= nil and mod.e.VkQueryType(t.queryType) or 0
		_pool.queryCount = t.queryCount or 0
		_pool.pipelineStatistics = t.pipelineStatistics ~= nil and
			mod.e.VkQueryPipelineStatisticFlagBits(t.pipelineStatistics) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeSessionParametersGetInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeSessionParametersGetInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.videoSessionParameters = t.videoSessionParameters or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoSessionParametersCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoSessionParametersCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.videoSessionParametersTemplate = t.videoSessionParametersTemplate or 0
		_pool.videoSession = t.videoSession or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.WriteDescriptorSetInlineUniformBlock(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkWriteDescriptorSetInlineUniformBlock)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK")
		end

		_pool.pNext = t.pNext or nil
		_pool.dataSize = t.dataSize or 0
		_pool.pData = t.pData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DisplayPowerInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDisplayPowerInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.powerState = t.powerState ~= nil and mod.e.VkDisplayPowerStateEXT(t.powerState) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindSparse(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindSparseInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_SPARSE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.waitSemaphoreCount = t.waitSemaphoreCount or 0
		_pool.pWaitSemaphores = t.pWaitSemaphores or 0
		_pool.bufferBindCount = t.bufferBindCount or 0
		_pool.pBufferBinds = t.pBufferBinds or 0
		_pool.imageOpaqueBindCount = t.imageOpaqueBindCount or 0
		_pool.pImageOpaqueBinds = t.pImageOpaqueBinds or 0
		_pool.imageBindCount = t.imageBindCount or 0
		_pool.pImageBinds = t.pImageBinds or 0
		_pool.signalSemaphoreCount = t.signalSemaphoreCount or 0
		_pool.pSignalSemaphores = t.pSignalSemaphores or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceEventInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceEventInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceEvent = t.deviceEvent ~= nil and mod.e.VkDeviceEventTypeEXT(t.deviceEvent) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ValidationCacheCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkValidationCacheCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.initialDataSize = t.initialDataSize or 0
		_pool.pInitialData = t.pInitialData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DisplayEventInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDisplayEventInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.displayEvent = t.displayEvent ~= nil and mod.e.VkDisplayEventTypeEXT(t.displayEvent) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BufferView(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBufferViewCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.buffer = t.buffer or 0
		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0
		_pool.offset = t.offset or 0
		_pool.range = t.range or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SwapchainCounterCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSwapchainCounterCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.surfaceCounters = t.surfaceCounters or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyImageToMemory(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyImageToMemoryInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkHostImageCopyFlagBits(t.flags) or 0
		_pool.srcImage = t.srcImage or 0
		_pool.srcImageLayout = t.srcImageLayout ~= nil and mod.e.VkImageLayout(t.srcImageLayout) or 0
		_pool.regionCount = t.regionCount or 0
		_pool.pRegions = t.pRegions or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceToolProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceToolProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.name = t.name or 0
		_pool.version = t.version or 0
		_pool.purposes = t.purposes ~= nil and mod.e.VkToolPurposeFlagBits(t.purposes) or 0
		_pool.description = t.description or 0
		_pool.layer = t.layer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineLayout(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineLayoutCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkPipelineLayoutCreateFlagBits(t.flags) or 0
		_pool.setLayoutCount = t.setLayoutCount or 0
		_pool.pSetLayouts = t.pSetLayouts or 0
		_pool.pushConstantRangeCount = t.pushConstantRangeCount or 0
		_pool.pPushConstantRanges = t.pPushConstantRanges or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceGroupSwapchainCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceGroupSwapchainCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.modes = t.modes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GraphicsPipelineShaderGroupsCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGraphicsPipelineShaderGroupsCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.groupCount = t.groupCount or 0
		_pool.pGroups = t.pGroups or 0
		_pool.pipelineCount = t.pipelineCount or 0
		_pool.pPipelines = t.pPipelines or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceConditionalRenderingFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceConditionalRenderingFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.conditionalRendering = t.conditionalRendering or 0
		_pool.inheritedConditionalRendering = t.inheritedConditionalRendering or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ConditionalRenderingBeginInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkConditionalRenderingBeginInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.buffer = t.buffer or 0
		_pool.offset = t.offset or 0
		_pool.flags = t.flags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Sampler(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSamplerCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkSamplerCreateFlagBits(t.flags) or 0
		_pool.magFilter = t.magFilter ~= nil and mod.e.VkFilter(t.magFilter) or 0
		_pool.minFilter = t.minFilter ~= nil and mod.e.VkFilter(t.minFilter) or 0
		_pool.mipmapMode = t.mipmapMode ~= nil and mod.e.VkSamplerMipmapMode(t.mipmapMode) or 0
		_pool.addressModeU = t.addressModeU ~= nil and mod.e.VkSamplerAddressMode(t.addressModeU) or 0
		_pool.addressModeV = t.addressModeV ~= nil and mod.e.VkSamplerAddressMode(t.addressModeV) or 0
		_pool.addressModeW = t.addressModeW ~= nil and mod.e.VkSamplerAddressMode(t.addressModeW) or 0
		_pool.mipLodBias = t.mipLodBias or 0
		_pool.anisotropyEnable = t.anisotropyEnable or 0
		_pool.maxAnisotropy = t.maxAnisotropy or 0
		_pool.compareEnable = t.compareEnable or 0
		_pool.compareOp = t.compareOp ~= nil and mod.e.VkCompareOp(t.compareOp) or 0
		_pool.minLod = t.minLod or 0
		_pool.maxLod = t.maxLod or 0
		_pool.borderColor = t.borderColor ~= nil and mod.e.VkBorderColor(t.borderColor) or 0
		_pool.unnormalizedCoordinates = t.unnormalizedCoordinates or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderDrawParametersFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderDrawParametersFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderDrawParameters = t.shaderDrawParameters or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderObjectFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderObjectFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderObject = t.shaderObject or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineLibraryCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineLibraryCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.libraryCount = t.libraryCount or 0
		_pool.pLibraries = t.pLibraries or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderObjectPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderObjectPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderBinaryUUID = t.shaderBinaryUUID or 0
		_pool.shaderBinaryVersion = t.shaderBinaryVersion or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoProfileInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoProfileInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.videoCodecOperation = t.videoCodecOperation ~= nil and
			mod.e.VkVideoCodecOperationFlagBitsKHR(t.videoCodecOperation) or
			0
		_pool.chromaSubsampling = t.chromaSubsampling or 0
		_pool.lumaBitDepth = t.lumaBitDepth or 0
		_pool.chromaBitDepth = t.chromaBitDepth or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceLineRasterizationProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceLineRasterizationProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.lineSubPixelPrecisionBits = t.lineSubPixelPrecisionBits or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ShaderCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkShaderCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.stage = t.stage ~= nil and mod.e.VkShaderStageFlagBits(t.stage) or 0
		_pool.nextStage = t.nextStage ~= nil and mod.e.VkShaderStageFlagBits(t.nextStage) or 0
		_pool.codeType = t.codeType ~= nil and mod.e.VkShaderCodeTypeEXT(t.codeType) or 0
		_pool.codeSize = t.codeSize or 0
		_pool.pCode = t.pCode or 0
		_pool.pName = t.pName or 0
		_pool.setLayoutCount = t.setLayoutCount or 0
		_pool.pSetLayouts = t.pSetLayouts or 0
		_pool.pushConstantRangeCount = t.pushConstantRangeCount or 0
		_pool.pPushConstantRanges = t.pPushConstantRanges or 0
		_pool.pSpecializationInfo = t.pSpecializationInfo or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalFormatQNX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalFormatQNX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX")
		end

		_pool.pNext = t.pNext or nil
		_pool.externalFormat = t.externalFormat or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImportScreenBufferInfoQNX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImportScreenBufferInfoQNX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX")
		end

		_pool.pNext = t.pNext or nil
		_pool.buffer = t.buffer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceClusterAccelerationStructurePropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxVerticesPerCluster = t.maxVerticesPerCluster or 0
		_pool.maxTrianglesPerCluster = t.maxTrianglesPerCluster or 0
		_pool.clusterScratchByteAlignment = t.clusterScratchByteAlignment or 0
		_pool.clusterByteAlignment = t.clusterByteAlignment or 0
		_pool.clusterTemplateByteAlignment = t.clusterTemplateByteAlignment or 0
		_pool.clusterBottomLevelByteAlignment = t.clusterBottomLevelByteAlignment or 0
		_pool.clusterTemplateBoundsByteAlignment = t.clusterTemplateBoundsByteAlignment or 0
		_pool.maxClusterGeometryIndex = t.maxClusterGeometryIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Device(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.queueCreateInfoCount = t.queueCreateInfoCount or 0
		_pool.pQueueCreateInfos = t.pQueueCreateInfos or 0
		_pool.enabledLayerCount = t.enabledLayerCount or 0
		_pool.ppEnabledLayerNames = t.ppEnabledLayerNames or 0
		_pool.enabledExtensionCount = t.enabledExtensionCount or 0
		_pool.ppEnabledExtensionNames = t.ppEnabledExtensionNames or 0
		_pool.pEnabledFeatures = t.pEnabledFeatures or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceClusterAccelerationStructureFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.clusterAccelerationStructure = t.clusterAccelerationStructure or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PresentIdKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPresentIdKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_ID_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.swapchainCount = t.swapchainCount or 0
		_pool.pPresentIds = t.pPresentIds or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDescriptorIndexingFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDescriptorIndexingFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderInputAttachmentArrayDynamicIndexing = t.shaderInputAttachmentArrayDynamicIndexing or 0
		_pool.shaderUniformTexelBufferArrayDynamicIndexing = t.shaderUniformTexelBufferArrayDynamicIndexing or 0
		_pool.shaderStorageTexelBufferArrayDynamicIndexing = t.shaderStorageTexelBufferArrayDynamicIndexing or 0
		_pool.shaderUniformBufferArrayNonUniformIndexing = t.shaderUniformBufferArrayNonUniformIndexing or 0
		_pool.shaderSampledImageArrayNonUniformIndexing = t.shaderSampledImageArrayNonUniformIndexing or 0
		_pool.shaderStorageBufferArrayNonUniformIndexing = t.shaderStorageBufferArrayNonUniformIndexing or 0
		_pool.shaderStorageImageArrayNonUniformIndexing = t.shaderStorageImageArrayNonUniformIndexing or 0
		_pool.shaderInputAttachmentArrayNonUniformIndexing = t.shaderInputAttachmentArrayNonUniformIndexing or 0
		_pool.shaderUniformTexelBufferArrayNonUniformIndexing = t.shaderUniformTexelBufferArrayNonUniformIndexing or 0
		_pool.shaderStorageTexelBufferArrayNonUniformIndexing = t.shaderStorageTexelBufferArrayNonUniformIndexing or 0
		_pool.descriptorBindingUniformBufferUpdateAfterBind = t.descriptorBindingUniformBufferUpdateAfterBind or 0
		_pool.descriptorBindingSampledImageUpdateAfterBind = t.descriptorBindingSampledImageUpdateAfterBind or 0
		_pool.descriptorBindingStorageImageUpdateAfterBind = t.descriptorBindingStorageImageUpdateAfterBind or 0
		_pool.descriptorBindingStorageBufferUpdateAfterBind = t.descriptorBindingStorageBufferUpdateAfterBind or 0
		_pool.descriptorBindingUniformTexelBufferUpdateAfterBind = t.descriptorBindingUniformTexelBufferUpdateAfterBind or 0
		_pool.descriptorBindingStorageTexelBufferUpdateAfterBind = t.descriptorBindingStorageTexelBufferUpdateAfterBind or 0
		_pool.descriptorBindingUpdateUnusedWhilePending = t.descriptorBindingUpdateUnusedWhilePending or 0
		_pool.descriptorBindingPartiallyBound = t.descriptorBindingPartiallyBound or 0
		_pool.descriptorBindingVariableDescriptorCount = t.descriptorBindingVariableDescriptorCount or 0
		_pool.runtimeDescriptorArray = t.runtimeDescriptorArray or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePresentIdFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePresentIdFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentId = t.presentId or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMeshShaderPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMeshShaderPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxTaskWorkGroupTotalCount = t.maxTaskWorkGroupTotalCount or 0
		_pool.maxTaskWorkGroupCount = t.maxTaskWorkGroupCount or 0
		_pool.maxTaskWorkGroupInvocations = t.maxTaskWorkGroupInvocations or 0
		_pool.maxTaskWorkGroupSize = t.maxTaskWorkGroupSize or 0
		_pool.maxTaskPayloadSize = t.maxTaskPayloadSize or 0
		_pool.maxTaskSharedMemorySize = t.maxTaskSharedMemorySize or 0
		_pool.maxTaskPayloadAndSharedMemorySize = t.maxTaskPayloadAndSharedMemorySize or 0
		_pool.maxMeshWorkGroupTotalCount = t.maxMeshWorkGroupTotalCount or 0
		_pool.maxMeshWorkGroupCount = t.maxMeshWorkGroupCount or 0
		_pool.maxMeshWorkGroupInvocations = t.maxMeshWorkGroupInvocations or 0
		_pool.maxMeshWorkGroupSize = t.maxMeshWorkGroupSize or 0
		_pool.maxMeshSharedMemorySize = t.maxMeshSharedMemorySize or 0
		_pool.maxMeshPayloadAndSharedMemorySize = t.maxMeshPayloadAndSharedMemorySize or 0
		_pool.maxMeshOutputMemorySize = t.maxMeshOutputMemorySize or 0
		_pool.maxMeshPayloadAndOutputMemorySize = t.maxMeshPayloadAndOutputMemorySize or 0
		_pool.maxMeshOutputComponents = t.maxMeshOutputComponents or 0
		_pool.maxMeshOutputVertices = t.maxMeshOutputVertices or 0
		_pool.maxMeshOutputPrimitives = t.maxMeshOutputPrimitives or 0
		_pool.maxMeshOutputLayers = t.maxMeshOutputLayers or 0
		_pool.maxMeshMultiviewViewCount = t.maxMeshMultiviewViewCount or 0
		_pool.meshOutputPerVertexGranularity = t.meshOutputPerVertexGranularity or 0
		_pool.meshOutputPerPrimitiveGranularity = t.meshOutputPerPrimitiveGranularity or 0
		_pool.maxPreferredTaskWorkGroupInvocations = t.maxPreferredTaskWorkGroupInvocations or 0
		_pool.maxPreferredMeshWorkGroupInvocations = t.maxPreferredMeshWorkGroupInvocations or 0
		_pool.prefersLocalInvocationVertexOutput = t.prefersLocalInvocationVertexOutput or 0
		_pool.prefersLocalInvocationPrimitiveOutput = t.prefersLocalInvocationPrimitiveOutput or 0
		_pool.prefersCompactVertexOutput = t.prefersCompactVertexOutput or 0
		_pool.prefersCompactPrimitiveOutput = t.prefersCompactPrimitiveOutput or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindImageMemory(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindImageMemoryInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.image = t.image or 0
		_pool.memory = t.memory or 0
		_pool.memoryOffset = t.memoryOffset or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineCompilerControlCreateInfoAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineCompilerControlCreateInfoAMD)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD")
		end

		_pool.pNext = t.pNext or nil
		_pool.compilerControlFlags = t.compilerControlFlags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PresentTimesInfoGOOGLE(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPresentTimesInfoGOOGLE)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE")
		end

		_pool.pNext = t.pNext or nil
		_pool.swapchainCount = t.swapchainCount or 0
		_pool.pTimes = t.pTimes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DepthBiasRepresentationInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDepthBiasRepresentationInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.depthBiasRepresentation = t.depthBiasRepresentation ~= nil and
			mod.e.VkDepthBiasRepresentationEXT(t.depthBiasRepresentation) or
			0
		_pool.depthBiasExact = t.depthBiasExact or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorAddressInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorAddressInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.address = t.address or 0
		_pool.range = t.range or 0
		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.imageCompressionControlSwapchain = t.imageCompressionControlSwapchain or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageViewSampleWeightCreateInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageViewSampleWeightCreateInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil

		if t.filterCenter ~= nil then
			if type(t.filterCenter) == "table" then
				_pool.filterCenter = mod.VkOffset2D(t.filterCenter)
			else
				_pool.filterCenter = t.filterCenter
			end
		else
			_pool.filterCenter = mod.VkOffset2D()
		end

		if t.filterSize ~= nil then
			if type(t.filterSize) == "table" then
				_pool.filterSize = mod.VkExtent2D(t.filterSize)
			else
				_pool.filterSize = t.filterSize
			end
		else
			_pool.filterSize = mod.VkExtent2D()
		end

		_pool.numPhases = t.numPhases or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceImageProcessingPropertiesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceImageProcessingPropertiesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxWeightFilterPhases = t.maxWeightFilterPhases or 0

		if t.maxWeightFilterDimension ~= nil then
			if type(t.maxWeightFilterDimension) == "table" then
				_pool.maxWeightFilterDimension = mod.VkExtent2D(t.maxWeightFilterDimension)
			else
				_pool.maxWeightFilterDimension = t.maxWeightFilterDimension
			end
		else
			_pool.maxWeightFilterDimension = mod.VkExtent2D()
		end

		if t.maxBlockMatchRegion ~= nil then
			if type(t.maxBlockMatchRegion) == "table" then
				_pool.maxBlockMatchRegion = mod.VkExtent2D(t.maxBlockMatchRegion)
			else
				_pool.maxBlockMatchRegion = t.maxBlockMatchRegion
			end
		else
			_pool.maxBlockMatchRegion = mod.VkExtent2D()
		end

		if t.maxBoxFilterBlockSize ~= nil then
			if type(t.maxBoxFilterBlockSize) == "table" then
				_pool.maxBoxFilterBlockSize = mod.VkExtent2D(t.maxBoxFilterBlockSize)
			else
				_pool.maxBoxFilterBlockSize = t.maxBoxFilterBlockSize
			end
		else
			_pool.maxBoxFilterBlockSize = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceNestedCommandBufferPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceNestedCommandBufferPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxCommandBufferNestingLevel = t.maxCommandBufferNestingLevel or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePerformanceQueryFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePerformanceQueryFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.performanceCounterQueryPools = t.performanceCounterQueryPools or 0
		_pool.performanceCounterMultipleQueryPools = t.performanceCounterMultipleQueryPools or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassSubpassFeedbackCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassSubpassFeedbackCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.pSubpassFeedback = t.pSubpassFeedback or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TensorDescriptionARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTensorDescriptionARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tiling = t.tiling ~= nil and mod.e.VkTensorTilingARM(t.tiling) or 0
		_pool.format = t.format ~= nil and mod.e.VkFormat(t.format) or 0
		_pool.dimensionCount = t.dimensionCount or 0
		_pool.pDimensions = t.pDimensions or 0
		_pool.pStrides = t.pStrides or 0
		_pool.usage = t.usage or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePerformanceQueryPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePerformanceQueryPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.allowCommandBufferQueryCopies = t.allowCommandBufferQueryCopies or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTilePropertiesFeaturesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTilePropertiesFeaturesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tileProperties = t.tileProperties or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PerformanceCounterKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPerformanceCounterKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.unit = t.unit ~= nil and mod.e.VkPerformanceCounterUnitKHR(t.unit) or 0
		_pool.scope = t.scope ~= nil and mod.e.VkPerformanceCounterScopeKHR(t.scope) or 0
		_pool.storage = t.storage ~= nil and mod.e.VkPerformanceCounterStorageKHR(t.storage) or 0
		_pool.uuid = t.uuid or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TilePropertiesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTilePropertiesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM")
		end

		_pool.pNext = t.pNext or nil

		if t.tileSize ~= nil then
			if type(t.tileSize) == "table" then
				_pool.tileSize = mod.VkExtent3D(t.tileSize)
			else
				_pool.tileSize = t.tileSize
			end
		else
			_pool.tileSize = mod.VkExtent3D()
		end

		if t.apronSize ~= nil then
			if type(t.apronSize) == "table" then
				_pool.apronSize = mod.VkExtent2D(t.apronSize)
			else
				_pool.apronSize = t.apronSize
			end
		else
			_pool.apronSize = mod.VkExtent2D()
		end

		if t.origin ~= nil then
			if type(t.origin) == "table" then
				_pool.origin = mod.VkOffset2D(t.origin)
			else
				_pool.origin = t.origin
			end
		else
			_pool.origin = mod.VkOffset2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorSetAllocate(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorSetAllocateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.descriptorPool = t.descriptorPool or 0
		_pool.descriptorSetCount = t.descriptorSetCount or 0
		_pool.pSetLayouts = t.pSetLayouts or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TensorFormatPropertiesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTensorFormatPropertiesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.optimalTilingTensorFeatures = t.optimalTilingTensorFeatures or 0
		_pool.linearTilingTensorFeatures = t.linearTilingTensorFeatures or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PerformanceCounterDescriptionKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPerformanceCounterDescriptionKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.name = t.name or 0
		_pool.category = t.category or 0
		_pool.description = t.description or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyTensorInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyTensorInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.srcTensor = t.srcTensor or 0
		_pool.dstTensor = t.dstTensor or 0
		_pool.regionCount = t.regionCount or 0
		_pool.pRegions = t.pRegions or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueryPoolPerformanceCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueryPoolPerformanceCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.queueFamilyIndex = t.queueFamilyIndex or 0
		_pool.counterIndexCount = t.counterIndexCount or 0
		_pool.pCounterIndices = t.pCounterIndices or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalTensorPropertiesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalTensorPropertiesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM")
		end

		_pool.pNext = t.pNext or nil

		if t.externalMemoryProperties ~= nil then
			if type(t.externalMemoryProperties) == "table" then
				_pool.externalMemoryProperties = mod.s.ExternalMemoryProperties(t.externalMemoryProperties)
			else
				_pool.externalMemoryProperties = t.externalMemoryProperties
			end
		else
			_pool.externalMemoryProperties = mod.VkExternalMemoryProperties()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorSetLayout(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorSetLayoutCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkDescriptorSetLayoutCreateFlagBits(t.flags) or 0
		_pool.bindingCount = t.bindingCount or 0
		_pool.pBindings = t.pBindings or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ShaderModuleIdentifierEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkShaderModuleIdentifierEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.identifierSize = t.identifierSize or 0
		_pool.identifier = t.identifier or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.OpticalFlowExecuteInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkOpticalFlowExecuteInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.regionCount = t.regionCount or 0
		_pool.pRegions = t.pRegions or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.WriteDescriptorSet(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkWriteDescriptorSet)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET")
		end

		_pool.pNext = t.pNext or nil
		_pool.dstSet = t.dstSet or 0
		_pool.dstBinding = t.dstBinding or 0
		_pool.dstArrayElement = t.dstArrayElement or 0
		_pool.descriptorCount = t.descriptorCount or 0
		_pool.descriptorType = t.descriptorType ~= nil and mod.e.VkDescriptorType(t.descriptorType) or 0
		_pool.pImageInfo = t.pImageInfo or 0
		_pool.pBufferInfo = t.pBufferInfo or 0
		_pool.pTexelBufferView = t.pTexelBufferView or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceAmigoProfilingFeaturesSEC(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceAmigoProfilingFeaturesSEC)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC")
		end

		_pool.pNext = t.pNext or nil
		_pool.amigoProfiling = t.amigoProfiling or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AcquireProfilingLockInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAcquireProfilingLockInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.timeout = t.timeout or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PerformanceQuerySubmitInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPerformanceQuerySubmitInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.counterPassIndex = t.counterPassIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AmigoProfilingSubmitInfoSEC(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAmigoProfilingSubmitInfoSEC)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC")
		end

		_pool.pNext = t.pNext or nil
		_pool.firstDrawTimestamp = t.firstDrawTimestamp or 0
		_pool.swapBufferTimestamp = t.swapBufferTimestamp or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMultiDrawPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMultiDrawPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxMultiDrawCount = t.maxMultiDrawCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExtendedSparseAddressSpacePropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.extendedSparseAddressSpaceSize = t.extendedSparseAddressSpaceSize or 0
		_pool.extendedSparseImageUsageFlags = t.extendedSparseImageUsageFlags ~= nil and
			mod.e.VkImageUsageFlagBits(t.extendedSparseImageUsageFlags) or
			0
		_pool.extendedSparseBufferUsageFlags = t.extendedSparseBufferUsageFlags ~= nil and
			mod.e.VkBufferUsageFlagBits(t.extendedSparseBufferUsageFlags) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SurfacePresentModeKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSurfacePresentModeKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentMode = t.presentMode ~= nil and mod.e.VkPresentModeKHR(t.presentMode) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.LatencySleepModeInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkLatencySleepModeInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.lowLatencyMode = t.lowLatencyMode or 0
		_pool.lowLatencyBoost = t.lowLatencyBoost or 0
		_pool.minimumIntervalUs = t.minimumIntervalUs or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDataGraphFeaturesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDataGraphFeaturesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.dataGraph = t.dataGraph or 0
		_pool.dataGraphUpdateAfterBind = t.dataGraphUpdateAfterBind or 0
		_pool.dataGraphSpecializationConstants = t.dataGraphSpecializationConstants or 0
		_pool.dataGraphDescriptorBuffer = t.dataGraphDescriptorBuffer or 0
		_pool.dataGraphShaderModule = t.dataGraphShaderModule or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.multiviewPerViewViewports = t.multiviewPerViewViewports or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineConstantARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineConstantARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.id = t.id or 0
		_pool.pConstantData = t.pConstantData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.Framebuffer(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkFramebufferCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkFramebufferCreateFlagBits(t.flags) or 0
		_pool.renderPass = t.renderPass or 0
		_pool.attachmentCount = t.attachmentCount or 0
		_pool.pAttachments = t.pAttachments or 0
		_pool.width = t.width or 0
		_pool.height = t.height or 0
		_pool.layers = t.layers or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineCreateInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineCreateInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.layout = t.layout or 0
		_pool.resourceInfoCount = t.resourceInfoCount or 0
		_pool.pResourceInfos = t.pResourceInfos or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineShaderModuleCreateInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineShaderModuleCreateInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.module = t.module or 0
		_pool.pName = t.pName or 0
		_pool.pSpecializationInfo = t.pSpecializationInfo or 0
		_pool.constantCount = t.constantCount or 0
		_pool.pConstants = t.pConstants or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindDataGraphPipelineSessionMemoryInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindDataGraphPipelineSessionMemoryInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.session = t.session or 0
		_pool.bindPoint = t.bindPoint ~= nil and
			mod.e.VkDataGraphPipelineSessionBindPointARM(t.bindPoint) or
			0
		_pool.objectIndex = t.objectIndex or 0
		_pool.memory = t.memory or 0
		_pool.memoryOffset = t.memoryOffset or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DataGraphPipelineIdentifierCreateInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDataGraphPipelineIdentifierCreateInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.identifierSize = t.identifierSize or 0
		_pool.pIdentifier = t.pIdentifier or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassCreationControlEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassCreationControlEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.disallowMerging = t.disallowMerging or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSubpassMergeFeedbackFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.subpassMergeFeedback = t.subpassMergeFeedback or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRayTracingInvocationReorderPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.rayTracingInvocationReorderReorderingHint = t.rayTracingInvocationReorderReorderingHint ~= nil and
			mod.e.VkRayTracingInvocationReorderModeNV(t.rayTracingInvocationReorderReorderingHint) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.multiviewPerViewRenderAreas = t.multiviewPerViewRenderAreas or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRayTracingInvocationReorderFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.rayTracingInvocationReorder = t.rayTracingInvocationReorder or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BlitImageCubicWeightsInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBlitImageCubicWeightsInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.cubicWeights = t.cubicWeights ~= nil and mod.e.VkCubicFilterWeightsQCOM(t.cubicWeights) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceLayeredDriverPropertiesMSFT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceLayeredDriverPropertiesMSFT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT")
		end

		_pool.pNext = t.pNext or nil
		_pool.underlyingAPI = t.underlyingAPI ~= nil and
			mod.e.VkLayeredDriverUnderlyingApiMSFT(t.underlyingAPI) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineViewportShadingRateImageStateCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineViewportShadingRateImageStateCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.shadingRateImageEnable = t.shadingRateImageEnable or 0
		_pool.viewportCount = t.viewportCount or 0
		_pool.pShadingRatePalettes = t.pShadingRatePalettes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTileMemoryHeapPropertiesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.queueSubmitBoundary = t.queueSubmitBoundary or 0
		_pool.tileBufferTransfers = t.tileBufferTransfers or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TileMemoryRequirementsQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTileMemoryRequirementsQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.size = t.size or 0
		_pool.alignment = t.alignment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TileMemoryBindInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTileMemoryBindInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.memory = t.memory or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TileMemorySizeInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTileMemorySizeInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.size = t.size or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentShaderBarycentricFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.fragmentShaderBarycentric = t.fragmentShaderBarycentric or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CooperativeMatrixPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCooperativeMatrixPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.MSize = t.MSize or 0
		_pool.NSize = t.NSize or 0
		_pool.KSize = t.KSize or 0
		_pool.AType = t.AType ~= nil and mod.e.VkComponentTypeKHR(t.AType) or 0
		_pool.BType = t.BType ~= nil and mod.e.VkComponentTypeKHR(t.BType) or 0
		_pool.CType = t.CType ~= nil and mod.e.VkComponentTypeKHR(t.CType) or 0
		_pool.ResultType = t.ResultType ~= nil and mod.e.VkComponentTypeKHR(t.ResultType) or 0
		_pool.saturatingAccumulation = t.saturatingAccumulation or 0
		_pool.scope = t.scope ~= nil and mod.e.VkScopeKHR(t.scope) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentShaderBarycentricPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.triStripVertexOrderIndependentOfProvokingVertex = t.triStripVertexOrderIndependentOfProvokingVertex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCooperativeVectorPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCooperativeVectorPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.cooperativeVectorSupportedStages = t.cooperativeVectorSupportedStages ~= nil and
			mod.e.VkShaderStageFlagBits(t.cooperativeVectorSupportedStages) or
			0
		_pool.cooperativeVectorTrainingFloat16Accumulation = t.cooperativeVectorTrainingFloat16Accumulation or 0
		_pool.cooperativeVectorTrainingFloat32Accumulation = t.cooperativeVectorTrainingFloat32Accumulation or 0
		_pool.maxCooperativeVectorComponents = t.maxCooperativeVectorComponents or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderTileImagePropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderTileImagePropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderTileImageCoherentReadAccelerated = t.shaderTileImageCoherentReadAccelerated or 0
		_pool.shaderTileImageReadSampleFromPixelRateInvocation = t.shaderTileImageReadSampleFromPixelRateInvocation or 0
		_pool.shaderTileImageReadFromHelperInvocation = t.shaderTileImageReadFromHelperInvocation or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExternalComputeQueuePropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExternalComputeQueuePropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.externalDataSize = t.externalDataSize or 0
		_pool.maxExternalQueues = t.maxExternalQueues or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CommandPool(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCommandPoolCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags ~= nil and mod.e.VkCommandPoolCreateFlagBits(t.flags) or 0
		_pool.queueFamilyIndex = t.queueFamilyIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderSubgroupUniformControlFlow = t.shaderSubgroupUniformControlFlow or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCooperativeVectorFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCooperativeVectorFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.cooperativeVector = t.cooperativeVector or 0
		_pool.cooperativeVectorTraining = t.cooperativeVectorTraining or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CommandBufferInheritance(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCommandBufferInheritanceInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.renderPass = t.renderPass or 0
		_pool.subpass = t.subpass or 0
		_pool.framebuffer = t.framebuffer or 0
		_pool.occlusionQueryEnable = t.occlusionQueryEnable or 0
		_pool.queryFlags = t.queryFlags ~= nil and mod.e.VkQueryControlFlagBits(t.queryFlags) or 0
		_pool.pipelineStatistics = t.pipelineStatistics ~= nil and
			mod.e.VkQueryPipelineStatisticFlagBits(t.pipelineStatistics) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCooperativeMatrixFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCooperativeMatrixFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.cooperativeMatrix = t.cooperativeMatrix or 0
		_pool.cooperativeMatrixRobustBufferAccess = t.cooperativeMatrixRobustBufferAccess or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CooperativeVectorPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCooperativeVectorPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.inputType = t.inputType ~= nil and mod.e.VkComponentTypeKHR(t.inputType) or 0
		_pool.inputInterpretation = t.inputInterpretation ~= nil and
			mod.e.VkComponentTypeKHR(t.inputInterpretation) or
			0
		_pool.matrixInterpretation = t.matrixInterpretation ~= nil and
			mod.e.VkComponentTypeKHR(t.matrixInterpretation) or
			0
		_pool.biasInterpretation = t.biasInterpretation ~= nil and
			mod.e.VkComponentTypeKHR(t.biasInterpretation) or
			0
		_pool.resultType = t.resultType ~= nil and mod.e.VkComponentTypeKHR(t.resultType) or 0
		_pool.transpose = t.transpose or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceAccelerationStructurePropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceAccelerationStructurePropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxGeometryCount = t.maxGeometryCount or 0
		_pool.maxInstanceCount = t.maxInstanceCount or 0
		_pool.maxPrimitiveCount = t.maxPrimitiveCount or 0
		_pool.maxPerStageDescriptorAccelerationStructures = t.maxPerStageDescriptorAccelerationStructures or 0
		_pool.maxPerStageDescriptorUpdateAfterBindAccelerationStructures = t.maxPerStageDescriptorUpdateAfterBindAccelerationStructures or 0
		_pool.maxDescriptorSetAccelerationStructures = t.maxDescriptorSetAccelerationStructures or 0
		_pool.maxDescriptorSetUpdateAfterBindAccelerationStructures = t.maxDescriptorSetUpdateAfterBindAccelerationStructures or 0
		_pool.minAccelerationStructureScratchOffsetAlignment = t.minAccelerationStructureScratchOffsetAlignment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCooperativeMatrixPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCooperativeMatrixPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.cooperativeMatrixSupportedStages = t.cooperativeMatrixSupportedStages ~= nil and
			mod.e.VkShaderStageFlagBits(t.cooperativeMatrixSupportedStages) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRayTracingValidationFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRayTracingValidationFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.rayTracingValidation = t.rayTracingValidation or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoProfileListInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoProfileListInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.profileCount = t.profileCount or 0
		_pool.pProfiles = t.pProfiles or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.workgroupMemoryExplicitLayout = t.workgroupMemoryExplicitLayout or 0
		_pool.workgroupMemoryExplicitLayoutScalarBlockLayout = t.workgroupMemoryExplicitLayoutScalarBlockLayout or 0
		_pool.workgroupMemoryExplicitLayout8BitAccess = t.workgroupMemoryExplicitLayout8BitAccess or 0
		_pool.workgroupMemoryExplicitLayout16BitAccess = t.workgroupMemoryExplicitLayout16BitAccess or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ClusterAccelerationStructureMoveObjectsInputNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkClusterAccelerationStructureMoveObjectsInputNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type ~= nil and mod.e.VkClusterAccelerationStructureTypeNV(t.type) or 0
		_pool.noMoveOverlap = t.noMoveOverlap or 0
		_pool.maxMovedBytes = t.maxMovedBytes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ConvertCooperativeVectorMatrixInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkConvertCooperativeVectorMatrixInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.srcSize = t.srcSize or 0

		if t.srcData ~= nil then
			if type(t.srcData) == "table" then
				_pool.srcData = mod.VkDeviceOrHostAddressConstKHR(t.srcData)
			else
				_pool.srcData = t.srcData
			end
		else
			_pool.srcData = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.pDstSize = t.pDstSize or 0

		if t.dstData ~= nil then
			if type(t.dstData) == "table" then
				_pool.dstData = mod.VkDeviceOrHostAddressKHR(t.dstData)
			else
				_pool.dstData = t.dstData
			end
		else
			_pool.dstData = mod.VkDeviceOrHostAddressKHR()
		end

		_pool.srcComponentType = t.srcComponentType ~= nil and mod.e.VkComponentTypeKHR(t.srcComponentType) or 0
		_pool.dstComponentType = t.dstComponentType ~= nil and mod.e.VkComponentTypeKHR(t.dstComponentType) or 0
		_pool.numRows = t.numRows or 0
		_pool.numColumns = t.numColumns or 0
		_pool.srcLayout = t.srcLayout ~= nil and mod.e.VkCooperativeVectorMatrixLayoutNV(t.srcLayout) or 0
		_pool.srcStride = t.srcStride or 0
		_pool.dstLayout = t.dstLayout ~= nil and mod.e.VkCooperativeVectorMatrixLayoutNV(t.dstLayout) or 0
		_pool.dstStride = t.dstStride or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMultiDrawFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMultiDrawFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.multiDraw = t.multiDraw or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceComputeShaderDerivativesFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.computeDerivativeGroupQuads = t.computeDerivativeGroupQuads or 0
		_pool.computeDerivativeGroupLinear = t.computeDerivativeGroupLinear or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceImageViewMinLodFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceImageViewMinLodFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.minLod = t.minLod or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX")
		end

		_pool.pNext = t.pNext or nil
		_pool.perViewPositionAllComponents = t.perViewPositionAllComponents or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceComputeShaderDerivativesPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.meshAndTaskShaderDerivatives = t.meshAndTaskShaderDerivatives or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MultiviewPerViewAttributesInfoNVX(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMultiviewPerViewAttributesInfoNVX)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX")
		end

		_pool.pNext = t.pNext or nil
		_pool.perViewAttributes = t.perViewAttributes or 0
		_pool.perViewAttributesPositionXOnly = t.perViewAttributesPositionXOnly or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureBuildSizesInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureBuildSizesInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.accelerationStructureSize = t.accelerationStructureSize or 0
		_pool.updateScratchSize = t.updateScratchSize or 0
		_pool.buildScratchSize = t.buildScratchSize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePartitionedAccelerationStructureFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.partitionedAccelerationStructure = t.partitionedAccelerationStructure or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePartitionedAccelerationStructurePropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.maxPartitionCount = t.maxPartitionCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PartitionedAccelerationStructureFlagsNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPartitionedAccelerationStructureFlagsNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.enablePartitionTranslation = t.enablePartitionTranslation or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeRgbConversionCapabilitiesVALVE(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeRgbConversionCapabilitiesVALVE)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE")
		end

		_pool.pNext = t.pNext or nil
		_pool.rgbModels = t.rgbModels or 0
		_pool.rgbRanges = t.rgbRanges or 0
		_pool.xChromaOffsets = t.xChromaOffsets or 0
		_pool.yChromaOffsets = t.yChromaOffsets or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PartitionedAccelerationStructureInstancesInputNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPartitionedAccelerationStructureInstancesInputNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.instanceCount = t.instanceCount or 0
		_pool.maxInstancePerPartitionCount = t.maxInstancePerPartitionCount or 0
		_pool.partitionCount = t.partitionCount or 0
		_pool.maxInstanceInGlobalPartitionCount = t.maxInstanceInGlobalPartitionCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GeneratedCommandsMemoryRequirementsInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGeneratedCommandsMemoryRequirementsInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineBindPoint = t.pipelineBindPoint ~= nil and
			mod.e.VkPipelineBindPoint(t.pipelineBindPoint) or
			0
		_pool.pipeline = t.pipeline or 0
		_pool.indirectCommandsLayout = t.indirectCommandsLayout or 0
		_pool.maxSequencesCount = t.maxSequencesCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.IndirectCommandsLayoutCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkIndirectCommandsLayoutCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.shaderStages = t.shaderStages ~= nil and mod.e.VkShaderStageFlagBits(t.shaderStages) or 0
		_pool.indirectStride = t.indirectStride or 0
		_pool.pipelineLayout = t.pipelineLayout or 0
		_pool.tokenCount = t.tokenCount or 0
		_pool.pTokens = t.pTokens or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GeneratedCommandsPipelineInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGeneratedCommandsPipelineInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipeline = t.pipeline or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.dstBuffer = t.dstBuffer or 0
		_pool.dstBufferOffset = t.dstBufferOffset or 0
		_pool.dstBufferRange = t.dstBufferRange or 0

		if t.srcPictureResource ~= nil then
			if type(t.srcPictureResource) == "table" then
				_pool.srcPictureResource = mod.s.VideoPictureResourceInfoKHR(t.srcPictureResource)
			else
				_pool.srcPictureResource = t.srcPictureResource
			end
		else
			_pool.srcPictureResource = mod.VkVideoPictureResourceInfoKHR()
		end

		_pool.pSetupReferenceSlot = t.pSetupReferenceSlot or 0
		_pool.referenceSlotCount = t.referenceSlotCount or 0
		_pool.pReferenceSlots = t.pReferenceSlots or 0
		_pool.precedingExternallyEncodedBytes = t.precedingExternallyEncodedBytes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil

		if t.fragmentDensityOffsetGranularity ~= nil then
			if type(t.fragmentDensityOffsetGranularity) == "table" then
				_pool.fragmentDensityOffsetGranularity = mod.VkExtent2D(t.fragmentDensityOffsetGranularity)
			else
				_pool.fragmentDensityOffsetGranularity = t.fragmentDensityOffsetGranularity
			end
		else
			_pool.fragmentDensityOffsetGranularity = mod.VkExtent2D()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceImageAlignmentControlFeaturesMESA(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceImageAlignmentControlFeaturesMESA)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA")
		end

		_pool.pNext = t.pNext or nil
		_pool.imageAlignmentControl = t.imageAlignmentControl or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageAlignmentControlCreateInfoMESA(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageAlignmentControlCreateInfoMESA)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA")
		end

		_pool.pNext = t.pNext or nil
		_pool.maximumRequestedAlignment = t.maximumRequestedAlignment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassFragmentDensityMapOffsetEndInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassFragmentDensityMapOffsetEndInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.fragmentDensityOffsetCount = t.fragmentDensityOffsetCount or 0
		_pool.pFragmentDensityOffsets = t.pFragmentDensityOffsets or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeCapabilitiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeCapabilitiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.rateControlModes = t.rateControlModes or 0
		_pool.maxRateControlLayers = t.maxRateControlLayers or 0
		_pool.maxBitrate = t.maxBitrate or 0
		_pool.maxQualityLevels = t.maxQualityLevels or 0

		if t.encodeInputPictureGranularity ~= nil then
			if type(t.encodeInputPictureGranularity) == "table" then
				_pool.encodeInputPictureGranularity = mod.VkExtent2D(t.encodeInputPictureGranularity)
			else
				_pool.encodeInputPictureGranularity = t.encodeInputPictureGranularity
			end
		else
			_pool.encodeInputPictureGranularity = mod.VkExtent2D()
		end

		_pool.supportedEncodeFeedbackFlags = t.supportedEncodeFeedbackFlags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.extendedSparseAddressSpace = t.extendedSparseAddressSpace or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.HdrVividDynamicMetadataHUAWEI(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkHdrVividDynamicMetadataHUAWEI)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI")
		end

		_pool.pNext = t.pNext or nil
		_pool.dynamicMetadataSize = t.dynamicMetadataSize or 0
		_pool.pDynamicMetadata = t.pDynamicMetadata or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineViewportSwizzleStateCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineViewportSwizzleStateCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.viewportCount = t.viewportCount or 0
		_pool.pViewportSwizzles = t.pViewportSwizzles or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFormatPackFeaturesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFormatPackFeaturesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.formatPack = t.formatPack or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE")
		end

		_pool.pNext = t.pNext or nil
		_pool.fragmentDensityMapLayered = t.fragmentDensityMapLayered or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderingEndInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderingEndInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueryPoolVideoEncodeFeedbackCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.encodeFeedbackFlags = t.encodeFeedbackFlags or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCopyMemoryIndirectFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.indirectCopy = t.indirectCopy or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeUsageInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeUsageInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.videoUsageHints = t.videoUsageHints or 0
		_pool.videoContentHints = t.videoContentHints or 0
		_pool.tuningMode = t.tuningMode ~= nil and mod.e.VkVideoEncodeTuningModeKHR(t.tuningMode) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AccelerationStructureGeometryAabbsDataKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAccelerationStructureGeometryAabbsDataKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR")
		end

		_pool.pNext = t.pNext or nil

		if t.data ~= nil then
			if type(t.data) == "table" then
				_pool.data = mod.VkDeviceOrHostAddressConstKHR(t.data)
			else
				_pool.data = t.data
			end
		else
			_pool.data = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.stride = t.stride or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ClusterAccelerationStructureInputInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkClusterAccelerationStructureInputInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxAccelerationStructureCount = t.maxAccelerationStructureCount or 0
		_pool.flags = t.flags or 0
		_pool.opType = t.opType ~= nil and mod.e.VkClusterAccelerationStructureOpTypeNV(t.opType) or 0
		_pool.opMode = t.opMode ~= nil and mod.e.VkClusterAccelerationStructureOpModeNV(t.opMode) or 0

		if t.opInput ~= nil then
			if type(t.opInput) == "table" then
				_pool.opInput = mod.VkClusterAccelerationStructureOpInputNV(t.opInput)
			else
				_pool.opInput = t.opInput
			end
		else
			_pool.opInput = mod.VkClusterAccelerationStructureOpInputNV()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeRateControlLayerInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeRateControlLayerInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.averageBitrate = t.averageBitrate or 0
		_pool.maxBitrate = t.maxBitrate or 0
		_pool.frameRateNumerator = t.frameRateNumerator or 0
		_pool.frameRateDenominator = t.frameRateDenominator or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDiscardRectanglePropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDiscardRectanglePropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxDiscardRectangles = t.maxDiscardRectangles or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ClusterAccelerationStructureTriangleClusterInputNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkClusterAccelerationStructureTriangleClusterInputNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.vertexFormat = t.vertexFormat ~= nil and mod.e.VkFormat(t.vertexFormat) or 0
		_pool.maxGeometryIndexValue = t.maxGeometryIndexValue or 0
		_pool.maxClusterUniqueGeometryCount = t.maxClusterUniqueGeometryCount or 0
		_pool.maxClusterTriangleCount = t.maxClusterTriangleCount or 0
		_pool.maxClusterVertexCount = t.maxClusterVertexCount or 0
		_pool.maxTotalTriangleCount = t.maxTotalTriangleCount or 0
		_pool.maxTotalVertexCount = t.maxTotalVertexCount or 0
		_pool.minPositionTruncateBitCount = t.minPositionTruncateBitCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineDiscardRectangleStateCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineDiscardRectangleStateCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.discardRectangleMode = t.discardRectangleMode ~= nil and
			mod.e.VkDiscardRectangleModeEXT(t.discardRectangleMode) or
			0
		_pool.discardRectangleCount = t.discardRectangleCount or 0
		_pool.pDiscardRectangles = t.pDiscardRectangles or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeRateControlInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeRateControlInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.rateControlMode = t.rateControlMode ~= nil and
			mod.e.VkVideoEncodeRateControlModeFlagBitsKHR(t.rateControlMode) or
			0
		_pool.layerCount = t.layerCount or 0
		_pool.pLayers = t.pLayers or 0
		_pool.virtualBufferSizeInMs = t.virtualBufferSizeInMs or 0
		_pool.initialVirtualBufferSizeInMs = t.initialVirtualBufferSizeInMs or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVulkanMemoryModelFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVulkanMemoryModelFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.vulkanMemoryModel = t.vulkanMemoryModel or 0
		_pool.vulkanMemoryModelDeviceScope = t.vulkanMemoryModelDeviceScope or 0
		_pool.vulkanMemoryModelAvailabilityVisibilityChains = t.vulkanMemoryModelAvailabilityVisibilityChains or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.HostImageCopyDevicePerformanceQuery(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkHostImageCopyDevicePerformanceQuery)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY")
		end

		_pool.pNext = t.pNext or nil
		_pool.optimalDeviceAccess = t.optimalDeviceAccess or 0
		_pool.identicalMemoryLayout = t.identicalMemoryLayout or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.QueueFamilyDataGraphProcessingEnginePropertiesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkQueueFamilyDataGraphProcessingEnginePropertiesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.foreignSemaphoreHandleTypes = t.foreignSemaphoreHandleTypes ~= nil and
			mod.e.VkExternalSemaphoreHandleTypeFlagBits(t.foreignSemaphoreHandleTypes) or
			0
		_pool.foreignMemoryHandleTypes = t.foreignMemoryHandleTypes ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.foreignMemoryHandleTypes) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTimelineSemaphoreFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTimelineSemaphoreFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.timelineSemaphore = t.timelineSemaphore or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceVideoEncodeQualityLevelInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pVideoProfile = t.pVideoProfile or 0
		_pool.qualityLevel = t.qualityLevel or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCustomBorderColorFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCustomBorderColorFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.customBorderColors = t.customBorderColors or 0
		_pool.customBorderColorWithoutFormat = t.customBorderColorWithoutFormat or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeQualityLevelPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeQualityLevelPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.preferredRateControlMode = t.preferredRateControlMode ~= nil and
			mod.e.VkVideoEncodeRateControlModeFlagBitsKHR(t.preferredRateControlMode) or
			0
		_pool.preferredRateControlLayerCount = t.preferredRateControlLayerCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageViewCaptureDescriptorDataInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageViewCaptureDescriptorDataInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.imageView = t.imageView or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceGroupDevice(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceGroupDeviceCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.physicalDeviceCount = t.physicalDeviceCount or 0
		_pool.pPhysicalDevices = t.pPhysicalDevices or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeQualityLevelInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeQualityLevelInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.qualityLevel = t.qualityLevel or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMemoryDecompressionFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMemoryDecompressionFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.memoryDecompression = t.memoryDecompression or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeSessionParametersFeedbackInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeSessionParametersFeedbackInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.hasOverrides = t.hasOverrides or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMemoryDecompressionPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMemoryDecompressionPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.decompressionMethods = t.decompressionMethods or 0
		_pool.maxDecompressionIndirectCount = t.maxDecompressionIndirectCount or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyMicromapInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyMicromapInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.src = t.src or 0
		_pool.dst = t.dst or 0
		_pool.mode = t.mode ~= nil and mod.e.VkCopyMicromapModeEXT(t.mode) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExclusiveScissorFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExclusiveScissorFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.exclusiveScissor = t.exclusiveScissor or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TensorCaptureDescriptorDataInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTensorCaptureDescriptorDataInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tensor = t.tensor or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalComputeQueueCreateInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalComputeQueueCreateInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.preferredQueue = t.preferredQueue or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BufferOpaqueCaptureAddress(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBufferOpaqueCaptureAddressCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.opaqueCaptureAddress = t.opaqueCaptureAddress or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceHostQueryResetFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceHostQueryResetFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.hostQueryReset = t.hostQueryReset or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceConservativeRasterizationPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceConservativeRasterizationPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.primitiveOverestimationSize = t.primitiveOverestimationSize or 0
		_pool.maxExtraPrimitiveOverestimationSize = t.maxExtraPrimitiveOverestimationSize or 0
		_pool.extraPrimitiveOverestimationSizeGranularity = t.extraPrimitiveOverestimationSizeGranularity or 0
		_pool.primitiveUnderestimation = t.primitiveUnderestimation or 0
		_pool.conservativePointAndLineRasterization = t.conservativePointAndLineRasterization or 0
		_pool.degenerateTrianglesRasterized = t.degenerateTrianglesRasterized or 0
		_pool.degenerateLinesRasterized = t.degenerateLinesRasterized or 0
		_pool.fullyCoveredFragmentShaderInputVariable = t.fullyCoveredFragmentShaderInputVariable or 0
		_pool.conservativeRasterizationPostDepthCoverage = t.conservativeRasterizationPostDepthCoverage or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineBinaryInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineBinaryInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.binaryCount = t.binaryCount or 0
		_pool.pPipelineBinaries = t.pPipelineBinaries or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderUntypedPointersFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderUntypedPointers = t.shaderUntypedPointers or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SwapchainCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSwapchainCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.surface = t.surface or 0
		_pool.minImageCount = t.minImageCount or 0
		_pool.imageFormat = t.imageFormat ~= nil and mod.e.VkFormat(t.imageFormat) or 0
		_pool.imageColorSpace = t.imageColorSpace ~= nil and mod.e.VkColorSpaceKHR(t.imageColorSpace) or 0

		if t.imageExtent ~= nil then
			if type(t.imageExtent) == "table" then
				_pool.imageExtent = mod.VkExtent2D(t.imageExtent)
			else
				_pool.imageExtent = t.imageExtent
			end
		else
			_pool.imageExtent = mod.VkExtent2D()
		end

		_pool.imageArrayLayers = t.imageArrayLayers or 0
		_pool.imageUsage = t.imageUsage ~= nil and mod.e.VkImageUsageFlagBits(t.imageUsage) or 0
		_pool.imageSharingMode = t.imageSharingMode ~= nil and mod.e.VkSharingMode(t.imageSharingMode) or 0
		_pool.queueFamilyIndexCount = t.queueFamilyIndexCount or 0
		_pool.pQueueFamilyIndices = t.pQueueFamilyIndices or 0
		_pool.preTransform = t.preTransform ~= nil and
			mod.e.VkSurfaceTransformFlagBitsKHR(t.preTransform) or
			0
		_pool.compositeAlpha = t.compositeAlpha ~= nil and
			mod.e.VkCompositeAlphaFlagBitsKHR(t.compositeAlpha) or
			0
		_pool.presentMode = t.presentMode ~= nil and mod.e.VkPresentModeKHR(t.presentMode) or 0
		_pool.clipped = t.clipped or 0
		_pool.oldSwapchain = t.oldSwapchain or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceInvocationMaskFeaturesHUAWEI(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI")
		end

		_pool.pNext = t.pNext or nil
		_pool.invocationMask = t.invocationMask or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceHostImageCopyFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceHostImageCopyFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.hostImageCopy = t.hostImageCopy or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ReleaseCapturedPipelineDataInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkReleaseCapturedPipelineDataInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipeline = t.pipeline or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceGeneratedCompute = t.deviceGeneratedCompute or 0
		_pool.deviceGeneratedComputePipelines = t.deviceGeneratedComputePipelines or 0
		_pool.deviceGeneratedComputeCaptureReplay = t.deviceGeneratedComputeCaptureReplay or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SamplerReductionMode(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSamplerReductionModeCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.reductionMode = t.reductionMode ~= nil and mod.e.VkSamplerReductionMode(t.reductionMode) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDescriptorIndexingProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDescriptorIndexingProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxUpdateAfterBindDescriptorsInAllPools = t.maxUpdateAfterBindDescriptorsInAllPools or 0
		_pool.shaderUniformBufferArrayNonUniformIndexingNative = t.shaderUniformBufferArrayNonUniformIndexingNative or 0
		_pool.shaderSampledImageArrayNonUniformIndexingNative = t.shaderSampledImageArrayNonUniformIndexingNative or 0
		_pool.shaderStorageBufferArrayNonUniformIndexingNative = t.shaderStorageBufferArrayNonUniformIndexingNative or 0
		_pool.shaderStorageImageArrayNonUniformIndexingNative = t.shaderStorageImageArrayNonUniformIndexingNative or 0
		_pool.shaderInputAttachmentArrayNonUniformIndexingNative = t.shaderInputAttachmentArrayNonUniformIndexingNative or 0
		_pool.robustBufferAccessUpdateAfterBind = t.robustBufferAccessUpdateAfterBind or 0
		_pool.quadDivergentImplicitLod = t.quadDivergentImplicitLod or 0
		_pool.maxPerStageDescriptorUpdateAfterBindSamplers = t.maxPerStageDescriptorUpdateAfterBindSamplers or 0
		_pool.maxPerStageDescriptorUpdateAfterBindUniformBuffers = t.maxPerStageDescriptorUpdateAfterBindUniformBuffers or 0
		_pool.maxPerStageDescriptorUpdateAfterBindStorageBuffers = t.maxPerStageDescriptorUpdateAfterBindStorageBuffers or 0
		_pool.maxPerStageDescriptorUpdateAfterBindSampledImages = t.maxPerStageDescriptorUpdateAfterBindSampledImages or 0
		_pool.maxPerStageDescriptorUpdateAfterBindStorageImages = t.maxPerStageDescriptorUpdateAfterBindStorageImages or 0
		_pool.maxPerStageDescriptorUpdateAfterBindInputAttachments = t.maxPerStageDescriptorUpdateAfterBindInputAttachments or 0
		_pool.maxPerStageUpdateAfterBindResources = t.maxPerStageUpdateAfterBindResources or 0
		_pool.maxDescriptorSetUpdateAfterBindSamplers = t.maxDescriptorSetUpdateAfterBindSamplers or 0
		_pool.maxDescriptorSetUpdateAfterBindUniformBuffers = t.maxDescriptorSetUpdateAfterBindUniformBuffers or 0
		_pool.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = t.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic or 0
		_pool.maxDescriptorSetUpdateAfterBindStorageBuffers = t.maxDescriptorSetUpdateAfterBindStorageBuffers or 0
		_pool.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = t.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic or 0
		_pool.maxDescriptorSetUpdateAfterBindSampledImages = t.maxDescriptorSetUpdateAfterBindSampledImages or 0
		_pool.maxDescriptorSetUpdateAfterBindStorageImages = t.maxDescriptorSetUpdateAfterBindStorageImages or 0
		_pool.maxDescriptorSetUpdateAfterBindInputAttachments = t.maxDescriptorSetUpdateAfterBindInputAttachments or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineRasterizationConservativeStateCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineRasterizationConservativeStateCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.conservativeRasterizationMode = t.conservativeRasterizationMode ~= nil and
			mod.e.VkConservativeRasterizationModeEXT(t.conservativeRasterizationMode) or
			0
		_pool.extraPrimitiveOverestimationSize = t.extraPrimitiveOverestimationSize or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ComputePipelineIndirectBufferInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkComputePipelineIndirectBufferInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceAddress = t.deviceAddress or 0
		_pool.size = t.size or 0
		_pool.pipelineDeviceAddressCaptureReplay = t.pipelineDeviceAddressCaptureReplay or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryGetRemoteAddressInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryGetRemoteAddressInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.memory = t.memory or 0
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineIndirectDeviceAddressInfoNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineIndirectDeviceAddressInfoNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineBindPoint = t.pipelineBindPoint ~= nil and
			mod.e.VkPipelineBindPoint(t.pipelineBindPoint) or
			0
		_pool.pipeline = t.pipeline or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PresentInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPresentInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PRESENT_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.waitSemaphoreCount = t.waitSemaphoreCount or 0
		_pool.pWaitSemaphores = t.pWaitSemaphores or 0
		_pool.swapchainCount = t.swapchainCount or 0
		_pool.pSwapchains = t.pSwapchains or 0
		_pool.pImageIndices = t.pImageIndices or 0
		_pool.pResults = t.pResults or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentShadingRateFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentShadingRateFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineFragmentShadingRate = t.pipelineFragmentShadingRate or 0
		_pool.primitiveFragmentShadingRate = t.primitiveFragmentShadingRate or 0
		_pool.attachmentFragmentShadingRate = t.attachmentFragmentShadingRate or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineBinaryDataInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineBinaryDataInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineBinary = t.pipelineBinary or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineTessellationState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineTessellationStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.patchControlPoints = t.patchControlPoints or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDepthClipEnableFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDepthClipEnableFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.depthClipEnable = t.depthClipEnable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageSwapchainCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageSwapchainCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.swapchain = t.swapchain or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineRasterizationDepthClipStateCreateInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineRasterizationDepthClipStateCreateInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.depthClipEnable = t.depthClipEnable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BindImageMemorySwapchainInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBindImageMemorySwapchainInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.swapchain = t.swapchain or 0
		_pool.imageIndex = t.imageIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceSamplerFilterMinmaxProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceSamplerFilterMinmaxProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.filterMinmaxSingleComponentFormats = t.filterMinmaxSingleComponentFormats or 0
		_pool.filterMinmaxImageComponentMapping = t.filterMinmaxImageComponentMapping or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.AcquireNextImageInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkAcquireNextImageInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.swapchain = t.swapchain or 0
		_pool.timeout = t.timeout or 0
		_pool.semaphore = t.semaphore or 0
		_pool.fence = t.fence or 0
		_pool.deviceMask = t.deviceMask or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceGroupPresentCapabilitiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceGroupPresentCapabilitiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.presentMask = t.presentMask or 0
		_pool.modes = t.modes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePipelinePropertiesFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePipelinePropertiesFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelinePropertiesIdentifier = t.pipelinePropertiesIdentifier or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderSubgroupExtendedTypesFeatures(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderSubgroupExtendedTypes = t.shaderSubgroupExtendedTypes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DeviceGroupPresentInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDeviceGroupPresentInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.swapchainCount = t.swapchainCount or 0
		_pool.pDeviceMasks = t.pDeviceMasks or 0
		_pool.mode = t.mode ~= nil and mod.e.VkDeviceGroupPresentModeFlagBitsKHR(t.mode) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderMaximalReconvergence = t.shaderMaximalReconvergence or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.HdrMetadataEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkHdrMetadataEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_HDR_METADATA_EXT")
		end

		_pool.pNext = t.pNext or nil

		if t.displayPrimaryRed ~= nil then
			if type(t.displayPrimaryRed) == "table" then
				_pool.displayPrimaryRed = mod.VkXYColorEXT(t.displayPrimaryRed)
			else
				_pool.displayPrimaryRed = t.displayPrimaryRed
			end
		else
			_pool.displayPrimaryRed = mod.VkXYColorEXT()
		end

		if t.displayPrimaryGreen ~= nil then
			if type(t.displayPrimaryGreen) == "table" then
				_pool.displayPrimaryGreen = mod.VkXYColorEXT(t.displayPrimaryGreen)
			else
				_pool.displayPrimaryGreen = t.displayPrimaryGreen
			end
		else
			_pool.displayPrimaryGreen = mod.VkXYColorEXT()
		end

		if t.displayPrimaryBlue ~= nil then
			if type(t.displayPrimaryBlue) == "table" then
				_pool.displayPrimaryBlue = mod.VkXYColorEXT(t.displayPrimaryBlue)
			else
				_pool.displayPrimaryBlue = t.displayPrimaryBlue
			end
		else
			_pool.displayPrimaryBlue = mod.VkXYColorEXT()
		end

		if t.whitePoint ~= nil then
			if type(t.whitePoint) == "table" then
				_pool.whitePoint = mod.VkXYColorEXT(t.whitePoint)
			else
				_pool.whitePoint = t.whitePoint
			end
		else
			_pool.whitePoint = mod.VkXYColorEXT()
		end

		_pool.maxLuminance = t.maxLuminance or 0
		_pool.minLuminance = t.minLuminance or 0
		_pool.maxContentLightLevel = t.maxContentLightLevel or 0
		_pool.maxFrameAverageLightLevel = t.maxFrameAverageLightLevel or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineRasterizationState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineRasterizationStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.depthClampEnable = t.depthClampEnable or 0
		_pool.rasterizerDiscardEnable = t.rasterizerDiscardEnable or 0
		_pool.polygonMode = t.polygonMode ~= nil and mod.e.VkPolygonMode(t.polygonMode) or 0
		_pool.cullMode = t.cullMode ~= nil and mod.e.VkCullModeFlagBits(t.cullMode) or 0
		_pool.frontFace = t.frontFace ~= nil and mod.e.VkFrontFace(t.frontFace) or 0
		_pool.depthBiasEnable = t.depthBiasEnable or 0
		_pool.depthBiasConstantFactor = t.depthBiasConstantFactor or 0
		_pool.depthBiasClamp = t.depthBiasClamp or 0
		_pool.depthBiasSlopeFactor = t.depthBiasSlopeFactor or 0
		_pool.lineWidth = t.lineWidth or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyMemoryToImageIndirectInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyMemoryToImageIndirectInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.srcCopyFlags = t.srcCopyFlags or 0
		_pool.copyCount = t.copyCount or 0

		if t.copyAddressRange ~= nil then
			if type(t.copyAddressRange) == "table" then
				_pool.copyAddressRange = mod.VkStridedDeviceAddressRangeKHR(t.copyAddressRange)
			else
				_pool.copyAddressRange = t.copyAddressRange
			end
		else
			_pool.copyAddressRange = mod.VkStridedDeviceAddressRangeKHR()
		end

		_pool.dstImage = t.dstImage or 0
		_pool.dstImageLayout = t.dstImageLayout ~= nil and mod.e.VkImageLayout(t.dstImageLayout) or 0
		_pool.pImageSubresources = t.pImageSubresources or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceCopyMemoryIndirectPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.supportedQueues = t.supportedQueues ~= nil and mod.e.VkQueueFlagBits(t.supportedQueues) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeIntraRefreshInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeIntraRefreshInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.intraRefreshCycleDuration = t.intraRefreshCycleDuration or 0
		_pool.intraRefreshIndex = t.intraRefreshIndex or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.FilterCubicImageViewImageFormatPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkFilterCubicImageViewImageFormatPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.filterCubic = t.filterCubic or 0
		_pool.filterCubicMinmax = t.filterCubicMinmax or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceExternalMemoryHostPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceExternalMemoryHostPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.minImportedHostPointerAlignment = t.minImportedHostPointerAlignment or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.TensorMemoryBarrierARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkTensorMemoryBarrierARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.srcStageMask = t.srcStageMask or 0
		_pool.srcAccessMask = t.srcAccessMask or 0
		_pool.dstStageMask = t.dstStageMask or 0
		_pool.dstAccessMask = t.dstAccessMask or 0
		_pool.srcQueueFamilyIndex = t.srcQueueFamilyIndex or 0
		_pool.dstQueueFamilyIndex = t.dstQueueFamilyIndex or 0
		_pool.tensor = t.tensor or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFrameBoundaryFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFrameBoundaryFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.frameBoundary = t.frameBoundary or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DescriptorGetTensorInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDescriptorGetTensorInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tensorView = t.tensorView or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceShaderClockFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceShaderClockFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.shaderSubgroupClock = t.shaderSubgroupClock or 0
		_pool.shaderDeviceClock = t.shaderDeviceClock or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineMultisampleState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineMultisampleStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.rasterizationSamples = t.rasterizationSamples ~= nil and
			mod.e.VkSampleCountFlagBits(t.rasterizationSamples) or
			0
		_pool.sampleShadingEnable = t.sampleShadingEnable or 0
		_pool.minSampleShading = t.minSampleShading or 0
		_pool.pSampleMask = t.pSampleMask or 0
		_pool.alphaToCoverageEnable = t.alphaToCoverageEnable or 0
		_pool.alphaToOneEnable = t.alphaToOneEnable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMeshShaderFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMeshShaderFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.taskShader = t.taskShader or 0
		_pool.meshShader = t.meshShader or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMeshShaderPropertiesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMeshShaderPropertiesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxDrawMeshTasksCount = t.maxDrawMeshTasksCount or 0
		_pool.maxTaskWorkGroupInvocations = t.maxTaskWorkGroupInvocations or 0
		_pool.maxTaskWorkGroupSize = t.maxTaskWorkGroupSize or 0
		_pool.maxTaskTotalMemorySize = t.maxTaskTotalMemorySize or 0
		_pool.maxTaskOutputCount = t.maxTaskOutputCount or 0
		_pool.maxMeshWorkGroupInvocations = t.maxMeshWorkGroupInvocations or 0
		_pool.maxMeshWorkGroupSize = t.maxMeshWorkGroupSize or 0
		_pool.maxMeshTotalMemorySize = t.maxMeshTotalMemorySize or 0
		_pool.maxMeshOutputVertices = t.maxMeshOutputVertices or 0
		_pool.maxMeshOutputPrimitives = t.maxMeshOutputPrimitives or 0
		_pool.maxMeshMultiviewViewCount = t.maxMeshMultiviewViewCount or 0
		_pool.meshOutputPerVertexGranularity = t.meshOutputPerVertexGranularity or 0
		_pool.meshOutputPerPrimitiveGranularity = t.meshOutputPerPrimitiveGranularity or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MicromapBuildInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMicromapBuildInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.type = t.type ~= nil and mod.e.VkMicromapTypeEXT(t.type) or 0
		_pool.flags = t.flags or 0
		_pool.mode = t.mode ~= nil and mod.e.VkBuildMicromapModeEXT(t.mode) or 0
		_pool.dstMicromap = t.dstMicromap or 0
		_pool.usageCountsCount = t.usageCountsCount or 0
		_pool.pUsageCounts = t.pUsageCounts or 0
		_pool.ppUsageCounts = t.ppUsageCounts or 0

		if t.data ~= nil then
			if type(t.data) == "table" then
				_pool.data = mod.VkDeviceOrHostAddressConstKHR(t.data)
			else
				_pool.data = t.data
			end
		else
			_pool.data = mod.VkDeviceOrHostAddressConstKHR()
		end

		if t.scratchData ~= nil then
			if type(t.scratchData) == "table" then
				_pool.scratchData = mod.VkDeviceOrHostAddressKHR(t.scratchData)
			else
				_pool.scratchData = t.scratchData
			end
		else
			_pool.scratchData = mod.VkDeviceOrHostAddressKHR()
		end

		if t.triangleArray ~= nil then
			if type(t.triangleArray) == "table" then
				_pool.triangleArray = mod.VkDeviceOrHostAddressConstKHR(t.triangleArray)
			else
				_pool.triangleArray = t.triangleArray
			end
		else
			_pool.triangleArray = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.triangleArrayStride = t.triangleArrayStride or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceRelaxedLineRasterizationFeaturesIMG(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG")
		end

		_pool.pNext = t.pNext or nil
		_pool.relaxedLineRasterization = t.relaxedLineRasterization or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMapMemoryPlacedFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.memoryMapPlaced = t.memoryMapPlaced or 0
		_pool.memoryMapRangePlaced = t.memoryMapRangePlaced or 0
		_pool.memoryUnmapReserve = t.memoryUnmapReserve or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.multisampledRenderToSingleSampled = t.multisampledRenderToSingleSampled or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceOpacityMicromapPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceOpacityMicromapPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.maxOpacity2StateSubdivisionLevel = t.maxOpacity2StateSubdivisionLevel or 0
		_pool.maxOpacity4StateSubdivisionLevel = t.maxOpacity4StateSubdivisionLevel or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SubpassResolvePerformanceQueryEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSubpassResolvePerformanceQueryEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.optimal = t.optimal or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyMicromapToMemoryInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyMicromapToMemoryInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.src = t.src or 0

		if t.dst ~= nil then
			if type(t.dst) == "table" then
				_pool.dst = mod.VkDeviceOrHostAddressKHR(t.dst)
			else
				_pool.dst = t.dst
			end
		else
			_pool.dst = mod.VkDeviceOrHostAddressKHR()
		end

		_pool.mode = t.mode ~= nil and mod.e.VkCopyMicromapModeEXT(t.mode) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MultisampledRenderToSingleSampledInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMultisampledRenderToSingleSampledInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.multisampledRenderToSingleSampledEnable = t.multisampledRenderToSingleSampledEnable or 0
		_pool.rasterizationSamples = t.rasterizationSamples ~= nil and
			mod.e.VkSampleCountFlagBits(t.rasterizationSamples) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.CopyMemoryToMicromapInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkCopyMemoryToMicromapInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil

		if t.src ~= nil then
			if type(t.src) == "table" then
				_pool.src = mod.VkDeviceOrHostAddressConstKHR(t.src)
			else
				_pool.src = t.src
			end
		else
			_pool.src = mod.VkDeviceOrHostAddressConstKHR()
		end

		_pool.dst = t.dst or 0
		_pool.mode = t.mode ~= nil and mod.e.VkCopyMicromapModeEXT(t.mode) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.BufferMemoryBarrier(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkBufferMemoryBarrier)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER")
		end

		_pool.pNext = t.pNext or nil
		_pool.srcAccessMask = t.srcAccessMask ~= nil and mod.e.VkAccessFlagBits(t.srcAccessMask) or 0
		_pool.dstAccessMask = t.dstAccessMask ~= nil and mod.e.VkAccessFlagBits(t.dstAccessMask) or 0
		_pool.srcQueueFamilyIndex = t.srcQueueFamilyIndex or 0
		_pool.dstQueueFamilyIndex = t.dstQueueFamilyIndex or 0
		_pool.buffer = t.buffer or 0
		_pool.offset = t.offset or 0
		_pool.size = t.size or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryGetFdInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryGetFdInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.memory = t.memory or 0
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImportMemoryFdInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImportMemoryFdInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType) or
			0
		_pool.fd = t.fd or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceTileShadingFeaturesQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceTileShadingFeaturesQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM")
		end

		_pool.pNext = t.pNext or nil
		_pool.tileShading = t.tileShading or 0
		_pool.tileShadingFragmentStage = t.tileShadingFragmentStage or 0
		_pool.tileShadingColorAttachments = t.tileShadingColorAttachments or 0
		_pool.tileShadingDepthAttachments = t.tileShadingDepthAttachments or 0
		_pool.tileShadingStencilAttachments = t.tileShadingStencilAttachments or 0
		_pool.tileShadingInputAttachments = t.tileShadingInputAttachments or 0
		_pool.tileShadingSampledAttachments = t.tileShadingSampledAttachments or 0
		_pool.tileShadingPerTileDraw = t.tileShadingPerTileDraw or 0
		_pool.tileShadingPerTileDispatch = t.tileShadingPerTileDispatch or 0
		_pool.tileShadingDispatchTile = t.tileShadingDispatchTile or 0
		_pool.tileShadingApron = t.tileShadingApron or 0
		_pool.tileShadingAnisotropicApron = t.tileShadingAnisotropicApron or 0
		_pool.tileShadingAtomicOps = t.tileShadingAtomicOps or 0
		_pool.tileShadingImageProcessing = t.tileShadingImageProcessing or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentShadingRateEnumsFeaturesNV(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV")
		end

		_pool.pNext = t.pNext or nil
		_pool.fragmentShadingRateEnums = t.fragmentShadingRateEnums or 0
		_pool.supersampleFragmentShadingRates = t.supersampleFragmentShadingRates or 0
		_pool.noInvocationFragmentShadingRates = t.noInvocationFragmentShadingRates or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDepthStencilResolveProperties(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDepthStencilResolveProperties)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES")
		end

		_pool.pNext = t.pNext or nil
		_pool.supportedDepthResolveModes = t.supportedDepthResolveModes ~= nil and
			mod.e.VkResolveModeFlagBits(t.supportedDepthResolveModes) or
			0
		_pool.supportedStencilResolveModes = t.supportedStencilResolveModes ~= nil and
			mod.e.VkResolveModeFlagBits(t.supportedStencilResolveModes) or
			0
		_pool.independentResolveNone = t.independentResolveNone or 0
		_pool.independentResolve = t.independentResolve or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDescriptorBufferTensorFeaturesARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.descriptorBufferTensorDescriptors = t.descriptorBufferTensorDescriptors or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.XlibSurfaceCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkXlibSurfaceCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.dpy = t.dpy or 0
		_pool.window = t.window or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryGetMetalHandleInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryGetMetalHandleInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.memory = t.memory or 0
		_pool.handleType = t.handleType ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.MemoryMetalHandlePropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkMemoryMetalHandlePropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.memoryTypeBits = t.memoryTypeBits or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExternalMemoryTensorCreateInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExternalMemoryTensorCreateInfoARM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM")
		end

		_pool.pNext = t.pNext or nil
		_pool.handleTypes = t.handleTypes ~= nil and
			mod.e.VkExternalMemoryHandleTypeFlagBits(t.handleTypes) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExportMetalSharedEventInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExportMetalSharedEventInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.semaphore = t.semaphore or 0
		_pool.event = t.event or 0
		_pool.mtlSharedEvent = t.mtlSharedEvent or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ExportMetalTextureInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkExportMetalTextureInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.image = t.image or 0
		_pool.imageView = t.imageView or 0
		_pool.bufferView = t.bufferView or 0
		_pool.plane = t.plane ~= nil and mod.e.VkImageAspectFlagBits(t.plane) or 0
		_pool.mtlTexture = t.mtlTexture or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PerTileBeginInfoQCOM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPerTileBeginInfoQCOM)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM")
		end

		_pool.pNext = t.pNext or nil
		return _pool
	end
end

do
	local _pool

	function mod.infos.DisplayNativeHdrSurfaceCapabilitiesAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDisplayNativeHdrSurfaceCapabilitiesAMD)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD")
		end

		_pool.pNext = t.pNext or nil
		_pool.localDimmingSupport = t.localDimmingSupport or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImportMetalBufferInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImportMetalBufferInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.mtlBuffer = t.mtlBuffer or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.SwapchainDisplayNativeHdrCreateInfoAMD(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkSwapchainDisplayNativeHdrCreateInfoAMD)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD")
		end

		_pool.pNext = t.pNext or nil
		_pool.localDimmingEnable = t.localDimmingEnable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderPassMultiview(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderPassMultiviewCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.subpassCount = t.subpassCount or 0
		_pool.pViewMasks = t.pViewMasks or 0
		_pool.dependencyCount = t.dependencyCount or 0
		_pool.pViewOffsets = t.pViewOffsets or 0
		_pool.correlationMaskCount = t.correlationMaskCount or 0
		_pool.pCorrelationMasks = t.pCorrelationMasks or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PipelineTessellationDomainOriginState(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPipelineTessellationDomainOriginStateCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.domainOrigin = t.domainOrigin ~= nil and mod.e.VkTessellationDomainOrigin(t.domainOrigin) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageViewUsage(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageViewUsageCreateInfo)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO")
		end

		_pool.pNext = t.pNext or nil
		_pool.usage = t.usage ~= nil and mod.e.VkImageUsageFlagBits(t.usage) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceColorWriteEnableFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceColorWriteEnableFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.colorWriteEnable = t.colorWriteEnable or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.VideoEncodeIntraRefreshCapabilitiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkVideoEncodeIntraRefreshCapabilitiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.intraRefreshModes = t.intraRefreshModes or 0
		_pool.maxIntraRefreshCycleDuration = t.maxIntraRefreshCycleDuration or 0
		_pool.maxIntraRefreshActiveReferencePictures = t.maxIntraRefreshActiveReferencePictures or 0
		_pool.partitionIndependentIntraRefreshRegions = t.partitionIndependentIntraRefreshRegions or 0
		_pool.nonRectangularIntraRefreshRegions = t.nonRectangularIntraRefreshRegions or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DisplayModeCreateInfoKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDisplayModeCreateInfoKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0

		if t.parameters ~= nil then
			if type(t.parameters) == "table" then
				_pool.parameters = mod.VkDisplayModeParametersKHR(t.parameters)
			else
				_pool.parameters = t.parameters
			end
		else
			_pool.parameters = mod.VkDisplayModeParametersKHR()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.DebugUtilsLabelEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDebugUtilsLabelEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.pLabelName = t.pLabelName or 0
		_pool.color = t.color or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.ImageMemoryBarrier(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkImageMemoryBarrier)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER")
		end

		_pool.pNext = t.pNext or nil
		_pool.srcAccessMask = t.srcAccessMask ~= nil and mod.e.VkAccessFlagBits(t.srcAccessMask) or 0
		_pool.dstAccessMask = t.dstAccessMask ~= nil and mod.e.VkAccessFlagBits(t.dstAccessMask) or 0
		_pool.oldLayout = t.oldLayout ~= nil and mod.e.VkImageLayout(t.oldLayout) or 0
		_pool.newLayout = t.newLayout ~= nil and mod.e.VkImageLayout(t.newLayout) or 0
		_pool.srcQueueFamilyIndex = t.srcQueueFamilyIndex or 0
		_pool.dstQueueFamilyIndex = t.dstQueueFamilyIndex or 0
		_pool.image = t.image or 0

		if t.subresourceRange ~= nil then
			if type(t.subresourceRange) == "table" then
				_pool.subresourceRange = mod.s.ImageSubresourceRange(t.subresourceRange)
			else
				_pool.subresourceRange = t.subresourceRange
			end
		else
			_pool.subresourceRange = mod.VkImageSubresourceRange()
		end

		return _pool
	end
end

do
	local _pool

	function mod.infos.DebugUtilsObjectNameInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDebugUtilsObjectNameInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.objectType = t.objectType ~= nil and mod.e.VkObjectType(t.objectType) or 0
		_pool.objectHandle = t.objectHandle or 0
		_pool.pObjectName = t.pObjectName or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.DebugUtilsMessengerCallbackDataEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkDebugUtilsMessengerCallbackDataEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.flags = t.flags or 0
		_pool.pMessageIdName = t.pMessageIdName or 0
		_pool.messageIdNumber = t.messageIdNumber or 0
		_pool.pMessage = t.pMessage or 0
		_pool.queueLabelCount = t.queueLabelCount or 0
		_pool.pQueueLabels = t.pQueueLabels or 0
		_pool.cmdBufLabelCount = t.cmdBufLabelCount or 0
		_pool.pCmdBufLabels = t.pCmdBufLabels or 0
		_pool.objectCount = t.objectCount or 0
		_pool.pObjects = t.pObjects or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM)
			_pool.sType = mod.VkStructureType(
				"VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM"
			)
		end

		_pool.pNext = t.pNext or nil
		_pool.queueFamilyIndex = t.queueFamilyIndex or 0
		_pool.engineType = t.engineType ~= nil and
			mod.e.VkPhysicalDeviceDataGraphProcessingEngineTypeARM(t.engineType) or
			0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceFragmentDensityMapPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceFragmentDensityMapPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil

		if t.minFragmentDensityTexelSize ~= nil then
			if type(t.minFragmentDensityTexelSize) == "table" then
				_pool.minFragmentDensityTexelSize = mod.VkExtent2D(t.minFragmentDensityTexelSize)
			else
				_pool.minFragmentDensityTexelSize = t.minFragmentDensityTexelSize
			end
		else
			_pool.minFragmentDensityTexelSize = mod.VkExtent2D()
		end

		if t.maxFragmentDensityTexelSize ~= nil then
			if type(t.maxFragmentDensityTexelSize) == "table" then
				_pool.maxFragmentDensityTexelSize = mod.VkExtent2D(t.maxFragmentDensityTexelSize)
			else
				_pool.maxFragmentDensityTexelSize = t.maxFragmentDensityTexelSize
			end
		else
			_pool.maxFragmentDensityTexelSize = mod.VkExtent2D()
		end

		_pool.fragmentDensityInvocations = t.fragmentDensityInvocations or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.primitivesGeneratedQuery = t.primitivesGeneratedQuery or 0
		_pool.primitivesGeneratedQueryWithRasterizerDiscard = t.primitivesGeneratedQueryWithRasterizerDiscard or 0
		_pool.primitivesGeneratedQueryWithNonZeroStreams = t.primitivesGeneratedQueryWithNonZeroStreams or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePipelineBinaryFeaturesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePipelineBinaryFeaturesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineBinaries = t.pipelineBinaries or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceLegacyVertexAttributesFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.legacyVertexAttributes = t.legacyVertexAttributes or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDevicePipelineBinaryPropertiesKHR(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDevicePipelineBinaryPropertiesKHR)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR")
		end

		_pool.pNext = t.pNext or nil
		_pool.pipelineBinaryInternalCache = t.pipelineBinaryInternalCache or 0
		_pool.pipelineBinaryInternalCacheControl = t.pipelineBinaryInternalCacheControl or 0
		_pool.pipelineBinaryPrefersInternalCache = t.pipelineBinaryPrefersInternalCache or 0
		_pool.pipelineBinaryPrecompiledInternalCache = t.pipelineBinaryPrecompiledInternalCache or 0
		_pool.pipelineBinaryCompressedData = t.pipelineBinaryCompressedData or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceLegacyVertexAttributesPropertiesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.nativeUnalignedPerformance = t.nativeUnalignedPerformance or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.RenderingFragmentDensityMapAttachmentInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkRenderingFragmentDensityMapAttachmentInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.imageView = t.imageView or 0
		_pool.imageLayout = t.imageLayout ~= nil and mod.e.VkImageLayout(t.imageLayout) or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.deviceGeneratedCommands = t.deviceGeneratedCommands or 0
		_pool.dynamicGeneratedPipelineLayout = t.dynamicGeneratedPipelineLayout or 0
		return _pool
	end
end

do
	local _pool

	function mod.infos.GeneratedCommandsMemoryRequirementsInfoEXT(t)
		t = t or {}

		if not _pool then
			_pool = N(mod.VkGeneratedCommandsMemoryRequirementsInfoEXT)
			_pool.sType = mod.VkStructureType("VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT")
		end

		_pool.pNext = t.pNext or nil
		_pool.indirectExecutionSet = t.indirectExecutionSet or 0
		_pool.indirectCommandsLayout = t.indirectCommandsLayout or 0
		_pool.maxSequenceCount = t.maxSequenceCount or 0
		_pool.maxDrawCount = t.maxDrawCount or 0
		return _pool
	end
end

return mod
